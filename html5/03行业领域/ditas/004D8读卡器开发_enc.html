<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eeb1f6ce69abd01ad41ab3b9be468a2bccb0f3a0ec99840662a72f7904ba62785b26bfc4d55c1047e13aed840f1aa9db54110adb3c5b6017e244547ee2cc0a07d4ece9f223f17fe4a3e97694ff48ae4044cd47bc41d50e79e997f5a124deec13a46ebd5b3ae3637bad48fa234164481188abf262a632e1a655daec243f8b535fc34f268c7450a64f762b4c577475473bc721831e547ecef3c005ff79a1346572c8f6b62ecac585fb1cdafbc03b95844162b3ef04f3ebf44dd829131986152467fb4be8aa99d9bfdcf125309a870c737f7f74a3263ffc0bbd79e6f023f09d269c7fd80c3dcd7d0ba0df9c12cc4e7ee4034ff665114006163794be62601d533568d0eb5645be4f011f9d4591b225cf27ec4f69c17044c65eb186ebe1f5e7a983e69ab418413fda77b25d48c5efe0d0939fe8e915261411a4cd8a4e5d0f4e701013260062566553cdd728f653bc34f53ab6aacf41705bf7633d111026b61cdec106677b490b8f1ac7b74d50770b3d19c16ecfecaace4c47c5674d7e2c165a21816f6d8a04a6ee1231659104b60fb72e9c6bf7a385ea6bf3f911f0842b019e8075ee281eb7807ecdfcd29aea70718fcdef602be0a59162b61ae0a07cb24fa85aac3af96fd00d4c8619d61229d94ea8075e927d1a4699f41195a3158194fb72fd3ade694aa598a9848720a68a0c4edd206685f2df05fbb2439ff1f78db6ee8966bbe4b4676706cdac72bddce3946a1a51e53172030d919fba2ba94928a2f2923e3bf58d6e774385dcbb72ef64b12a4071e4d49f6c49e0ca0402a1f2ee987caf07038fa87e3697ddc531f15dc718d2285ef085c26a6ed45a15e770901b70fdc760851fe82acbf7350ed643e7484211b2dd768d892256d802bab375256cba22b232dbbfe636ed90d2023521ad5671a7b4e9df4f5c5216f242e0e29e0af9d16963f8cd8577592d81590ad02eb4c673af18c6c263454b489056a15d72dbd31a328cbc7d56b7ab573b3b1bb261cf7de73806c97027835410357038823c98f78c6e0f05e14fd88263094d7d66b1a14fc2ebbe31681664a8e3327046591eb9ffee3bc13c072473d9e031b89c82e90eb62ad229ec21006df99f2eb95037c8fd9cf55d5f3cc6ee3e6933550512fb895810b39aafd70f091e421467ac67b338b799a6a8b166b12bb4c9c686c199b5efbdb23c44262046a3ebd3088f2973724c25707c333910e80e76eee33c722de10c944d1c2b205bb7eea5eace22aab2b165cab8fde42f25e84c33cbd12af0882ed84c308ebf81c7f55b956134ddafb9b51d3c299c8f69407388f7e5cb80cf1c2c8663b98ba479bb8748c1048df85771a3a85c49dee0fb1924fa32fe363519dc4ecd9d227ce9716e45a22b766c606ba267098f1a3438a78b479da5362bc8992325199bd425a45346ad6e864a9427cc7ca97ad6087130215b2ac2c38cea60a9207edb8940bf3fc4d57c6a153e48f7d45261fbca8e8d7181875693fe5f31a003e95c0fb847bcab597e8277d28cf69ece9baea09f5e117c9f85c69e49d839a2869a1c04c18c267da3a45af7be2bb658e208d57dbc902cf2a81849524b9eb276327e31bad4722600978dc8bc47786405745ae13bd0dd217a8ca8aee7cd8257e1d76dabe6564bdddecf90bd47f6a571ce11a90a4fb37a10d2a2d9ae270fdb264e6252c5d7db4694420ca7ef629fd8ef3eef2327350980dd32ce397235e3c6372f2724a63b0c3ba9e8e5fde4d4852fd2f0599e48ed5337f7be62ecf1cd75d5ec412a15bc945816ec82ce35f91d6fc5a09b3c426cde2de55cdb3ed0093d96c9bfa36a54968de95e7f42e56da9dee12eb7bd3d6d8a57c771ec0f37706c1cd9457ac2c5fc718baeff341ff6aa278f58289798bec1a5eac4c9aa303500a114682c75eb664285ae29146f2e60f704c22a193553691b124c57b08be3cb80344d717e7001911e2fa2884a1e59c45964c592a8d24aee6f7754b56c3384afc4fa4e4f38402d9d8c3925602360957f1fb72b123fd36878b913e22b895014f479c5b45d6b5f6f253d9eca4552192f533e19ad88076c9249ea80417f85848e4d50093f19ce61645c312c7d9c17632d4e46293d770358929f8649999c5d95b6df965dc674b36ac0f21a13247cedeb34d07dca7aebbbb4ede94c3ecfc2b18276f8cd167f2b949b2a2e8c0e46ce74f4b86ebb644568487cd4b0b48aeaef036a4df0f78119ec25954f5f7d04b6bd18ac27f57038ac330840bc83a32cb1cc655c6d452fa53cb0b64cb0e223d4204998202c15582e120436bf3a68234a8c2f17eecec705c06fb6e789fea245157dc9abd2aaca7afcf14a473a1050ebdac4781765b43a0cf6b0ea5cf77d54da2d65098e690356b3866ce7266b5b75bd64e73400fa4274e678db631e64e1158f3cbc9e1b84fa07f9114bd783a5928c03683595dcf57d5dd30711f6892ad133a8a1f741235a4f1a6fbe3512ece3680b627b14de7663441dc452ff202a1b1e88f0b978dd11760b0b806e755055d81c79839263884b0b6a8a9bce27f619c12eed9ed57dc24fa7659b5a17b8d63c9cb543f5a03e775df21e1e78e56850e96810448a1fe1e45ef03c5a1cc3889d29fb227e142eee5c65282f365205ed7b68dfe420a6cd74537b9ffcaa459ed95f643c8b0686fe327a2b6ad9e89dc7301c44c4af3de6d24a35040791879ccec2023d924b3177fda0f6c7ba10b8fd8ba8409660221cbd45daab166f57957769938bdad4f70cfb4bb5deab1a2c01c58b27d7f612d8465e607529fddfa6110fa86ccbbe2655d2faccd93507cdef6c13ab5b26b6d43a0e427fb9c5e2d5d415fd7883e04489a5051e31934efbe7268d984b7347ffc3c84665b5645e364745b05da03da0b54f275418505e38512ec6ecb2e9243d106d8d95d98cf169e56e69d59ab6a1d241af8a4b9bada295c62ec357e726eb24e41dd1ab7a1a3e478f358b8aa56d83f4aa94c895719fcd6183f5b481092963c55882adefc08bb9c391a62b7ec0ce1c6312bc4c2a691a9d1bbf9ac70bd7b8367bb642a63516779e641018bc1e85347a80a29b7d763ea4e78e37c60089c56ad97042925f1df60440b77a1c4e0b7c0d1d473a3abefae40a27a961ac5537ecfc6a7189ca705c4e6bc90667839c9940249939493301080d0637b72be95d77fd72e11a7c9c2caad6246b857c17924acbe9d16446e5f5e89f358ac2b6d5289da43303e9c0bfbbaebd72b609722b7fed17b718c7a02d25a72861037da436a86fd09cb45b04b4b2b36e62b020b6b5ea8204f119811ce6c11f28d7c73c5782bcc0bc706faee5f3fc8e00871d2f349c4d28321a33040ff0ae716082f54e0d74e9575f8492be9ae8ac655be05e81af86ef7bdbef935f04796a1b321d07a9f99daf63d452fff44ff50d97b43a259c6a92a48cd1fc76db90da142947279e5416e994e9f0dd8a402f52c5cae269121910ea6eba74adb8603472a6202dddaace04fe0365c5b8c6c54d24ddeb7629aacc681e8ac2312917cb9ac2d2ad7876dc925d0cfd11d6fcad27a4e9845fc19d1e2d371feaa021fe1c3496bda6af911e20505e2b441da36dbc819e524d95c17179545659fb741bd3d8c47459261e1eceea789248fed134bfb10c879cf0d6f7bcb4dbf11b5bfd0b00fc41d1461616eba48f5172989d3d6ad7bf44271d2e8e823a818448c8953efaa85adb9867fc52d4b90b10b9b8f2eff2456f37626481f75f528141323cea690fc260532ac0839c92af5552a2b29702bd49b3bc6c3ab04bdb06fe9e9fd21bbb6042fcb143a3d73ad1584a0b7e0888c6cc449ba74ff919c94e84f170c75e95bab08a051df60f8e0328204e25279bf166a76a62499e42cff4efb6db0e05971eecb674c3191fdef5988f1f3bc28917c3fb5c435311dfa393b0debd2613810c07fbf79f9eba664a06be42bfd40f66578c93a9f16efb7763c1dd338e8a8f9c6c49f32f8b561fa9e50af581311440e406db1462897e0e3579792af07fbb34a5f6b26fbe78fd8985620fb3c84133d9065ecd68a22d509e7b552d10ac4a2a56c623367f784b1b0f87a00e429e4e891d81746eed8f274a06ea2a86536c46b0a3d0898dc12bdaed3dac89c2cada4782bd691463c4ea6ff2cce239f7a2ea69caa739efc822855af3986b9a94cd31d539d0e4e55df581e945b8ccb9e0b659350d1ca6119c11710d3af71a7ce1ae594b1cced90831ceec15fbda8759f0c229d5ccbd25f7c3fffd67581a8b539df6a5303af6ffdc5a4abb134042c0611b789f7c4b435f5902e12127dc4d50cf71018e5752ef13d691b6c543e89617e3d7ee4141a66bbd6f6c23c31989e0e09768d2671473bffdf15f442cc648b6da748dd14d517a90bd1af13bff6ef7a856b55b820fe870b08e475949c0e6c80511daa3270b5ac5046264bcf0ce19d67dde2a9de464d30a249f42e4ffec865ed55c4855fa1db2a20d83f3a5e7f549c566bf91f4c8ba48f06c5cf4f78d959a397f22604c20eb77a1e1b1a28d9801a484fa1e446fbd10e220ac84eaf29595a1ed6db2479bd2e56a1ff2458fc48c7ba81474e21c245be7b8a8fe325db08f61c055553834ec3948587a29348aa099d7b160bea5fc842f891ead6df5b8f55309d61d73474833d35beace29209b674e9e2291e98561b22e0cd04afb4e8d772d6d284b38b975667725aea4a3bfbb5ae2ef9659c2cf36588b0d09db582829e32bf6a5f5dea3406328a65947eb58ea2def9e4022064b4cb4121baf01a8abcfcedaeb72752d69505ee503407518ebacaf5307b41bd805ea6537b366072875c127751ad91cb4f5b7e6450fc6d9d4d9da19d504ad50f84a09ffafbdbf57e7700ae0ad5f5f766363753907476ab91eaba4dca974024b16b072f02b8c876ce2b8223cf24c03e9788297f186933f585a866393265460869d16ace1a10f0ae84e3c4545cd7ca5375c258a5fc5ae8e3da3e0fc6b263fc253afe5041d16447ee254a787410c7ab22301ab128820e120d68796b5d905a1a857d203517368a05f16b238e6b1d5e8882b28823507fb3e21f470b00f457bccc1058cd27b4a4cb5f203204a6e3d6725ddf3410471e9f70d236d6e3b1a2e9abe10d62b1e3eb8d39917e3104310799308719456c66c0d8da784a513ecfc3406537e2cde9827ea3c5168ae6d76c7a511bed56ce96dd280f397a46fc8194e518cbece13ba1426cb528c4ead05a7c7674c44dd638e9b9ce14e64837c433b7b325a9a3d440eb01e557a161bdda313d9bfedc437bf811b74d998d2b83171b6ff722266b0e34e719a668cee2271b141b94ef0256003a1e662a5b62cb5c2e8dfe8e256fb6041799c622cef69b45df1e97803556070c41c5fa0287771ded83c231900fb77d654f486db3bc4eaeaeefba2efd619358d60f9b807c98fa499fda9cd25983f33d4d05e646fb45c8e4ab0674755efad5c65b8c3c66f96c07e8b21b8bbdd2e1956fd30daaf02e60335fef511a5699095d3ad051415a5a9f7e2f6e29dd07dc0551e7747cb6eafe8062cd275ec17d5b3b92962f953516d41aa7c8175ca29b298bf3d0162b90845dbbfcb9918de37da37cdaa88cbb9c753fc026c3fe2c725f6ffd2622aba77b12c333bc7c7916ce3e5f127f3459c689c196a273155bd20e09cce821c58811b0604f294dc59582c06f649ec296402c0747d7cf737f4c549e992ef0875cb8dfc9053938cad1b9ec9904c4f7a6809705e0c9e1cce5f7b89bebe032c3d2cbb2bcf71fb452b53ea2255c0952fe11e25cc2db59d25086e669a098a7a1773a22addbc7ec8ecaa7757b833fb68f2d713fd55dd38f39fbcd5d1fe00b26e619e3bcd4502c0f045f3940d4cab20c0a1ebecc524a85e174f521d1c955cb0050bbe49e765e402402417b150fabeacec6a183dadfcc2cfc59669282095b913cfb792c0faaff00d28ce980d6d00c38c473a2b282c091a90f7d6b1687cffd05a9c1b95dab14429d42d90f4d5f343d72875c6f9048dc38c0941c23f2f4853137aeb820fd45714a06d69631c03107e0f6f4e121d7817263e5fdfcb9dac70f9a59fb66481186c2afc05e25e43a7c35357623671e7ac3612029ae17fff2586638688b8949fccaaead8f5947b2e046c350f464324943f1438c6e65beb4a36116b68551fce94547d9d40990e6dc370e8fe66a392b55f9ba5d53141d5dc790943091fbef03b63c03033d138ee72a07fd1d67c5d6e4375e2077e9d04f2c161159bdc421614b3205c7d6fb612454bee0b6126245adb1fdad72b753316f18ba5585d1b47c568feb7de1185be5a0e10292213bba5e232a0fbbda9182f6415b95ea5ba501a9ea1d4171a7ca9ddd9561f75ea63bf1f09c0c19ab101cc29c8034b193ab56b2caa850f18bbbd698310c7df7e1892fe7f9da2d6e1cbbb34070b981392b0ceb5751df3b89185f5f8ac5370040d4a3f9f9dc69ac9e31875493aaa0b86f9bd6eadbafe021a2c42882f7e234cb419beb89f7ecc140ec78ec6493b9c32c99301f31f2ef7d7be571fbec919f489c188314bcdf9f6d7df5ef043576793483e480ce6617734d86c4cb4a91b0d7478b1d4fd9ee7d62efdb2a7d9f2e67ea2388c5bea35d2171ccb267cd871d7007654a68133551065be34bf035b1890240e257012a5062d7afc8d2daef193e7f24d08f198ad737b5668cd91d545e7e45be731a97113879507e409c4a1ff984ee93cfdc3413846ea06860a1123caca7fa5a92727e7cc6a59717e9adb3d67c2532554874f5266a9ea437cafe8272c237ee91f1ff085d0828351f3eb73bed159853d2fee2c7edf736e6c93fa1b5cc62632783ac8f9b22bd4bbcdd6cc399e6d2a448e0faaf2a4c8e59aba41ee097a681c1d0cfd6e279db1a1241f52c7065fc57b57e2eef7b36e22bb6b359680e4889b2e8981a56f3767d5d3f4833238a21425ad05323bce967870f0aa3735d844f87ce41a66eafc43f63913edaa7eb1df58ba92c7829c7d16837ed7f26d8191d66f207dee01a916b353858534d4336dfca1e1b8bd35dc695aa58e476c52ce85654db759b3747c311691f8f33cf76597aa579171d2058c9d68bbe8ad7fa765ad8b1e4b2267b0708121dbf597ad6d7d9f060a79999545ee355c9667adaf4441f328b5c939158e352144bb630a0c06c450120db6f4958a588f5a319c4e450dc4938c6e2d2bd1b3afb837197addec382b2620d95ffcaa6b8bd18d1d5b5d7d908a630112a0801007e369ca9a11a751691401df7eeff7065e425a528b56deeb7887bcf90cba239c0af22e9bf674af06a4c4bc5ca036b81a2920f214c82940c555648882d9b84c118a7a5dca40c60366aa132b0e9b7deab349e195b0138078309a2a96a0f5fa2319bbea52816b9f9440e65e7a66c3f30f02bb880ba6cda664c300fefc156fd19a9008863b957f0f8b3f069cb83f188ef09cf79ea2371c79b6c2f80bc32de264809909a2189dac55668cf51d0f7735c1de54070da2503d50ffa64cf2e11f0147daa046cdf578778e62cd8b1197ffd1991c980aac88b77a0558470f0c3a899bd98b76618efd7acf6d2729f130e57b0cd1949f3c01fa0466d94bbb9983a858d1552557efc1a8187dec5699811b1618dfc86529a23c27495cea747d3db67d8ded0c750ecd32860b3eea116ee5d9862f157671f16c5e5bc1cb9508796740c169dc631cac1059487e5bac52bf1c73faed5e0fc99f27c118b45149460176cd9d4d3334d57b42a0c241c2a8418750dd38959f85f6c08473c2f541a51458ba1760fd61a6d5a4ff5202c4adf55db278476908104be40ce167c3dabedfd54cfff58bf9bc719cbd3730715791fbe06792126810bd90eaa8927f83184d7cb00963794d8e2b8099d079f1952fcd0967e1ec549457b6fb17b889f0eb2f8e64559239d072c3656185e892ae4a371a65af13c2fb8e811378abcd78ec5973538328e974028d09bb8d79254cc7e186505abb3c8046d4ebfea4faf034d31155147490bc8a9abaeb1fbbc90118c89fde6092ba7408e4e1bb56ea0fbdf90ffc66d52643a2194a04dbe8138eaa26dd693c40168045037dca1847fd743da1878a0169c6d595b9103b49dba96ade473454f036532a3c62198e21d3944c58dade6edf64768b2cae114029608db4f78867de0cc6dec645bb970bc9882402833911dd113517c2a11f198b8378873afcfefdd48266d85235b99607fee7e7b9cdeb4b64e6d5bbb29ea73798b627f068995ca963cd6c25c86e746dd22b09bdd315d0427a9f05ab6245600e38383839e3b8eacccabd26b0e578acfd0b578cd2a46646ba1e20e67761a2a9620854a13e6f1d0cc7f16b21dad4eaf99477f5df65ac42193fe91fe6318429600d0e8ec5d0924531933022bb061f55f00e5c29bdd918bc2154ad972359a0cfa2b5b0377e95652645ae19e659bbefa3202c53e685e3ab55c2282403878111e23b1031b5da0ebb55d6b1d57e93f389527fe53b3c30b59f775ebde126a233caa527b46406e77ac1cf1fa704f294ff0872b39beff07daf72450c073aacee70ae60dffa7d50e5007c0870b27ca0468dc5c6e128127553ccbd49d916e03ae9a8c6df71c45df5956f3b0120a29db9c230a77292ee6f0c1d84656c8bf66e61e1b8ac57687984a76b7871ef804a134e33396702e471d4d756b653cc4612c5c4a6880b61249cda7748523a33a5632090bba3d5b3da054e5e0fb44b3e565935c9369b705c7eb9c92e4b2626bcfa2af89966768272f1a64d76a8294913f0327f58a218d73ffec608a7936d37c2c5235ff5611ef1b621c6e247d871846b2078818347de238085a2b109bf6fb62ae9bea2f2c420443efe8be32175f1c9728fd686f2416fb76432c9fe9fb3c51bbc2a12014b51de3e8b61740a5e75f3167f2c1c548229e8a53b935eb8e1dbecfac95ec6daee80e0f41636e076b3752a7ea75c58611177b6e3741a0ab7f0821bc5e8e3c53edeedb1ee30355b418ebe416f171783a6fb062b972b4d3953f016a7812c6dc5300b39cc11945150b0e6467e61ef348893d3f0e5597f033a76413af9f8eb54d25611017ad7517a8cb780246b665249f809710ad044c1cb2944eca1a24ce26a3d38fdd6660b82f080e0562472e5125be60f41d4cb3db53d4d2a41ea9536a6f25f988fddf0f380ab93ce2c458fb7c58c7eb304a9146c30eda802915dad6351145364ff27881576bd81c28eec0333de85eb0af20404f3c5a06a8cec38e32d8d3900f2ef6d10f350782b3d1cb67fc33d5131cd0837127b183b6ff3ddf55f64d761170320bf345e7f9fb9562cfefc87be75be1883d60715d5b10574a10187fa9e8d51fd3aec49e8d03a84e9937cde4bedf2be32f16d8dceb982b842a705c3c972776431710049aef38285767e456730e1e82d8afc8595bb09baf7eb01f1875ac57c0ba289259ee0d738085dcb24629d563fc2856bb3ff69764e0c1ffa87bd3ec5654ec463178d0904af0bc93386141c1b932557de7c36ef533ecfbedca55c00dfb3219ff1cc643c3a8d306fa3708a78b5867c220af58443519392090b1b573886613bf7640694705cb2a39a8ea86a24876b08fddc4982a4683ad4da8dc8a32bc422f8f41f26af9e011f784f1f2bac0aafffc7f7ec43c30cd140e48abef6444071d3d32558ca2b3683c53a7bbde058cd8f630c73b500c563697063a26dbe8a7e1017c34f4b95b3f133211a3cd429e277e73157ff5bd5bb043cfc1db7ce7ec6b44ea53c2f23181c25ef0ccf9d9a7537c52ac5570fabb5ccbd153f2f5742063d007beb8a1279ae6ace76472c6c263dc0f7233e3bb79057f9464e1ea5d47f8fa195b15cda3ac91282ea6131bbca710b469e80110184881125f89f638fa27a724ba87eaf801cc10471fa3a7981a6ca2b9b8c61ea0eb00b730bbd09f494dfc9814384bbfcfa521c511e0710e7745a4da30a1773fb6d2c826186181baf4e95e8cec905a69253a4e2713689c6a32671815b801e4ab1e37f3015884b54163bdb60192a4be4fdd0ae4ead5db51e814386c4bc2e36017d6b57c27e1220f9c1a897c2446a8dc7157d1fbca0c90de03d8d830c7af96d5b3ca84998b4b98e47ffe868b5095667a25bf8e61ccdbe454bef69e9a1439d8c5237a87cbdd423d9bc0f0e25143ce10e6f7df01103d68b0d76f38af929050ac240bce625331c1e47a070753e108f173ac097f9c61263a40777fb5aa40d3f9bd9b74dd1e515be09529a72b82d72fc9170b40c79f450649d55d3ca41a729fe68745f876480d67b45c66bd995f180d561e875eb3128cd655d950501828e48f72544b729cd4a07f4c773a37f36d237459cc089a6567dd8ef4617aa2c3d53550e293f8bf99cc55b85af6db06d56748a712873e9541bce4bf812430e78e16d42592044c9cae51e7e814f2d268106f003a04d3a236451add48241ab9a76ffb9ee670a147ecec6ae10f290dd30d2b3aec5faafbe15e48bcac74a8d65b8b8ef902c252472ab3f5363ac2e8acd8d4b69c90e3d088a0dc551c520289e7a50ca78035857962d0f46fb8923d00be8893e7a38ed6bb4c3a2fa1ab085e50273f1202dc60d33c6729376dca7a306f6ec2d1292dda47d81eebab374d1db9e8c15654086a8bb107b8c49191a5b1e382e9ab49a9af613e189cd18b47e10c69a958f2ce29c8ad73007accbcb429953e06661ffa884dc1937f89728d75018e68492211b7481c7fc36fc102629e78c9b92251e3f0dca9ea981e1ccaa7fbce03cda37a44d49e1e5975584fe3bb7846744e54c7adb53e387d381a067246c17207e3a84e42a56aa16050f9ca7b1ce4bad47ee43890b92b9f714428250a462f3cc4bda50cffbacba11f81b0ac4d8a28ed3bdda97b62363d3e096ddd433924ca3e645cf9ff0b0d816affe67ce9965039bf3e1ab055bd678b3ed52404fa959de68449066521f9da0c3574c8b070aba85d1177b07d987a05dd932fc5c5c05d9d4c5ed573d420db37195bb2f4b26bfc8f0cbcf93053dbd656519f5d678822e16d90d67e79526f47d7abeeca50418de916687a27f8cb7697bd54e7ed149f0c25b4ab933a6ab742a0d467bf7fa431e62298dc4cea7b3dc9c76eb91b2f84db07418fc1041793ccdd2499a6f3998e853354056cb54c6a6cb180f9412697849c5dfa677db2a3299f4b5c47cb23111cbf6a52fce19eec11687b9d4456e686c8075ec7859c401f7fbabda0f523dcc9b1f6600d078b86599d6dc3ef9b5412f33b3cbec709aae2208714ec319aaa8fb650d4722a22d757e88461011ce56fd38c219261d906811f0ebaf3c12fce56a1842d2fbe61f2777b8d838fe4b2d5ab3219de32b871520eb31e56c80ca82efa905af14792289e771172694ee251fb255c3565d18eb8e8a14d0fd10df535fe016daa043b0e9acac3be0e43c72f582be95b1dce56d6941f37b5d8b6f1456c1d671f795493854d3dd7a2083d784d3cb22cea57e2c5f22d1ea34d7e5c7387e382447fa479f1d00b1d19b6cfe48d9204c3e63ace0881cb33a51022257f499aead8111ecff4a8edc2e85d25a8a4a9fa15874151663b051f7e95a5185dd033262d865ea1c5fd7835563f3421888778b5c5e311a18d8af16e0f3e25e190714da785fc791a89a772f8557","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
