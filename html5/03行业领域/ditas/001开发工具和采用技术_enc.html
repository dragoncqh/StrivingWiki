<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad173c1d9489f9e20497033e10eb614ed59461b5fa17ccc908c803c5d47d07d1c95f3fccf8c48fb16b490db09571d79ee38b11060086857944815fa364e6125d832696de48c679ac331999d630acb8d3e8dab219addd3cbaa845545c7580286aad837bba643b09c6b476cc424a1b3e2e174a6a4029ae9796ef0975ddcff8cfe73c5f8bab944679dc8718dd5ea16765da2b6cb08b66191675b6913a98af99a99f180e22b2484ac466f9ca56964084f1f87e230943bafbfc6fbff8753f9af679935f4e68c6789b25ba4621e773abb740707e5d45e2692e595eddc7385577af062b0acfda48c095612144524350232e1cda8965db9edb10894843b700e225382a5dee0022bc60fda2116e89ccc27bf3616d39b740c9f85cbeba52a8f0e3092dd19ab7fc9a3eced5fe0615cdfa45609283031443db72c167ede34c0918ecbb32858a36a3cfde9de39bf8130d0152a0978228dbfb0badd1b3a171758d824f73bc66fa0f1c40250bc9ff9aac44763c5a8af309caa63a2d0b3ce8972f1cbc4cdc6ad11d45c20bb85e44d295d8489b60baaab96e0908a1474011b90c8b1c1b23c82a321e38c47f8e06b042830f67f9d7d151c267ab7ff315d5e9238c65bab5db9dff9a39f88b53bb3f8c6a0013a92079b7f7ee31e992992c31732db27b93d4c5f2273ea7abfdd082d6e5f89efb033dec0ab9f9a6f12a6737f3d117e3e7ff82299ef547726bf6965014b2721cc5744b5ce15ce67811440dceb8b9d00cf9619a9919db7ab1e966022d4335a680cc229721c408c370fa90e51df4790fbe623991f84a1d68084d788e52f6f4a6d1bf8f2a9c06e6296573a09e8c4137191fadff3c8bfc6edd32ef1413eaf99c04025f767987cb3af4f066479bf3fd568521d8f42aa53764f50d2d850d39dbc83a503e98eb0eae4eb4943adf7bb60af36a2fe6a85e8d398044f2fd918424f5259906bf3bbf8997e3461280128d3423b0aff098f6748aa0ce3120f51990ff02e7247c2a4d62a379eaae8eb506678b0983a0d2f9addab6bd287aba9dbc50ef4e492a858a4b062ac1f2cd4b511396752fb4c0589a65e288418b16b21653480a7bb86b80202932072dd111af6e163aedf7d5978bcc383cb299bb3475b9aa30ccf1149057a2104c04da5e8b4fb42f9e2bcf77cc24f75d93c02b4150556109dfa7981e47c008f3d9cf7263719435ece534f336405db598c712ac02356345d38991981078fca5d02f58658112b6f2d279e4960fa0d6f34b5811624ab40761cb04c70ff3bdd1170343e7618e2bb4267f0195308988e13c241c7830d9cc94e12076bd036f7c446ff05ed45d0de94f822dfe63b231d3b79037d8ca8bd68355954806330880cb39b5d5df96f9d6a9c25e2428dd4755ea11c02416409c9193fd65e0c98dc29afa370b4ff997773abf319d3b92c8cc2c4f93f8cfd4faa9bcc98d2ec99d2debaf32c907edc56306b9de65d7bbf1161a3102627d38b0f8fa666cba833df32aec20fc3b2d33bb37491c3f14dc9c8dd9e912cfa826b21dc6e9345db203f2a148a1c499113c8115556fc097fbf5d4e896f7a119e5b06b804b2c23b7147507f1e6a578326ad16bb50e6759261369af75fd66d5a64dc3924cd56e2e55883c7f2bb03061e457c7dd5fc1defda739963e4396b7544224b685fe8273453f0850639f2db490710e4314609d854b11fca46a522f7252578b9c370022b47c5c86cc1c1fdd9326ca6ce442fbbe4b3df7cf65e48bda5b95b00ff3ea4eb48dcf454be70b6e701df67ce61ecf5f8a59147742706a6fa33d286291ee51d0de6ece8971e0db10207a5847e69209ec4c41677dc2acba982b9593f76c6169bacc80772b64a7617a393f802b8a13f8cf9d8cf45812cb012d3e54d368a86c92be7d0c49412b22be0ccd97892a3135931cb3c1d15af87ce942393faa2780444274477b7db48ee9c64de8913c31bace359b3f975aabdddc176e5956fd849e5f036c6f0f047e649fc145ebd3062e813f645830689a507600b15b7344d4f99c956bbe963b43b1ffe0d0641e177c40694cfbebf7f7a1270a6d0a0682810c91706428eb152301f6ded81a981fd8839e48357f79e621a2decb17efaadbcdbe96df8c3778f5d2458a173f98f762817a3503f38ba9f835da65a03583d52d40fb99ff03a10e7c46b9d60bd59edf5f9d9fe0dcb3eb46d9fd399c52b687c557f3e180ddad613829995afc9c04924f7cb64ff5345d289c5c072472c134d1a461d7117d67714615d447c58d2b1d6e8be5553584da4333c1aad46971e6a1659b555c6970749c0f75be2c2c8a13a2189640b4b550744b679728dc8df12238700542070610fe5fa1182bba3db7b725ec5cc394c09ae6c030fca97fcd1cf062e53f7d8a837a3470d253c0b41b12d3d6151431b2d55da7eb8fe697f21aea3cd49d64d5496110811e46c2c30e526aef8d0d6a79930ec64e4629f7f8d1ece54a4b0dabba4206f56f2a834131e166148cab58f916b3579f282a5082d78c5ff4992b9258d2f4c90110b637aabef16e51e0a6be1e42f42163db8d8a89f1a17366bf958d4fef9a63b1d6d36d0b9cdfc0a7f526d75f132bfecb0320645403c21b05641e089a3cf713c76ecc236eda86c898ffc3de8dcdd38049f0cdbd82bfe965913c1d00284ce228dde635b447422c25cfc7fa1fe4d2717ad199c1b9f49aa1c2e25649673c9d57a525e2cb4d85a4f8a22f051d0ada0127c457d98a289b1c6a5b953508517a0f5b9a4bee97f1487c227f33c0326931a465a87b4fe2a4af2c1b5f5a4e071112e197eca6203394f14db50e2a4a7d8148fa31678e05ae616e9d09c182be80deb5d9c584dda9a32a16213238ae90a591d79bdf979a0cf9fa291e5bc7c8b10dc373f2946b9cc1abad6d72c4ffc0afa1d38d2ad7bbcb5f1c7f5d72e6326ff8787570298609838b9702012b6722e47437b09a8b869ce1ed1e92015c8df6ffd8c127b5778fe52f02e7d431f7955e3fee5858f393fcb752679f7902dc04f3acbf5a27123f634596722a1ae1d1fd0de9439e3211decc64a5885c48b22c53af090a39cd2975f2c87ae81055153e43f580f3e6b41ae1c070687c0c0af34bb0291e0747e861ce04a9a8aceb06ed45c452034f33fb0b658a273d00b5b66413967142e44bc7591f95d9250312c182b35fb19d6bf5bb8754b94b797810f451e73e36596e676dae87fc99c7aa5f185591dcf8dcfdbca9a0017c5d09420da50ef617fdc47805330d2125b4afc9e86949a7bb05b5c57814d22f051031e66bcf40b54bf8dca8df651de0e0d679b9e1a42df835d9c1bb468d56304c519c47d7e2924a469d55191d6a85d80cce451d1d2c6efd007974c4af3ea16a294cb3af3c29147825bd888cd646eff50a25baef1e8cecb2ce8eca704c3942792da02a7a0d24644daf270493d1bc9cd7d5cdb2039d744fc668a8d69d8f0076d8ff2e362409dfc6551d682853d0b31ad4ed0889f8cf03c77758753bf0dc6c8ce5906c6336544b37c2f10200f179ab5fe89f45775f82a0969fb369c2a9a20efb7629f5de61fb1e29b971c98fb14cb1867e61309f1a4347c08f1d18c7193137226faae4ba80ee3662106894a0184fb3fde53b39a1732b82032c6831b4f1666c13223a38472522af662c61e8122f5283e1d5215d79985f6e0c1d350e15ad2f7cdc8f275d425d4691d539fa09b3043190e1ce246665a870a58e679067edcd0f4023d58ab9d14bdec1dc018697063cb168e06148aee17e8a8c6b2c2af30e1945165eb6962dea17daf21db279b8d9fb46a14d76200a0c1ebc038189e450c0b902caaeea93a1cf6eeb5c9ae50da7e4ad11e9fa8aa467159649383b31a15543482741911db32f960084e73fa88fd22bbe38694af8ba0cad913e60bd4c4e6c5356fe927301970ed6fdf3fc3702ee391ccc45cfdec759f378ffa708f5dd711e50d86aadc81816f900c06c2a2f0c2f91f72efea9a1f9cf9071898e2d0b2da7a505959516dddfd763cd84f4717e84453caf40678d4ea3999722bbe8aac8aef5488afa8ad498fced02d4ce6ecbbcc1e8c78f4916049da0c11845eb3b588cae8deac811d16dadb20125207b1829061f325528afbb047afe1824938c19c730f9cdafb5cde59565dc3ee22d6d7cab15f9107596fc31c8f7ed1964089a870dfb42e423bb9171f967ff778a3003b6bf8af154438e5067a03f598b4e348aebc6a4c3853afd3779b98d1dcbcbf74a3257f93ef1e9be5626dbed96163564e28a893435693c23b58159fd530d17d5b598b85807e2f7e05206b6c2febc4a74cb556963e4811b9e25623c7008c101b09737f842a70a3df7ca8111136980d31873c3bb8cc4ea4403524e3ec77fd27d83f9c3e5d74b0e0aeeec21ba057496d83f382eec317aac4d1e4a58aeb08aadae42b50ac6ada62d92ded6d38712d69350db5e08d754bd5e99fa6cc3ff2373e43059a98700fb6eccddb588aae1e5d765c04c744f7786e36d124b8f4e887e7c49b1fbbc0931387570d2c0ec2a4ca6aa34ccef56229d4b804ca2249ade22fe65beaccbac3e551b6b7bd8207f7672c473abf7174979db8f6625660cf9bdd20648476ed6c224d98c8608a9fb3ec46782d7bedfcdcdd62485d5a674c4c4f67870fe95834240b73b5b3844626d322c776db975f51c87af167a9af974c16bf1ef59ea410f8b2455f6f725e0570b8883c6d07ee3bf7537ff93c20ff1200b85332dd4451376247a1d60bf4c3ca60934490b9d0fced9f14518710cc6d5fb1ecfc34685e605f27ce68fc304d1f1431698c72311823372cea05ba2bd9ac91911fc25922b792cfc54754550f9af080f8a99cfe6ef14e71f14c4a56abc79775880430395b7ec63dac4fe5fb96ade8f3fa85116b64dc53c261d74054e46e97e063d8be668f8bbf93d722b554144779472948161f192c8e8a4f0e35e8341bee6019ea816a2bbc6aadd47d9910f7b1dbdc43b1f7c8213a6cf7d6f6b56f3af7e7271cf4714d791117a5adabbe6354a6aca12b96fb6c074ae8ff876e33496851d5b3c0c01e5ca3fdf362d32c9683b947e31e9ae0f4bf397fe2c6803845eaf1bf802d5aed43a555efab95714e217115baaee43bd862afa6d7cf416ee3f433117b33f270d1a194fef3df48d80336787f281cc9b79d177e66d89e8985631de365bcc215143ace05c9f979862718e22564d0984e55711c703d161b54921c75bce2e59d6005fa4d97d22e1de81e9a8b2eff30ba5c1c6a44677059e622a750924a5d76ae0e0a5c71ffdd2bc98a7dd87a774d14435f27e8cad4d1e4df0c0370019318fa3ebdad1d2cf5098f78ede5d33b016ef6869fa3d8639bac916c9eea306c18cccd31f90368caa66a557327e35883531c0bbd03e0e0d82dc03df114212c64e750bb22f046761c04156b462e12084fb6f6193ab0eeaf68b40a4a73ce089ab79427707b1ae3b262473c43dab353c9c958eb5fa256d817c18e0f8536c33f0ae41219af1f255d00debeff3a1a6fa1cc970452760063dda5480b5fdc6bda8c9c6d97d57f32cd6ecee1d0ebe43efd2f2296e0d2fa3d659e2915286a88857de7b68abdc27f187cf76e55092a261a4042a925f2b1d49d6709d5b4a213295cda3833bb806c2735dcb580f852deef66c14165ec1c8b88d272f5f6e3bbdeac1738cdfc059297b019e9f0abc86d5e215a69115ff82c86acf13b502d1164e6679b22fcfa1532b7b36440ce6bdbff53b17a5b7dae6ec2f519002155cd923844d9daa933417db0d59bf4ccbe9ba600cefe64e5cee0c12252a3691596110ba647f94ece33dcfcccceba1a3e14a09ac958e3e9e4755d224a91487c47bdb9eba7ac1d7dc52d8aeb9c65b1068ed4bdff346d560bec86a955aa423b5eee8f232ad3d9d353f0bedd6f445e35451ee5a625d062549ff43effc4723d4b27f9c5d68c27acd271898e1fbdbc50748007078347fd6d909b14ba4e4ab24db3deb696c97df7453e409352067548469ed280ab981ebb9163055d6689acc01c35f5797cebfd9934f2a96328b8f3c19fbecc20fe6bd8b91c5c1545188fe5da42d5b1bedcd5cb96fc0298fdca6d439a30774bacf6bf2f4a16a70baef1a73bcc660e76ea2ab3e2454809b8985860e6bf647ed6f8cb8a0980bfe8a5976548f5f4c29ea6bdd47264c67107f7f6a60b8d9164b4ca51ada8dabac1d00c6e35c7386a023f7fe58ae1107e6b75b85401a0c139721960221108f30442ddddfe7556c2c0f51f71877090f6544d08bf293356da3c5d36e2e6a639b095d0be4b3de40c3395f68777107715ce2669a1107f20f82a542b9b2f949e893fe0ab07fc306de2a150778470e9d94fd57d99f25e180fae4a13f7db19be2e30434749e965086218787bd13adac427e51d5b1e8f1488ba6012982b1f3b70f2bd84dc42092a77b70d6dc0cc73d007686cd8c92d37184589c53f5623f0ed6c5c25bdbf3023f79cf9f34ef7d199825153c02435597197161566a37a975294ecb80a7e6adfbd0860b0286134cb19542ba79483f926d415587584cf1d021e4751251fa3b005b0cb018471898adf69e2486c1a625c89e713a63c8a270d90c89aa6cedb919d06a21047d781598c73181e598753730520091f95b3aeee8b3155a2f84bd255e764103a39c2afececde983a5ad78579265b8c4c6812d2a8973053e82fedc6f13d15338150e740a6348e0852a9da96ffa8eaa934c9e9fb1538713d799a5b04e9c0dd0581541745a9e1a61f14e0a9750c5d830bfb4204979c6dece43ba3a330abbcb26ec87e7c3eb8019ba359574d57e240639d10c4c15bb6621896f65d92149e0bb21dfdc6daa3e53f3b6c70d506a087dc7b06badaebc407740a90cb2e7303acbab93623032bcb1f6694e26683a46c43d09d479ba8a906969b996689346e755bbd34b53c533e6a2fdcb2aac08ff508a5459592bdd436e1647567d6e9c0d0681f39f50c34671ecb0a1e86f7b5006238774fa9345b2e91ab5b2566c0799ef3da4e588b0ab38949ff829f7cba55b53190b9379ecd641025600db4e9235d7060fa297fabef13b14da4d518fee6f31896b60b91c9033924972481bb99a6e8ab51d85523443113bb141deda05fbf00081518e4838dffddff9fb9856e03c3f2bf896ecc14040e6e437e9ab50c57cd082609496ba6af9ed5d5f1c0c71d701d7c16421cd157e7df0be04f2b93e71496b619c87fe2e1db02eb6a0b24683333ee4907a8a2b12923390be4802e5f1d331a05ac0ba36d59e924da8269799eb0590578eddbe82e4d5a800b5816b93f811895d910f1d60e88c77b771837bb5b412bfcdf3cd326fbccbdbf38eab8654eb84a95c4be8538c4e4977e7bd8b414847fabbe1b1252c690585d04c50c75e8401ef1f022d7a7d5a28ea22a28175e8ce64b843997a24fa2a497062b75e6d629db21d414e42cffe34faeb60e25efc9391e9fd6caeb382e5f129c222bf8c464e511175f7ac5978ff1b3e279e2546ab918becb557fca01a766240e68f587b51f4ea5a6b767b89691e4bcebf1d80b50f3b73f3a7bc8892b213187329ea73279bd9e0557176640997de177820e8350a4226cbc4d006a5422772ec4ef3be17f1b2b7dc983e480f9d95e077d08b106add3e7b5225c7ca0f94f04b4e65f20d88806485957e827eb630925c644d71bb6cfa5e5b003ba0e93bc249a5b150fc10defe24671d488118b1ea5df2db00abfbaf5ce573e644290932e3e49882334376aa78e15b9b421daf78422ab459be483c1b405b8ab4f47be73e11a42ce23c0af1715718eb9d348bd95022dbae1f37e901798f64a28639d512dff5814744e2d198fd466dd571bbc32a8db5de5be35e55800132697bac78f8bb10f7e33d50d31d0e66e7be97659f35702419ecece54245e346c5cb59f73de28f5e25bf03f56b7eecd620d90d1462b89cac8cf052bae9515e86d5c65c3d6d8679f8e3762d919bf41c0b09c340e6a71ee2b5094d5826c640b7db079ff7348a679624c894d732a2b6026ad78a7732714bec9fe1949a4c855cf68e1aa6e69d9f01fa51a9a373b1bd14f722e59d1007cfbd113bc15b07d4e5a22cd90af1e0aaf02b96ac784526aaf95ffc512d1e9cc6a371adacbe655e950885669e3026f2dafcf5ac00006cc586002ff331ef09904e4dce9e4e02a8e3977da128e245a24543048af6440c114586a96456cd815f0347bb097248a33a65c019ee7d75c05bc82083b4acdb9333cc749e8add58ba4ec18fb846d4f2869ea041959a58037dc86918be41c8ec5f6a4deee91f38153a06e94943630dc31bc86cbfdda4da4450d50aafeff2d516517a776bdc02394697881cd54b3ba669b6b22ab420913078be22bab5c4af5aac401be507efa9408a4e2175130fb2fd3f38f1a3a162f88b90f7f076d4bb340e3d993ec17b31da8b32292a504f2e4f204a3090203a4d56c8ffd95ba465199f6fe8c7feb24a54f9e2c43e6e25bd30b027231f9ac2767ca03a03bfb18be2f53aab1d75d2b79029729022a3a57b4d56d7e32c7f513b29926a84a92c54ff348a7e4e14254c356274a7d013dd19ce0f28ac62c016f9a853ac150a3e5c2e5ffee0bd24b3a780256ef95d8592a85e98274c6900280e7a5f8652164f4ca7659ff96ac69eafbf3a18d259bf15a237cdbb02b2c355944315474acfd046e601f1954292b14daaa67ea20fddc291c53f49d9c9709b61b91d85e199329f3da8ae91b068da7c21efe82c1bae35d65843ddf8b1303b866e86e0ba7fd1d511d6353ec6b38055785a90acb126f9610f2fa52f54ebdf3916063966814f29ca3618de0dd02f9810a25dd8b4a2ce506ced9d02119f7ac3a27fb4e771cb5f8cc51ea2ec87fa393a0e08949f2f6ecdcd72d3118a637fed69cf4ac3305004f233581208ec658d58283f6159003bdb9d959a6ccff4b425e20e068a9a6dd113f69f17276efcdee406e1101b0e7cf00514ab950a24c3a21ee01633c7fdc7dde64866b1f552e4c262d5b00e517e45b4c36bc18c46cc8ced8f816f1a97844d2caf9915b3a0587c56eccd5ec0f1df33379b2ed9bb9e27f4f188124134780bf37c71a7b376a00baeba92a3e701c354cf849bedf9ba7433029c9655e7b89822e28c3027d012f94dae1ce6f8f4f211e2364fe4a25553187bf16464a66aaae7ccf2b6bf5230c58d7cd4237c73bfdae8371c59010f5f830a21b63615d85d438b149e63ca88bb0a264a128a02f3c28fce69d9cc5da9ce8f2c27b84adaa230a104a8ebc3343545d7e757be164b98ab03b498d32a444f41cc5a9839960c46d61215adbfbbb25758fbbb46b4fc213c5231a990a376e3494ed47b65fe28de037294d24e290ff6b027ec0a4bafe039da220595d8bf41aad48e9ce5105566692428f89a1366084d6c039eeabab706ce0db15e29eb0f4886b68421eb9c332cbf2238f354d969289942cdf2e9cdc9250afd4e685d57c4e0bb7cb645f77a9b761fcbe414cb04f3a09007e9227bad052a8d89cbda70568686c8d14c2f13063c7ac3428a97dfc31028760b56623577552ecc70a61728e159395d0a61dd90daf5ee2cb89808c1988c3f5b35e2544f7270499d6bdf912f4de4f88bbf0762aa8c9145a9639477d1f35e9bd37892aa43dc04816d2a507ddfaf2ad258e80649fe1c730cdc2bd4105dd6f5505b19c8f3c450ccc69b670e960503ad764e972dda5d26d0a5eec5cac6a7104689b48ee261f18f7e1f258c2020a91a1f37c6e08e970f077da690188b78e581356ca8098e4d7dc5f20fc04daa041504b5e981062a303cb3b0306f518f2343e779cb2ebf6f67981baecd266c75aacf5a2984f069de7e3d9794dbb09ebf76bf3d2faf6d8698b3f23ebaf85858498f02e98b22f031b153210bd2e670ae96b9e766906182ea6c989001f4925b321f7f9ff03c0ca4e0c9f121f7146a6e21d881f2481b1e4327cae4a7e1c3d71f9512caeb6396c1e7623523eb14920f6cf0cc04d6bfdc1402ce22f6b6ab1a86916753263333e14a882a8d9b17c7314580da907159ee0a469e3cf415db9ead918c2f8805356e498189eef409919a92af69776c86a9022edaf07a0297e526ea9b137e87b77956f0fd47751621f4575f720c3567cadb2c96d605150034588f4fe660e21a2b131fc801ce1c31a8842ac569c04a123cc1e1afe1a116d836d4d22c4d18446df4477158a1e8987ae75c4e54dbdffd1855f8a9c8a8d857ddf8ac4e75fa1d8149a6ff74b2250851d700a87ee7a943df9497b695f3c3cec99f8a3140b9c4c9234193d4c57251afe6cf1150a5d7662341b0f32eba00027bf7213e9840d3878c297e6f5df0a7d36034272c6e901cbce526943b2724bab29f727d15beebe99d6aae98ce04dce3dc0123ca308945469e0c11435a4e0cafe1b69a4e7a5efda5ff25690b8db9c0ec421d5c0452b050677c90776828cfe0111f0fbb88570e9643fa40fbaf6877184a049bb4692f9483e4e6b79d62f5de7ea2e17a710128c9b870b04fca59c0aac8f655a46fd77cd4f4f30258eea296ad19889d8d0aaa5f298eb2f9be1e1b022769453d8e5478f8637e52541496a2ff591bbbb083b7631210b2e4ecd841826c4d847a8dc187209a257155c3e613f5af23f9451a399fe877c734b04bf542fde5f60946fb9e73896326d4b3d71d847427ff5ce206f8930eb4db8569b69e6707b6f1e18473c075151b142d56cb32e9e12a788a3e7d2e17a9c61e883397ba2d201918d9cc8e6f6c8f627aaf5a182949ab74677d8eb25de0109d49c28e3902a2804c6535999cddb798d2aaa985d1e0b352f4caae07b5e0b29c341442470dc74cc235d2a21f4fedb45070a2726f5f899d23c60ac17d8fb2ad3d6eb628d312e9e267d223310ded9446bdc6e18e56df281ba36957e2b85510ab3392bf76995ec8397b8c2443c385d18c08d757c740ade777235f504f67b05d765b06ac43c2e0fba3f22a94556120f572bb6540493c369dd8f493a148e5f380d6ad4998f87056d322e25b53f0f1c8d9d3661db2d2479cb5294f4866fcb78c58a301889b2c8fad37b10ac50c22419a5b664a210c6d4f0f63032d599382b80cd8b1afd272be6b9ca14913de4944260a5c165bfcf92a1c493cf66a98983544d3bdf561ed7a13d05190aa2c409e2ab733970522c96b28d01590fd0aceba2fab1462a00d3072c5aef8566d16ed1615679e0fbc86a2cec496c9a43187eebe075570f388cc443c6d5efa6ae07dac6583c6dbcba36b3d2362af01e313f95c27ab344db2b5297e4632fb16d1c749d27bfc065cdd473089fc48a864b82cbc168d3962d58280c85bcddeec7359aadff5f928d07b1aa4dd4cc9c4b0022885fe8e8d9c52f5100e2747f14d5bab1dda27095935543f69c0262276a41438239e98690ded3df9ca95f9b220816c99c3b5af67b079c0a6ef2dfcc69e16ed3700f47ccded2e448b8210cba00d3a793fb5d1b424c23a578fa16e966706c80e208ac67b7747e7c84f148539ff7a7ce4d58b8d06a34f3d3b458f0ad3b893bd7b0d66c773c3b9e198421d71a8ddc46e40c4fa85814c4873497fc61888d9d81a796cdd56be49bf75b5adf8b2055253f74b47002a44eb64d6c8923e29a92bea4dcc9c75aaf8701d70b39ca6650948bd63175d2330c828e871e8d228690a4a8af5dbee8b5eec1eef06fd742ddd4c5ee62ee5d850b2e191b7fd23298d1a6932aa19f179a6b43efae99261773e50409b381b01db3591a6620fa99e542bee874c6a8dc2d4b4f45db1fa7da873bb626df9946ef12ae295d321136702c7325286130a1bda446308e4d6c84430cb26b4058e27523b97292807c0a4fa47e07cdf5871093074e0921bcec0e1b147c64b3665f7083350ec69cd58692685f018a57d03","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
