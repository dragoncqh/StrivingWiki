<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>C++开发框架</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="C开发框架-D00DA078"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">C++开发框架</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p"></p>
<section class="section"><h2 class="title sectiontitle">一些稳定的、可信赖的 c 语言通用功能库</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="http://developer.gnome.org/glib/stable/" target="_blank" rel="external noopener">Gnome
项目的通用功能库 Glib</a>&nbsp;</p></li>
<li class="li"><p class="p"><a class="xref" href="http://www.gnu.org/software/gnulib/" target="_blank" rel="external noopener"> Gnu 项目的通用功能库 GnuLib</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://apr.apache.org/" target="_blank" rel="external noopener">Apache 的 Portable Runtime Project</a></p></li>
</ol>可是，它们是那么庞大厚重，就算拥有模块化导入的设计，我也还是觉得，这是把牛刀，我杀鸡不能用它。我要的，就是一个提供了基础功能的，而且很多人都用过的，经历了各种风霜依然稳定的通用库。
 有了它，我才能装酷。各位宅，你们有知道满足类似需求的库吗？求推荐。&nbsp;</section>
<section class="section"><h2 class="title sectiontitle">跨平台方案研究</h2><p class="p">对于一个软件来说，一般都会碰到几种广义上的平台特性，特别对于跨平台的网络程序来说。</p><p class="p">1、硬件指令环境：比如说英特尔、摩托罗拉等芯片机器指令都有所不同</p><p class="p">2、操作系统环境：不同操作系统或者同一操作系统的不同版本都存在需要兼容的特性</p><p class="p">3、编译软件环境：现在很多IDE都不一样，即使象C++这样具有统一标准的语言，都会被相应的扩展</p><p class="p">&nbsp;</p><p class="p">跨平台方案首先要解决这3个问题。一般来说，我们写的都是应用级别的软件，硬件环境可以由操作系统或者编译软件来处理，不需要太多的关心，但还是有一些细
节不得不注意，比如说字节顺序，大端还是小端。一些对性能要求比较高的软件，比如Apache和GCC，多针对不同的指令集做相应的优化。</p><p class="p">&nbsp;</p><p class="p">在很多IDE环境中，都会预先设定宏来指示编译环境，比如什么指令集，什么操作系统。在通常情况下，我们都会以这样的方式来编写跨平台代码：</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp; #ifdef LINUX</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</p><p class="p">&nbsp;&nbsp;&nbsp; #else</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</p><p class="p">&nbsp;&nbsp;&nbsp; #endif</p><p class="p">&nbsp;</p><p class="p">利用编译软件为我们提供的宏来区分上面3种情况，这种方法比较简单，但在大型软件中，会让整个源码中充斥着宏，大大降低了源码的可读性，而且很难维护这些源码。首先改动一下功能，都必须考虑对其他模块的影响，以及对其他模块在不同平台上行为的影响。</p><p class="p">&nbsp;</p><p class="p">我们指定3个源码库作为跨平台的研究目标，STL、BOOST、APR，这3个库都是可以跨平台的源码级别的库，而且解决的问题都不完全重叠。比如STL
更多定义的是与平台无关的功能，或者一些已经被标准化的功能。BOOST是对STL的一个扩展，号称是STL的扩展库。APR和前面2者不一样，他完成是
重头开始实现的一个C类型库，可以在不同操作系统，不同编译软件上运行，在局部还针对不同指令集做了优化。</p><p class="p">&nbsp;</p><p class="p">一、STL的跨平台方案是通过文档方式，指定一个标准，由不同的编译器来实现。这种方式的实际意义并不大，因为绝大多数的我们是不可能去制定一个公开的标准，而只能根据不同标准来实现自己的功能接口。</p><p class="p">&nbsp;</p><p class="p">二、BOOST是STL的一个扩展，他封装了很多和平台特别是操作系统相关的特性，如线程。在BOOST的源码中，主要分为2个部分，一个部分是C++类
型的接口，另外一个部分是平台相关配置信息。前一部分主要是平台无关的语法和接口，后一部分主要是平台相关的代码，这部分依据平台特性，实现前一部分提供
的接口。对于用户来说，看到的永远只是前一部分平台无法的语法和接口。我们更关注的是后一部分内容，来研究跨平台方案。</p><p class="p">1、配置文件【config】：针对每个环境，建立一个对应的文件，在文件中，对环境进行初始化。这个技巧可以通过config目录可以看出，config目录又分为compiler和platform子目录。</p><p class="p">&nbsp;</p><p class="p">2、平台细节【detail】：有些平台差异无法通过配置来消除，特别是一些缺失的功能，所以在detail目录下对这部分做很多有效的补充。</p><p class="p">&nbsp;</p><p class="p">三、APR是C库，他跨平台技巧比其他2个C++库有更凌厉的表现，我们可以从几个方面来作出总结。</p><p class="p">1、预先声明，具体定义留给平台相关的文件。比如文件操作，LINUX和WIN32下的API有很大区别。</p><p class="p">&nbsp;&nbsp;&nbsp;
&lt;&lt;file.h&gt;&gt;</p><p class="p">&nbsp;&nbsp; typedef file_st file_t ;</p><p class="p">&nbsp;</p><p class="p">&nbsp;&nbsp;&nbsp; &lt;&lt;win32/file.c&gt;&gt;</p><p class="p">&nbsp;&nbsp;&nbsp;
#include "file.h"</p><p class="p">&nbsp;&nbsp;&nbsp; struct file_st{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HANDLE handle ;</p><p class="p">&nbsp;&nbsp;&nbsp; } ;</p><p class="p">&nbsp;&nbsp;&nbsp; </p><p class="p">&nbsp;&nbsp;&nbsp; &lt;&lt;linux/file.c&gt;&gt;</p><p class="p">&nbsp;&nbsp;&nbsp;
#include "file.h"</p><p class="p">&nbsp;&nbsp;&nbsp; struct file_st{</p><p class="p">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int handle ;</p><p class="p">&nbsp;&nbsp;&nbsp; } ;</p><p class="p">&nbsp; </p><p class="p">在头文件中，只声明了一个类型file_st，这个类型的具体结构并不知道，只有延迟到后来每个平台中才被定义。这个特性在APR中得到充分的应用。和BOOST有些类似，他相当于将整个库分为平台相关和平台无关的2层，但具体技巧还是不太一样的。</p><p class="p">&nbsp;</p><p class="p">2、结构指针</p><p class="p">预声明的技巧，允许我们将具体的定义延迟到实现的时候来定义，但遗憾的是，我们同样无法直接使用结构变量，因为这时候必须为编译器指明结构的具体定义，而只能使用结构指针。本来可能是很简单的语法，但我们不得不换种方法，比如：</p><p class="p">&nbsp;&nbsp; struct file_st file ;</p><p class="p">&nbsp;&nbsp;&nbsp; void
init(&amp;file , sizeof(file)) ;</p><p class="p">&nbsp;</p><p class="p">但是现在不行，因为我们在外部引用file.h的时候，实际上并不知道struct
file_st里面究竟有些啥东西，而且sizeof(file)，也必须知道file的确切结构，才能计算出他的具体大小。所以我们不得不写成这种形式：</p><p class="p">&nbsp;&nbsp;&nbsp; struct file_st *file = NULL;</p><p class="p">&nbsp;&nbsp;&nbsp;
void init(&amp;file) ;</p><p class="p">&nbsp;</p><p class="p">struct file_st是啥样呢？我们不需要知道，由file.c为我们分配这个空间，我们只要得到他的地址就行了。</p><p class="p">&nbsp;</p><p class="p">3、分目录存储平台文件</p><p class="p">这个技巧在BOOST也有应用，但主要体现在config目录和detail目录下。而这个技巧在APR中应用十分广泛，你在APR源码中，几乎到处都看到arch目录下，有win32、linux、beos以及其他操作系统的的名字。</p><p class="p">对于不同编译软件，APR主要通过工程文件来实现的。比如在根目录下，既有configure.in也有*.dsw文件，如果你是在LINUX下，你就可
以直接是使用configure和make来编译LINUX下的软件。如果你是在WIN32下，也可以使用VC直接打开*.dsw文件。以此类推，每个编
译软件通过这种方式区分开来。 --------------------- 本文来自 romandion 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/romandion/article/details/1763211?utm_source=copy</p><p class="p">&nbsp;</p></section>
<section class="section"><h2 class="title sectiontitle">APR – 被遗忘的跨平台库</h2><p class="p">提起跨平台库，很多人立刻想到的是C++库，<a class="xref" href="http://www.boost.org/" target="_blank" rel="external noopener">boost</a>、<a class="xref" href="http://www.sgi.com/tech/stl/" target="_blank" rel="external noopener">STL</a>、<a class="xref" href="http://www.cs.wustl.edu/~schmidt/ACE.html" target="_blank" rel="external noopener">ACE</a>之类的，很少有人会提及跨平台的C库，<a class="xref" href="http://apr.apache.org/" target="_blank" rel="external noopener">Apache Portable Runtime</a>，就属于被遗忘的这一类型。</p><p class="p">&nbsp;</p><p class="p">前几天一个很偶然的机会，当了它的源代码并且读了一部分，发现还挺好用的。但是不可能一定完全满足你的要求。</p><p class="p">&nbsp;</p><p class="p">对操作系统底层的抽象很多，无外乎内存管理、进程线程控制、IO、文件系统接口和IPC等，其中对于锁的设计真的很全，甚至在Windows下把posix支持的<a class="xref" href="http://apr.apache.org/docs/apr/group__apr__thread__cond.html" target="_blank" rel="external noopener">条件变量</a>和<a class="xref" href="http://apr.apache.org/docs/apr/group__apr__thread__rwlock.html" target="_blank" rel="external noopener">读写锁</a>什么的都自己实现了一遍。仔细看了那几把锁的实现，用的时候还是得小心，例如那把读写锁的适应范围就比较有限。</p><p class="p">&nbsp;</p><p class="p">对数据结构的支持很少，只看到了<a class="xref" href="http://apr.apache.org/docs/apr/group__apr__hash.html" target="_blank" rel="external noopener">hash</a>和<a class="xref" href="http://apr.apache.org/docs/apr/group__apr__tables.html" target="_blank" rel="external noopener">array</a>，这可能和C程序的弱类型有关，很难像C++一样写出一些类型安全而且又可读性好的数据结构实在是很困难，此外C语言世界里已经有了很多通用的数据结构（例如，<a class="xref" href="http://cvs.opensolaris.org/source/xref/on/usr/src/uts/common/sys/avl.h" target="_blank" rel="external noopener">平衡树</a>）了，没必要重新发明轮子。</p></section>
<section class="section"><h2 class="title sectiontitle">自制跨平台框架</h2></section>
<section class="section"><h2 class="title sectiontitle">参见</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="https://www.ezlippi.com/blog/2014/12/c-open-project.html" target="_blank" rel="external noopener">值得推荐的C/C++框架和库</a> </p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.codeproject.com/Articles/20648/DynObj-C-Cross-Platform-Plugin-Objects" target="_blank" rel="external noopener">DynObj - C++ Cross Platform Plugin Objects</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://www.c-pluff.org/" target="_blank" rel="external noopener">C-Pluff, a plug-in framework for C </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.codeproject.com/Articles/389667/Simple-Plug-in-Architecture-in-Plain-C" target="_blank" rel="external noopener">Simple Plug-in Architecture in Plain C - CodeProject</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://www.codeproject.com/Articles/6990/Multi-platform-plug-in-development-made-easy" target="_blank" rel="external noopener">Multi platform plug-in development made easy!</a></p></li>
</ol></section>
</div>
<nav role="navigation" class="related-links"><ul class="ullinks"><li class="link ulchildlink"><strong><a href="%E7%BC%96%E5%86%99%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8F%92%E4%BB%B6%E6%A1%86%E6%9E%B6.html">编写跨平台插件框架</a></strong><br>讨论使用 C/C++ 语言开发跨平台的插件框架所需要的架构、开发方法以及部署。我们将以一个简单的角色扮演游戏为例，来说明我们的插件框架。在该游戏中，我们利用插件来添加 NPC。游戏引擎加载插件，集成其内容。我们将从分析现有插件/组件系统开始，一步步深入了解如何开发插件框架，以及很多需要注意的问题，比如二进制兼容性等，我们将开发出一套具有工业强度的插件框架，可以运行在 Windows、Linux、OSX 等主流操作系统之上，并且可以很容易地移植到其他操作系统平台。这个插件框架相对于其他已有的系统具有一些独特的属性，并且灵活易用，兼顾 C 和 C++，提供多种部署方式（动态库和静态库）</li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/ORM%E6%A1%86%E6%9E%B6ODB.html">ORM框架ODB简介</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B_enc.html">入门基础教程</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B_enc.html">项目实例教程</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/%E6%95%B0%E6%8D%AE%E5%BA%93query%E6%9F%A5%E8%AF%A2.html">数据库query查询</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/Container%E5%AE%B9%E5%99%A8.html">container容器</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/Relationships%E5%85%B3%E7%B3%BB.html">Relationships关系</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/ValueTypes%E5%80%BC%E7%B1%BB%E5%9E%8B.html">ValueTypes值类型</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/Inheritance%E7%BB%A7%E6%89%BF.html">Inheritance继承</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/Sections%E8%8A%82.html">Sections节</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/Views%E8%A7%86%E5%9B%BE.html">Views视图</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/Session%E4%BC%9A%E8%AF%9D.html">Session会话</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/OptimisticConcurrency%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91.html">OptimisticConcurrency乐观并发</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/%E6%95%B0%E6%8D%AE%E5%BA%93Schema%E6%A8%A1%E5%9E%8B%E6%BC%94%E5%8F%98.html">数据库Schema模型演变</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/Pragma%E7%BC%96%E8%AF%91%E5%99%A8%E6%8C%87%E4%BB%A4%E8%AF%AD%E8%A8%80.html">Pragma编译器指令语言</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%E5%92%8C%E6%9C%BA%E5%88%B6.html">高级技术和机制</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2204_CPPORM%E6%A1%86%E6%9E%B6ODB/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8.html">数据库系统高级应用</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2205_POCO%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/%E6%A6%82%E8%BF%B0.html">概述</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/%E6%A6%82%E8%BF%B0.html">概述</a></strong><br>openFrameworks（以下简称 oF） 是一个开源的、跨平台的 C++ 工具包，它的设计目的为开发创造过程提供一个更加简单和直观的框架。</li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6.html">插件机制</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%9C%BA%E5%88%B6.html">项目工程机制</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/%E5%B8%82%E5%9C%BA%E5%90%8C%E7%B1%BB%E8%BD%AF%E4%BB%B6.html">市场同类软件</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Ubuntu%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85oF%E6%95%99%E7%A8%8B_enc.html">ubuntu下载安装oF教程</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Windows%E4%B8%8Beclipse%E5%BC%80%E5%8F%91oF%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8.html">Windows下eclipse开发oF安卓应用</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1.html">交互设计</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.html">交互设计编程基础</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Processing%E6%95%99%E7%A8%8B_enc.html">Processing教程</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/Arduino%E6%95%99%E7%A8%8B_enc.html">Arduino教程</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1CPP%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.html">交互设计C++高级编程</a></strong><br>交互设计C++高级编程</li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/openFrameworks%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B_enc.html">openFrameworks基础教程</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2206_openFrameworks%E5%88%9B%E6%84%8F%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/OF%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B_enc.html">oF插件制作教程</a></strong><br></li><li class="link ulchildlink"><strong><a href="../2207_Loki%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1/%E4%BB%8B%E7%BB%8D.html">介绍</a></strong><br></li></ul><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="CPP%E5%BC%80%E5%8F%91.html">C++开发</a></div></div></nav></article></main></body></html>