<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b40c34c8aaf95008cf83f2c1956b8dde775f1f6c2df7af734dfbd5413fdf37e0034bdabd6a12f8e2cee45051e96f6e09ad63b80811a7a939947c82ec8d9f9f57cd6d001ee53c81ab4676c4220b581bfab0eeff1cc05cc2b2d403eb229d3b13728b0b8bc118ea4255421f64d2f79baa237ecdd747e95781c33cccfaeee76a24f399860af4ce596c1e6e5b4718ef390d129d31e95f5ec37ff4cb1fcebde268da1c4d3a07005a0c61cb24eacbc3669290c50fc4b1125d4adae886bbe5181a1bfddc8d07e5bd5f4a5538e2816d6aead1725c0dd30bce0090fb6aef5b191edc390bca9531a4bc148cc329922e411bb09d832d029402019d1441162e081dec6702a6ef286b9f2c506bff826d5f42933fa998465bdc4bab46f0538098addea6030c11df097a15d05d69a0c8a0b8ea7c26a65271d0b5a0290117885ba0dc64c52c271731ae76df5f4da7f3bbcc205de00502d91e54cab5d4b651838fe7cb8abad42187b2be38ebee96365dd3b9cc8ff21b30208ffdd5ff4c2af842fe52d2e0651c102549a4be58f0bd452c17de3437b1d3b30659d8fd4947863fd0bf46868fad14bcc2718b53aceefb302b456dd0274c68102363d5893149d4f153db48cb147c7cdbc3bfc9fb7a66d2923dd78c50032c03b46eca77ef0b2167e7530c35134c4d57e9246229ad286d0a24407235b764174b61de246fb65a007efb3e2e3a6d4e230edbd884c04d0b67e8b289a600405ea811cb124dfea60635efd5d1a375cfb837825a722f9882de428d387dab00dc527a15f6dee717e0e7b73dacd22680d271db7e7cdb8541431cbe87bb85aaba07ee54d1c4c3d464801df5abbaff7517dac30e4a009777dd80b2a3c8f7335e10afb80cf081c734d75c50238df92955ba0c8b6595e978036ab87a36105266df5e7a84959240bccca3a669f6caf5661cc84b3649d18e767c7b04a1806e7ad9b5aaa4b7e797ffbbaf1ddc1e7437cd9bc5c65267e7cec7fd19348b33f22f51be4edbba0ebff09f897f3eb15c78ac642fcf028e25cf7edc1f578ac59734694e0e19ee9c94bc9f7293e80734264ddf39da96562ea0f2136b5f71f113b20b257ab8b3d9f8ef03b86b1e1a9ae23afa48b85539c20fc5c1be81dd274a9146ffe389e24363ec712404ef826d29a47363eb2d37e7c4e8edbe9a6bce5be6aa57495e066b4cb387b7ac200287c455cd3fa0e6545d25b691c4b28327a778a4009bb40dfe4d8094bc7b326b2e2cfec80165a769a442adec7f6703b137c86beaf4d03a45ff23ad1531e595a3b7c71b913cb26fd951f11c8406b03fb1f4a3b60b88f6925cd2bef797af0b3e66279b798c567a5332ae0fe6f7963d99a90806c13dfcce2947b062a01185553345afd58c68742fa1a41268197bbaf0470dc01e9a2e954e72dba5c06ba6d3b22068d990b2edd7366efe256c39fd55d18c2b35f8a43708bcda4e28cae828a1a3100a2f5a5b4b51dc0f2cb17686162745c79959c0608ae95b873233b0fc2bcdd588a2347a082cd1b24d999eb4b89bab2256563d7a72b3675ba01c59683106dee8e5617fa6ebce6e85e4ad5eb074d6f53a00c971d482cae8093c85c7fe088df367c344ac8f6d1b9d674fdde6d49d721ffe746a9cc7089bbff49941ced28b496681a09fdb4c4882adad408742c2c327dbdc45162590a7210ae3679202259de807f34f08a02961c455d64457e91653d91893a29681f1e68e3691a2c4a148a2fabf0facc4c9c3ff5ab137625a36d1687b08a0b1f0834b71fa8f019acc287a59ca06ee062a39b5ee00baf85fc336018a99d3d45cd8c0e99eda2b6e035c33548090399763dc4185c39d17657bc64151a357fab4f7aa15062f165ecdd9c77ebd10181bb3865af14f1d7fd2d6a71778219e452c37392b2cb2fe672f4497fbb8a1aaf6df0fb2d1e88d4fac06073abc605da4bfd7ef0d4923cca9bb212f5cefc4990f28e3b0e99f5c63b6a253fb7e9088df9aa49394235a37812159ae0f74331fab6f6817faa9e9ca4c922bf2e144e78d746869e3e47ccdcb86e438c372593d4b0b10839f4b1887b2eebdacf5eae5f584290437d0cfd2851fdad9889a5248a68e681d775d454c22f6f226457bcb9c831f529df6cdadcf63d6354c9a170b5ad218fe0ed74db57c88474135cff9e67c660bbbabf2d652a4031e8995e7e6d4d00451ef65a4f0eaaf6bac4c647c8352188882cea941129bf978e9a28a0899407b8b9f9a58f18688e912a79f6c4440b8f7950abf6d1166b904c9d31e8615fe769b1e53582b5c3aee8e3c1f3a017a3e0e5e6d2d428e7b43cdde254d12c1aa3d982329a90aaf5a0bb2ea4a2179622012df7f0904752098547dde93bdaf776a4f3c62b79d55602ff7ee86a868eceba2a23b9694f3463ce46e00aacf8e7791ddb67d42883a138774b255007e076129a517389dabc1cdde96f3116b09e9de64d6d06a539dfff8d7f5255b3f2163c9ef7f70a6e1240908e92b1c25dffda014af6c7d752f9b2b16ea46a215a9373d4c1be1d34dfe5eb71fe0e4bb10c4ca8a37dffbb20b5e9453278b631252ad0dda69559eda0286b3c5076d87415ebac4fdbb0669dd9500db675bf4c39605b4ac4b478ef876fa32700da7bf5df2dd98918961e2caa70e3172e5d5ffeef0914c66b14bba9ad7cd1fc7af06b06b0829915fe9c6c96c9bc33e3ca100a87e974f21ce30c6653c5c74e5e8b5d592de24e1d42e3376a4a9df7f65e9b9ca87bebbb329820642f8ce6624f6d97e4456c903d7299a322f56a62b1dd28f98a5985e1e4d77fa8e243326bed4163413b2832171ecf069b9b021116c036090f6251b7a9af8a79ed64e49f667dca6cd94e211f5c8537354a4d99d6278b7a784584221b09f0419fada63af4b9412eb5cc0d4aa3e40b2b73bb2aac9558748346ec756b584278dee3dd3bd5de4abfb4b8dfcb309979686e490f74623bc119543b80ee991ae030f3b78bdc043cabb63387358792670327e5d37375a0f34a0ebb646d836d0f35709f9970853c659ec6f969a89a9333bf5e234d26a7e85de13eb142dff184971ac6b8b6353b8fa1a36eb217f60ca5f3bcab7ba414845d506c23db11ce82d861d5fa508f932d84fbf0ad43790d3797fdedbb8aba5c08cb348af9680d2f847eb9624115f726f98fe24ba81b69ed8fc94128ca0b79cf9a9d312ef7b668186e078b99091fc5a9acf858db904d99c782f6198fac891fbb1ab0dc4c39ab7791446751f8ac4c931c4c0e372e038c1c719c25b482c862a9f4be50d7929adcc38381072059ebac296e7dddde47c13fb6a5f7857e14fd810e47217220c291ec23781dc875ed1713be87db0b5e09de7bdb3db4f73988dff4cefa4cbf38513fe402d5e631efee5aed556ba0bff0a935c044682de37db79ee847639c19baac3d5436f476050382805389c7c963ede45cf13aed8170a1a0fa75a17ac8f7e40a8ef7b77047e246e6ed5121d0d1bb8bc92c96767e3a0ea6a70dd683bfd524cfb60825e8db98f59eea4d427531775b9d17fa63108022b566cff2228220da58199809d034469518ea9e97f7125458713f7ced385d9b1e9acea6c84c25ca50da9a8865226f1e91eab7ecba6735e48bbce355098829bae429f6b81686d5a419165f3c91cca17d315e2741fda3a0b9781ee3fa3c463a1a5a2dea9016441d5b4381f5d4660f3e8a44f64742de62c6059ce3e232b33968036dad58924c3ce5e4dbf5975242e4637749b99c4e291201294e0b1f5af8023e70b8624ec5a791e796737f2834cada00d4edb634505962908bee3f2e1a667ac63cb405ca542d30924b52e241fda0fa3a2a0bfe61dd6069231a4a8e8df0e599f136242a6be22a2e83c3a830d1fa7675f6da483cb8c98aa1065682c77c9b799a57546566295d30fb5492f0b17e59c63493e5f722274f597a509b03a5c12e1f281988684ca0caf70499ecc68f65fcc4077f32a57d8262a0684da8e33f64ceaf67c2fdec59e616d56d6236d158ad197179126757f028b7162479e454de363a524df0062ee4c84436cab3a3aba588f37b726aba41eedb7e7ceb36bda0223827e1f92cee260aeb4c756343e28fef33b818f6d1cb0e643cab9829e774227dfe004dfb2188d894118f2097bb0074fa4c750ca1e6d332e043bebd7660237fe98a4c09363ef46225c4519d5245f9a28357705daf7eac6a6eddf9cf490f8dc8de18dca5ccb8e5553823cf46e6d896c3abff836f792a87eb0ccc9aaab2be39859a5f8da4590feb414d6afabff4dd76e97f65bcfaf2b01e0895d1a8891e307bc8ac951b44a96a63894acd8a460477593f426235cab71568e2ed649b44c24d71400dd2bd1b88a9add69d4e96a9174a2de0433a38fbe536dec8f27cb21b7a1d7b61b6bead3b3912a2ebfa98bc06ea230988f8554769068a82a2ff2b2f86ef043b24e6f3b3a64a7bddde74892fe4cebc4c849addb4c2efec005b73607d6475af538fc3b0e2a6de5eb438ed8ea44f0062947540274d0ad47795635f8d743e4dce4dad650ed8ff01efd65d000c9e928e6f87d6dda912658bade0e43b1e25d0aa90352101ea84ff8bf74928c0d4c9de005b2d092b34ae13bf0a3cd1c532a8ad9951b948b7695f432dccd232c4854e9190fdb9a9f5c0531b0e3752b47fe2b876bd954836d23ecb11f1ef9d6d5f01b2a3d7d272f6d1e32cac83f7e256f121a5a72c2ecd3f2405bb29125759b52b252ce9824a0b45143f8729f40ae4f5f13e11e04ad280546c09b77cb0f6fd7de2d7322f1d7ad5e62d10420eaf46d3027dbdcca50f858be2a31db1c3a1a8fcc5b6becfbc6985e422f635899483398f540ffb84115b9251b01b5585697c9559fb51576e7548c51f35a36895113c126d99012fe027bac29a494181bcfd1fd0e09ea59be5f04b5a9da6cacd7896e2daba8ba767e79309ccc6b5186e381da720dda6e7554346d770d355d5aa954584e49b8f5a64d6c529fe4b6c7a34ff21df755484fa2b1c5b312fc7485ddc3894c5ca3efb576e7d7b21aabc19fd80af2a9b842b3f173d96d2ce83e33b645ad772add8a8f704529ad55a91378c54102c8bc1d2effb7aff94c13dd14598997dafdf0d17a8823cbca7efdfbbcb5407b837eb772c4f1513fb05b5aaba3d255e4719f720b28dd6e7031ab2a85abcd733ecb4a8807ef200131b3570d0e5e638d0099903a4cbc69dea314ffd4b3f65f460d3211cfe1e574b2a48e661b4a479a88f1deab7edf65247156a065a0daf0fe3b332a7d9f0b6801a1c9187041eaa1257c3eab640fa8e559d792cfd6702232bce7fdd63e8eca1fa935d9e4543f32c42a9361ba2db635998d1540baab5fc31c87def84901236e70175cb9168e743d1c5d2d224df8e2dec8dc3293315df5a7b0826f473ae4cc71d0e159776fbd20773d9357e19684d423b8ba5271a2ebc76bb40beaedf512ea09655d48fcca192d022218c93414e3d9274a05ef2e251ee542ebc893741013fc1d4ea21e67082635c77fac0623935e28e9ac31f57bd905814d8fbeaccfe0dd54d7f48fdb991b7d04fcb3f4870f4d7640daff9f1158b27e0a9266f5025ded0438b3474a3161db92b8f677c7625f141c90dce39cbe4653c5d6a29bc7e489435094620b1711741ee41d471ce56e9aff07538c9be5d1aec633f9bfb6d0332fe665a49cfa224106bc4b0cedb876b13e17910f6e66b8f189ee8ff9ac7067d9a38b206bebc1a7ae2b17309b3ce599c4c9ef713a9238ecdba43fe8e73f4d6d3ffd6da6c827ce69e85252764424936c92f2ff1c4354086578f77cd0d76a90b374f5fb8cf9296e1d94a1b24343848280b478ef036a2a276ed2f211aecaffac048a43391a0aa65c299872780d252a0f898bc616eb0d36f1151d21ab3d1cfc088e2616cd08243f8852712b894cffba0d4e234bff84e0665401013fa1cf5dc98709005327d4dfbc81eec18975dfc78d0491d1c8e9de723b63766c05de07b0dfcbfed68f27158fe1f18996b19a533b4767e3c43d4ca3ef5e9b0581e69cd465e17952ab11548f20c59c6ffc0ab923d5181be55cbcd5725c4dde443d3a97a7acc200a9c89b90510821adc030f428862121660926434d20cebbae1ab4e41babe5e19385336c2d25633a555f19731e6ab6fa59464e9da6d5a819a30d34dc90a16fa3431d6bb8bbba5b889eba3765e655c3d6688853ac37aaff394ddebdb5fb4eb8c315c7c17aed626b2aad7d69767926b5911df11aa571422b0c3281e93773a8a5c7782d4ca7c1f4196bd9df6b36b5a18e11a1b873912d5eb6a798dcf8c27709e6a537575c4b1671acf5ff36bdb14e1d7520f96db6fc4ea9a89e85a76206083fc1e13c3625ba454afc4764d304a36acc06633812fc58d3562af75ba5c52b775b28b4af69f45160981b2b905b26b449092dfec39bba21dbc0cf7d373c8abbac7eede592effbbbc0985a830046b37e2d205e60765bdf45fd6f61afc21ab0c85f70fefb166518eeb30c11bd08cd9bd6183bbde90050290149fc6bc07291b7e71d4e04588281ba1140f2989e0187869826201f208265e9a45acad8b12397122f8e3b844a54ad7218c4e799570497f9f4118829588943a02912f7fb7f01453a8fc689f97cdc2b83e72dcfda4deafda4ca9bbcc0bc8c2041e56af14f07d3053057a82af6ce9275c85b7d3ad34e3dcd92f5e2e7b93498b9b161774715c6f5eeee94221ab1376b9d7919ee9c8bea745e43f58f8e77ed5b01568aba5e826468d6beb22bce3b423ad99d87bb059a5deb3c3434d3b4be7896fb9cdc4d057157e3af58960e64b9690ef82d19ec28507547a3087209bdb14b1741c9d5c4bf560f8db120ab5bf8fb3ecd7aa0b4d7657d58f8add5a11580ad946c834a51119ce1c8591de69f8815f808811de29855ed338de206a6fb84bf4d99da0f98a036872998d79871885a984e2d4eb289d94bbfd3fb94e764926681ef61295d40b278ac094fbdaafc76733291e00446ff7d30c66d602aa8af78d592542abbf87571fbdf51a603f5ed712bd8247c1488a81a9e8cf99812c2be1f92ae7c76169220d6a40363f8b2738ecef71612f4f1ae149d48b09a992bc6461d6aa3d3a1941ea566aa6fc9c26be803c6abbe5368a2f4f18f2f3959b2c125d6ff2ea7fea2c2d0ffcc03c399e5e0ea73f253e22644c7af29975a4b2ba28f864ced089580e5a6ee3a350f4021791a99d01e7733362e70c153b148b3fa7331dc0ad6393a3cec9e5cd84aa16ee10b84f9d5f59750681d6296dd6f19a27b4d864f562e980e6ffae593e7109d8d1bc668c197c82734f6a4d50727caa94e32ce3a4b18317aec481af805103e3402ae6aa6dc785142ebf4180d4856d17ec7a85ce84afc6bd9a6df7799b3dfeb6129eb9cca896e4f00e9f91f48b16f0e61f72d9e7ae577616f2aafb43aa50f516084a5c1877838b646d0a0479fa1664870a8aa49a206754c4dbace516c12e9af7569304f72a3bbe9fbfcd91af5766f3fc4bf41e256f973db89c62c68b96bacabeb70b99e7cc1a172862c69297d668fc099aeb7bfb629845838aea094c656b5dcb00ebd3364f5e61bd6c2cf45a1d5f5079321420e71fbc005fde9fc1c5a41ec9c814e5182ef4bf80eedee2c1394da574ed07b7e8533fb93198d0aada5a3bc6cba0d4d3b9f1ba6815bf13be90909a49244186f5f7f6ace2579d35114c15a579e4e1a9a52cc219e14177b55b42cecd517e3a02423c36d5ddbb78b66fbf047e327ce84c526c305d6e5a4a111a165fa6fb3ba84323630e526fe6f478bca4149350f89a4fff3fe82642da8a24300b759f3fc2ffecf953185278a746c5fb20c148905806a8ff6516c728ec5666dbdc4c50c4411a8de437867862d5a6841ecc63c9fffef0cda2de8dd13c0f4ef8e34612abf3c6ff932c44969286f7cd8db6dbaeacd54f947cbb7aa91102d10b087f1362f28813f0535b9b41a2cfaf5ec1d86105b86489b455241fa154bce5fe233fc37c4bd139413b1c3b3c45c413a6656cedcf39bceff898c42381a792bcd1be611a9401a04b3833a00fc5575fccf887c10a1f560889251e137c72db107f6d12eeaf907972fdbae681401bb4a45698cf833fc1000e5e0a1bce2675db2f796f3e048b7baaeaf87e758cf8ce8fc4ced02cc7f12219e1694b369a5f0ecabb4c98dab12cf573ceade74457986858ba4d372953ac80d3a659aa0d2f442e429c67d4774239034a5b390b6022b50a669345e3cdd66aba2249a172ae19f8cb9f425630c70e113eb76d41a29f776423fdd321ced6b13d1a3f4c6f5be8c0545c51b81d2d28b4dd7e2ca0471667dee550cbb8c2001ac27a8f1db2fc14194dd59bada8cdfc78de9afaf06e8b08fa35465e7f5e6533a48f37f8e06792dd3194398106472f8215194245eef0614dc266f25211801b9fb74bfc72189484fed07de0d6d19c4322c2f92c7a8918634a5909ae536693bbb50fb77e16aa6ed8f1bb111f4de882af5bd1cc6f28684e60ee08203cd7c4dc81e3d0d9d44a536075af0b3265402eda68cbc09befb9073b427a7d5e29b7c4e322184c1127187cbbf5349ac85bf395140d91454c4da52d6808eedb8b5ad1d6d5643d424cd01b4b2f9dc894e97b63e5cf457c099d1ef7a856102132436772e460cd7a1e95fa2661586ebe9437f9147c040d7ba834ce83717aba7d50c8410cca51ce97f0f6330dc8ef718872c5036effb0f9a8e585aaa522119e45e334b7be12516a4ccfe5d3653ed6970ade2fa45f00a35aaeebc7938a1fdd4b99e3b0c21b894f00fb44528f38312b1b6035f43a3d94ef65e9ac06f5e2c8e58e336043e527cff38a3c30f4ff12cc7dcdbf7c077f597b412893bc144831e30bea470803707d362e6a9856114d197d8163211f6656fa46c38139a05ec52783af440283ee0fcd735b18ff46f4843b63d27cf8be661d59f6cb68f50ad7b39af7cdb204c7f7d2f7a9376ed7805001684c6e7ed3c926ea6172f52f8d7092ffdddeab0eaaff4548958a370585a659fe812a4601fb7aac67d74c6f6fd98eca0d348afb598d418e6cfd449eb8a03aa149b5092c18d6bc0f08438c7f74dc99bf8b0063af77183370ae88a61c1ee2cb5ff5472f133fc77bdba38abc89b4d42cb8e4e2ae62e252d8f845fbe19116212e04abe8980f731938c6102cf457d4bed0ecf47da8e2f8c2dd9d2eaa171307e67fd976dd0ba64302e01e5959133ee284fa1995dbe7c4e4469243a87562717cf1959214903ea421f515511ac713ec9484ff38a197bc8119342e38bd9dd545bc159916803a9e1399a8b8dddba5a2cd825c7e5f66ec29c83df6564fdb44790cc2a78d584f610b2fc8b4757d3c65ee21909ab4ee2c2f42e96fc986529a4e9e4d57ba0afbdba93cf70ae04478bcc41c0f18c4047915be25e66d4153f226dfeb70eac81782d04e86fc679239b6daa27622404f2bfce0aee5647384ce6d09b901aee98318bf5dc2e72664bcfb52c9a2c69573ce7aef64c7d48c02919f340891ddfaad71034a56a3a2b03580bf15c89768ad3f2586c98a3593c79fb70fc82e3b8b21fc695c9032369f5524857256387945c542023b1ffa855006126e7e5b6b280f4e2abcd81099e33089abc1f85fd92702ac6cd01dbcecac2f9e3028f6348843506dfac8db864cdab8cf0ae2c655dfb494a3671f71886de138c392d2ef12b37ab2eefdebeae855069bf0526890c7440aa5d73f7797e7be5ec230e8be6ff3f0a6a2bc7555e277ffa8458b4ff6ee80155976eb24e35ff46a9f22dfc56b8945330f0726cdfbeb4376b2cf8a909c8a1eb68c4562b7f08f6a2019bc8731085870c0ff01ed721d0a2aff2c12bce4669a0d07737888d896425eee2271629476adbc2a8c9181efa1be12f8f93564b465c5bc9783b75a978c1e9ef70babfa141fb7682b848c8d7c6099f6d29e8aa8e40b1a372d9dad587299f420a31865caa1042eb3f6b6932aaa6c68064255faf1a5f370fc4f5f03a2b9eeabb99edcc0ed7bb1c996e898a119b432ca4f11df8c8dae7e29d054e50383bcc0768dbce3748602b01ef6b0e07da00ae3d58eb86b023ee847ad669b56c07308b579fedf36602a1b43d56a9fca620bc140993c7d20f6b949b379a622c92cff62e532a7097b99a2295368ac8b31455c358d847e8b3e033132e74fb51829fd0c30d42a439d7b6c01f84e670a6c5ce13f71ea77eb4aadd4b7c8094ba3189d43332f7641bf638fcab1a9afdcc3e8f6372b0c39110687f55519755eb548d4a429fed0749e0d7008d9eeb361f516e10be9ef695a47f1cc4ae592aabc6601184921b45340704ee860955e47b48e6b9d3dfab10ef7e9703da22ff9a24ec8a11e0d64e14139b6aa7864d28c01b5e6b3059df1a149cad542f69b8fc6804acc93666045a36ad76db027b7ba7c2c004b67c744cded29b763b338f1130fae020124b6eaf69df12d88e2b6f911548a13df6272bc8b3df73195e6b701544469a3decdedf0081d7817e88043fde02d9cc9999f4765657d2b2e5a7477268cb1c1111d648643a8a07e520637643688629e7fa9b28dc82cac03dde3451abe2a3b4956cf297955acab045d4fdb20cdbc60a12999c89ef2eb74d0bc6fddf6aa903a0eb0ac0f05ff93b6ceee4e5760a78fab9e32e621fa9e68477e3643ac68a33a88247b12d5fc1d191aee3e42790449236391a6bf96b3c1d6b241e0a282afd75e24d48398bb075b263d41d0bcf739a2c61926bf5b849307a0d40ef01b1430d9a94f5c0963a58065daa0b509e4e71299481ea11890788ed8d53dd3569ebb0473d2f74406c69afb1750ce051ded8ed9c59edbf6792e7b63fb705adc5e8cabc0a96ae92e3dae70057bf3f0f7029e623366129c3b210cfdb85766fbc7aad833e17682559c3424724d8adf4912cbb9c92de385c9ae908b821640ff9d6fefa739212a78193db637d199817e9944d89afc9c23316ca0c168c787dbc6b2fbd278ca1aac7575b84087eebc11cf8922694e93a81f1da03e7d0f7b5eb62c3d4bf1ebd61f6c703aa65cac82e5624be9c25e9f0d10ad308365fb619b9d2b6fe530cc97b7c3fe931c996b4ab365ccd2cdb8f57135906e2e4d3bc90b5f1330c365ccd9266eac473ca36cc440743e440ca82280e49f0a83ea48ee91c23e0b5301737f41a0c81bf515ca84408cf6d2959041bf3279cfb3664beadfedfaeca1b8994aa069e54517ba6710aeeb2d3bcd728ca2c69b7d5f07da46fb3ef4dbac1bb0ab7c6b16b7fc248bfc38beb6ee14aca6329f9a7a5715347f4742fc32836dc32f6cd6f034470d37033bb894573919c56cab8f4955cac532b8929602f926843f04512c376a1886c4b432455ce7be6a6159139999b6d55ecaae5036b661d9710958d5721c960ad65e0639bb63a83ec80124d4d6abbf69e5425492f0fbe9919c115fd1f243fe85f1d3f824f062c443a3e0ca463e0715d0e73f1fdf8a45fab2b66993251d00a6fcb70faef13a3d2c11941123e416f700172d6cf925fd257239f6e4c398d5d2a0b7c278dc5490445735a0a5bb695416050e958609cd8946f607f6accec008b2197dbd8274f9d916b645a40df3bab3cd8fe42ee3a163b20a8e7bea7c5cb6eef57326d5699f9cb709ba71d7ccb5ce4833135483e547ac88bb38e635353fe47e0ec920ac15fecd07647b6f78dd9c43798087e5cf5135d804b6f906db7b9c7a4fc5af5808e41e878233c76f4b2531a4f975305a4c972f8a04766c545fd7610740493ba4ee121fb50cdf1822fcabbbfa8eaf1db500d7bf076b7528b10faa1133ec4242fac9160ff5e6688624b7ec00431a9a9491921165309bdfeae58f93629f095b63e1e53c0280ef3188fa886c8523c3c584dd5f3d2ea44aa09154d5f0b56be2f3073133326da94e68ff8d0ee1af688119ad490591d2c448eef28e760f0c4a198d6d7794f76f3f454de9dcf8d2f60fd87dcd35cb5f409fea45cd6c08c6e786bd99c34b693f929315b4db6e62f9f5f40a5270c64b9190e8d9648fac8fddbf5991f34987a437ec2394300665f7aa13d2b3af4d7efa591c7e833e1a1cb767483cf5e589df58cf01b42ca500ebd46dab1335e8dee88d0fde5eec048a4c900bde5c9520f7591a80923d5d6ac0b0e80a9ba5a4864c9cbf3698241bc08a58fa84f24f0d11aca73c3287d585e40957d4921de6cf01449785183623ee08df4455ae089a2caba99fb40dbd95dbaf974a3a05f0afdb488e8237a916309893d357fa8802707dd9d2251b34febb18978985f3d564103446e49ba8860ccca5a35569e5b378de9fb9b01c9a8fc0818c144ce88a4dbc53ef4ccd2586a3e573098d7ca4a911c7a7b007857793fa4f531e6d961ca30131ea27ec75947c2e93ed36814afb681796260ecea0c07be3dc93af6db01b8823ea83cd62e594df87da53e96509ed6cd7dec2da83a39d5a4c597eb5ee75e919a1d8cb0ef83946200706672e80441520776066b29e0a078f7bc8de757b11b6082b5e3742291be332c455e31cf5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
