<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72b78a4c452a579de9e832b6039dd564965de138c1f0906953a907924c8adbd5ee8c7402d5821230e8490a48f0fede0101218c56fc53ab4158133378e4fca4ada0848c3c81bbf9d990179acbf4152bc4b0c6b0335597dabc4f58006603e59331625c89b77675825186691253ceafe606cf03c9a2bb0ba44f808228c703a8437a22077638f6b05c8d46448a51b36f758c2dbb6f291a12dedf821ff418d3e72f6133cf02f5399b43297c3c01027f88af17ef368159e4662d5c5d57c20f1edee08abf5ad1bc231a2a9448fa7ebc985d4b87a0007e45b0ec21603914e50054b1b49dfbf56a0e3af41afd1afc1a14ebde10ea073c27a0e65a5df223af88029b8ba493fdbbd811bae310d5928d01ba2e5d9a7aef9176c4108155590fe91711547732a2bf64d28bffdc2d6249eca290db6a7b8a8d83851b65829fbd5062ec0c581d3121aa0f0011c6cae433bbd6ba31a291345c8324d4359dad6ef524289d9a6b30ad9fd58a3d2d11530611596eac1963fd526d85f1b603ecade8c4e7c3d08f10152146bc1caf0c4507778648342663e7d0448e72ca5273c941ec823d22f0e5bc8d961130f5e334b084e178c7f390919ac62af1c3c633c6b70de790bba0e0196dd7ec7eaeec631f728bc912ee03b7b47d43af9be6cd9dd36b913f1eeb73b63c953ba67ba871c39b0996ce531ad82db508eb3daef35d0095bea8796c4900e96a68e97484326a72840c855fa1a2d0bcd7acbac52d7e475e3bd613953dedfd14bd6615301bcd0af43601f683fb76c10a910b23762d2a3aa046433ba47ef3e6a85ae0b0f345b2d96538a1ec56b7a1a0d5f0971e5bc6b8b3c6e06127a680fa91a919e550054e047df1b1ca2d07c49bfda9cf3a53f34994033bdd60282f6b64755aea76a8d4722c48c1fc092983f1b658977f24c7fd9a0d56844fc50a69505e17b73d3ca728798be55728e8a3f2239ff81d6ef954853ee2f61307d22a7e8c4c4e94e90f44941a750c26121ad7222db64140a6db08026e594c645e2cc521e447e1b19138dfcf3f02b492d9d1e5452fc781453267ecda0bd41fbeae5aa97d3ee7dc0270552c01843d491a1d0d9252bb880bd02a30304b9e16fd3cd0d7dbd749832d35d1f0d89a474ac9aff76483ac53804631ada73d393a4f99c42ce27b40f70cc1af4b175690bd80d9e08f159a649dd4d6598804b44d1d9623a4d208ae08ea28d7f7cae88465fbc9c88c05bb3bf0e6923ce2633f32129912edf874fbbebdafd6830843a56928827e8d98d11537a4f40f9cde7cfe2f39a8d37f09b0b7a347655aaa22782d73dee02861b6f54c5fef816451837eac1549126a80c79d4f62dc4bdcd389feefcc5fd31ae93a3570c2c4317755d5cb1b71b3d0575415688ed1bc34a92624df48af39f548f87b714c759b99daa650704a6199c465e655df11435ace92042538d7809291c1a25f88dcfcd9c0994e1c22f062b41e1f553a4c7c5c30f7411d459557ef6a999e6bb2e23036fbc6c3d6e2d564bc475b77f92c74fec1c7de321dc571328bc83aa1a75d7b2b344f314538a7d7adad9bcb9e33a96bc09ad87c3ce1838c57b54effd94ece18559e9898810db39ad4f617de161d166032f7ab2123c4b60ad0026e5e00ad295c83a045ab95a60a7a131bfb60255b4c76b66c5efd43f067e8be5d5535e2aa08c574975cf6700937d3dfa54ba755a2163ecf546ea462605cc30c65db2ff2e745cd84b3df28e1cde8eb7ae0ef04493f28edff64e92eaaf7f73c56c0b694d49fa579b2c4116eced15d61b747355b339f1cb5e7ae44ef4b1e62b189cb73989c769c1d0d05cba045ead00721f6a277e9e6bd46929ac806bf0ade2ee5df3f6573f09fe1e64dca2aa5296c4add1a95489fe5ca5364f0b20a86bf1a4e8e5c87c28bb20fafe4db740c8ebbe5edc5517859ca927f30d9241ef393b716c0d888754c8eccde129d8bae34af9cc9bce97d090cc855d5b7de9fc6af7ef15b22b8f01592365f8cd6d94da6bf39d03350827aa2cc0150837705919c5a7a8092af635174dc2f2af8e89a0a7c7b1016079f85b97674274de3e59724261babd2761b741c27c5629a23bdae1cd241c3423cb74342c58dad6aab66d89d65089e7333b7dfd95be308c01ab27e51f237d49ce1aa86c5cdbbb8fa23a8c095beb089f632a6cf48104467795c48ebefa1346566a5328e4fdf1c78f50f8442425f2f21bdf0d8bc2e4d64f293b1f85a5fec10bb3620ba89951c4518218894ae3dfa13366f6131eb7bacf4d489dac12a8962e3e95533946fd8aafacbd03d59405940dddd8145bfbc76fc8db52daf26305653295734f8a4f1bbcab5e68aeae3470b9e3e6ed80357029c0baea8a78e0cd4ab41ba42a00dfb9fa7a6ec247c72e578c3b0c3018442af78b22002517d853e19a2c870764732e6f05a53acc9cad8e6b25863eb04fd3ef133fbc39ca848f0a92e6106a7834d124e8d743013237fbbacedb70ff38a470cb501704022f700b1ae67a19e28621bfa600ae4086a1847dc64e71c79cb02801db6cc11c5be127d61ce5c1abb83281cfea8022c3ccb69db473daf959621dd36c5c90f1174af9c3af440906c6d81e2b18953feb1a797bcd4efe541cc5619833bee4532e8ecc0eb0fa003510dc5260c821ac50526d80c55e6a6c78b5e032454ebf14d7d7ae9526268ee162531a17d90acd41f822411a56729b0a03cc9993f7b80ed4694769d22ee1c90709142ab5a3ebd4f7b1b936236623a4166e34e5038dff7b98b7dd8312b84eefdbb80dea77d9be4813827f5904bfeeff8ca0592de22f8141201b4b1feab0abf5dfa5135c7153cc81cbfdc85818319618b14177f73b76773185444a51f48b69e4c95592970a71061cefa1ac47fe7c42ea3ea2320fd2e700de243b7b39f9944ba4395a725b7adbf4d813194f38c6c5d0832367ade3528853ea74d7418f48c3fdea63ccf5a42dec38883235c6b024e99e9ba68cd5b7cb2c36b15da763fb9bee1bf08963ea05631445b84d568f5ca4cd0efbb28607fa0ce33353be3f068aea7421edfca9c7f6fd06e9250fa22158d71cee66fa20757c9d4abe7a41bd29a71fbe1aa7f5965670d95f5115e3b3d361cd5f2f3585d144fed92cf7e503411ce1d3e90b085664a37595f32053b70624c80842c57b19521f8c8110ec4bda86a3afae4f797a8549c4424258ab0505fe6644af943db1d230ae0ebb5f1722e7151e63e21b206acb8504212b5ab43d386a71cf436d6bb70469b1551500798673b0233f7aa8f7a6b40ee3dd76662221f0260d7e67e2983e11a9d956c8012421f95c4acd85c580b0a95da9e94107e31d5bfa3270112b5fba35c05dbb09ffb06b7ec4a8a07fa2b989ff140c331f4b5fd7bd8c547a72ffb16983e4161708f2e7b024655e008d9693fe4dbf7d5ab6b2968adb6cd65d804e7be150e30b65199cdc31764e833484326253757269e62416f9dc80638eee55edd2b95ce0a44a7d913e418ffb00901aaaf4dac253394dd0b9561ebca98aad077ca53fb0f4826ed0e8b947c7eca6c9376e5cc09ff7d92c35d0d07d2410dfa4875439b27d909ff91b036d6cab03394140c1298ca1b6adc91ae09646a78dc79cadadd7ac7c8f2cbd3256fbc630eb269d6a6e46dec2801026847706d69f9a0a3619ed82d90d740a7601d0da5c1c31b4169d93fd92cee3b962082ee0bf91ab836c7198cf08cf09ec22128ce91a9912ec36ad76e314833a191fb36a6109676212b7515eb8ace755b5e00dc712cb9214e256e05accd9a5151eb5ba122445edc49752783a05d065755e8a916375942736de5ed412750f13810714c4eb7524da79aae47885f1363e71b05ace94726d3b5b9ac214c808aca21525efdbb5bd57846c7571c870fbbb05ac185dadbbab5eac0a7c5bf80c4480cc3521e314c8618d7f23c1042654f9a4dac8aad1b6c1fd769e07f8d1db6d2bd8f6d0334de729c7d589102a61cd8da42d49832b87f0ce929998ab818083b6a7e36390d4c469bee400d8d9a69fdd22201207774c321f622f68b6b0b34cded6a1e8eb5981957f8ff24ece667b016aec44e9a5afdc7e1d3704cbc7f8ee9029008b672edb96e38e6f424ce02f145adaf0b7a004fd2e4edeb84c14c96680833a6dd67fe4a4e30aa673ddf093e4bca7906b7a3d521c41806c1eb693a54995beb7cf4cae2660f2117d2f25cee23039bb1e2b5015dcbe9769c4de6c113e0cc4357ca3cd40301127678ecaaf25500c9d0f40aaca55cbc9c5c292039ba7b1073073e321db89880d503aeef5e8be76f5efaa46dc78604b4dddbc4136b53b10783fb3f77899c0adcc6a6f5d2fb37db9fef8d0aa59d5536b62b79033559ca34344ced6a91525b082557aa6039b9487332a9b9ad24f02a3657811795ef2b1e07a877420cf55ea3d55ca8eb0239f0a163463caf4d963ca696e2870eb9d8c3afac58fc354c98edddac4bd9f9533011d9c418724d378df495d6c6e5ced04ed320e85fb52cdfb43fce1a64615dd8e45740f5eb264c21e6588cc97d4594cd159b231fbdedf45e6667d4988146facf74a6f63ede5c2a28a11dc7eda10759de2171f8fd135fb07a1aa04d59ba55235ad2a568cd70893eaf2b2d1b325df1ad4b5758bf6a2a499c2ce2d3ebf0c2afe2479eeb957122f34c92a7901badd7cb5a7201f7d496bd17cd39cd6fb66ddfc416e36f0c9828c1f2257754c4dd7b3deeec7b90ad8d38b0635342d5b764c0513b86985937cdb8848d13719c9d9d114f19313b087bbc39f5fee8a955a944f12c282bc2cd112c463e73ecaf6c565301a7e1903ae112da578d6a4c520a95dc4070fada9588b37d1de1f1ac62be32ca357c81c87ae8e78da157d51854073952c1659ba88d3e12895473e5219fe1ec6c985522875093ac0863156c7c8814cffd308038a5e40a5e71673b180441b99491de03df29f502f1f7e94c5d3c719a07db241362668abbd79b7c82d61b0b3d592588e1b9c566476253a6338afb0e927bfffb6c106620f64d2eb386a0f28304b66a0ec83a86ecd9193835db8c79f3755815d085bf4fe3923f44c7b59902179ffbf7791594ea8fa722ef5eec9e8859ad723a5261176b3ac6e928e9cbb4359f5ea67e9353325d95aa05458b4be4cb4dc755f08f7b2a2803545e784dc457f515ee7a783a67049c906c8ae014a33ac5ddc6ea7d6a087f428763bf0070c653a9f2d6e1b5d6d475524fe50e4190a1dc35f890ace22bf4d0c0cab0ef1bfd7cd44e300eeb73c4bad35977a1485e6b568933f6ebf4c1a97ed00e82cda3774146b688ddb095c2d906cdc44fc14eb316f59aa4d1be387e6cc706f2a05686ea565fb3817d0f49a9cb50b82cc0c12bf27110345d71de4b4ac58db7f61eae19dff88683d54b8d8323db1b3cb41fc551e8498e37287146077b1588a8fe5b8a227d19826b2dd82820a182fed28bc011af73adbe2b2b93faaf7854df6c129406b967ad68f7d88083ce048ef073c4183aeb9bc5965b687a5dc7bef7bd9c53067c58a39780f438a571e1622ef8d23902061b1ecd63d051d1123dd97870f93e87629e94256dd0509ffbc9afee1f5c35db8bfafe635d348b223dfe96cf17c269f4f54ff0ae6a568e871728141a1c64d2af73fd0f3361a949127a72d40b337376c98b6dcf9f06dd80d0b47af3745cbcbcd8bf19fab1a794fee5fe40d1c719c9a63537f3833288c8399b0ca0db692ff1d1b284b2de5e013af4f100082418288e90ecdbfa50a82c329a68c9e7fc17ba32b54aa1eff5e7bfa6463abaa82e0922cff85d8988b0f8372ff37d5802ba4c7472ed45d03329a4cf60e6c3eeed63e911c89b0af764de89a65e9af9aee93be3d9ec6c064e0962351f62a3e69f3129c05d769a4c7ba615e26a509026384905944eb6327f9c13eba93a114511cf2435cc7d84c9bc5dc3fdf93b0c2ae0ea6cf7fd63d13ca8e07337a05f80179e49cb028a6c4eae6058e129e0267e17627866eee1021cb1ce24b6265fa0b61c8a208fc9bf203ae1eb5be48a6800a268296b51d65c94f36a9fbdda7429e54b47405e3499e1c043de2a4eddacd4247ff461534e022786f03f49d59721d387ddd5d27005721daae9458dbed13a55f70802ee26ff96e951fc10396becd4980b9d29049ca01c4ac677920c24c818ea275ebabf4261270eda36d7b2bd0c41b0ed28e09e8dd623eb8286dcac8ce18d392602ec201689bf7ec2a98ea5a845467d56aa99889589bf8db23db3e44746e8306a5e16524863f5e254645dacf55a5bd1a611f23be6943020b08864783f300c251155ca08884b691ce4d4dac6d2d7b7857d752bd1242aa68aed6ae26cbf3bb853fc5972f0c599d234b67bd2501b22793dfcfc7e0e5c688d3174f2029b475f7fb584e07c8607f82f06274539fe52b35c0be001a0a11d93a3746d25603a855f3108d5eff3cb14c26c638f07cb934c18c3df67f76335c23e88161a82c9577d0f3f97bb9986a0a11c72e2df70f8dc13a5df8eb088072ace7f8c8bf36ad14d6905d96ced4f653d809fb5b7ba4238477f405156cb053571c72292e77ecc36a5726d13e89e67ffdd540c5288fe493adfaf14609c294332f7951c84ddbc8fa55b6779da3d6903601e7927b601e36bff517c7f8f1cd884984b91887a94cf996c7be1d8a1f2113aac598912b2dbf6c1ec672e6ef45ed58fb47c5136e88ef23dd77efa21fae10f8a14068cfa902907c2d92e8f25249b894743155c39e3c11e60640283f3241f1af770a8760cec3b9098ad779d68f67c8639df0f454792b5cebadf07fcfa9e42a551625a850372fe150e94cb282dd6c648c0fe6878a4f7d5b87e5ebb5ba2eeca1acacb9de856e2214a9971b14598b094dc5c08101677db30059227993b5d24fc0b52d3a16edeead2171cd6bd38b42802b2abc029df78859b6d1b4a95b8aedeabeb892514ef79ce346f5e73a8ad09adff76dea23cfabd31111db72bff98ed6e0aebb1c64092ba165f22077acfededfee7021ebdb84ddee2565f686b3d5310ee39cc6bb59a2ad103697f8b895eac788b0d3b85d7a453efceeba46c009d5cd7b751755837bd156a6af9d770b4d4364e856db8dccf146127cf201c8b50d90945ad6b1883cc04a71a4fd94b9ae907cf0cb703df5e56c48e8876a67e0d1426556458016a0ec5db29f887688fe5fb3f0b491a231513ee3e1b96dc91bbe699f5c7fc782655e73737edad57681b9b290d398ab707e97852ac958eea5fe36c2d837ac1c7b404ded1d7e2af6f635b4d7616c2206ed3f43a500d3925661b1ae9734e6fb36d733c03f957af81d816febd647b03a01c73acac2e789bfe828fbd3727fbce28c1521c920f3e1517a3e2e62a63b0be89f72d009f75b058183cd7df889857792db9b75694fc7c38c794af653bd24daea2f66a0968db68243bd5add0691edf783b8bacf71508a6d4f392d509b475a6c2e5a35da2f09fedd32b61a4dcd026d472ebcce97d0cfed892","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
