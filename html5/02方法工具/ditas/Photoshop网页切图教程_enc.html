<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90d6ee469d932f77efc223f773999a843747dffa8886123b41472e36f237657783d352d3a5eb898e08345dc0a7c9c38f63c743316de83299ad9f75ae0cc5fbb5cb548d966f89a7f133160f7bd9917a40e35860f924a9dde19f0a6de5502e161c3e01b398c88bea935e9ce3348f4deb2b77f643edca14044549ccf1646dab3641ad5dc776e47763640419c0a0bc8833283b8ac595f6a667fbbc5192983e8356f43c473f5cc72492165c24977c3cdaaef50bd70f06aa0a71d904bdde5dd0af1592b7a548d98c4ac22adf60db1a989e08f382c4fe0ca6793fdbcedcb5b46c7050dd57c65dc95f5bbea0650ba6bd84af453d6e6885d2ef6d73a6b831f57a74efdec09d0b64adfc28ca1488585e543b74772b1fbc4379202421a917366ebeb07ca5e36916e3111da2a0bb64f71de08f421ce99ded0c7b4dee9dcf7f74a2a7cf8fd97df60eb047830f2d94b11d31748ff414fa9a67bb26f86693c5b614f79d2ce158a082129f517a227938fef160be675325836321e36fac5ddcfc8c1ffff2a083e47034dfcd6305d592985d3cb8dcfd227e95d5fe5d3c72b9a9ae00dbb7623225bc3fa4adc9fe859b50f72b8a460db1aed8e5c6cc08c0323283493eaeb1e985be3bbbdb97d18d83a682aaa6355c5d9285eb078bb9c17b1811294cae0abddf10f6f2ad31c68c3d694cd694de4523050ded2919280b88ed2f448e29a633dacbd1356e1bf3fd1594be5081e9c4d8d7b6615de910812e3f2967fd942c6dc29a7d75c9cf3d9ca4cdd82f1cc054028ff8b81a1eebe6e9a37d6b2aa8421b2309af21d1e4b26e0a8c744fc70ee22e80cc0c312da7c6b45cc883bc77adfef56c58bfe7d63926f5811d150f148a27545d57b839f9912d85a1c4b4df7374a955aab9cf9c395e51ff79b5ca81cc7a37456c765b2d7a15cd4a6cda5fffaf1df6150c58f4361606e7d5aef9f2ff192b37e01a72eff8ead9d1daaef5cb71572b7bf440c70193eeb4d07608bc767ad64bcc1f6cbd179fdf958e45631e6de1d83fa1265b08573a0612ed5857616d81f04e888ef9ecc0c4a639640a2af71c8ced016da71cf0022b87cd4224f69febe654e887a3f70756aa1eac2d05df5f5814ee995c3358edb3a9819f6a2d3b55683a37ba400f3ca20646d8bdd1ef80eece066de238191edbd736b2f4f77444af8270027b65c3833432c11329b27069a332f1481ec0619c9caab20a319cf46647196114384bf21543f95cbb4bac41b711ff5396d421d0cb3ca6c6e846deba05a87392746d98583b5ba11d2afba528fb062db30f7c15a97334f30c87ac575b17a969078c01adb701ca615f746b512ea5b77a44fd63b8cbbef36c1aa316ba131ea69fa1ce0585a880791aec84942e08d7402f212776ec557baa26121723750ae2f2bc378e3bd388ac883e0e59092596383ba134019b5580922ded988abf77fd39a1ae5b851f065d5ae3ff31f66dc315f63cc3567775300d6f4f94320c69412052c6c85566e0d85649e84297f0c921683a8249ab75c44e2b09d7e2fbdbb86b4962f22b0a3bc1ac8a7be8eed8b7f3652ced9d8b4ede6d0c67bf59f5eb8c8bfbe833dc0bf4838ee263c49560ca180607d3ce2f52b89dcb68f9684723c2fe3c90d5c6f8d7bd448fd4fb3e098aac62a81bf024788d0b2baf9a9b489bef94955f95c9b1df459c10549ebb7a69601711378fbb7e63c984ee5aa2bcd1be27e4a0bb6d3fa91fa98b067624c4bc0af859b1d46d13aee9d9c00a6185187eb18bd88a7b811d8f8b739d7771694c78282df3f642b407be12bb05dd4be76a44b47982df77b881b21af879bd2459c446df5596d6b06e368c346635f9292b910ce29e85b2dbce63a251cabe1c733b7fea10a7fbe5f85306104c6ac24a819e852174b7ed983f19e5a6696682d0713d4b5c24a95376869ec9a5912234534b6306f216bf83cf9630dc2547df7d6814dde896fe13c2c97b694f155b84e14a2e0c7c4db5ed06d67add48273aa906e517c9fbf5f6b44439fe89f86f616dbde1389053481f97086b15790596edaa52d902f758d1673a31b06cacf043030cfdc35d71b8007d7beb2a4d408b342f6d5aa03b846bbdb3c6710781cc589214c14b87bf8aeeded0970b2eca9ac94a0d76f2b75f88363837543a7cb6d96e3de9f2390be7113ca87219efb625c423d62ad6fdf62e42b331b09a153c8c5cfcbc09c5ed2b9c57c732f7e30e970f78cb6b649c4acdf377329dfb677b4e62fc4409875039e38087a7435d41ce602b45785e5924c2abb3efa2de9a41c83936e90ea7a044e699c0e4a3afd82bb539a1f1c2fb429fb994869f1cb7257fb24b19ed14b07d4b3ffe4cccbd42375db18bccc1b29450875daf49c7e95edaa72dcd75ddafa78a2610812894cc183a39ab80bc6607cff5650288d4a581fa241d1de4abd5139527ea06f4cc2a168c80c7d7ca6228b1972af31992b7a1b7853af83cc98fde8ed2e0d6b16b8f6d8d45f88927cae5bf6f59a103b5c97ea164171fa030eded00b02ebdea2619b18434f3204f1ebf2617727bafe59f4b9659591413183a92c7d3918a2339d1cfb396d5c5b87d24478e65c4dc1bf38e502501a92d4ed18699dba3409aa508000a82d930874bbb889482a23933ca94c7efbdb31558afd4578cee905a6db171fa9ed368ae5da088fb7a000d06ec8ccab1e165a2cfb50629552cc428131c64dc28f667d701e4df7b982672a185a0ddf61e84a93590bd8e6ac0a19117a35e81dc6fbc7e5f4a372a25b96c458c24560f9667435edb6ec56465f342257d336160f1ffcce6f65f9e013408f1f06a025442f7e5ac9bc21d94044aff5629952d84696565a1f392d2e3c035beb5c09aae4a1415291808687bd51e98096576eb43d0d86dbf8a867ce9c2536bb8c0f4dee867a51bd324726b230f6168eaf7216c3761ecdec43a2f2df2fcde374051049d85dd14066be838790fb1b2cbe302a4f469f98ec704d13e8c7e434acdb68a84e9b02f53af32972f13302c7bced6e143bb12413558cd3dac4796037e36703de6d9daec003e8f933301c6f24b1e9e135a4b256a2c99e1f46108e37e09ea867348a507f12513bd5e4d41be1e31313af1aa259a855262fba61adbd70186b9fd426f680848076f1fdf8fd24597674f664dc80808e69035143dc8e80df90e0a33de37503d102688d0c8511527e6b0569183ea12d7e31ddeb6f564ec8b14a2a16988eab233e33a6f89b3f854435a1c996e96c8f37e1e45300e5b9c6cabd03e4ae57e9fcf68af622d6c71360ed71f412c4b739e8c8a61329808d8989fdd3e060846fcaaf52718c40bde8b411123a730c8f7a9269b2c3415dbd5706e6f34222282840693e97bfb35ff6126f8fcb4b9aaee2cbdd51765d789db7d8e6f15b334f1c7a4387ba2e5cee49ecd3c5318905a7ca0e2248b15263f34e1ed709f96a455c2e8d8308c03e1ccbebb4bcfc1cebd1f122e7314f1254d48c459381326bcc4a3491322d94cea68d782a9249b09003e4d2ff0927b24c30f51336d8619d954e40bb5778d61c7d3c91460d93e9817deba7cab02d610d2110cdb3ca23986ddb6008d3eb4ef7ea6f6c29f9bf8735d1e1ed8857cf96dc1501750e0b27e9327fbecf62296c685a250794daf43d576afbe425dbb67b4317acf5d6713eef8838eef396b47ebbfb844cb5ce236ac1ddb0f83340a88ccbc66701e35ed487dcc6f2ad09d3b6b5da9ab0f5a7f95a02a1bb153b9fc702c890fbd68c9587d702247f5f9d53e30561f73a44d0133dbd62985724bd7049a9e3a80244184734ade0b61d17f71dba44d136343a985a530560be04cbc3846d7b93467e6d99addb4177cb7bdb765b909464b4f13f903b5107aa5422c326ce8ed37837d2da583af1e5485eca564c22ab8053e0943e6e298ac1e98f839d830bf665b7ba68bdbe79ec5726217494643e3ade0d6486aa5ea4507f83e70767ddc15d8286bbff4268a44cacbc8231f76df498fd34a7d87cdce152bde125ce4e50b861bc6a08c0bfdff20cb8d3e6a4ef634ecfc80b74ccf6fbc8ffffdd9d1441f7dad64122fea6fe9bca14da07b1361c40e9144e8c2696027fa5d7c4869e9103ff5e31d6f91b15e830a9e56e34c5706969a0d958d6f0e650d43f0b2c3b26142f2b415f9ce20a09a68da04b67ccacba68abec4a5ebeacbd55599e71c06c64001d301014be72a93814857a76706b563e5051719fdce358f89f9e252445c7fb87849877eeff0aef0a0f5d4cee71a84df69d16cec49badbeee6dfa54105d3f773c90efa55cebccfc2bb83d258b2892769ca7cc14881ef533ff266f6dd3bb122f5595db5e4c00d537ba5cff93439b131788ced6585b847c20127f14870f71ea898b21079b4d5bcd9da1fdb017f94c9a676c2e7128d5e171521cde4d83c51f717362748d590d62db1977235dee7f30e6c008d9a95adc166f118f0664b72dee07988f5df2cf5c71769f5e202bd95a5ef782bda9df8572c4c05f7ff1edc9521cea2e231a81ddd41fcf57f5acc7c9ac01a390cb6cfde9666d06d0a451bdbefd7bdaed795ffd213ed763116b4746192960766d0020a620ab9c5a35539c10017c102e9e867987a666f0e0fbb64c3445c7ac3c69eefde826c8f3de8e01ab42a32289cf4a73b3071ba99d0f33e43460decf8b47ee909b8cf3ebcb3bebfa5cce19a6d01ac8757ef8731d47e456382785fd7561dac061610e8a1aab26792464ec2d51b128ab1c73a36c6828584feb0a433454e8109ddab6a547f0d86acbcc5de97e54a4bfce21520dab865bb70c8af999a192deaf9465eb2e5fb7e2ffc8bcce5a0e7e3f1a3e391d557109d2af27d5d84b91919bcccc989766569054b33d130d5484e839b2f73cd2f6af04ec2aff6704d37d600c59d2b27cfb81f11269aa618ad65292654624b226608f1e06816c67ec8abffff00f52d57fe684000fa6c589650b9de4800baa47ada9215edd20541b80200247578cca1d1a3515af4df0237936a4d0c8476efa853f2536537ee895b06040e0bf3720ff0a1393621506144d4597f77934b4f661e307b55c24627189dab76c56e7cf8b6941aa352fa773d85d39ccd57cddb899cd01ef10c9398aa658e7484aa02da80d745e9bed130ecc7b8637f2aaf68f3fb8ebba1d162925cf5eb3986f0c4e2f139e8262a1656b095c1451cf171808ec23f6d7fe16ff27eb7f3387ce489662f2bd7a073a96df19ad0b0a201c7d6de06ffed8e939530aa1efacfa9b908ae81895188ed9d47358e0e097d5b0e640be16b9f54c3fc43e3925648e51054e81110bd6bad979fa86fe7c200d1f4f2b3c3b482492354368ceb02e655b5f0c4ce7480916226cd1984573058c9db488a072c33aead4761dcf37216a3bf3fa13aa8b3d95d76cb2a9f80fee40283853218691e071bbffd05a2aab79d49cb954b5782352285fcde9c80e1a7b991cb1238c09b88ed9bb5496a8f6688eac906cef8b64d8b51d4edca1fc5f337492d18b326deb6d58d239c99a5d233b539387670cf522f948c53c9b8545bc087a4edc223a3adc6fa3d80fce98ed8bc07f34a53a3cb68a13ec82a33ba01bf3642742e9394ca1eb1690d55b143c15f51aa13748422b38c2be413ae353a596ef1ffee8279334f68802eecb1a6b11be8024b0eacb3d28590705eb68fabfe6421cf196a38a5ba0ce62e7fe29d1517421cf8c66d84ba6e69c1574896ae0ed0d63beebbd530a4d5ab6d82b0b0a30c280d009a0f406951a070d3fc4133f8ec3f770bf1fc86a18b67d2846d0f52bac4d29ec6a5b72f78718112adc9e3f77352b3da72bf798eef0a5c006d2d4bc646f747e8b666fbb08ec8b9af4eecb90bcfc43025eec80ff946631835c87572a1d35cca205bc395335e05d911092c726f00adac662724f50ecdc6476f62ad2d7977e34d6e1c5933468fcd9ad6c4d229134fce433d339d3ee4606808aabf708418c3acdb02d5737862bd62d3c8ef4e7be702df0c606454687bc2b59966c61b6f5b73b571fbc9114b1e3ea673c802c1601bcf3e16a53ed0fe160433f923200c92264dc0d4e00f3fdd87f05d144c702611500032ad75c4b151485b4cc0e21e042193381af66caea0b908e81bb701fa99eca547c3e5f5ca1454e6b8d6fc268d2c4714d0b19665f720e3cdaa97fecb4a0f556fcf9aefb0ea21298e917add43fd032ed26811ddee37bb31b1d8e8c85d88bc44dfc2a1665ece1dc493af42448bce04e9535336bf5ffed9d82fb5f0de9a58a2981b9e9a68e884ce7d1333d01d05a6375d8f9c38191130af0ed2ecf281381d4541b333416f711c49ed39e99b6bf5feef9116685459ee1ba00d50030db662e1e71b41fa9f40081edc7650ee87f6ffe8686c457ed2f789ab9bce5beba896b22c8bdc88082c7581f7aedb8afa8548f3d9e660dd0bce26c16f56688307f16afceb56989a3bf76f62a319eb2dba0512102ecfb0cefd656f6079b6e96fa5be23dce6aebcc9e0d8636f76812e18dd881c6d65046b6f1db09b0408a470f817718f3f6085358e3167737bc82b90146e2e85f4acfd1b5bd50971811ba2c4c71d8df4c61ac87d2004b18ecbe0b1730cee5a8208c6e4493a01508998642c0c1de793a5f926a2e19ea06e493a7b02ff3591caeab2176a31e4dbf4c24043db5102f2391df4851d86cd9ce080b2558813686ec94cb62a7af037717ee51c4f049f937be4fe595bc900b5a7efc3ccd6e102efa0a7bb3953da3ade39d830dd4b6d6d2cc68573588632d2fad1f1dfb4f8d1beccb751b08dc74de58b983ad68276f6633fcd5b029614d0bf369aa731e3caace00cddc589368c89d647644d892ccbe147fe1034b1be8d2664762238d135e1509fe07ef456fe6ee70a6a76380e743722277ad9d848f390790a21816266891811d4c86da22c37ee38d3bdca5ef1ae0fb19eed03b0bdc534767aa48a129ce2269f2b98bbbca49817e60957b2b8b5567409b63c79ee75f074bcd3694d731dd9e2cc17b07309bb34465394508e4da00acbd39d61fa369c9d004e27234b81075de9a34567002e8a940980017cf2bfef9bb2916f55d79bee3dd6a262a7ff42d9b65849613ee2f93540dbc0310be899bc738d7d14500db2fcf2bbfd57f18760e70ac1f2adfdb72761d8eeb475a778a20394277ec016d68091d3c402ba8ff7a1036e4153a7381dec58316736752901e8df7150968170000618864973cf528f8d406d0c40798a33e2a59f97a541b1e74198e970c2a79db91eff4b4e87c14e560076928b257a0a976e1cd7586c693cb3f48741fd1aa7d88484885b5907a86d197b91cd0a4aaa2cff3e9e1e2c25a06233e1d5f83dca8b5883134159ce6aa03f94c571ee7f7f0acf4892fb87146e8393fcb9625e82c241ff6919c93d174ca73afb1e9633d1a03d870dc1714d27942e8231357fef856f0e842212eec71c99384b190f65ab39ec8442a625196f1880d9d46286cd9a23a22596bd656cacedb2b2ebaf13511b8e360e7bf322d29e8e07bd635a19ba6e8e7736df632b291e3221ab4f66dc60207d7f9b03855c3829a90786df7971ebe43a3d5f1a5b9623f58cc37a8d9e190b4e5305e566f61af5156f64c914a8d55222f435b9b54268199e4617fe3038b3a79d8b68b8fcfeaffe8199d240e0cb0a2df9d0cf1c8f01d5899557024fef0bcb9605515d36f49e7bbe47c52131c6f68f9bc5bfe6f9a3af9c22c2d6a05f548b3b1173aae27270a17b5e7569332dcdea97182caf5494258ef182e584271a8474878cef00b967025c19f434df43b02a053c2f6351ce51117c5cb5301169671099c9a4d2c6a375717bdf52e55eb9237bf24026fc78c8006e8c3bf651f07f5ef90c5a034e1de60004fb84a1f06fced9d5c455003a512c5b785aaf352343919d2fc247f57298ae188aa5cbac9b58a53b837b3f130607e2413e0d96f4c5e6d7851f210a15f161fab62495de262e90978a019e5f207dd91100355f1db2b3eea81df140efba7ea8e0090eab308ffe206961498b6f60881e32bcc635162be7d0bd2cd413195f38e1b99e759ad602a5d714e399c7716bef3a1735a815847de84d78d8d93a443856809c7c30b5e45ceb3bee52cbcef4745ef37731516e7bd4f9d259c8dff187b37a1f1e9fdffde86e3a23d4f1983830d36d46cab3f15dce88976ba368d1669812508f6790a4516856061b4a9743e321933ec7d1b45e82cd7782d728fd461c4896a315d147551abeaa29302bda2a598e003a78192cd983c1c29b1fd5b4df705e416efae3f7949ebebc0f81c5958d918d03dd6a6b9fdff0de0b4d3117d59ecffe629c9bf4958c97b269105dca44bb2751ae56190df4c4b5b358e14980079c5bcf81af8b7e04f26a37d2be03b2354e1915d52324503f959506fb57cdff18b7e13608067000ace00ee707d179795c8b144b066729a807d7599d92edd75a17e6dc6e45b8b464a57adce592a0ddf3c9ff9098228a58fcabce42446e2807ecd0f0b214b2ae9440ec974cdc12553be2147fc4cddc9657daeb758c65fffae633317d6a51b77a0e556ff4a87030fa2f8537268b6cc217e81bcaa7e1eb33a6ade366d12fe7e367fd76232232bb65211fcddca57882cae9c3720c3d9fb12d6e8e1a5a744b15ea1d346d619027a28d770eb6df6af720a9af8461c4f8179f1545a612d15dae8153c9b67223856960b27224252f17cbd55a0f957b8662563279eb294b41500c4825c8cbc2ff0f27cd83346a040ecb19b49434e8f33e5862ea8f91bc0a9dece2f43091480cb764f86c09c22bcccc228752304635ead8d786ded2a04363b48d35aaf0bcc1712eac33fcea7b971865a1a36d822191681adfc419a9b41a3a1bacb0aa91bf508d7790582508c10f773d41c5d22125b73a307c6ecea772ddb874264b7714a1b00273ed4eaf4ee6d453e2443a1caebc34905dff81de9fbc79198ba31d433170057b175a44cda012eff3d1eaa284654e880832ab0a0f930508b8f8c56acc23502d9a5449981c0030434c0fba425c864156efb51f897fca42a1ecab005f4b27633d36fda4e8571fe3c47ed0dc90ff4eef7293e4475118a092bbd04d4868765c8a74a8673e852d4287d1d80dbf5c0d202f6c6054e73f7758b0499803083b402b79f52b84b5266032c10c5a0bd312ddc6edfc631f8f9efc80a1a25d570882fa5ef9a3b62ddfc30714b906c374271e41f01a808fec84467f32a0691d2b70f8d9e61e884ae884a93bf8b4547d2a2acbbba9a90cd59e3045da6220ed104d0dc4bbc0c6bd1c44490e9de1faa9a464ae03fa14873c986ccf1a1b6db298a88879f86bccd8c5465f25f640d0b7ae3b20a1f8c06ffa03bf5244c3aa917ff28c5b76a457d0be4663ef7458331816d7604da539a42b6b495300437ea29461ef9ec9a9524331eb983653b03313b24e90a90f42c9ad26be839a2d06fecfd795381d916adf389ec8a67e8ca4826f5ad689bc25802a4a78a2dbdc341dda92170e9cc6246163a1d28f33a003a69df97a83acd8371822a4560a221eca5e244fbf975864e4c128941d6eb23e2b9b7dbb5ba8d0b9d0e7e643eda91a154976d8d0319b16bd1dd416bd1baac4ca229a44921071385259fb539cccbb720669096a51dfa1cb2048d96cbd6eeb8705abe4e63011f4cbd6028d51fec5cb2b1cee5f79881f5247ca13b74a5d8ae873a7f3d32c08fb69c36c62f5007b4b64eb0be490157bf493b51640bce5ba91fb4a608a148d0e3887a6be17825d8b337795034f38f12b51036f2d8647c6b6b48b0f4b97b767b3588ad1ddf64c0cfae0b18fca7ee2c48d1595c4cf5e08f01946bd2d489bd7d37d882a2e756931c8d640486bb0d67802d7afb9e332272a2be221d5114a8420fc87db19022ec53bc119b7239d573606920096e831face20622af986d79b4ac3e8002596048c5a82e8ffe0896f9bcd786b11ce89742df639922194184a9b6c5f0157a065648ff16e1b5e3d9272c66139943fc26401db1ce0fd645e4549aa775fc45c99d19413bff952a221ca5ba369c73abe4b74588ccb489849730eb6f5d935f6d2eacc99b53279c4686303cf6ce3bcdee28576365cc6ad691fd130f04c4ba3d52ce62dbb1ea676fd73d047ce3b09bf57eff6ff96561f7a2c4be8365e0b29c12dd768dbf7fc4ca80222f296d76fe4f91e577da2771aa54f3041670ef2e882b454f4f6a3346c185634e32274559573e8197f81c1d82823e033c27d6691a1558890f666a6e199df2cfc30ccea560bf663c3c3e60ddcc5722c7273dddc57db2480d2f93cdebe3398e6457b8aa146edcbebb055183f05b21e2064ddd673c986c8930bf138b6df43d3b0f19c8541a0e6a365fb3fcd26fca2d33039716931c6d5f8ba03d296340e411218bf0997f70b6a1ab3857b3f5097a78374ef6e1ebe8372a6b4101775f8bed55f2e78f93632643dd6d6c0e15b0e8be6161b97012f35c8afd730676bc2b8635456d2b89cabb8b171a13fad17c8bb1794985ca1c5c8da63b430ea4be97c4d604e8a03098fee72ebdff01b3965e752441ef231862b5116f822183c24c9f131b1e775b38c157a605ee60a105515245d1673cd298b7dbd2a73e711ab72a2e1f08bdd7f9d0aa0edab681ae655173dcd0865fb735203c9ea78bb71c374f7fb0a7436c70a19c12c8f718b71dbff79a4d503a7f5192e434cf94044baa4807e712928314ab2d2d1b5e9ef66bff9c60e8fa8f7536bc40f1db24c0fbd5e6bbc91ced51512633b7f46d086da44fee58f1510e8b5c786574c4ceab6b20b581c6de4917f4f95b3cdc2b1b0a0b9182d1909e83dce160e7eb6f33bf3c25b918dfdbd98d32425fa2cf83502bd70710226e4ab2dee6fb114daa198fcc4ee16086d415d9d597c2c69d2754fdc5144a7b0a177fefd6d546aee5e1b6a073f363bf8bbb0717c8e0385404c78dc1d4704506d7cd779764c318b630bd6ae6233de8c8b5db07759678299c123d130c99c85e0ddafe45bd486ecf66ef1639af756e3d1737cb897bb4ada7fa1dca57255be3d2ffa7aee3dbee5d6c178631f78001184682ecd0a2407688fac1ba53e6c4d4df216e0060f8cb073505120ff6f311790fd79b272719ed15777fe658ab37a1480717ba4d62a94145c3766d3981799e14c9021e6061efc522425f2f5f74924d3ebfc6008c6a22f5c20d2676637a5a6514222d996183fc2c6a33af7b8eb0c1b4ffdba90bd116a76ad893ac6313643ddf8e7d1cd5320098a66f53819505fc6b04260685562ddeb5ad731823e75dde59137054625c045297404449f4e3cf07206867320277d752d1289c4fa7ab1dbb625a0905ec2725e210f4d264337fdd0e13fa10ec1ca8ac68ced22746bb11da4079f735b473a808fca6ffcf1a60f5b522fbde5e0051d5b277461cf69051d0b28e2c4beb966fa763c0fb69630e956d77c2aeec64285ee04d154e3e127fc55c42e1964ec49ceb8877ae85851d716c216fbc4437d7b56a6ea6bb11b0d12bc0d4075ace8f9fa2e049c2372dc23ad2dfd3c2009ef3939149b1a7344a6dbfab083b4f4ef385aa0d1c4dcb3940f4c5423d556eea7e77bcac5d4be94f1c3b2d19515e3b5a4c7d4c39dfb81eff98473ca2afb01a6729df2329d5f006dd0d0974d95f1e064b06cf0ea3b48a2edd306357384bd65a2e0c6d6e1bde209ebc7f93df1f51a7813b78221e16d97883760367e4ff3fd789fe4b99645008c3064426d96ec82e9f4cce9d52fa968abd9810e7aaebda86dd644a0aee303374e4d8a1536fca11bc7ea667ffaea9b85ec16220fb1dc92091393572492664b0b1f6893790e4ebb34008e8c9b9a63b24c58bcb852f612b35566c99913a2346b6da3fb64b3187a69263b9f51d73898f653d86bf946f5b1024b0bff5047f9f0aec8023359183836fa8ce86c5de0b8ae08c794672ad5fd7279aa64b979facc2fec85f98d66559e6e79e7880b16150f41f1558dba010c46201c43d518ec80faad6c8b38affc9f78c395077751d1981cd41e824f9f66a42617fc1ac85155c7ad93abfb6ff814a290411c436f4543a2605176231fd04659f4dc53b7f5d249aeafa42a2eec9bf90d7d31b0d500568fe9164fb2cc4207b1b67fbb2b42d0c3595d200674ecd884cf2b2e70b73dc89851daa8ffa38490f84f0824da49f1d0e7b1157eb031b3d181950bf2949116945bbe3d2597b31bb014ad4091df87c3afcc6d8da8aaa02e12fa257b17ce7c3c43e28cc3ba2c3b49afc9c19736207c16bcd35fe00a32c39a6af7160d78be9bca2d792deaab763e5d43e377c733c3b1dc54f5f8e4a5a5329c5677de081dfcf71e6a8fde451deb7ff3529551e816b38b5cbcd9774e7c4d165b9b6e4aeef6c114e2688d7dc414e5c588cd5ce58889deb355a9bc4e8f04f7df63eb1f39723a57835e675c29fd536c81a7d5ad7614618ece6719dc9aec72806f2afb613da863ff15e806d7bba91918793882ff0667ae978cf0e84bee812b50710b3f73bdf50231a8bb1a861be6fa4f94d7357acaac12569939b760af42a2ec741f899d493be8e7bfa610754b3b2949e2f177b02037f2d36ec7018ec92532663cc33b929b65d7cd3465d1060224ff2088e8f7d0739a6f1502116d21bbbf1870b50914bf7060c22287d82d7da6267ba170ab6770760455c8c733fd167d5e9708ecb7bb02500534ca17d967dc99352a68746164f4f177bea79a98338b637febe32151d7942d989bbbfb2cd321dc72594318772de90abf29220b5f6a3a19f775910341c38398d59524e07b10df784d0b47f045481f82db3d3d0dd6273a6217305d72db7962d98d8d01b7608f81c6eccca8eb6bcda5ffdc00c57cbacb1c09dd354b656b369a713aabe90341b97d63898442f3377f30adee985e4481d08a8228dba73b7464ef6cc33859d20d9cbd766c7e084ca8613f330f44748df0e9cd5547518d6c011e4b3c4f085ea26bcce102a63312783402817abe8c62f19e19322306e81bb3b8b0fe59683f781b0cfabcc18e435c6de9e46f6d66bcac17651c7e45d1fac1049dad4d0849e35479fe22116ac102c0972b3e1f5210d812e19f47ef30129dcee5814f5f304e50acfc5c2fa38da6b9c6f8a74720fad2ad9c74e316c866845b6bcc3e664dc391f4ce412bc135d0ada348690ef8dfc3a5059b092c73796c46baa59ff87e6cc61251c4881f4164fa28c9b1277a3013301d62a1f460f0b4deaefd5e1d177a2447a833b3c1834ee006ef64bf7f08a020d50db10fe2eca80251bb331effcb7cfd76dfa924b6a49986ab3f624b8519fb4b8eac1d8a75f3a54896f50c5ead95ca113f6df11a33902a262d8ce5f5600307e430dc5ec8c7c15fc3d361d329a14f18362656be8c7f7c4f30e783819605a1a2b36f757c94461b878f2a2573965d02a78e55276a251da32a9fa4a20223007133b37fd44891996dd6fc9c4807ba4a674f34a06b607e0ecbaf5729d86689dd39514675ee5e736bf324b9ebc6689b0e2b1c2a7a396b822e0190d503404f0d78356e9be205beb8f347893a5ee3a4b244e2bb806e2ad6741dcab2c7bf066714955efe64aa9622e2d2975174ca452734dc05bff41a0050feb69bf4dc7b70ed0974f9a14e0cfd840ea20ee90638e2271f0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
