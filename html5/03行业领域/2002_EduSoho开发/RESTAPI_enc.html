<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a02ce196f36cd2263b1a1f5da84d9396e46e3fd010af9af4cff3374f9b78a2fd5d6407c4ab7fae2dec09f097859a7cc02d0c672d34b0c00400e5236c0e780346470768af2744bd97b281d1786a2998a5c7f1ac5c284acb32befb9959d776a3eb71b892b48c999652aa4dd5e393dfd5004522ada29b182b735c2ef03ddac5ab6664d5d897d12cc40323c7ab155567676e371b8c718e6695f769a048b8f10181efb098143457ffd39aef4fa5e1cd42e5103f47a0551a26aa9b50c81fa3a0509f5465a2d08abdd4aae624b075ebb16b08d948bb78051e48e06c66ef099d0d6ef017dcde7c4f1f25d5a6290a592758bb02ce31cd656179c15f1795ccd737b93e4ec97cb1b54262dc95b0ba4dddb0c8840ad6434da2b8184e4ff7065aa1f6d9d139b6a4c3ed809721d30ff123820fb5fcf896315acd59010a7c77467010f7cfbf4af326fb59e061836ca51af3b0ecf65f0afa481703182198b75fe257a0df3cc7b64614ce4a059432d9a7fb48b7f13c5f36652b04debeab5633a4f4ed99720653a50bb01f98c37f28c238cfe06de6dc213832dc7381ab7c095c1b5c6d2f8c3c68111a106258258c6087ffb1062986d6ca08d1d207ec5c6b086346064712ae02788893f7acab6e5eea22f8782ebe2d5ecb5a024bcca6d319f1dd22372a196942cf1b26124666977bf7f72462c17f92873f88f8824357b5631287ea5182fac406d82818db1a8f36a73acf3be145bc36c71bf7be2db240febf8394fde7624fa1a06619e79e8217f86c674bdceeabdd6b05fa0181bebe58bacaa73c917dce99c861622efba68fbbfd0d59a51614b5620a51928afd8aab9f4b218d7028bf057919d1af8777091c2646b597c87a9f6034b6b4a9c8c221e802ed21045ec34c9fa143381c6977897b4cc8ba83d0302936244ac00fc3717696f48067dad71b81d2a0ed516c6782b880a2272cdf36d74c517ebac03c71247871a96b46854acb7dcb211628ad13a526befbf5e6139ab27f99ad3c93ee116c99ea293ecefaf32f9eb3c4ba52222e01de78a7e1f2a57323ae4df3cdd77ba1d793409e728f361075cb8f3cb2f06bc5540c1d762ee87ecd2810c83cf9eff919d42f176fd6fe257fcd0b3616a0e23ed98d34e1c007703c8030e92938ba093135e9b5fbc9c002464c904ae73b7becf6297ab3ef73a391ea3e9065ce8a0fae63e528a0e18d74faf1cd4c9eb10fe5702b2a10b227fc38cc87f74a9bdbe6d19afdb9a4c077d9d2f8361b57e1ad3dc97fad06dbd789c5a19a359d6f3b9fefa2f670d781a8d879d573ba07f9be5b7673493f5753b2856a866c84dff2a18ecbc92eb17f00de0e697bc5e06be1a01e1a5840a9be6229182d0cdf788101f03f2e3b96258dc08d3f8c0bc19a6abbbdcb3add1aea5e19efb7aaa86fd447da3d93c0d8fdaa9f44cb9508b70bb2605ce9b01a522edd3d2573213da867b15167b92364ba9bec58a70849f96b9546f3cacd62e634394e7bf9eb44fe4429a2cf2766d30481a4e5d80dfc351725923232258785c3eb4378652a819f4d7b373fd42fe0705a0fd9c0812403a3aee426ef385fdf251b36401f479ad37e5cc371c81baed14793b1c8bdda5e55c2a3e6caf47693db127c500a1289ba8c72532cd29f6afe164bc4b13488023515e2c33190c3f7d06daba43e0d1d48380048e5ca46322c5f7fcb9ace4f9a1db3f6c9005b715f7d87f80a5477f51339a7dc630ea389e58a7d204bf7d7ecbde5b70d6047eb69015ae8c51069d6d6d232e2c71f87c33331c85318932733103ebfcb508932c8030c76a122a9c69006495ad0209537f864a513fbd5798e6761100e897f7990c17e8e6a2a680c0a7e7406795b5bc5e9fcfeebaed8771f2c11d5392232e32f76a28f9ffcfe45ca3b62e75b4acac918da5125e6e137164f702e70142f400cc26b66f82dc63ec42719436d6ce190c48a6f0b2b454f40881eb89db6f4f65260cc73bc6432c7bded2928f6061ac85ab9ed4bc3d112a8e6aca34fc8eedcded6b08dc3975a490866fe8510e589bbb04a68722f228707fb35038bf4c63ad73b77072c48f98ab089890b895c5cf9154559f1f78f89484ad23c670ac83abae6bbabfe5d9c9f30a8970bbd655ba43285220edf749e54e989117bc0eb1adb658e75393e67beaa509ac303c9d02cdff30c195ac8bac52d8dab973b2d7352f156db9815ca09cdd59de970cc5adecca11d48005b9b85256b9e96c704c05ee1e7a84ddbc88583491f0490b6a9879b31f39184a224562a3f7c42a230cb33094e54409c4d3ba898647b69f5883ab1d0ef7b27427b1e0d0ef441298a6b42a2887e2edc626834a429ab589c7264e1236d72ed89d4d0c3733c2db6263ffa610ecd3a7999cf79f16d39bd7406ca07adaf583cdc6c047578814b076527bf748700508ce573adbfcc60b68a03be0aac0c0d7dc05aee6272cbc5e426bebcfefbe76075ddfa829bce86856a9d2550761a72e40d286ce042ccb82b2062c26621aceb4ee96d040713693da6b16801aa56500d2dbafa4de16fb6a63763d22d73561e08087990c61e33131562999445560bd0620c039332b7e942ea7c637031ea657fba48a248829acbbfd3aedf925a344094c474a3dd2fa31490e609485dcef2bfa3ad416d9536a9a7502fd7a5548a070090fbfd907273247be0f7535e4bd7a5080ef96e1387ca58fbf6b94f655d762548e9e4516ba6681d2e09d46cf2953f809b8d0fddd0aebd3a6f3c9cae16acfa90df7314a8171113fd9a9068b47f3493132f1d6e4f2355ee6f5ae79b25e4351b5e7295f343be2526fc221154c14373063e6025a4f009883d80a55f5b8f19f5fd422613262a37b77db897de7e77f8377c8015f7bd89f45c3c7673f0f5259bed97200d0365891c29308e5cda8eaa3988e9d1ca57ea6e7fc4edf95341f2c74c9bc55f87ce35b2584801c41168419c8c2af4bad149b1e8269ff20de9723662e42618e0fdae38499198fcdc5ff7b45b087bbe4991ba6412bf9d66984180240ff6c09e558c4ede27e1b4059ef65c5b4fdb1b0cb3bb4a2c31a814c3e833c0d3be7ba14b7d6da1a0e7f0c10c5eb0e8d986477dd8217efdd46798687a78a7ca81504869ad65f9860427161baeabe020592c0820a9e931e2165c525d53f3ef68910c13677566d63fe4cba26eb8f2cea95eed9684dcef5a797f09f0a18714797c0e66d275738550448bafe6e16d99e88a9ac74cd403fd2361f05f1d1abf894903e5e5bb095c1111656dbaf5880e21cbb53654f2142920ef8f4956852cb7baf4afae25369e50508dff8b3da0b2a038e0a1e5863a35dabf3116d284fc0d18303df7448b68fde60a50e1ce2f3a7184cb07f4a931b0fdfa9a6769c5bc9f3c95603d4e5bcf21fa3d6fd81ae48da2cdc30a1366aa9a324131f482fdb8e953f015bfd074b7d1011c6fb67543e360e5fe3d4cee1e5d2ee796b6dda4a70ace07e6501f65e599fac8671a22b1b02cf80054a6fa19ce03ad29a112c9834348c4cc4af7de33e14720703852131df32af14999517e407406461fbce46142b05c9f9d6948a79e8ddc5c57c8adf205839ca40fd5d517e92fb97e855ebe56ed87ac93516d656d255662b2e47c02acf781b9adc2707fa49ea64c9e36809b0ee9816c28396f05b698cbe9837c7e173dd03fc8582439c300a1208470c57fd55368786d9e9943e3faeb3e754e74c6e4a1cd4700445a821be4ea0548c89fdff5c10999f08163d52e08daa488ef5d52efb625167e8cd9d549b38805323eb3a0cc4c8e67b63ac21c7adb2c6d0734508ecbd5f721419e04d7c809c3d9c915393af1bd4989d7c882089a64dfd6856972038d140e2be184dca38702fe9d9cbdfbbcdd0f20bc6b683ae949b26f166edc489df17c8c1f7ce9ff8a1f5056ced70b47e7675cdad28caebcd93d0fc4280733a4ecf403e8f6913f8c1cc81c3f8978a9cab74e705a01f7527495bf2e96bebb62914adf829663b180a0913ef3ebe4d652a8791654ac01882d6f2cb242a167f79f2a0cb82bf891dc97493ed1beaa8669276d0ff993178f63512f018718f2241df4794854df0fc9b3bb6654aa1f58abb323a0875fbc121fc3dc0f043314be449517a84ca263210ad2550d87630563a3d78b4cfeccf6a54fd6709d0a9814129f62dffe75a464d6d8a110d7c5264959e8d7484154a833a5d37fabaff45f8cf4207c901536c50030d129227298a42a972a626e0385977ddc9c13bbeb2b1d7fde7fc3d666faa7b302c645a4606365ba748bce68cd9c5e661991a83db73f4ad11a577597d88d64ebedeff756de4035b425693f9988948e2993a6421902ecd7b29f03594b84e884a56dbe465c1555418f4c97c4ac8ec58f3c3844ba033bb1ff61c0c983c29b3ee42019ab584064a3da8cd0b4e39cde5b4a36ffcdbbcb3cdaff787ee1a2d094935d2eae318e3b4007963043cc0cae9ca9ac9f80a2ebd7c808f106b8c3e0a861d59edf7876a4f0395016e53b878a41d04e7609a4ae1c4e5e6576b66d9196f611ab9384819c447142d3e2e3da4004314dbe8a9c58e15df38c7eb86c835b327339e3d8adf5987adcd41f1b53345ad62c743e3496a6c29c988317bdd7e2c64ce29f6159db075d4782d2fb8c08eee5a0f4b487799a23f2ab4536146e4d497f3cbfa1ab89fd39e09956ab5c2f98ef98b13af293d63042ae9fd63b0c9110a6567fc25f8da0bdadb00ef9332e9ef5654009b94230dd3b7d8d45ccf7169811c5be64b74487a0418d340583f646c999af956684f1815271794f17ad5a4cd3b9b33939091cca3db7d747cee5d27414676cd63bb904ec0fbd19f87be987f446c1f69d1614806b685d791c7bf750bf3ae798abc52c8b92ffe4b324b53307da9942b74c87dbec28ce8026e6e35ee0979cd263de69e2e5a253ba62b669447f819943557182b59a1ec0a3de19b3b47142c0072380b45b0753a1b157d4fee8ced52a3a8b2efb11f9fbb30cf3a4c8a2aad48328811bd420ebb426c6f02c101cc8012359cac23297a9ed31671b52766336da641a33cfd0fdb1015c4b5fb872e8a704553e74a6b3aac993f84e15f33e28ed03eef6a713382c5157b716f63134813ded9c42006dc3a043ecc86f06970343b96612e47cb9a298cd7f4451415bcc2aaa97414bf4683e868acaa84581c258cb9cd0c9802bb8abc625badc9b1694630158bbac9be4303795275a5ed0e9a292e84a671375a04684d7ebea1860fd06364936b2d3e1fb1d17169affbcb55243a21adffdf3435d56a15679cc0619e1aa981a2ed0c947c2106197f993fbcd05c4fcdce7e895dfd7244ab6d3c7c8d386415157ef4f9084fd2557f20bdb94b710212d5493e909d123e4ecd66125fe79efab64bae29904889c60d07f67ae9524f456ee1145d991bfe7f827ab6ac1b8618e70d423f4ff2dc9e7959e8ec634b89b63ac599776950c507e6bd32ce8894e143a53947137b4486080828cb328663546449dc67c82f67ece72d62cdb13f6a7d5db81f86c1ce7e6c48c12ee2caab06eaf9ff45a07cec09e575c8801323cf2ae5737b2b6471fd882849dc7354821f192cf2c7b99a7672a83c08b94f3345fa2690c40b4f895a29cbe290e785bd0eb5022a138294bacfa067300abba093db55ad9280c64b256df7e2370381dc32449ced146ea4c6d6ac7e427b4e687bf9c49d66ee1763b57b7671de9737f12d66d410d09c1ccd918cb0ccc898b56458f4a37c396b9cd20e861f431f70aba4fcaa28539459f8df04fa9019cbaf31f033c82d529d4548cecb3c81128c855a3db747c8ef381d37d086714846638ca3188a7a276bea679bdfcfc084d3a3e1c149dce141a669d94b7da711d4e823c4560b475d12294ce85cf4f5419554cd9bbd70ba63dfb607c8a2298c338c9ced688efd0c4f17da8b59830c831a7b46248780e062873384c4df2a78c0a373920823941fb0d18b47d3552b94948019bbef05908af70e97225dd7cfd4c0cacb004be2276e65f7c4b3e7b0287387de7e9ae1c3ed2ba684a305ee97fb383cbb9d5d9adf68536ba0e4a1e27bf7a5db2a58a8fa72d3d16f0ff81c16de221968ec7efc40c1a7bea453656931bd9033c55368ff656ded86d473ee3cca439c84340ed8b2b1e66d62fe1a0fc0ec83a0b82227468886008a448e9bd19eb89de63c4964f69cff462bddf6ef397b7bf643da1bdb658f455afbab58ebb92d85edbc384b79d0ff9a804403937888fe99ab683f0bf6d2b4a46f3dfc46e981dc4c0046d1035842d7dba34971f6b5e4823820c3811b3ad985215b50d3e459424515daae2dae8852c8064d7ee77265e41fc482e805f6f7f5452e6a0307eb5f22a16e2d0130abb810d074677732f5a8f696eebda1ed3156a90881e75ed02e77cbf40e5aec5cbad5e493df2cc37ea784f6d8fc4ae656f9428676d0cadec423e83bd20667aca26b2553734590588ff31f3d87563e700abc9e9ac00f29145400bc5a0e73e68df6e3306ef46fec99e74637be3738712d0a03615610d612fcff3375acd3b53a471de45940429b129b7b2e1903c8a3d97f047d82055c4aa99a0f1e556adede69eaf7790d72db75d0e4623466db844ad9008061938a633e113a4e4557e097e906fd4f1dc49e1f8be8dfb620b1420bb7a98b6b288fb58785d99437a39e0553f1f47e5fd919c47cf076403169f4f2142a37649686126423c5d45245659c1d0572f79fb72cf00ce4234d68f152017066c9046319fff7f5f5bc98b95eaa54a3b2f2c8a31075276995bf5cc0118cea5f0c04370163d8fc167e0710595d7298cd86033d4415d8abf48671b81ca35ab337d3c9d6c1c538bfe20a3f494283b4d0659a2a14be6068281ab86f0e1539c302f486335bb8ca34d3796e86c05e9ebb1342bdc1d407b351ca7f1b911177971c2e4e42e573baa1e6ae0dc15d5dcd940594758cf078566701a6881f967dba33c9fee45d16de66a90d71671442f53f1e9c613991183a211a7a6aac7d7c1733b9e75ccb008869763be77612105deae6ec8286c3de8f4ce40dc71388a978c573e94864c74ba78887bf0b79287c1abcd474727b0c4ab35844486c616b01081295f10dca98c437c2b7a5688d4131e66e1731913cf31be5bb77d9a0a05c93860a3792d590e786ab540487c4905264ef01976f4387bcb735dfcbb893424aeec770fce79a61db25bf8a3c8c26db1e0321526d4cb654a4d67c4d44cb4c9db0e0415e94624f98f9c6ebdd884769704a047713b2dea81b1126268a5255ab96b93232fcfd4fdee91d180ec38c5ff922d83fcacc3a8e1fd5a616b3c1057df5e032ae0a01783b73cf1dcc9d26dd29fb6b0949c5101d36daf59a72a0ec95abaf90d92df5f20b57b92006c5adee2315e1fed5dfd7eafcafad4886a992038b763f8f05c775be917340551a0e9174358a8bccaa47a48addb83472dcc5f2fe9b7b6d518dd2d1a4fe3af6fd0c851677f1a7071f8ff79ce633658c7d76d3a852baa6bf36f7976fceb45b2ceff148155bdfa023321e150765019ba3569f638f6e1bfef6cf3c410fddb1b792972f42e2bd98db7ed2b7a22b46cf19b8a34cd2c7b2f8e189b8f8876280f63eaeac1185d91e129b157199648b4132018ac6f92a7b3f220f05acee7286672f89ce2a05b2d54e84393e443509da13cc64478fdfe03cfa8538b63143458595dff1dda7af2ea71e063f9d3de333f198f9fbae91a1658fe8c551537ea43d0d06c6df33fc1f0e9d11fae66745e995a61eb92863ba89b25b91779e42c857e528c8020fb9a92cf59fc327608994a559e13978232244fee3ab1e730e069a208c2574d3aa5a57b9eb5a676b18aaba7cbf9c830254e5fe96f2c75268f929c91499961873951f9b5e501f3ce031394a15355bc61084dd14e69af33f5c29ce9910417931b7a93522eb08a9f052b258259dd7d2ffb351cb8625602126592680553fbc760aea06ccff2f6c7b52bdef19f1e108d4eed6076100ebbfe9db99c48475586cbb247fd7a6a7dde3efa870eb369872d0b552d13a48c1c1c8b8ac745150cc578bb945fba85e264e59150dd86e8f55d12a897035e609a0d388f92598205fca94cafe097b50353f62f9a0c1582b78b985c0bd86a5ead0757f8adcf06c46a700c8c4c168bd7bf082d0233207a367d17681518610866994e180277d96be78799574b9e9858f616dcff39a95e8a3f5c66eebeaf8aa2c9cdf7e9e4649adf7922cc3013fe5c314e126bfd476e66483ca496b6bae68fab5735c82727dcaa4b7ca0a0a64682df7dcf37a43a7631a56a4e192791b4ee1c15adda15eb998742b7f76376ee4668442d330360bdb455c98971bf2d961b0ee60513ff206ecdaa92c6610c6afe617a2afaef70d8f8e1a0dd60023d8e8b63e70b5ebdf0eafe0121c050b5ce77a0108521749dc7b30368eec14f901f1db871c046d68c2e02412982f49879aa1680efa808f9db07e5a3fa7b8432e58031cf9cbe52636fb1b4e389aa64284152e6b6181a957312faafe3bb4e8c5c38646456384106fe697d851da35be0c1b8f3d189d3b96f79a4040303098967ceb653fd4c473590c4106defe94f878b3d54f3e5dbd144e20d0eb2c3c50135cbbf9a5adec588815e620bd1aa09f1c2e37d2a28c58b5f454cddc470711f8a63bb9b11d8c1161129c0cae969ef71253f8f9d6bd9ad92100ff93a8205fe536bbf77bf7c3a2f6ffb2fb52167afd6918bf6b683adb450a026777d188ed600eb8926180f578db1033b27f6460c01cb858d9690402b708546716f4c4a7c7b8d05f0588a2a6bcef54046654db1bfa02f4ef673546e657c924f5f145029446336751e9c60d6a579532f36a5c4960182b915b3fce13343fa9a01ee008276ab97b1bc6f01116bbcae6353a61f6b04c9c08e4e38186dc9d7620b9e5888b51baf2246683c3f575517a1e04aa816e2e494c34b73fb2447d2efc6913ea8c462e8221a54c9b87ee5aa40a8051342d51f1f8fdb40b8b71587a291faee5ff630605522ee2d62282da5de2f651634be92b4f188d883edb9a358b36db49739243751fc1bc4cea5924fb38a7055111a434c6314bacf838b7ae1b61617c35f0d642a96114355f655bfcc411b64bbfd9487c4a39c419c0afa82d0a20a1d2ac623aaa885c7f0a4ac3516fdd9caca755ababd31f4662ad0d9485470a52a8ffeda7c1d2c1d8e19354635fabeee3c5d433b833df7339dd5b75bdec9974efdc763134f7f7dee774266ed17566ebd5e3da10e8cc9ae697f886e3bcc78112a7ed561929a70240745b96695365fa81d22bd019a60a2ebeba610edf16373682e5f9d236d1718cf501086860b2276fb3d20ec7ff1e47071526fb587978a2e56744ebd65ad2b37c64dddffadb70a01c196b6e3a3196dc6baa7c1cde551e1bd03e6905377cffe4a15cc9d9c1e5ca38bd9d320878e1fdcef857d5622ef8d81ae38e440655e674080457d873d0e4f06554795456205a087e42be050c3c3ad1e9762ebbc8767237c0d25ae0b8d58d3d7d29683378355ae1def67a57704b74e6a131e5b3c9b21886314c69c2b83a7062d8adbb694774dde26541387ca2b8e1913e3e293cae9133828eb61428bcea55554e41d419bb26ece0ddc44c37ab5f8f038d79e856beb9d960b829011fdc825356537b2eb855ac084df159d8e40fd40af8dbdf50b65cdf86e37adc5bee94c24070c21cc0848705ca6c3a7296a85514eaeb3e81c6eb2255cc75bb59e5b965bf5116fc72374a27ce104e180cce562e09d5d478a5dab6e4f84e20b43ac3dc3306f1dc2232b0b3f5bc59a6c91d2450c0d90113a2c06a0c9c8167c33832be81793bfd0615a9a7902967f0b7a5464730354846394ace9db311b2aa92bec21e7afbfadc672753d2b32004ad21431fede0abe43a8e1a8b18df15d4db3bbd95ad3797f2716c33db85765258f6aabf12a8de4261d87872f1157ef8267cfeabc3b089a2b06da2c3c52782a3142295569dc9004232fd5313c5adbaa755403d5e6a96ab667a7651fb058663b2e028961e3740a85cd88ce7633898453b53f345fc2affeea97fe71bd31c2c04363facd39d1df7294605566e85272cac15614484c25365d1ace1331aa4ca7a093f764dc20d7b6e963b6d19ac40aeebfe7d418dbeafe51647d9cc5f680808db42534e93e4b60a9a8cbbe1c4589e4cf51c743fe83d0e44d2b2ccde122b491e8279d0be05bcc9ad247d6be4a77a7c906310ba5ac4e798d7256fffaa1454e9413948328b5a77f5ae9b48e28f932b29cb8ba97dea82c3a6aed45fe686cc4c401217e6b04e82236861364e80604b5878147996572f8d3c3294882deded2bbcf253fcb32da336cad506e818e99609edd721d54b94c20b3801f5532eb746a11093137f9bb106e16c6990eff924463486f7bcb91e53375a8232bd0dad2048d2a85f988937e5f811a6f75034f3b3562d0f702b3dcc93a6f4fb5c29f30429eb54f06e028aafe21e72b7c1ecec61303fe673974e690b6d26519e3d087ad3b379c927e8891274614b334cc78558ed7a80cb10eab650f2aaebd5753b7992f2686063febaca10d0bba5144ee3fffdaf0784d96eda5471007d4cd2c3ecfb6260c62f872e6187c467dc8629261500cb7d78f7e3b13181f3e4f485269e6c714adb4916e65b6ccc059fcc2654d30171560473f4becd1b7fcc127aebde4b0a557d64a0998218a0b5c0d33421d8b6f82b5c64ef42b512e4d7fa6c2484d04c30435540122c05ed649eae1f8647f00cc8d9286e99468bbd820d6d91089636853d196ce70e764387562175c88c0a04d7a9ca1b3d29e7686d06d50486884da6fa7e8a0de63ff6bdd4da76bdcc49c53319d9b47c14f30bfb8abeb36a6b22a3e7be8b547abe51bccef2b403ea6fc0d1d574523eb57b7fb358b256f42a6baf4600148fe0048970312b259f84f965bde5abb3df261df8758e530b638234394010405d0b8c337a0f136bce340d951924e88dca3487f0faa50bb3f6b366e424ec568c9a6d5099c151fda1d9f13290f1b7dc09c3ee4a3da39af361e25150bde8eac353b3c0a4cabc2073206e39931b891a4bc54d136549d37e99151ed81236a181555566bd31dfebca3e036e214ba6f7f5b2ee129d761b8e7cda440d67dd529ce053711eb783335c674f8296cfb3709800a124678f2de143c6febd70964628116523b37f77b29d3ea594e03e9b99338cc78beaf5565ee615cc4b2be72465bf49a94bc4e9088ade921fe5d679c142498d67b03cfcef787a540292e3f47821e3a4821e7e7840c4e636d0a309b166cff1871ca2cdea84910fac60432fd8c1a22b661d0fdad1bb2132c8fd86d1a59837e7678ba4337b6275300cd4a5943edea90b0fc0d8f376c2aae53895183d56257cdbc6aa09fe2ad06aee091fec9bee18161ee96d89b5334939c3d2b4baa5a03eaef62731120b06aa48da74d40cce6893f5705005b174de4b9709a021f32a4c5558242769eaf0c8a2848b825a9f1e5ea4feb99db4fd90c21a322f66f5a04ed6b773a678accd4405a06addb1e7ec3ebf5185b1a5f56968e17c6c659b72094bb2528b2a3b0e61344c3da37d81378eec36f2e2b2f59c176fa7b58ba2af63cc4a803a51e35319db4376c5f373f1077fc665cc0fd64b30a6809afbcb9a4e03ef49e4afd3332a1056d3ca6ff9e79fd21d2aecc455c488d0bf40e28d50286e83c65ad22fe728e78be507385e2f0df46ddc5087a04b6207b66b72483213fd57da8f221de4ff5a9c5dc45d66105b237c5656077f21ae8454a0f7f8a77e7f57ab0716a9695b86b79c16871eed8b461db5907ccac042a2acfcfccf13d1844c348578df1136e4e73c63cb327a48a417cc6fcd39ce73ce38bd14ec6dd4c8b0bdceeaa581a06f2279e0fb9b7b807e2fc30d8a337b068a737378ef85cfbb05c2d5e259378c66fcab499bc01eee04ed357c854e30662a3bd61aa862cd3e7f14ca855901bedee2f5632e575ccc7f1ebf841e4ffb9205d93372fa58cc28af1d36b3b3659c3381094718664b298e6b0e3cee6740fd1503c02218a5677bb04ed3615c7ff4f47a017ac420a4b053331884280857ada7f87f64811e17aeac5d823d80099f8e2ce967d5866c18fd591470f741525df94c94cc79114aed56f50c4db1e749c2d9c1e8cd64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
