<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e1b4e01f7b7dc09b42b322ed9d3a8eff76e033a8e99b1dc564725183ba93318f8ef7cd8451838dc187531d2f99fbbffbde12a3a20ea02eb699b5558ed92bf5a66184d238fa1defce0c3977c95381cba2f886c77f0f11f4cee3fde56fec1b09719ab6783c110f48e7681449b5dba89a828f1aec74bc8fa72aed1925d7d2c50ba5052032e413e944e8526f8bd762ab867158bf1006c026cf7b8c86e51d164c5555e5a4dacd488195959ea2563817ce74d3ece012f96c31b6615fce93d1c1ebab2076d326431ff3abfdecd6d556f46fea01c8d2755ce342ef2f91b900ada90be9d9da071c2c1bfa1c3732e1a2432d446822840e8695b22b1d70233b8b0503f2ce363aa03eca46eefee023e1deae5e0546134bed987531dbd09541d30d3f7da17359667d843206724bbe08652775575a4188c8a215ab07d55080cbffa334b40bc2ff0e3138c4779f926bbac7a3220bf84b10d254e3ef6449bc6f401dfaf8ecd59f8e1c9351adcfa6a019e3177504aefd003a8a2f40da74695f6713b21e5395b5db7a56648372fc011c3f5fb14f05ce9af725b0faf5176f8f2a2cc337d5236b56b8a98f16882e20dba8b9972af64e1f39a549c00783d14dca27254f6047d06e48c24c5f4721ad4d4125e28c8b6da74220d225b6c7a1b560eb34aa924a70a660231d9af7ec43ac18c9688080d3ea4936f0f9bab162365238983cddbcdb297225d00ff457a423dd2f48815a6ddb3dcbdc1093826f1539c7cdf2fa53d0c57a20fd6984ebd4f16781c3083ef006d1ceba468b481137360bb08ed4f3acb1731bf7d0f67d0793c8c06d7d167b5b9f2f62be548ef45c78ceb0032672f9e99ae3706dd2de09e59673038c838116593319f04f1f9df34d6e236730b3202f2a21a09a2d396cc9c52d1b6562dadbed164d7532ec8fea338b85a59ee7622870088a7c95676754f592aa6cc99418f27e2d1623e5d4452259f3f75510ce6f7d1d23c96f6194f259348b63897a93963a227ef0afaf6eda99d6fa909403c17b7456d7fe046269b4f000d34f342edffc6cdfe04d0aa1aef60ed26ac6c1c1b4858918ce97dd9155cc93772715916453ca24bfe68fbe6280fb0caff8ba872d8e525fab7cf80bed947a4c7557fc9e163e35c26cb19aabae9f4486fe9ffe8b680aabd69457c7b9f25630ae1e4278ab889ed264e677ba33d0e44543b4405cde9f4513144ed4621dbd859286feb82b14d743b33c729de6baa8dc0837e681f38781fbed02ee79ee329392eeb3dfb125031d2e765b38b04843560fa93037e1e2032d7d68709dbf3ad5ef8be15b78be361ee4746cd3664a7ba5cfc5c33fc195de6e846720ea81c1e3104cd7b62a8ff87b9f4bb471e4460f96775d4df5bcf1ac42e30c1c6f63717ec45e8aca3e300a04d279248f6cc2c7a33da590621848c3267be1e01ed0170b47c5adfdd6ab5df53f8c8d4dc74d4d8c0ead655dfb2e7b9ab8946b3cc4653ec690890719e80d61766f2a42a389b6b62abbfccb65f777fc23448a07adce79ba2d9ef2b20b31ff587b2ee2916dcaeaba8480131078a98a71a6a2725611e843a223a0e4e6e636b3e95f79973f463aa38d15b3c4a08470cb222a0b402a80c2c546c0057e578b2c0b37833e1bf114e1c7c025328e26c969959c9a9a1403363b37121fb94b5266e8ec29fa90641de424df59f411831e54ece6841a5cdf360b4d2ccb86c2f10161ddd4a7f6a7f0373f1557ec722eb1b7ddd05c7929905e26b7c3eb424692d6d726d6e1ffea079ff0f1299bdbacf50d059ddaf6df265714ca99bdcec9e0ebe1d2a2082a046b7fd9cfaf3c339304314b640c6e6559adea4a6b9756a651d5984dac0899e18a1e54746042c7390fa71a2d27321ba6bafc5777735754ddd47916f580d9aed20d214ef21bff5b58183c12e727bf2df39074465a0b100cf7082789e93489e208fd99363eb629c9883e99f7c3fab90134cfaf64d5ea058ddf3b0b4a5eecd9b336782d1dfff8824634414b9a19dd4da2bad2d2d35bd02755fd902d8919578f55035e845ebc7e618da62f6ea9ae5f849db1e7ca893f091f0702013d31e5be47cc90941415c7aba07a95bfa8066b0e3353deb1e60d695a6bd86a3a23cc815d5a65c23fc8abea99421597b23253a7211c42e8f44cd70613826d105971d2e78626b08299ebcd1aad4c49a5e1a2e385b433c784c651ffdb792fad152d2dc4b726f31742ac0275c71af8fa54302775edd2cd7c84197cd6d2f8e00be95e4aa4547fa6da5b9f7e7aec85122c2aa24106eb81c6db5dde9ab6c9c759023d8b2f0c438ca04835ef1fe2399c79c66b24c7179a7c7d74a6710da3f1f7a2085167dd907fb576ffd16ae291959d349258e75b96edb13a23c72e1de84040fbc70770174edbc43e043b851d66056434ab9c466d8558b0f861f34c261cf4f1da27b45135515bd57b85bfa4d4de17d0952bc91515aa847b5c47816c8908928f938be70e8b1341384ae4e38e298d5538392376e48755de35b8eeaf13957994d48882a2f4009457f18f418bd421dac698863eb7588e8ff0dbc816642913268d036ef513f9844cfa8238e3292cb4f7c6f73b845eb42b9b5abbc72598aedcc3dcad91bd7ac27764cbffb57077420d527a9887f1e47242683fc822fc638c2dd5b96b79a49ead1e9e59b7d72010b19a6a972d007a2ca0513a45448a12c9acc2472c77da0aaa3718f745c76ddf02f5c2a2fd55929622ac8660f982d92bda25201a190963a723d22464a72b79e7e6ea7adfd1ed0398a84512586d21b722a69ca5160cff0a0076c32e6b136faa6df17a1a67e4f0e822e9033c5b9e30d6c2ba9587ea23eb5ad7e43a1f052e84689f114032149b948a8e6aea304e8b5355b23d461ba8133774cb61efc234fb9238d01f11727e8b9f35fff671a6265a4efcca4473f5b1761f1befa9fc2dc8716f8e622306b19357dc2de429e64c48379f2ed037f2f475026685e34b8be1f8180a2072fcb6f485113f4a2c9baffe3959fb932b753dd2543c2f7f7bac6244ae605a94555ba1c4fc42d560a717f7805f9af78219e03bc287d28db94cfb42d7cddde5303924d5cfae5cd194e18a53a2b9c3edbf78ece3cf1f18d8f7a233b49d241f4fe2163381ccb5d964acc4f0c121ef82ff23a442334f836ae9b4d18ad3c8ce9db9194cfe0eb8c87fd531cb39a14bbd321dde491da711c907ace811348977c53df7f13d007521c569eb848a6f07ff87dfa091011162320cae78499687c22e3cf211f8e55303eb0631facfb086d2c2543a8657ec0cfdd3cacccb7f570552deb447223b6a3246d03f767029226bcf3f65cb43c8718753739930f2497ea3e6ff26de6ec1040dcce5901ba377f4c85b9d24d6abe369786e53e334ddc774c719468e56209a85304c8544b82f0f35637000a839f9ff7f7d38d0562492e2ab6fddde114447fed8159ad9927166d7ea7c46baddad677f6fa727a9c1a7d5616f7460725eb72e3b4b0cf879b1421436a570755309edf23d55b4475d6b5c515d4fd871dbdd54f8407798077506684aeb54f5dda3977b5923dc9db2f8c6b215589b49a43c53842f9ca63d71c0ec8c687d57b5c5261c2b5d41891870f7021187be4a815102bb707bdca89e9c8906462b85f277932303647253af4ba2fb3131827b01942eaebebc38ac0d961a7db167539f62e02682290bbbc1fadc4943f525437bd2522039e544d5dd1740bd906a53356da4fd1ded44e52a421ac28843e14651846cc9f68abfdc1b61fef3e85e90b72109f348d5044212283cb139e70476498fc3ee0b24b38769ec11c5cf635aa3df1e5505503504507ed3bd7095e1ced32bd2a9a9099015058f25c415f7a5f60c28b365c31417b68f75955957cb72009113fb8e28f3a6a81ca9632590ce2c9e1de6c39eb19c242eb45cc94a5bbf4325bb088439a4acca77ff7a75583f4198d6daa4fb22c1de0ff7091e8dc427b8b56ad6bf96d9ee715c2bb1f96d51aaf1a71fa2116ce74d73d724223bcf45b39ed82051a560ff86ea2fd8e7ebb51b621d9af5f289e9532f7f2c41c8446f79a591192851f55296653a9fda30ae2d4bdb6fe9252790cef72f90a1f47f38c8612a4c920532ebacde1efb0f046a72efd2fbce1bf9e9a63e3908d933fe96dd07177ea0c18e98f9c5820a4ad09c71899fcc7ac4f417d51f76fa0551365e4ecdb5bea8c482d51bc0051ec20f6474aed591450cea14946e22f83d1235a3b84c558f0b1e5b232b4a1a16411a5d44cf3e03bc2a250f3ee50992c7a284a63ed3c174f190b0c65855433f7f65fe1f5e0fe3a245df8bea7d707cbfcbcc6ae779371952429d75b24c7a76fb4b5ceeb4af90844ec15f8adb43e918ac7aec9d75a0a29d2e728285e12f3815a480d8b1c6b25b8a33672b6688eb541a1796929d4f38ffbea656c008eceef4000f2e0bf7ee0cc23e6b1977d72a924cc59b32821041b10a218a6d05d26be7b82c03249fb15bd39d6d1c418267b4b2dadefbaaffb431c28bf1bcaaa7db7b89776168577c433e350c6eb8e8bf00cc04f02807ddd11434e78c51237ec6c5cd6500a4d1901d3b6ab70c6fae0632497c8272ebcd40ced663bd5bf3ece4328728dacd7bb3e3e9dcfdc5344dcc3cde6c9424ee5ab7b56123f25399272fbbc784d88ab510a010109b49d27456cd264261069c35561dc7b0379164291fe3a24c18d0ce0004b51867c887335e69ee90c3923bd33b18d07b4d8f0466ad5b5b273be374b7ef178805b6cfe3e6dd472477ae4e6a9f7fca24a1c5269ebffeebdaa197f09bd69bbb321a0171df3b933127e6fcb335013f3990aad0b0715b891a15ac59e1a2b66bc0b57958199097f78caae51286e393e5d99f482820f4440c4bcf87ce2bc37c6b8675c5535c8dbdd120e0ddce1aac96a2b2b947aab0da2c19158aa59e3cee9d332b1f6f698ca3e9a0930831c5584a9847583edc68db137353e0e6082472fd99859313d73ba0607eb9456915663fed7a7b2bc224ce75ab1ad912d8237a6b0518e8d376a66bfb06ce8345b9cf52abbea1dc154062cb3def981f46b1be90ffecb4b44adc6d845c565b247224c07c08f80f9b2f000fda48736a9e8d0a95fb7c972b1804c12e4c4e952b5681dfea7b71223277949ce5ada67b58ce2a53536aa179ea31479d8678158f4617ada49f6a711c2d67273e4b2883d3769365fbc0cb1d92d57b5dd6a771b7ddb03ef2c1242e6ca8510fe9fa9a1e9dd6de3f050fcca555b72efd114195d4a7715e788ffe06ba140f24b148de9e874b15c22f88e631bf3c24f2bbaedcc51a4f404e44fa7c6a5af11495c22d50da749a03b87b83e2fc2601f49fa9228d48e33ebce0a82f2e6e195c8d5451d9cbabde006ad151267400a00718c46850607902cf8b3aaaf8a0afb81978ee6ffbccde408dd97237eea605702754d3e63a571b9958bd8272977f82ce36e9d8dd9103c451d541ab922358a39506e6607732964ad4426f7b5bccf34f199b1098b3aaa057b8cd6504712af02baa9112828412be4215ecfa79c3ac30be995ca96df95bb74cfe90dc2a5969f89b8add421a1ef56ff54e6a607ff590fdc00c919e2530074da02856bec02171d1efcd120c6b2dc30032c81ea02ad5780391e208f5f477a12c3ba9b552b861f9012668f6114f51b7ea28652cb50169fb750ba1d670f5b95e1c415959f4c0e7bc310dd05b5d3e22dd07874e28d7ec97e518833e3be3478a0b49f786c406a92c9875fc25906702f107fbedb8d70e4bd6a65bb782e45c1b7c62d5aa0a80a11afeabe77a7e716c74549f8a06c8dc9e6c80fa9336eb2bd6ef7b19ff818c75dd9d3c130b2316b8c26a79478471c3aaff20b73795cd82ac76ecaf0758df1908562a1b5fe57707d28da12119160ed75d6d7f38f85238236d1a50527e9d64b7d6b9cd7aa871fbe2dec297a0d706258bbd78216feaa8a57d86d7c16bbcae7db5a976ede817d0c3b7702911b23a5223eca9bf1d9584916aa2a3cd59ed7a541b0a194b605210c59ad50f6a949eddd043062de16d31ab42664d284e8b5e98867021d4c7e3239639ba9d3f075d3361d1515dfa857064cbe9e94ad7075e15673206974aba880ff3a9b962c10ccee8124972052ed88e8d1022836e70c7af83241819094ca6b2767140bb0044bbc59acf33315df464071c26114f48c2d5b641480fe835c8ab7947da0efd4332c55ef93b5336ebb86ff4fbdda9fa9e2f75697cc36d0d041c1e30625ada843d16c00c4fdf348ca8be552c3163629aacdd68a34c3dddebb9286501060076a6c978543c4ac090632ab1e55f19dc4e1df228c86a29c6c94cc0fd9af5491fa6c1087ef6f4117af7018c7f571aca0ae74a2d154335e6a470349c4ae99eb0a603a1bb786b2587ceca8cc092b9ee40e634e4acc1a3b7e1b0edf0328790cf3ada64476d15500e34155ffd5bc602e3ae369f504cf25fa7148b7f307fded8feb38701213a761049c455dde76cc14488543502ab9beaea2203791656f35c3505f79e9721b297089244dda9ec18503f64927cccd589cb1f610f0a561317a5814194977fbe39e5c509548f567e89fe650bfcc2ec065320ea1cb14d4fd6dd97190295427c8c4a059aaaff5f24d4421978c11f9a50702b5e54106d120da55bc110f516ab6ec827df50543247d3230421e8b0a335122f8e0fe0f7f2b672c2976c9cd30d990d68c8540a22c93913fbfcc324c9af49b7e835bf5be926dae489bc0d30082f5411d96f5e6984949a9b296bbda9774032b2d71dcb55318809ffd69f91223d4d9acbfc1b4c24264fdc1c34e509b086fc6bd7ed0d641055d1334d9e74cae0edd36c3dd5fa077dc81ecde2d3632d9aecfc5c28c00128c09ec489ba60ac20de8aed794ca3a91e56c44e2394259814dc5d76f6e399412231ba7405581b8095d6fba80b1f069b4793808759ec63742d8846e26b5b5155753ed845853ca79f359ca70f61b3bfd5cd0b18579c962b131328e0019e7f02bc924a76e0a7064417e4bed9056cc8dedd43c80c9ec5b54e2ded81199c7ef208055d194044ce8a749869733fe19137a8c1c2221d380d261d14e4390247a82eb0976ace090976f0209e09896a4c2a8aead28df15d040da0e443f334ab4cc0064c2eb42e728ca5bc02a24b28fe5383b4b9aa88251b605fe36c06d3297e1acf31d949598152ffad817962c9d4acd79440c9ec4174b5b81a6718b5e2ed5575216ce7df8d307228f4ca44707abccb9009b45f4965606b3f6ff642c87a4c38189ad06c328eb1ed7ebc7469da81dea7779eff4c642f36b68835bc7535577a7a378f787ffb7adf4e6bc5ae8ed43005f7cfa4aa0344ff58918b9a65499c9c0305ac74eb4d42b6cba0abcd1a5654775872869f2e5de4f76d0242a180301e297ff0997c6ee6ca3553436c5258372f5003212c1e11e39edafcf1326348222e67a464418157dceee1c0c3ee1c270b9fee81d8a98cac846d8507b95b44b892bc7a6011ce43945f260c7d5da037ca43759e9aca5260c19ebe4687d2de6e64fc3a3e52062ac63b5052c38d3cd83d94ae7fa2b4242cce4b978583c8b407c6748fb98d9d704b31a23599278060c3fb323edcbf3092160bf3a6e26119ca0e44716a314be6c5a2a9a988d514690e3084ceffa2c3b5749e0fa7c49b17388c28602bc2fd0bf3a04e66038528931967294f4ae2087b0d87c4ca639b4c403c7060a5e93b37fe3c0129cbf8b967b847bdfcba80a12d644ba9734b3cc793215aa4e70ad265e4d5554abe316a9c459d17da5f462c6485a78f7556df793cd21d045e8c1420862179756a7b72517f8fcaec77c5bbe1d337692808cbc1c1afe27d803a46a065d96b49a047ea1356eb7212c9fe227faeb72a5eff505834778b22ed9c344b78f197ab40f1290f90b910d6f378fd528abf94c0d1fb8397617395235996f8edb20f25bd8e22e949ef6c66be020c06bdb172d8788f3ba6d5ce2188aa3d761b5727d432cd5f443f68624a443996245f71f627dfa88d66582cdbe52b16c9fc25d5294857aadda8b80835ac46f3547275c64cb4918516255eea6e162d6f163ac7d4251e376d7a0e2e7fdd0d87a47a408523f2c29d1279c162572d41acabfcdb70cce0469378143954787e7c8285fb1b9381fd636b36790c7983e11e309b395c71eab333dff384d74749e29e9e09e007fc2fa1e752a6ee12769a812916f1fa7ef8d64f1bba7feb486ac8a27b86c6dd4b95384ad9b5c7406c9114fbd73b06b461030f229400b9ee8dcd8f62aede38a74b93d2732ce96ced858ae56b0fcb2d3b09c5ab7e71f9f4cc86005f978fe86519078dfe7da2b08ea745b7f3015d653d1fc7ec21df370972373b6ebbb1a918f6c612b46f946a71a3307ecdcd74766c50dfd8eed3b3ec819d4cb0568ad7c7b261fc881ca51524a1f3d9cc360a8bc6aae6df88c065078f17a04457f0e56b4efe2c289655e8b731d2c6c677e818e9e09e5550f75ae3b05c31d2ecabaa58b38d9adacdfa1a1fe9cb03669566b449f82d2401447e1e279ea945178e763fbb2dbe039bfea39cbee844d91e0485063f3e622397b65dde657c6cc2dc57d05341008f8268e876036158e5e04be267e4b20754d46a728cffee95a05b297eca04f5624c6e8ff06d0a54dc334ef9080741f2da4845ccf99882ff270d9f77994fb9c3dbebb132b9f6a4897697d8f6e8d6fe5cac4b657953facfdd548f0b866d551301c21735d67a38691380fb3b6d5534198d0aa485ba9bba5c09fb6b7981b47605e3f51258497060f0728c8c1756c3901eafb10c57c292660df11b1efaa8876bb0973a819bead66fc013d29ef6bf123675416c3cdb4850cd6696a2925231ceae64158d4ea5e36bd3e6310f91f37eb22764a982ddc711937ae5439937577522c9445517dd1716a1d2a4a8577f5b8bfece2bd81990dfec4c6d1d82ee6449e8546cdcbabea86f1be09003232087cea84eea3ec6cea696029a11d22ff1d32408fdcad677c00b3a0dc17924ac6ff83147e243e3253e47ef6df2ba6eaf960ceeef46be6afe1fca9f327628341abd2c56f11ba9732bd2a6d71ae2019cead4ef969583302b054044ed8996030700c748dbd5d660f8cfad9772ae95e8ae6833180dea1c8bb29b1772f27c78ac19a2b321ef62ac8b16ad217f5913e0fd4ec3b5fff6420abdd0035608745f81b4043c3c4b1dcf72f1833667da5aad2cd31672f92e25e1056ebbb3a93acb2263109308a6cb3a73b4fc02f8e368e3e93316c3e819b370bbb403e38a4d04fe6011820c5ceaa4b666fb643ed08eccdcff8a2b5d2c98ec26c9a8fbcbb884190bc5cff27e9bc3a879ea5cbc09652c1432bb03244594c86861cd3c2ce5596d81f79dcde9bc9183457a5e92d54e78613042118081495cc86d56479b406a40173bff95c859a589bd835821806cbc27ee6f1f04d0c0847914d7e51f063ab5b36653d47f49e49d0a3f4f52c35b15b8bccaeec5931eee8551f0ddeadb5ecc23b8e0a7862c44ee4587014a903bdedcaf24c3b3fb0b59f2691d69aac3dda379e5cd2ba28323259c4f9bfd1d30adbe45dcbe3391c0388524d435645a9a01509146ae3bec16bc9440986aa1897112fbc41b6f69fecdb69f6fcf77efd52d05b695548a573f457b0009ff0d6a40aec09aded6c52261a86f0f522abc43ad7d01c56566374bb7db91b1834f534124e221869af80a26c0c6cb55987dbabfe1b4b311cf4db1db7d2826feb0c7f864b8d9e22cb6954500e75d7137a1994c247a75951e1b83c5261928394792ec8db4896c4518d30dda4ede825748821aaa50c89d11fb46bb68dc30e8006ade7dc1a49968a2305a5691ea0aa41603a6123c2df46060396f7446223c2519ab29e30a3061d5a092cc8d1a1153b1b6d2a6bbcdd861d95dc4baa365449285228e578940b3301101da3e07139c7a6e3106871d8a7b2d6c3e54c45409630b02cbefe4ce72db3c5ab336aa4facace8a545f453a526a8ce0ed38203ebc2a48085a1a1ac1d6d4047afd7d29af0382930438810f3812a501857ca302f2178922cb953a13354b81ea25f6ec3675ecdaccfe0483bc77f0c4040e50068d4fe6b2b5b0fc28ed5fc5c395f40ac7c867122fe9c70d2746f621ec7190de2f2de779cde57d95b7927222e15f4e70dd797c186daaf513eab448b924d45b4d0aae59171937e8a635101e806641190c4cbf143610d37fc7442db00176c19a40834c362a0da3f9eaaa41cdf54f9b2c02a0e7a02c4eb5e9d8d1708dd18a433c2d379741bc27df0a5b9fc871d0a23e0381740453474b12aea277c6fa005147b4ec3344b2ab7b4d28292341b1507da73db7fbd5e6628044b2ec426bd4c6ac4dc8f4e7675e31f023c3da488122e614e5812a8100d29dc8696b12780218968c5fd6e42602c321514e236a76644fec0ac9701edf255be461d80988869d24c46795332bb5c2cd4e2e45334a4ae55671765cca33a9b0ebd53556d345b50f2f5f91451a3fe1ac71fbe9e8bafd04733a9e80b5c0d800f13f9ab029cb9875d86def54e470ac138db81fb8d0729a13542d8d970bc57824e60eb562de347dc0495c8830c13d5be4b6eb6bf6744136c3f456b3d2fd1b809933dead49cd7cdfc4cd6ce954c6fe1d8737f7bead2848a67b79876d0437f63ef39433e1b3b5d578c33e4b1488106aefd8e41a3737b74281cf8d7a33cbc5581f207100963bc299dc32f95b5f2b28fc53d55cbee175f0859e3991c4964d899b736d238a8c3228d344cbfbfd689db5910589de8108c21de91f3c75439e85784855c352864a35ff73513e7d9855859e25a5083b81127c0170464f58f7e03798e87d4f8a872a8639afd9298c262f61d13d3bcde4ee33edb59baa728e1209ea18004a3809ab8b30e4a7a23bae473daa30c211350dd0680e0f91a7ce01aabd461d66a154ee00781bdb30f1b637e0d5e35ef879abd6f4494fd9fcaf71c3c5247c976fbbea94a6645f4c7e063f5948bb3f8a3d05eeee9b6cb0f592eaf7d94833eb215184eb445506a6ba6af233d8845601f6b826b68705b4fe1f9f3beb2791f315bcabe3f28b0f24f8b2575cbb7215b895b04b2670dcc2a71858a101ce28b92b95b95427fa018dc6565b32ca15176fcd78c1bbe8c855354f5e29968d9020f6e2d4f7ec3f32edccae3cf8b58160c762ab3d23dc9c90cebabfd3926afeae3435ef1218832638920cdfbb4e2d5c001a83eeeb0b652e2267852b702204cd0db337db9d2c672e209447dbbc7b6256a65fbe4891c171fb274eb96810a6bcebb7e5d71195c76b84383fd998af5d673c9a60d02bbb738f3ef0f56294187d8d425c537663b6198cd35c97e4e20d2a4affb2b16a95494617c42be3f0db85a14b3008fbee35b0407dd10080da1e69cb89653e66f9fd9d2fa016990afccc455311eda1183fa81ee7d9f1b956a0e77cd1ec364ef6fdcdf889de4b6e1da6d16bc6c1aa603921350e2fc49e05b8b954d32d0781c123bdae7b906ab1afc20e994787c4644830956021e3a73a0b047df3cdbe24df5ce8f95ff3bb385e682d131017f1ef3c1aeee10cdf51a8e01f3008662dbe73efde1abbf0de357a59e1669c09b34352a79dfe2cefae239be32b2e9d16ae9613bd4abc7bdc71c37c5e05dd89cb4c79c1627151d3f618ccd192e0f4f78b3a584fa2c565bf5c5cbdce471ebc200b85072ababc0e5019dd472c91483c39d43b47f5720561ef5bec9694de3cc6636f0d745505e9fc981dbcef00ce3e2c9d867b7a9165a61a812f7bb13386323ae0ad48e246ef1d2353ee3bdb1b62281d16b750445ec13ba04a431e568f6a102d16b7b44a0217e386f59e8e2f17acb5bcf3d8d300453a861e4025e62fbef84a7f2739b369d57cc2999330f970cfcf607f85e984f302661eb849ce02edc3ef664f71988673996d21c41eb0199664d77b553b52fa8a9da7a684922d5645dc63f34790441f46d60babc9725c96be65422eb22e3b386e8b6c2d37bf6ad3db6793e332b6eb72139e0a886ece97ac1fbc89544935e65baa7f54b8d709ec5cbc0e3b0d9ecaada3d3473f27696924b3de83d032da8500173c2cd341eccf8766f118537dbfc05d3d58bd932d53862920c0232af144d3b8573b520ca04dd5db0c65d7e8b83ee70f3e106dbaff309a87d3dd6fbb3737461a2ef316af9d1ec6d87186a9fdf7209cc02100ce12a62428e8ab6d3b3413af80f89e1200a2d095714280ae6543b588a20b7348f3c6c6437831ca7617f335437a61a64114ce0abdfcbd17bc893ba3c123ddfcb37f6d88c88961adc31273a147a04a51ebd7676a039e54b527198ef82ac2c9e816860b7081d9dff5dc9aa6a9b42f4b3c336096b0bf038540eb7dad80b821a4ba63edb843dffd4f15a99311a225e658feaeac69f412797f1feb4f24e8bc638d6b0f4614a32ef4e602b73ba78f843ada91d738bbd9711c85c4af3fd659603e5f3bc65f96151558596558c2af2de2d52a6caf5448e224d5242c9fe27fc133c627fb75c2ae933c4564798d5a4fbef9e95e92743c2cea5a1fea46bf6449e6f1e2ea0c7a2b4ee4f2272dea01a9b6bb6bd48587273632076e211918a6f1430bc52c6ed166b396fd311cababfd67aa6d38271ad1c5ed3d79aec0df8f0a75b50a0915429385ae8cb7ecda09482522baf0dfc07d15f028b18f4cfcc5717dad504b06734c09af535deb2f04fc512f62ee3609df29256600f32956deebc2db6b66344c604de81fb9fa8c87c5432bfac430d60b01a25b09fb46491fe6e7b01f6740f05a6b54db8fc45cb069f2e3deefe096ea9885fe0e4cb6f68f3a66144f906923ebfc1c247cb004fa13ced59574092e2b99fe31eeaeeadb81c4803cd44548e055d56b652593393ec3378f116d8f4985c4a12df743431fd7b9fd2905e7ac04bdd7ba463bd38517c966987b08fffaed839ad296203b7aa03c9344afd68a33178cd2bd3675a5a94f2d5d562bd486602a5feb8bac90bf167d502f91fab6bc981fd7666e1899b7aa54b85fe773b53ec456213dd14a356d4a68b669582d8d559002c778892f339c56c632260a1ff2028166a7fe6c9e37f3c08b55328509b5ccd2e8e5560b8de0c3d8312c4bb83f458662b955e008fe680a1cf437b245ea810110f1ee5ab5c7d4ccad93550a0360f49a63cc232ed9357da30024493c840f25494593e38a6ef620f1c44eafdd4176467fedd855da14ef6ec49e9777c6b61bfa25bc27aa25250a7c9221388dafe19841bfe1154aa34a48fe1b37d565d61bb82d656c6907a111b1d1de91312299e4ee795f335078823bf704050cf2d92346c718b2cd81b800ad1dedcedf5aca7ca1bcf034ff7566a1888c0ccc142a898ff170d3174da30feea6043693d6f7b4f2eeccd285741ba6abb205f39685ffe93d8c220e7687a4065d73d11867c0e3bc0a36c2ad370abb27d7ce96699ee63771e0d8c6f63a56ec6f7b967a3afd62af4c5f508852374a0f0b0e6587913734dceaff3307c5da5110cbf2e9707b690de5b01a79ff1174ff3e4e04fe6f56faf5c45127786befe57bb709c24bc490a5da2682209d6ba28f0d4573d2828b8e23b1b2abee3dfe6ca98a77d50c29fcef464a205ce110257731dbcd3b3a917839cbc12002cbd9780de0d235f15d5eeb223afb91f91340025d4a13d05a3dcc7cbc72e1a073c8709206142806ee22921bace698654fc33d7df9e58489d9c126ade8bc899715aa64d0c6280b0f171c5e9459064bae5d1bdd579eb9c738948a4946dd9d4c2800dca8dd7a08258a28d61906067f815a4ea93dd194f35b86727f149d06ec46566803d5251ee3a63023ae658fcb942ded8d32c59a3b95c3a1f1e9a445a7969a968f75e1c5f62f154ad6b892e8278b2a048a866c8c841694727891e45ef81cd12c808f814fb1fb054216a9608d7ed2f07d817480e794efb72e1c77e5012bb1e33966ad1e6c903e7cc17c5f55ee01f512138cc7b23ef7eef36a1ab83240983bf47302b6ace8fd9f7691d78408144aa2134aa563029e2d49e5dea9d936d02d306d182f5d3b57aea03ae74e7642325184ac2e82e7fb2eab316062ba9ffd2885dfce4d08420e32dbb36200b7e4652cd6110c59d879291c263c41ef21c70572594cc6142a1b559617fe5fcd5b33c27c1dbdb3d3ff754cac63ea57d7fc965101eff35d1c3358e4fccb1c2695d938e1188d0b003815cd9c2b7b8053091fa7cc9be4ddd79d68999b672339c6a457ee56ae29048c4253781295d21f7ff61053fec5da1bec44c611dae56c6fb78674dc95b249842e4758f8c7428d12a011c1b0ab2146a647ef1fce29dd4c9d01a27726b805e3f1100e30b58995407d236d0e024173f730bf83bd5037d129f541edab112083ec405db8516e0305470ed720aa654ab41faf9c5afe727a735203799b399b69c66b9526368133b772974e687ed11dbdaf6f0ba280b1e5ee3187c5f42ccfcf9b7d98c5890c0f384e10b4eca89167d654faa57d7e7c249a1262876f17963732b5306f82a505364e4d9d1c61ac45bc71082a071254f9a08bb1d959ddead98d0b1dbdcb260979676f460688a9fe3c71e6f374d5c5ef52c74e851d6f32b24adea9793006918d2e1669fa9b5b1284660f464fdfd30e295be5164b9b2262a8de55211fa058a3db5fae30aa8641c063306d0d107133095c06831605e054b1b902237bf0551540724fe1388fce1e925059e14e800bd330a25bc08a6e4efa0edd0f470bba731dbca4b0b0f3a5239c1b40378c9a23fcb49418e3378618fbe77e248d03d35f862b74ce10f3ee67255cb72dfca8aed99ae8c2f4b5ed5513f21c5ccb1174f71b585b62cd1860acdb76329be624a363a228ef47d9ebf49333d4c0cd4652915ce3739936713f9c387c5963da2478f4bb9c8065a5f37f48d04d9dc9b566ad6188ec29a8b389aad4e875c8f2901dff720d24ad08a2c760075047e1b6099e7845d4f817bde41c5d67eda21b065e8643ffbb0d47631f89bb681a4e24028c238cf7707f6c2299d48628843c2ef78c59957cb2a8265217cfc26c47403d7a061d7676a550f6b400e4ec1fced9674bafc7b29cc47ba415914638fe3f64910f0e84fdb01335617f8691ac41b0436c855322dad59d1afdf3a0f9460b0d35d242387a0015bfd7b4c80a4aa1253e011bd20278336e07a24c218d5666d70b3486b5f63d4a65bd54d4bf2ddd513db9839ac3ebdc91c9d3a0db3260ac4bafe19e16945447205ffa9357bbce5728ecff9d2012a5fc4957c8af5d150c9fdc3ed6a04632237e84a8353735274a913db3ff570a87db650001d5b17176afa2c34c646ffa0d5d53a151334dc4eee088266a168e00c4c098a40ec319d3f9c483933b872ed308efc1d96a2d5d39383e92a93e1cfc2a4add38acc0971a602c334bf393b98682ee9c20f8b614379f46bb6678e3755d7fec0a1ff9561686f1728041436f5d82254f69c5520d45743342dbdebf27c99aa8b0c25a1b3fca5c180c0f992338ac6566832a7c9214682f52e17a81bdb8540fbcf0a4f072d5c72054003cb88f1b692ff83c58256ac00271a9b1c7d1a6a6e1cc2a3791b8b323a62337c2e62d6440ee4c6a2b1f4280d7371a9f22d595a54c2c0e5c25388351255291cf588c6043af75b213c18c30ea32683eb840969ccb1eb4d95c98e0849670e07b1d5ee90dc53eb7a50d2c85f4e2ba839c84f0486cfd0d7426d18a457b3888f0644410ec43c62a0407ef9ab0862cb249f19d667fa5cfef50a2a26216eced1e6949f2079f6a07e83bf1eae177700571fd3c220ada2a4fa78325db4e2d20c5d6afa196c3d37ffc3e7aec9c6960d4a4aa76c944cf37e24680a997d6ad02b23a1fdeac41ea98acce13d653283e1029bf1cd81f5506490b94c61d465b0dc6f77a4f5ba20c699ecb613d863e3c64081111596c4073daa7d80622101a5095c43a51577d03c1f3ac179e98d1a48e11dc203e5fb31490dbf2793c77b52f2067eae0e9a04c3c49f7e9cc4a88303bf2f765f9bf8904f794bb0545c263ff31c3cb931aee1839463e6ffc5a7259c91c1f4f37c16d2a0b22a2a0cefaefa0442cd1a3ba1697051be9feba5e06742aef527b5fc645e6acce6700689bea5a1f2a21f1f3d852cea3d01610ead37f562c53e1c2cadd9485b30c693242efa8903ed4c54586e88d501b403c7f20ac03ab0eab4819df8f57615874943f4bf042bc0c2eb191a3f958a97b0c5429c659b520add3fb021d229314077a7dc086bbfa0843d0d065f320763e15afe22508d1036be843b89b2bb8d782a7a9f3511133bff4747fa9763398b64a3d6bf6ed674aa13d4166fc78bbcddd5cf2ca1c47b3f5b96e12bdda1855be71829ca7a2f11a4b85b5d5c56e6261d06135aafa8807700c3a3c2d6f7e8e6daddb03a5bb243399b37e1c528ebe06c64b30347b13b23c1ead0d2d635f213892d97da11d07b266393b0d5f08c6d23f4b6e61879142a1d4cec0c479e03b4e8ec16fc652bc503188a06f5eb090dc2330f87bc45afcd1dc1b7bc622d897bd90b09a40a860d66d749ea025943c091c6286c75e18f720dc2eefaf56e96fdb1c40ff4b97e3a63d81d511fe757efb702920b159eeb020924bf6418d3560ec87d13cb7b5a0a1533fd03cc5a83330d429faea26fed466e6339dfd12e81254defe735f75bb46a7f74b2d8b9be61d6236155041b78812e93943ee408f0e7a9db3fa1985f359635b40495cc06d808880144b4bcf5da48046fec1dc2cb4043cc04cd252313f5072fb3811759b6f6dc1782ed4853f4711e07de282c4521a61100782d1f0625a98c94d069a297102d6adb2d865f5e361e23424244c4b812d3727ebef34661784de9973d99acceecc5c9e107a51a51074a069e37c6efd6dbe564a1bcc88ea852163979a7b1e2ea1c66cd4505ace11a80e8eb650df3b63ac3d5ccc7018933f70fa440539d830d98919aced47a306eb8e089c7e4c2f2bc6b9c73d6ecf555ca044dcb6629f9ac5faf16fb7fce8d476a03cfeee4f9f8754db5ec9308a08824ef71f219019fee69c106314adef6e7829eb5282ba7ef1f2617576d8607cc4d624a00751c05381b82219cda26855dc714964d5b7d022c9e58e490612c024f352966a5cb9fc56d47d908df0de5754342f6f8f165fd9a2d138cb645b06b876c76afc7b8241e34768d69a331da258e621530eb117089fb736cdc143532a326605b8dcb8a1f27637df02f0ff6e05db1a813125e1043e54669400eb514634d9b8e6a9f1aba8a7f60c1e166a6239da99ef120bd938bcdf0f432866d4c427c9de22c9c31e4733140b82a27f0ada849fd2017859ebdc61b200a606cac4942913a537ec63b2777bbdb38c30c66a17f5c1a574c861d6591a6832a45585ebcbc4f55bed1a09b503d6f382c01ec5b0b01d69422568d5f333fb539bcd320b721af7ed3c7f3a436c5d3e4d0f5b45883e95d78f729e778c1050926cca0a212ae6a1cbbad71b5dfc8ba7a9773c73932ad8a5f8a5e58b436e7d24cc60e67b8fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
