<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"072f2bd404a2189adcac50f2bd0ed88591a05b542feb3e9d5c6e3d345e0534c207ee69ab4e6876e0327930dfaca029997a8498430afd8adfd09f7e8ef82286e3910a56e501eb339d0d9fb8e3d13c742b55ae72144d05766e678c378bba34966fa26b0495c5a670a3f2c312cc33a9efd7a453a537d2106d98278a7ac081d691efaab4263f626b71c301c9ac90404bb59286266d3563b351550ca7ebc51253f828685bf00b42b63c439e412c65b8b00e5e434df7aee00c29a11eb427c5729d724d8a8b9ff9b800937dc2dfcb6f10f9e255a412a3f2a2bbab1d7f909a7b430d8ce14dc7a85557448d0eb845b81ded58e7efed2e19bd2cb429314b019e29ec3e44412a94296a8213c08af688157ff955c77702fb3aeae88f871245ac65c6f8960292ac18aa9bfffaa71beb69dead0c9487379ef5efee10cee2af1f946a24aa976e3e1986759a79eb6a586c967ccf17c678c525f543f73796ef504970bf7ef93c7eaef5156e42ce6be4741b1816597031877d98c9c4a03bd3c86689bab883175c36c73558cdb1973fbe891cf829a3b075e6b948f9943703dafa55edbc8a172d60fcf243c3b32f9edefa624ddfdae177e2e2f3b443c10263b9e5b0f05edf8985d748cd00046c55b28a159e33cc01faa614ffed8e5714ccb425c6d439707bcac57feb5e4df7edf79b7fe7b05f98dbd6e4967fac7eb84c04a05c758f85a95daf5a483ddebaf48f1402aa1922968b8fbb8a546621f239a288d26d44a097c22177f3512ff8275bb8bd89f52038d1c90a61cd6f8263f046d019bb2329197a46a06163c49b167e4ba9a6e2205b977dcfca6ced6e929b5f2ba981e069c0c3d29d586c1a565bc1ad439b4a931194eda29bcbc59240122bd5ef9b796e66db69da9b11211205e86d79a884bd57802fb8723d95b0297007ab00b126af3d64a568bbda7ed42655d17e7d92f08bcfdb802413dc3e0dc887a0315c75b0454e3e9c1ef5192acf9300f1c6ee6d6ffd91509077a4e236a33c248fdc49d659bc3a102e008f33efce0a4d21d6244d63b93e325f67f474843d374fc69fde9d2a6b42683b26164a21f3a2cf3e05da7771a64cba1d03e1a7d6ebfc8728c163f2428fb190ff9e3f79d3e4eec9ba74646809a2f437b2f4a71c0e0ee80ce218352e70ec58d5e82b752c9e4142c05b4d401a7035729c1703f572b39e190cc048bc30cf75d593481a75aaed303445ecf2e2b97e279cbfba4f788877cdf162c6054fcbe70b7abf90d3e25f9a1b756154f7e9542980c5169eece329c088b48fe34e401b74797cc0a0c3be2d4858420993b3edc8d65a0575e5e6e45d9f44b0dc5b91fe808972b9e233db69bf4199802d4a147f64fcaf6e196a5a5fb707dc80eed7df6a9cc8717c5b222f9caf1c272f54b7f6ee2b5ffd6a35a53950d179ba1a9f91ebd3e46b730defc98454b62ca798e615fb0a14015c445f7bf7ffb542d90528378a830b77b4085a9b9b59491bf1b8b0d10badfba67834edcbeda6da23dd3b254d6c08a91caea07ce897308de43d544fd23c0adffc83c1389b23d2a1381566194835b799cab4a490480b2f7c1acc359c92f2f3250922e22d3e896e046fc7f7a58e8c8f33215c7a8c040e1d0a0f293f4060c96c7a3f021bca35fa96a2377c88aa424082787c26b7a417397f76e9b3f6ed76058d76de101053ba4620f32e158526844080b6b05960b7cb436d9a787f9fb70534810db5385a60b1e7c8aaba2c133d750603cbf1b01adef0cd7d959445e071019d081a99802e168206ef4b9bb1877dbebd30102c3fc42c60b984757b0f158eceaa4c84a0f6fb6997b4ec6ea55b0184b8d7d554154e678a6d48575811dc2912d834786c9d5480f79185b7c96c9057d3c21b6e5b05cdb6fca85ccb117997859d38bc252db74b9de0e4b9b7d4ebdbc962110510ada47399f2cf9f4f911ed9c230f619af30aa159ac4475cde918009ded84b18ac4034f7a243508167f868d0f9a447cd38715d8f8c7d296d84f957e60652bb2f484ed5099864e25b7f9f30e37b2de351116901d7ee42963980fbf05dce4c9c088b944fb79df5a8493d7c2aab34c44b299c14a153642258854b00cce09ff764ba8bb7f04cdc3d986aa9f26a6672e790665012025709331dcda28c09faa11b77dc09229027743e5f464caec2644e3254b8810b3f8ba3494b7d59d7a9b512b26876dfef555fdec098f570f13f8d8629bfeae239f55127231abbaca27793c4fe4f145bc19ce46b7f65fb4f1fda945b7c356f2efdf8916cf5a84f3bdcc972e28ec6492fa0f7507303d080593ff53956c0868e27a861fdb1b2df91d3c6117ff190a13d72838dccd456da149b818d525cc489dc7d47310b40b0618385ebbf939440996c4b19d214b80390091a4297651f5d44e44cf0e4bc2ad6bd3891687131b2929d12f7c8fc970b717963b2cb620f6d9a89b4ed4004ed63c3a3943f3d130ddc04a59f04012b97e96d9a50ca7447d55b986d146576fba0589d2409a65eee478f50aaea529e0ff22cfcd457fed1a86cad1a14183fcce4dac15d597d5f1edb13f4b5edbf64c953d36742f3b4e17a11f802f2ad4781e7a2505eff2c1bb0607ad70144db782f9ab9f8060b80b4c98e58a3e82420d16bc81c5eeeb7c886b982702b83eef32ac05aaf41750f5b649986e5d1da2e6ca9f0ceac2743aa142e295d1ec2cbb99c2d1a2727432a19bca9eb686c1371acbd32c6b23f50fd8e9d88175bbdc574edd3da41c35b828188f01c659bc803464486f8ac1c9b6ab705bbb52015e732b3880602f771c7fcb3d88901f3f24a6130c202cd0b2e62fc8c15ac1a5f4f77169d3c382471a9a585332ee5873b9f09020fb3660e4b1ea4209f315c775005dbef4604f41909b39ee579c8808a5db70f4b71eee2ed16a2564ecbdbd4f3e5a5cf53978f4c76eeaa66eaeb63ab419bf59e8676912bf55a45b8040bdcfbac5a1f72c8f59c5a7069fdf930fd720cb3d233262667224ab623a8f04ce748d9b0e6f90b826dd0c51b7a9ae250c2f8dc84742ab5243403c4156192ad7230797cb780c63dc1b6f410e29e556dd24a175fbf145e560fb1c43e11f2c55c3c713e4a07c1338de4851b3533d1291e457aa14b7d2b4620d914649097cba2dc6da5e0718cd870b5fe657d4bd5858ba70debf1c1a55bbd1596456ad1ce3a1dae025a7cfd097c70cddb53821e36a6f52ed128992d1df13433f4ef98d9cb675e12c2160577b2944733212bf51a0cdbd71f21e703abe0ba676a7322239bfc18cb5d4a27303ee9ca6460e38c688446a2a3d3389e3240e5c656784cd78feb7e593a311c0093e5c0c385ae6bb7828f2ec695d4f5c15102780b719a209875658c86b7060cf752e735d9929a0634539079ee5b970c4e105f29e516c04b4048e9d6cfdf8b05c2c85f6691bfcad4a310a3541dbe895380360a6a43a99da74a2c3708fbe38b9dbe50c8850043599e225711e903daded6dcd6088d10e3167a216c0eec1f100fc4f9271bc31fde3584bb308fae50e0c41e0cb5706382d9c9443d38bf7b054381c217ac5e94d758230c64d995b360ac38a43e6dce2bd43abb58c303d76e8544b922dbff3ea396f78226b27295ce48991c23fb1f8600d03a8eb1e36860ed180f9c82376abbe4d68774f9a63d8ffb5ae1bc45679ce1197a0ebaa27e3fdb011bcea2b9827b23eb32101e5b0db161fa1c04f0ea8c1ff839989d024b6d8e9abc78d11fa92e32b8a5e267138dac283c83298fcd5fa71d9f01943ef9d4df2afdfe406baa986a3d2dc09a1705ed0e8308b5e4c0b7322247dd11c83308068f378442acb80dfaf12fd5483fb222fc5f7e3215b9dc80e6ba6c478060aac32b0cf5aba18e964b3ef8aee12f59f87e08bbc620a4b4f6fd10965c6b757d9dd7099342c748535a5d09624dc4d9ef48c5b12fe252d10d7d24c48af0c856d2257f833c5372fa81f5704f7cf468ef5b3e267645f6426e15e7c5d1d00b33a6544e3fb8337033113869e249a5e636d618909f7cdfc1e6c58da2760eb2dc63e7e29414fea0d25b84f326b156bcf92b560d264434747071e948a1c58da34f46288b1f47040be97397ab094495bfca344cf2cc0791244882de08dd91cc2aca9af6edb2b1741bdc10ebe73e7f72f40fd3e44e628972e53509fc08be91f001c98035f14df38919009dea05eb57159bce09bf644f92bc356377b982dbeff9c0182f41b62c069f0ee6a416a2a3c04af84eeea8d32e045c62e0118a81bfdb08470c3942238f6172b6a848036907d50f1c015d3af9d9c56174b2faaa38b53731a80aae38eeaaf76d97b849895a57768d8d80fd3d90df1cf1637d73bf2421e1170b3d1a79af77613eaeee99123d853651312d2a6a5f97f497f600660e34073ce3a84fc1f586fd18b9714f9e72dc47441498bed18f7e1dc334f9a3d69c6f411a31c6a796385cade5336d24aa8dac67237b496bd963167b278f1d33ae7f935b3a4ca782f688162e1b659632ca6d984115e63b925809dd2078f33eff1f11db46da3e74223420921f9733a421a63ea91eff06c133fce900bce725c654556e4fd5be4da4f5dae765b467da0bf6c27ca42aee7509f2bec7a74ecb7730339301e59b0a2a9d35808be8c00f6482367ad6060277dff0b9da41bac8288d210878abe79befface0e4488243db727f2806a7963f9622f59f28a33c839b112a41a120bbda012dd9d641771945837d1778abb3427c07c1fce2846c8e0112ff0ef887ab75fdf10d5cda84d527dab2a08d7f33e30bf9842702a750bcdb09a67fb010ff4df198e9b65bb6cf8bd5085834c7c80731915e661f94ac2f2e2274458e13f393412ac1403f34620aa2b9f4cf0df8728106391d1bf1a3beaf592ca7edcb4c875ea27cea23c487558f8d29155d2a5f3317205e0a4d404e77d5bec1adca415204909ce7a235fbf284fb728914a454967696dcb938b59bdc448b9806d9a884a94d0abf730418fe25326530b18f11727d2e0c85034eff97fdda5bbbf7713d41ca847171facba5d2bb4cf7e83b4dee12fab5dfc3ce2f752f8232c1a993fc7e4c8c21255d01419a4eefc8d052359f6322467cdeff85d85400aa68b31795de29edbf87293d47b95dce4268d4ed4c464c3fb6c97c935c6bd5cc38f916ed6284920b820a91a607a04014b1661438250c66c170a6741a0a252c00228e3787b8bbffb98ad63733614f46640592521ebda970913b1171101343e8a5d61724e601497117979a4d8aa34a124569e6f24949f18aca59a576a31d90eed902921b4b6a34becc5fb5f38d06d567dd0e8fa42a7b965eb48c6104b071a1b604c697b564201510cfdf9a6951f040c8000f652da996ad78e9f7a39454d5dfb136c3854567055ff8c658dd43b92dd4716ffd3ddc10b4234c9eb87d1f016cb174a1efdbf762c373719085bce419daff92956cce012f8a4846da0653b3446a435074479090c5383d460119cfe557823c9988915f8186086f9180500aeff94b97fdf1621586896b66810ed9ef4e798792d76f4fe82555c5808f7e6751993ac66108d5cc3523a64cd8f81734cdb14a466af92dc01cca907287bc3d1c8d9c653a4531a50ef4fd6292adb9ee637650774eb51830e97e474f0379b64b4e5f70da0050576006d1ee52b8196430117ff9472498517fba0cdc03bb6679f3b19b56f66d2dca2adaba98eb732a4c90065d9ca348162188c5fe8c38f5ce02f2476505228140a7778c19193f4ab14536d6b670cac97dcc45ea7064cd4b746282653a1879ab49c9d08b23b036877466eb0f1ecd91cf5a5e405a24ec61e15845d9d7e965f4a1755781da791284b1997558aa2bb36d5a0a017f7794b8c7364640c5a96b9ecffc0c63e3982d8a65a819c53773738465a7381685843c22d487351544b20b38ad2068f502a566db8e7a26b43c3948e06dce856b1cb201574a84744c054af733ffeed505eca3832d789fb75ab5a083bd71804980aaef6278763bd8808bd12067f6b61135f95bd2abe697803c202c5a5cae1bbe05632f4623b0ffd9e89067a5465b10c1f6ef8aa0a016b4be1c419fa1924a3745d1fa11439dea22a7d8f22e0235d7568c76c80163f86bfbdff582479a13f87231a4a8a0f5dcc769fd658335df541154e8c425afdeff389940f311b8243d94e228f47d4789cd9cfbdfbfcdde423a099205b3564d23f930cb1b6dd2e004e2986f98bd19cc5dc84b5c0d60e03b1e280d1fef4ffb99fb0220e1162cd12dff53bb62d6eee16a10ae45197188757dc5873d071dd41d6dd0a199d86790f6c743079a2a92b4c525187b5ef71c6ef283ef26b1c1b1d1cd33e12a883e1106dd9f60ff2150e8d09d4e44a1fcedf165dedc394e8c5789734b1e0c6040eb5a9314fa45d18b172e5d140f2e08468774d6a5a1e780c4f23c1b250a940138f2b491c5595b3f8e28dbb012151bd95e7bcbdb8483f3bbd0eaf33db08059b14e5766723f73b8d0cdd1673e8106cff161c01e3484c13f0217f7ece3e49d1d54a81c66a90f5dbee2971ac5f700729aa90fea359345fbb422fa318bdcb4f4e684c855ec8885a5a2f54eb94d31068a7b941eb3bf010bd20849246f1181a1d3c929bcadd9c13d696ce0c13e3740f06819c198726df278ec679095e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
