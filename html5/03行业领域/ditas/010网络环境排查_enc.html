<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c64b93412f600ae8dcbc1fc1f7d9136f4728727ebf0797fd2bd54257c2669c50fd301c60077db0cef12b2bcc52b5626720866c25ce42869c3724ef956b357d21f1d4eed28711d6ffffc27ae945492b98fcd338e8359895c798259905277ce7f0197d607028e2e3734edcd26c1b9ab0cc63dae080f1af17a221ae7b2db34dd6b629d1cd0aca30ad5f7ac4cc2d62545ac12b6c4f655c780f49adb5ffdb3364843558c18b44f66f63180981faf8c5b26d82c3eb7ec2e7253bc73d4d8969b80d345788149eb9e9f6999c9fab8f6bd8c380dc1c2ee6af616684e5d1971b1ac2425f2428826fa5cd056caf08a74448f2046e26f98e71972dca1d912f1557fc29a0bdf8e5a4cac0a2c248d82d2b2776cda514484ca549e2005b94b3aebf66294a9511eddb5ce2acd105134d52174cfc563c56659d39b242c19e8b3a94a0de043764c3bad27f155f8a92a114d044e7b7bb7f6a4d4d8f08b39dece1ff1549703d312df45008c6cec1670f9ae4a48635f1421e20090ebddfd343dd7af59edbd426cde0800998c963f7df5af03d9cb96510da63b16b38040fdc7d341a3a5bf65fe4543577a1ea4280ecadb96a6e44d58de1f285f73ada56e93aea9a63222757eb44f6ea3cd80474837b323cf6a11272069df841e40b8a4d606f7493589b12fe4058745420812a6ea1427a481204acda50f80c6dfa3cfb346fe878eef07f43bee9a7c4f3f90d70aaae7512c2bb78916f90f283aeaa44d0fa18cfcf33b1954410fe4c00fc74e41b6366f384624508d1353dd5f75b2a1274dfc528d4112175a87af4a285451bd8a6f86417fa2d7a3bf265cea268a1165f3f7ecf68bce50c5cdff1f7c88aefd0cacf2ebedaef9d35e802f33d9c528f96278a69715c7c7e35d59807ce5f3cbb3bdff618c4cd27e5a6c52dc021ed0e03a62a7cf30a34bccad8fc7083f26bd616b47a007c95998da300183534ae40c5ec148bcb592c384d57c2de0d7b146dfb7bf08bf2c0a7855b1d9377168bca3c15277862af87c9bda310c19547280c8361a5f4aca49d02a530337de2cce902a0d22f2f1e4eea3a7eb65fce58eba71ee94d736de8e9f4f4240764bd458e21516bc12e2cf0e949377914c4230789d44ef13b7f661a86b5acf77a46b9b7594f8bbc1a8386ca1d6dbe8ac0791b3f529dbf783f02b7f82abd919bcbecb334ec0ee1119c0e567f457709a7f8fbc698b9f3e4f35251bb6880de7fa54ce4ecf4e860fe53ce341b61dfb180b3456a269c4af856d0155e457ddab5b329a002f6be20af14a67b8c34abc9ee82c93a08a7ecc82157ca2810786b374650a0826122c29916d5b6e7416b8e9d8c9328a5fd983824cceed8956750ecc160c2abcda21b59f00ecf250ffd737d140003c411b593992630ff137de4de4bb1a1a52e0847df5dfd53f8db2d85430fbc037d1a04cc9fc3a79f679d342d0d4f59c60b1ec774718228a33ac09e2a208430edbaa74dec4d187e7e7c6092c851cdf7e32b5d5e80e5eb79df9666fc39dc402cde351f2aa5b9cdb9511adb79bb99e5a18d02a24da9f7eff6d32f05c971a511108447c2003ffe567dd9b5c57f6eda833a9669dae834e710ac8088088e2e2d7c667abd659c6b23b19741fde906487fa10cc4b65833079e7c82057fae483b62240f87383f1e798ecf8d831a7b2e61c64bc33c34784aab2e5bf17565fd1bea1052594e6d037bc26450574c812917b3daccb55f42ae0b059840e3f620208307416cad16df234b6e75d4a149e69c269ddfc135da08048c4d373a4b6d3259f1567a1423b9df7017c4f90de0c72448b8bdeaf73928e788168baab0072bd113cfb223d4b2136680078c00e8ce06d5e33d3cd9bacc61286b722cac94cabf94968e778a392533b7448a7d59506bb3d23d1d440655c047c030c57aa79ceb0ff81725ecf694b210948771bc621230efcfeb8ac7cdc08c275d88b5b7f957075c9812a553fd9c2fdb6662b7c0da0b8431cc0d13c6e67db2726d08a865381fd55ce7ee3fbfc2151c8ae950da54bd5cb06900bb8840d26bf1f4d109ecf47156aab8899eb6f13842dcafdc32da695c1b9291cc81b2b9010a3da5545dacf82b159d22b28a514e31846ec3929bc921b3d78d4903a44d90bb67abafb282c286e79dad362be93a995ad0f2c1f34d92a5f1c4ea8d00a32f821a85ca18750d3153b89517ade7db50cd2c193f9012c64ea9942e6163437474feeb2670e7924d8132f1e792a3c6834146323f9767ef538017044185565d4dd964691af7722a2650bc871d08359c734aed2268ef32b5e5104fc1a2d2ec995b06e55921eadc7c604377e95d862532657fbc840d496f3eba8a8252e63ba1b027b19234540b9f02c376ba1c1d05bb7da2afdac2db9f69e0b1914d3eeca2d8b1cb1718e8900eb9792a632aede44da7ab6356502212fd2dc94a4f52e62affe4046517d6934f826e0212cf4b3e15b826a6614d708c0c9f3f280b7a4bbf1203287357b57b81708f457f9240653d016267feb0cf184fc629545ce187cf8cd699025469882925a0f84cc5a843600f267683e83337572075a964a170964007c6210c5782a49496cb63433df2e92d7554b85038b0b02a5e79441034c1bcd8b6d9aa7dd532c8137b646904e3d2af9dd49f6c4813bc4efd21c075e7bfb17254820210f825180feaaf9dbcf1e9728271f57657adaa3ac5ed20154b24cfe11c2f194e746487247e521b546f5065c37b4407415c5848a199cd5d07dd63d424ee82dfd5231eb3469ecf86655ae47ca3d84ba92f03433fd72e008ef66657b1bd8831a950fd3c86792154001ad02353ca4ce3e3e17b43ad02d3d38baad093bcc5ab7dae60863b15f369f494542411580d6d5d0d2857efeb3b30b09565d12563f0cdd72850328c1d1e4c1089113145788fe254125ece83bf619c924140a707b3419a5b4be2384b4848f061fab2c03a3854746988fa5ec714960f5be5cdb50dd152ac859c10c5fda5384c8351377fb2743849b0df6b1e72c375e3f7b2ee756e52af09dc282886f5c10d8b537f4b70e003034f04827ab993ec1372dbbf67b34090887ed94aa7837185825b78e8a758accde69637aa0a7b346a55e5e8687ef5b6b44d0c14ba25de202d43a6d01403b0e1409b0a492e0ed7aa922816454498fef1bb53fd36448031d0f85a54f373902f2cbbf0f872593c674928532be4e17d9af944567e0fcd360dd07cf55c356d277ae005ff153d2b81b390e47be0ee9bf7007b935389f045e79e16829ec1e9f9b0d6a6f2b8737ccae60c6a349609f509fdf2de25ae92d5d7ddc396f50eaac195bb4b31bb90fe0c8d402231a1f6c7f033e35a873cb2c581ba41cde2c2b747d30fdd0e934f81c5c038b70267df7bf34362a68f4e9864bb1a5db9b5dfffa1dd3d5b6941439a3f6630c21caadb9551faec300152e00b716f8641adf911d63497e0c2fb87e81e717de4880b75de602bfb56fc766201c713c293fbf001958cfa9fdc7c84746bdd06c43511dac217712917ecc0ada76c72f746a3f122823cf869cf7e7e804a87f56e67cbb77a6ba62a5298d21811c740fc0a7979f4f4573ecf1445eaa66bac6c0d298ac516552c151d957c5ea67c99c38833cb7ba3ea2cd96ec9c47c0467512a2e26cb8fff7223795e8e7ddf207177319722521f6da1468963df119b3f6c89c3125c9664c8fc742f50cf2bb2c0d5b3d30d77c0e52cbb06d5c74e34a6c85e9c8867aee00ddd20fd1664dba5964166423b3ff61e3c78ff1d2a0207fe05654bf58560278d625ae2c2ce3a7cd69fc7ed629cdfe33ebbc2e4e441036f17a7f4cb1e006491fc020e02800b3778acd582cd8d1ea97c0fc5ade143532276c5e2103b9aebb1b997bd78ad87ce8c3b58da7d852d5bb9b6da031919900dfaf269391bc890197db38a72f37d2d89adc40f8fff3e3dba27a756da95251f75ba5a094e5960183e2ea3cbab9d53e1013aea8b28e7a4ef23e20b51809d335f39f9b0d19ef05d4b3f124fa6cbb846f85a97d82c396ab7d46ac8a241740df127698920265a6992067659b1cee98713bd8e663ff7cb2fc4659afdb4a19162e41f8d8880d443f4cfcfdd02d1fc3f4d6479236e7b48993a1aca8797c9e34f3af9eda2890ba3ad1d144087d325263bb6bcf3a71a55d4e729d24d8108ed5fd09c59ea7567363b4cd5dd2aeac7d90147dbdd94601f0dcb3f98bfe8f032dc54398057ee53662bfa2d1aa8542d92c30356f83105db4aef11c3e316a93d3c12a368c6e2f7bfd8d458fbf59f5e2d50cabfd9a580a64a7517ec0ec24c14f0f8ab359d1a88a8d6a96d0ca1de0bd22e7cd6c6d489e56973d419e983b84b7b58584f6186510e72e1d141da629984d8d82121e2ab0ebc85af54fe30b05bdb8570e0c83de303c0517162a6c80803c95d5ee72cc32bfa8ef6346830a5da2ca51cb0a12c88e82ad9ea239f47e277ffc33a6223072486db965f24cda2c1fc7a20062e97bd76987a0a31c711b942fdcf7e318593ff3722d6e332908ee8ba4aacd5c90b74661978725760102dedcc9f59790a67d8433fff45738b3fb2c1a0687f4e963cdc6f0a5df2f44ebbd46b9081a686ce83044bab21875843442abc9d5ea7ca19a15336d988272922e584a4e525d9f9131702441d1aa9a9751c456752819c28454857514fe936a6462ed07923cd99fec12d86b0318ee06c79b7d6e39df2a373deae462140fda1a474fda9ba2800494fc9688381879d21c085d2ea33e0735a1a6d08103702a4f7a383356a9aed4853a6e47a1440c64b3b9d9e8ab1e792956e2aff5d0925741558d427f4e90f8093be6c363b699e716d447db7749f30e9e112a16ad4c9b4710c9826eb7475e301e5b793ff887370fac1ecfd8ee6ba09756d8ee3bebc99bb21f97e53f330dcdb7ce8dfda559ad1162d208cca8b7112a93477d178b4cdf5bd3f12f5744cc4f34328ea09e6315b8a8ca61ac8787db5b23a53ecd6b181817708521f9825f333639c597639f8eeb37624e0a62dc9d7f5d78e8dd9d47100d380994f7f8702b9d44436733a5bd30c9748547202a9093cdf1deb87c18c7a9ea7a88a0f5281be0ccd82be9b1b4b16d9a4227bc006c7f4b9b8f8ebd718bd24c039f7ed0abcb26665361d890e542cbd0d261ba98deaa07f92aaf5e3396e0e6b9329be192bf06c09aad3568eb2242b314547aa34a32aac6d6b20c9411f3c733cf68607857855e71ab727981b16331286953cf1960eb4d2a29dbf9d65602f0ff0b2327747f82dc7dfc75e4d1b2befbc9ac16e33bd20287cdde4ab0931deff0c94e89b00216c59dd40fc3d0ef360af0241f3ea65c719992a44a1393033f0e8339b79aaa3037c30f7459cb937da46ba2545325ba5d65f1e5847dd39e496990b6c377ed1fa6cbc7556b6455f78129b22bd274e95ed0addaa962820132604f153d5e7dcce55c58ee75f8d8ee7762aac93a7ba7218ddc0f251c12e9e851e976f72ba6557767d9f90846ddd9e4a95bd76a8d838859a3d49de16b8655c021b44666e954959ec7046c5c782fcfa92a5bc504406af209fa7becba59acc0374d930cad00ace4becc1d856b486bd11534f40dc8c0c3f826fb203dd618244b06f6bb57de03891242eeb3e3307c2aebddcb08d8c860f5d1c8c0f0c17c7f3712be413f80957b6962041adc5a5bdcdf10c4e741681d4a54bdb7963633a6913600be29d874ded7df29028f34f773547ccf06cda37107e1b43365e9a219478a96a4d5b64feb18ddcf48f463a14fcd8598c48f282bf7e1982beb99801c411d06545664240834c4a3f97ec69304ff32acb597f583cb1fd63b0feeba52a0141b7d99c761cf08e9c43a6fcbeffea3c64c7504018f8ea6e50295e158e0faf81e44a85e8252fda4adb21aca9792c804b6d9e51b4acd37c38d0d48e5100f5d762520b55e400c38d4f9753f3cd4267a36605bd24c158ae6f7c78125484c2502e1fab0f67afd63a1755d342e10cef7939b81ce8033db90ba4845a173751def24151eaa0acb3f2132e1ebe8e3cdaa0d5b99f420058805b8e04d7ca962bb0089f73e6fc166672c7c7b7f7eb3cf422eba305e3c6773d82e74d105c978513647390197a50a4b4b4776b59ede12d512b9974c7397ae8e586c242deba4da29885a0407c5bc21157f0b90e73b8db587df3d4895e829bfe1ba6496bcc93047680c4833db4fc9cf596002133fc13bb4ae1989d35fb02be164a06682ae1a27c7f67924d2142130e6c6195214a3451f6ed1309c387717901434afd08ce874ac2b09282be1664df6acce3391bfb64c86aa7475790e463b5f93847cdc2fe0af3a504bd5f0153f98a3bef0713ea38d50b2e85274913815c4e944d3ed6b6f2f23719e830f5b880068993e225b7d0d7de9e227b46da3560f2e540bd8f8b57ee9143b5b49853b136b17f2073c2bbd0c9ce66daeb92faaf1e5f048a542b23fc161cc63299ca9e0f3c7eecf9764d07149771ac31502c8485ac6569cd12b0b852812c5d56c325159d7356832f27f6167e75b8a1ee8c06da4c8f896e110505ebc42b223b7267a587f8d92b15b82c0069693fe4faae888ecf23e42c828e69fdadd6ab854ae08cc2f383d969cedb844425806d52604b6938aa35d3fe040196ac20e73f2fd9b6c81d63ab12bf702c90f3159249991ceb5ceffb1dae6dcd18fe11cd0ad1f73c8c951e3af7fa4359178ff0c459830640d9bd5a2fef452246dfff69e25af8f453a7a2e1d91cb0bc327081eca10dc36224f842c319584fc47082fdff05c32d116e71393f6ab3cc552c6e8c8b9716785db8860a476b0222a626f75dfcc2fe447981d9cffe2f9b97e571a569b7c72988949ef2afac1d46541d82f4579b57073b63f693523e0fb2238ece15e6e4d875523e581d496a6e9b57a41e5fa6436ebf3dd7a64d9ce05415914e6ce47032556033f8aaa4b5909f28a5d16f9b77a6f0dcb70d7a9da988b5b08778890445b7f34414f683d9f97024911242ea07a5aff803e6b30cffc338334124129be47122d2868275a65ecc4901be7533f202643ab3bcda65f78a39204543878d8add1e168d451744e362705a8b1be5dfa9aadc5eb72d77562043745722f64f187375916ca297b17831558dbf93816022345638476096bf258712410691e486d784b9310884762adaebcf27fa72dee213abfa51c146dcb2b5f3ede08363350ddd7a0dab75688039f116e51c84b3367c20aeb690b239e85bcb72c07754ae32143c3b13cef40d3d92b2ee97453afaf0fc4d3d3200f575a0e11b31aa952ca3519e5e447d269715e1152ab61539853484fe7355404f414a536d97b5e51ea5b03bca8ba52670223ab152635500ba58b763a59ce85cecc050ac7ef2eae0be9d820a58da2d55184f36db1d6d726d955ad89636531a28cc86f02bb8b4cc747d491b5ae315700f140c64e321d649e94674b2cf6986249ce85ae2231883fb126b23168a27c54f48d8af33ae3fb6a9d63cacc9e9e91a18cfb0902987e96ad5f50bde3f4619558f2ed777884249d4fac88b0605e12d5b84dc29c4ff067ac65fbbf1a3a4a9d9e81ca9f1f3b709f377b7d68c85cc84967102d26bfcfb92f966302a0f962aa30264271fa5aa07ccdcc186ef222d12c77999cb0c8d3263560302213a820c4f4d157d28747d42a1b0f6dce3761fafc42b594efcfe849aa8ec331584233c7b9c98657bc3f44fcd7b96426c6c626ca9bda18eaeee88a6799fee75285dd06bbd8db04c908b1e5bcafdd654b57eb606e0e4af1374bba6aa347544a0b8cdadd9e12a323dcc3958610aea4e4e31e039e4a64d4476a3d072fe8ab826fcf971d6ab5ec25eb976673710e8438a4ba354c97e6f451f57997db7256b74fbba76da0bccc6535c52ac7531dea0acbdb00ae6231841aaf3cedf8d7d1e917a7476cd42ca109aca3285d553829dd10e8b46b15b77b277127aa920207f37b8ff0ddb0b781bb1e4b60f9d10fbd06b43b19d980f742a89ee43c264f30cf6ea5db9c2e86453eded07ad59855ce047b587073b5e3892e50f618a1dc49372aef2c7710ad69a1dec5e7927bc0c483d15443c0b2cacc33943703fba02e4ad0ef4e32d04fbf370bcbd682e0a2be478d7dbc56052b8e881934003911922636645e0a7f3f0d75e578d7e24e81b71bedd3e959d6df29478e0f7d2591808246e5a9123160627526398a7d4be93a7fcdd23d52c962662ecf909a45ee0f226dcb1af1c0ae357be361f1df48392bc1e8b93738a0236dba2dde5f9e547a0e18873b43e5930055c8b6a7712ce3a7548d7cf548d382e54b74a7d715ecdc7a5580a4662d7e857fb3c0095bcc420e4cb58f7bc184c3f70d0574edd671034863daf0221badb78d6a4a214dd2576b3b2d8a0b4c0b81f789abed27c66f834b06a8b2efec2f4feef47aed776570b1bef4f8aac57fd443c086ef5aec64d0b96420bf71640ced0e67b5b84e4a25bff58dc00294b3c15d6ceff03a866af7b95c255ad622c4c6becb42d3e4c740aeb757d6bcab64c21909ce67dbeab3ed58327debdc53c8e8a802751512713583fb212ab38412d8a54f70d02bb80a19db993342b6aa933d56f4c2d68ec7c959ddde4d22f9286205d8cb0a7160ddb2e21b6d8227eef0e372f9aa5fbbb3e53ec10e9d1d083b2ca5aa8923f928811ff07455fe31baf71c6bc515676438c75cfc1591b219c0bfe7d36460a63b50dc0af01dbd8344358533708268412ff9d98ea3e908300c3293572571b93af63c5effe359b28306974c894ef7f14d6a5a14b7ef018702fdcb48d1f2e40a869a92c9dae1e282f9d7bf3ff67d109dfa00102a201218ca69a4f1d66ffba4e7442188fa44d59d1ceb37bee0bc0229e9827afc13b3e4e38782a4a0b18051cf1eb63826662852d134d777b1f20fcdf33ee2f3e5c858f17a67126d2a142fa12d059e9ac67e22bcb3a15bcfb1afe86e62ea951a12d35deaf6e7d6053d3234e137de4aefbdc94c91f23f73817056aafd47a0b1755376e614e90b4b981d9f262031d9565a65efa553c2613d98528c6f284559dcf4f6cd906202530dea4e3d7ff9fb8306cadb6b911bace41d0414c232c497545c7e0ad9f749225895bb24b73e12ea9f4c67358bfd4115a1c405028d14a3e551e5ac40bfbee8906bf474c114dae5bd3ec462d945f8763836df017d7d7b3d6f2d26a53c8a04a55f8f82711a1ea23740092100d23b7970721e474925164cb2ff9dcd691728779f2e265414076d7f719fd303b075ca5b371e03b4b0af3baa238de4c405aa7622ad9ff8979e9fd04bb6fed332ac7cb5d56ecca6cea355f85cd8e447f62e6e0cc440d4b9c70bf484b0ccfb4483dfe461b994c2ae976665581dd8473921debf53a83b11456af8851413d309531fe4addde7a78208944e74cb411c339bf99571fa1e74fa389fec60ad9087e4352e98977c81935f156487c263556adc861b19ae6af92a25b10e043bd2a4e8384a86d999dbdeee5df8432376dfc691c6e4fe6413308d94cff94530f9515601a89895d1fb39936fbafa2eead073acc46ed0fdfeb29c2fef4032b3452aaf0cfdeca68bd81acf3f86d3f00c769be3df0167993d662091b98e7f51272356f614be27bbc57f8e6899c27af353453f53e9c8284d1df519e248e7657d5880b7cdef65b890cc0e49b561abab3d695553d865396dd1c066274e0b26260a89d4417459ba8623053feaae9015f5ccece6f7479ec1d0ee1e76e85199698b6654328ee9e04ebee9b58794bcbef478328c941a4c8b5c19896fb22b165148ecd61af32ce187f1222c58e3269345a71bd342c7435385446440547d846211af3d5fd02f6f5b3f2505aada1d5e41d97e8c648f0acd0242a739c2b7d0c839288b427597ee26610b57ee63fad89e51aa2e6fa24b6ad024b36e9299956a0f895b449644c6be36bbdf95f65ef8cfa0eaa3061f68121ac27d0a9a08592833e27c217e261aa36cc405e89b7c07e8cf9e75aa738f97697eb12ade216328f42e96e6f4064daa87a17324b75e4d0c551c2f167c3fa9f1c101f3494db77aace45e0ab840e70a3f4564b46b4ef190e91c6217cf29fb566e8a420922ad2b9d63d0cdf15f7ee3c182737d0f9e143b9f173adfc2b10e4ae372b18960316ca85db9b1f5995ac2218fcd3f4bf7c206664e1022f10a186051f0bfd333d3d2f8cd57eac7fb3b2a51963492ead12ba755ac6b7956d65029017b015f96c983da7ca367123e87cac5465811c4a15fb93ff2146602daccd2624e2c0dcca070a62961188751f020ffeb957f83df1c2742e4d1d2670714aeda3529573db4ca4857de10f503c9ef4a87c06d688489cefbaa8443f67219ce30cfeb6b4a115d1c2d834687dc3784078bc789576de64230b3873514b1b5db4d552d10b49f6f4149bcb765bef5ad820fa02721285786c0100259e303afac014e008c1847e7bb70b29b6bbdc6cf7b16c85093957d4f7354125fbbe81db72a2d94df03cdad75212d3302a19658689724927691f0b68162ab7eb359a467aff6e6adb154f3b5ae00b6952bf190df95efae8351ffa97ff6b7e1592ea9a0f30383f65f319d9a84fb3929ca6bf612081d975ce38bc17d24ad324b63bf49d21ba8af50c764510b0830fefcdc690e124ab35191505aa0bbd469065c920ea18ffc2263b8912fbd3b69f86f8398f4d209da51602c1f4df08bc34cc5650a6883aa75d9d4e7d77db904ee4315778681d3276b41fadbc53f07af1d6c1592342bf4783a5d2c60a4b747bbdb872484e4d4d4fb6c0bf8f9a484ad8eb2b26e37a0752ae8482d38255ecf990000349449efb28201cf0dd6c9e4e9bfe52270aebecfeabcf8f54adaf36bddad4dd7f3b7a09b78d856757eb22502faa9aae30edc97e331f2c6973d007fc463fe35c2de9369317072de74278a4972bd7695bf657f6ac0b9658d83a922574963390f383f5b64c9cf3689394ceb6727b16f1bbd9aecdd891540bce34dfe829670f3c43ce922bf1e731a30faacff1c159537b424ff8e3ea2d8c436393a0a383eb7639be241e1fb8e0800cc724abfce83f37296244a3460f0b69c5f7eafd33323f811a35f1062d4a8aa2d7a7d35766a55b5b344ffb81d6b46b4954a18b39b057c81c4be32d0c3bd0608688a9829b84538e40d18eccb2056fa71d0819fc4580340096f730d9570347cae07fd5588879aa2254f360d34c3adc2abd6d718c1c4c17d669dda69428a9c231e722ff094b233d877da02787e5d7f1ee1a68eddab4b72aeaabf337b99f0c158e8ce6178e8b3a8eb148dae0509b29564cdd643bd62e06f8e84c8fa9e8d05744c1fb66f249a68a4fa37b7ff9bf63a5f9ea8885009cee3b341926e4dc390b426232709a112f9cca591459959ecc6cdfc6570d7374581af99ae80dba357e068f5fd4f29cfc307e5463cc96b36a5cfe4e56f0acce651d5fa95ba5263b101dea0b256c907eaad2c75c5753cbf0014837c21f73c1e2388e5fe533a32bc56d66a03450f45121b4f31e0e27638869e96837c7c2d6aae94ed8802086dd3f7db68613515d7e79aa717122346e5067131cacef671c1bbfa0f94db1ae1bb48575506b49542aab804b2e6c8fc8a0ecd3b519e78cc53b43637ffe9c172b7617d6dde24f9860fe73c2d70776893c954c247009d8905dc83cb44a11b0cb6a45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
