<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cca778966d4a3c8de6e69973e145da7114e40d8ca6ce73c71fc40cd457e13b611d119e398a58c5be7b19a6e8ff8646845d626fdd39601376756558ba0ed0f858b4095594102a2f0b903fa6624d9517a5bd5a6b49e60368209d2d71ca8824f458c712aa5162e526ddfd80eadae2f0b93d8fe14f236bda666af8840c3bd4c1ba51edb2cab293091cfb42eebc9ae4a13c29bfc257d007affa32b59ecd23762dcebe2f6c8b6e22eba94c5071f13b97d3a38ac9984bdeb25896f92602262bf7a665634ed450e05404329fb3fb2200a63d09228e0796384145a06a13435eedb19e8d827b087c027ab284262380595e9b50e96cd41854bc7ab18543c829b6e6e94446d9bab0c28ce2d6a3ec8dd1267558e722d8a9e59472efcd7fa8bd6e58ae397ed2e12959bba7dfc36a0b99e4b7de1073ffa86a08ae365adc9070cab0a43818a3f5b32b8c46f36d09c2ee9e75576be5305f82b82ae2bd3c1c2fb2ee0f698bbb74274df0e73076306095555c72fa3e9f735dc74f70bfae0a869ed3dfe0963206ae3adb7242bea3b254674ca94dd957ea122d6a1654858243780da8cfd7d36771be4db1093b1bf07111ffb3c41614ac4cc81211b25042c11b5dc80f5a4621e4d987e8d969573c8feec4962e3c034f223b5525ed5c2b3465fb88f734a959730794364a7186e476ea176d69730327873ed93bce32bc043936b49852a8ac06726be8efa0ecec80b2a9b75670f144fe930081e0808e0e051cab071c44b1a2b9eb2455a296f94853357e0aeefef289b8094a8dceb76b3b99828c143b002ce365b673264b89266fe96e2ecead2932e6dd7b5e934c67834e030db302cf4d2087be264f7ac0bfe23b8a1031be0fe084d697585e75a8aaede68e255154dd4d172cb1c0407cdb7e2a0f6a6d032e03141744b3466843467a305a162e8cd35931b09bec4dfaa1a5d7f8efe291fbb47cb2444cb472af5cd22409452fd72d96b56392b0be4b0c8bfc4c8e946251de9bf56f17c4a066f98204de055ac1762a37d8f56879f9a69c95d714fc3bb8ce04ceb9c8d5090b25809f28c6ab7fcfb8ad6cffed6e11c4026cc2c2e24efb297f4978c9f072074a43fa9fc4a5e948df15b07faeeddb059cafbe31e1c09546d7f1b81cd7349ce4610813eb58b64bbb8c4d1751c3f82852298417dc537195f7c8f339cedd88057fef9d3ab22eb0cff95178711a308465942f75a319bbc5a4debdca28900f82dbe889e6ad1e3cabd6950f783937eeac98364d819c6ee07e85c5ad24f27956d0fd57ffa6cce638cce615b3a5b7d546c7dc632e0fe689cadf1f8c4f02b5553583289ad1ba54722e71ee31edc2a73de32fe1fc11092342387b70a4989d7ff9a17738d9b4a525619c7b7ce7ab976e02973d941e614fd04c32ffa32ecf50b736ce104b0508eb7daadc551ae022b1f3f4f9fbbb016bd370a2026f24b60ab465f5b3e53c01e38f58d7433dadce210027301edf378b99b4ca33fa0ca99f926b0f199633280a6ae9e89c2c829e35c0028996b978ec14131b32a2bfcc4a95b2596f12124b0d713703240ad3706340911287776bf5d47175f63e716481d17220681c16b1751c60566775723841ed638c470e8432d70784e006194d393dc87c43e96514f2b3d038e0993a7c6331a95d576e35a623fe908acdfdd26ba9861b6ff2cda5b64abc0d143ba44af256377bb8a91a741ff617537fa1aef24dd634101853e6f668a32cd39fb261857258546cacd8bc7493129266bc181de74b88493ee8dbdd86d8b29458d90308be8682d4ca79937d8793fa1dec54ad61e57ff5d8b5f087a35a2025c7d15155a2b3514cbf7526eae536179532b16f6b3ea6eaa41ce250d672f9a3ce004d01c956f8c1f6fd01659a2e157580c08f7eff915257de9e6dd0b7490a6a097bf32c9391709a83d71e36db42e46afc82fc7cca7320f5b4c81fd8dd48979671247e592e213bce37f0dc50a7591b76ca6eade5b6cb3b60cc8da9eae6b6ecf7bc00313508a0364b650112aa147dffceb21e7210b4599b8f31ce05ca00ef74f112b5f52f39a3d9662b4062017f0f0b3373437a7149d1fbfe9cce86ede1277fcc59617677981eb3f47066ef9b530387f54c31f10c6fdeed5893497b8a705f9894667e0dc5b209cd5d0c42f950402c1c91ad8b5b03eb4d03e6adf64ac61a17df18e5402421255d444ceca808ca577ee877cb7a67a52113e0fdd85f072da36cb2c52c0facadda3df570b71251c94a3530c6a02a38141064cad1a04336dd17c7408dcc2c899c311e5d424764d8c61f393efa582ac3b343178c3b2e5e2420e287ee33fe343d4e01a4c9ea967a97c4c3774a365ed6756e676b484276b7bfed1be52108342adfe77100029fd63b009f2a9c71e53b7443dede82d80f1c649213311e9bdd49ad4175a4a65e1027294063e6c59d1a1d17f5ab8e581ab3a032c6c23a60ab496c0d75565e29b5671137751be313315ff7b5bb7e44228f28d439e53f966b6e4d75feee328570f11ce580047af4966c2ebc5f2f1218523d4c2c6d2ab961feff5ee4600194fff43c7c2bb9f6776fd88198876abf2bf99b2065c7b5651d3eea92185e45524381c0a974b3deed6200bae50dc096cc3f0488233200bb4bbeb2735177814b187a5573ae6a978dc83809a742ebf96982354082b046660028f1aa34427918945b6e305c2847dffcbe27480e068202084834a8c1c3f82b2c508eea0f2e609bfeab92677da6ab699cf23d1fd9467804a129c45b94878b221ac06eed4a2f0c4c7eb4fbc96d38231589630f1791981b9594b9544e1b7740fab6194cc046476b63399b925910f9fc8256279d798bc8fb0454099b7065509847edb4db691b47c59803582fa048b0b1f8bba29eae76a931fe0f15c0451f55a8333ed2e4b872d49284ab550275c2ceb91b2127145914c048694cc55808c98fab0b808dc15992d258573913edc52c745bed1f130e1d39c2401a6da06ebe595c82b01e4ca181436846a484845565a97e7dd8ea3318163dc4ce876aeb4954968a9ed736b450462ef15b8f59ff8896cf7aee1e4ac467ffa4a089055fab1ad142bcbd204c055c734962004f0ea7c9ad948d09ba6d0cdfa8feee857209cc5184c7cdf6dea2bf257ada43999e7cf4859d9fb6acfd8dff558d95f57246f2045b14e7f2b3565504b42313de40e1503236ee0ad31fbeb1b8cbd7b3474ff5316711166557b4761a35e5636f74affe4f33b7ccdd3a35f9d38cdc1190668da9a0ffaf8883edd6a6b2b91a17279dbedb558537f3097b5cb234914934773d05b97b7a08cc7501a242e50bc1b2f97a4f586521db672d933894444a17350b50564860a863f2a50620cc57bbb3a4400dd2d630a95a74039b58a36d29a0d8ad8bcb57173059df8b8a181d98111fd1d09681351dd8b3f5484f50a8c4194c510b7f68ccf4930aa7077bbb9afd6a5212b1c99dd80fb823bd40c2c4455363721a0ed9372b33da85d05e96d8fa152dfaf04b8d3cfe23cb5cea2312363d14f96a7cf8b80d1a0a3f15423aa26e493f16d5da5c5b752dda28ef791ac97777e8a8cbc9fff0ad431d851d3fbfe44419e1920abb7825a6be83eaf098ecf40930ce022cb4f7eae05eddf2fc433b416fede4ea78803a4b09e1e5004e569460339f5e3de67435d80885ceb7f1f1405b42860e30a4c38bc8089c181441ba82920bb561b6c5bfbf471c76aa143cd7625320b2bff7cb7df4e41daafc33895aad9336dfe23898888ee49eeff8012e3899c11a1475043cfbcdf9a6b1f38fb0e15d00e842b5d2a67c6081960f9074496f6d7b51798aeced39ca7fabdcacb2d78968c93808127f1cc00b78d5079ae53beeffd9682d3fa256ae01247d274b8fd745f6114a5800010b488a45a0212bc4b89d87ed86ebe1948f9c96ad6462d0ec51ba6c7ee3b4e70f506496c5d1dcdbc618353d5d9a335ca3eee79e89772ecb5e631cdc900490a871008ddb8b01026a0a25f329cf013c0673d2cfdf750e5e752ada17a78c78c946a520eb568d1e7fa9840de5f7c6963e66e7d754c4dda469d9f8a5622695fa50882dc0c69f19440b419c04ff8f0c86c20486b824afd565f2a9abf8956f96fea11e0f9f46ed9955d6c6335c309f544539a4a2fb754159ffba5098fe9a0576725483a881e2820c8504e1264f9c40dc51e192ccb2ec1e4c1fdcfe51c7f0167ffebd31a60a4ac790665b9e2fe300512b082637efbae3ce0242b975b85223cf4802e10a86142ed99aaf1095acd16eb7b430b6bed65df0d815dd3ed2987118d2090799b0ab114b4f1d3b0e6b9a088caf3b4f6722e902dacc5cc6d669ffaebbd05d13956eb514320a799beac094ff023c35e734572d7bcb8563b42c865e57832d57a979feab3e60b6ef2b798e4c9bc961952e70fa3b90b8b021fb6a371fe73af4293a42068abce67d8fd11c7017d0eeee4b33af04eb98291c7be0614e0bcfb6c3048d33c1199f063ac4bfb9b378b56926bce2780e6cd7690e7d44f438b5fefa87e04612098a74f6a70020f8db01b952f91c4e7fc670168df293858c767a090401c4893406eb7810b519a7a5b579316636da1bd20cce69a0fb1d4fe2b6cca523b174a2c1c9ff8d69d2f6e3e98da1ef16608c45d379a0eeb9c68fed6b691cfa229ed8b3e9883d12879c0c030ab3ce8ae44eb6e420629cdf9e90ebdb16034c4590206592516b7b7d580fec57129798b3fecb5dfadc680fafab97750dfb92b93a7d20c377498cb803f373e356055552a277c6fc7912176ff0acde73336bcacec11803041b4ef3f0382e10caeb6334f155c532cd4bd1060507f9c5c64f298229de885db4c8597f8aeb82b22458081eb327faa791b4bf7290fee083eb07830d5039c4047b4954c4031bdaa3f2975822b02226cd2ba66402c12e0fbb0fb00fa6222858a2df1edb24558418780a984913953ab6e7dae32688b84dacb0b27f49c1dd8df154356f94939a969eec43e1521e2a4b10eb9b0030896c0651e83b3e0b2f6ad292c4bf4b42eb61c2c18f658cb1ae3b46782f1a2566aea05ff7d37ea4396e088ee0c17a1f57ab84b398a134fc48dd1b4c6e0a5fcdfcc6fddc56b0bb946635342f7c678eb8a60406cb77f8b44c5c03a82d53e9802c9ce9b0197c61978957b40d878ea630dd8cd4dcfbc00b83f27494b4185a903e0814a7f7b318f39c924eaac3cd9c4e599843f93c80f0560d43b8ccb2573590cc7584d32555dd9196da258ecad0c7846fefc5f8b80ef48b0cfa8fe64362239fddc7b355f5e10e213305f65ca8c1863ce911eb0fb07063e93646eb4419e34a3e38d8884256574edd945176ce41d2129db81b23fe57f52c9105d9c4f539fc139ba02e8f9c6ae8988a4ed7543c604744a8603afa9d3afc0d5495245322e036dfe8796ae835a045693b5c9662a8dfb01f730c892c84985522863d61265d0b88aced7383896798207f9e71f10f5f430a262dbf229dfd761cff768f53f7cab6468181d01a15669d92f4ee2019e2c23490313377bcaf07bc3d9116ad53c723a168eb734163c84cffe35f0db0cc726f94d8c9c920845b829be926004ebfb08cd709c7544e044851eddf5e90c4c4254b023f3256ba0e3e1a52a93f09fc76e50785abbac144f0b049b309f8069bdf4017604a7f4bdb2df9b915bf456234195166c60d36874cf9034e03a42aebd90f13321e7fc6f429f9a942acc121369a002bde790ef138ff01c69dc7853f18abbfb056cb6c4fa38448b5a5179ad3522e1312b27558619e63571ad70f91f56d189bf568caf330a38e040b7f0f88d357cee2c5dcc007894ebf2c7e470bcfdb73ca1ec1af40eebfb4cfa8bfea8e9803b5f07bd7445922be03621713f47a0ef5bbe02b3b221758f4b92318f96ebe5248e63463c143c878c52e2ba1b3b079847f3f21b67f1658adbd366319ea4df45e780d3e93a46cf808ffdfab5098c8fa9182e5662e00459ed3220b0a9986620295599d5232491f520befeb52bb108748cdafbcee49165cc0acd0a31800a240fc2f4ebe221544abaaeed8c2a7f7b3de037c2012a0c60a77b75cee5bd4b50dd596ea0fee8f6aa3651b36ff8cd8bb2a75d66711cbcb36bfe9efedd9ae75ae29306d104654fc33e9f2d7b8fc029a75854705a0e380738bce64e95bc7d9511864740dd28e0df93edecf1fbabcc1ae9d45055d8ada90f27ec1504c4cacbd17b28e024511df165c8a6e66f29bf502864306a3633054510522bf20510f35e52c5d59676710f3983d7e9289a633822137deb02731bb7d6e78cd04d8a1c16fc8a010a7ff0201c9f03e54a7c238992ee2bb5f7b4166fb5c347a2cbb4418a8705b8dd50fc0c6124c461ec7d349493a7c9997106cb2da464d3ef3f94d1bd9912e9e83b4a559669293716c6f4b72780cfb63c927097ce1517b0d5c53b1a0bcd5a4037ebac33eef6a4f15e150062ef1260011fd21c74e5323fc094643548219e05baf5a0d204e477ec686a53c5eee7f60e0e8ec5b214ca550ae32be41cbf9b5585c91b5eafdb1aafc6432cc162b3862cc5b060b26e13a6c3e86983c29ec47c7513d76db029dc87e765d912107e86b59258ee3b6f3e8d165849e9567a11402ac2c5b5975e3fd246214f0c66aa444d64540cd589d9bcbf1c7dd3e31147b1b202fc87e34618cd77b28951f8b1eb22a249825746208cb41d58f4c84a814fc9b9ce283ca3da88e5e67ac26d8fc120037ba8d449ee7ac8811efb8168012d937899c3d42fec0ebc2e09fa9fc0581b47069af0c53e78be146fe2ac8032be6ec5a0e1d911fc45427e46ac8a4939db5eeb52b2bd4ac650ef09c2849caecd8022a709e66b44b979ac2d8de26e4bfd79012f3da3761fe260f7271dc98d979b4cdd464e6d0749cb4a71aaea8f75414f8f89a812014d1d6b30fe8c613241db4a572c67794a9b2de5c18f6923e78f53d570688e9a75468c2d6eda66a656e22258bc1396d3b1dbecb7f50c5b0fa67562a5863a1a04c0fd8986330bf8c84f201e09eee30d2ad9a89e853bd11931ae0e49a51add1a5ba5930487ca7126eb454d75aa54ebb2f2c95408efce5afb23d863c512c9c944e5b01b9d23c50eb2bbaaee8746cce9576474be923d1d5a57cba432c455e4a5e89bb0325f0d69f816aaef98921dc585a764f8806e1108c2c7690cc646762ac91722d603c1e19f967941f255407d8857280a4556b1a1bd3e3a72068e6dc806d559bad9f77b7d92b61aa020d0d1fde5aac86e86158d6b51068acdb33552d500051f29488c6d5893d74c55df34f2678ecdcef2b7f474353afb807c3fc39c68e0b650fa61e39e843de8cff7aa58078845f719dca08238b996c93318d9f6e9c9a5d4238ce9fa70b4c122cdf77503270336c0a6305eb33e1242661b87a6d9f8e6bddbf25e9aac3562d7739f6db7fdaa8c12ccb83635a88f989ec0d27e353c3aab6922d81a13d3f5563e8287f0b2b7de8fa55988a12f2abc8b749079510440390d9a440bce4c806f676de7c357199b74a7434fa7868c54e7524f596c0d6d18f2ee23d01ab197fd0ff257435e84565bab64824c83d84e776ac276245ee85d1dea06efd4a73083860a88f5e84f333266cbf67dd27eba774d87fe18795f686b52e736f44165d89684866bd2c22250ee17f243927a1fde032f391e0a649c6420baa8138b56fae5fa395c4eec9e16d0b81a88b74236758b97be7fc4ae76ad0a9c5af5ec0f0e1d24d1329e77ed86069d5c65e0e2e22cbf89be8b77c7ed0382e7ea742e647d84e2d24cfca7e7cd60719adc171cac5a9581c2f7413b4b5ce09c14adff1d8d999f8426c86da8f7ed0d4450f3776306f5d365a29f3bcc0dbb9eee073f41ff7d7e5c5cf537b654a49946a1b8c0fe1e6f35545a9d31e97b20c782a983436096806574f8f66856d364bae49bc0c2198529f1d333c1c73648d49bbcd01e1c70f1d8f28379ededfac59bdc8ec52d51d739675eb60ef1c4afd75b390cca2ffd7a6431639d7617bfe91b0cdab5783ad0d5caed6e1fa4c79596ec94773fd4a6b6b7b669e62969f6f629bd15a21b23a3d57aceb8a5a2c0e9c74cc1be2c1a8ba4bb6ec57b0c3db45aebf6e577093c0c4741a85b9193006f827b47225e42d979cc7e0aa983221c2287b32e23181cb3925d3e39d3b83017ed045eeae05946114d9df06a122ccc0d0c26d11e763ccf8474656a362d4a7a179e33d37b4e3e590d43d5d8862de5344420c5637d8c1491ca7967aa580f9faeb33ccc4d657e4502bfc93d453b3703ac2bad0695ae6a213a078f9d538bcc4cc32f64528176a651670a256a8d0ec31512246d6c818311cee157695ef94da98df7f324354d24c1d1591f317265be9b7bdcc79e6430c5286a800fa7e902f69a5ceb19e0cd394f6c91b631d68596160bdf6ebee74fe655d1732950860829a14a858b3fcbe9c4bb302f2565b0a9fc9fda73363832969043be490e449eea315e5c49606a50d417e1287cc22aa99d5b0c5953381c55769cc6c2722bb5b497479937ebec15e34218fe323b72140a32ff97216efd22dcc5a6b2908b026cc7547b3bd37d798d8368c4729cc44adb3834d74a9af714566020dff1daf71a4054ed5fa67f5585288f5084ab5b3796548c5806f395a3c6fbbdf9b823392318059a688b0191dbf52aedf0b2542d27b026d391461e3fce0653699b21d6b192baa72a59d3e30bc8303b7d22806d75701c948d09aef30d0b24538742d573d15197d20f0d99836a2288b10872204c719e7ed6e2146875d32eceb49ea72c6634127db0bd91f06e36673ee1b7040e95afed287501e2616cb566244c320ff2d76b97f339b0c6f12fd8199b0b316e2382078a5a7d04c820e314734abea4783865d900ec67da9c5f311e84ae419dbb0878f3e7377cc1442d659cf8d2846089897d8e17de37cbd391df9c861aae6167695b7ecaf853a41940262a2fa4ee3b460491d8afc07a18070401ff98b7b7a8f65452a66cf80439f99f43d45851a94e195c6dbdaca29a8dd70453d171b8c5800281806bfae0abd78ca8b2995d1160aac9a89281c07241007cd4d21846ffc9930fd5dba0ee5cb92f84002bc8796931fb15821b949cc122860cac9eff7494dc504265786f231784e3f5089bf71b7e67b86781e96e99dd03181c17f3b5f2f4f2d468488e53e7208bc2bf32d77dff343b3a4a453b559997ef52f6e95ca79515f42b8b75cc8d04a0ce856787bbc48fcbc38060083801444b7e714a9a3552f10c4fbc7c6e036e21e181a76c35a374dbec22904ea95181626867cda5a9928ab89e3022f3a275ee6069f78edd1accce2f084d3215910ba57d889d2526cc5f41cda6bba20dd197887f2453fb217c7d054aa48804a3b07018c37c881938b478f86589d7e9072ae7df9983762f1ebabd499323377f048f6a00ab9aa1d2c6cdab9b7fc11c2fd72d5fab22c931bf24a7657","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
