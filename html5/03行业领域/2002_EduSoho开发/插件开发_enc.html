<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66c315f99575d5f900482f3014e306e4d5369b76fda5154a9ca9c03ccc12622fbf2b1261e68aa20ae1c40f23e3815c472cf950f30c18971d5f85ed2dc412fbd18945d8c21547f57bb212eaaeab4983bc6b4fc40cd537417f7e3e73316340a265cf6244d078610764b28725d4c0747939232a9eefa4ac486d0a111e4751721fa56b2e9ba02941ae242d10c417e7e79afc0a4a21cf7d28f379ad9858b100716e1e4c32fea06bfccae0e308807a653e6f6532bb221a610a3bf5c1dcb0a1d63f8c38d7d5ba4a9f48dabfa14ba89b3ac23cd384dcdf0d720eb927f9c589ad5aedf5c3ab0be53f813e27584b9e1b79099bebdbc550ef4d1d5d6bf9a0f8282d71acb3c6a40edba4a701783fe1d381f582837d3eb890bb06fc0f534ff36d1780802a52b18e0894d0c31b856f5e2b50a1379fa0c95ff7a448c3f1bee444a8ce235e76b33ed35e70753117f706eceeb28fcf086ee438838e8a8dc5bf7a3cd4b6612e183e34d9be5497ef2e44d9aa5fdcff874aee5697b41c62b75c695d942f223a9541b925153d3bd2fd72169f30f2262f32ba389c23ec3bfeafdb8718adcfddd15013a69eb9fa437cc4e979453d63408d6cff1e069bd1265bab0cc799073a078af2430f361b7145d9c726fe945d1dc7b97594204092ffc53645e49e699d3957ac5b0c5760e33d2234ad2ded1515dc785b56679e5a0bd5d0a9f85588b052f6dd465da3dd8075338da8d0b794865bed9af66c6bcf66730f5797a73a54b8d09ea7da3b3daf13689f667070bf07fd4e01f88f6d9edeeb247b44c479e403357bb0b94d6798e22c70dfa47513bddaebff1f319eb0c1904ca481248c9241ae4048dcc763096c33b9846213fade4492dd7db0485f28e1f225e88a428a439c32a86cff76362fcc075d01c5b297343bb444d6ec25c95ad64defca62dad46ebb55a93fe5a77101cf8c44571118532832936bc1ef9141bd1f7f8727f6a252a588e6481224ea1ac3c083b63a6a82c06a6aa35ebf46287762925d066503d0a87ca34d20e071445f5ee8d78eacfcf96423ccd783d805e7041938580e802dc43d1e63e08da5c20033aad978b961bf5a48eceb406aeebdcafca723db864d859c62278e2677268fdfd2dd784d92269063648c3e9e64659e479190d66e7c481c2a052700c96a9b0cced96204cfa8e8dbf51379c00d3bd0f678b5ca6a1ea1de9eb2112c11c6ddfce0903d2d9f8de94425b62492ffdacec5553b2734f7ecf6e5e4e5693596a8b0f281e61b242d9d6a069526c6c4e9e16f9f875f6a53dc79500af2d21addc8ddba40477622af87cd2990b2ff5c47adbc707105a3a573e54cefdb9419200a72356c4bf0ab5fee70b19dbf8d655010a04ab126228165ad60f2da5cd4c2da30ae736936d93d597f71f8c501f856f1d035c3d6d339fefef165b2dafaecd6a1f935859d58e3522bafa00892bd49452b961435ccf72c3996015baf712e76445d4c9d0c7a352f0876e8c7432899d817a2a2deb178a8a6c32dbc06c7d2ab040f2e4657c88d4979024433b62160d0671b114d5ed0cffad6cc37270c8ba6201701fdfbcae2878bdc18017e3960ae710ae6c1583a52d21ec33c44706189c5cd05b6af7f6ce95a52e797cf6cc385fa36c3bb659e730fc553f2d86eebaa0993ee7c975a115de578c328db4dd3623445ce34c0d4594e341150b1c8a5a9797abd36ef48219d6ac75190163522a149614d2d09a9a5ff8fc7ca3e49b9f8d7f01b84c727eb4ab2634f9064171d62bb5e7385f2a92e96a216d5e81194387fc5111e4ed6e179ee4a25442d24fe3ab4837581b37a7bb3b3424483d0de8f1a236cfd881a26c211a0da9ddd57dc9df297dfb741d2763ff83b1c6c3639a6aa9908da8411a83578c879888236eefe181864b0a73674758f7586446dd004425193d9f451197c6eb47073d9224f3b6f030affc445a2243dd0167fb88fb7428e9d70984aa7d62fb3fa85590be82f2a3a6a0301232852d6e83bffefccd328cbff20949ed78f8a38ce63ab6161ee0c070a3df8e74bdde58e4afb4909b1c9dc60aa7f70f6f6f2862ced1ae765ab94b120ee4bfa4cb2fa716942b3c5be83d6b60150c323b18a384f995a4704ba556893f685f1f63d4306e7237edeebf428c25017fd38c2844f78ac4039765dedf6b0de8a4e4b21afa13955be3aa298898e583ee755e102160ed08b904c0c106fef3fe90b71a7cedcabd0851633afe06eedb3893f54e3372759717917e8e7f365f6e0eab306dda02c1281f246387070ebb6d333fb5cddb5b8e789766622bb321821d5d7be82b037b90ff73b2c62cb1b8bc4e4f5b8d6d7a5f4b5d3dbf8ee33eb12512f1d43b0958f19fe6dd55c5a06f23a4ef1e53ad0667abff7d5b6eec214941ac31a8b6c7dfce204b59f0c5651bd08eb7e284ecdbd6df5e51d02b03a3fa6114e2d19dbabfb8e142d1663ca987a195a41f5ea6a6497182082a7a06ce72526e6ccae2a4c51b0c4fd824e8f9c700173c8c480e227ca4d8942d76358d7fa94a68551f5429db2f9a22704c21b591dd4636f1144f7f8a03b2531c4cdf785a8d68d4257bc17271323b92482ec83529c5b1f4c6c03143e5ff05174c59a8cf697d12ed6cc8f52d6158e999781a0b25bf6044072ab92349a76e2352c120917bc822fdf47792df6b48501b99d3f70c9d7ef1f7046c6d32191722dc862e57f0672dc18b33eff1d7db16dfd242176c8429e25edf319d14b0311cee8830a9a93efb32a209f961975f326f56eea6ce73abc8c4634306dcd8c2012928efadcab92afd5d43ba6c739f429abad3243d11189295023303af3510015558b75ef9ab30d120ff6bbc9fdfdb7b6d55aef561eeeca2297f9f3f56999c7cc8c56fd762304f07dc4b25a1e62e572e599f5dd553bbc52a4d86b9101c23ae6323312af9c050c221271ebcbbf633c59a94c00d7eb6d23bb68123c6c10054cee72e5177513678e8cd9b47bd814dfa61fa14e400762328dcfdc9db1236181518e1668fa0e1666bc3a4a36c89ea8678ef92bf9d5e902a67cf8d53c15e5f2a1ed3af5f473e5ac3ebd320a0208064734ecd2a800f9642deb469fa4390f0cf522110a3e54ef700df3e97e2370c78cdfbdbe0f32dad0781279abd2c4bde934e87f271977eca4abc5f72a7332ee75dce9f4f15ff81048325f00755a031935ef48f9e615cd1044ea04688cc4c8e46fe3287f1b53de805f3a4b2840bcb11e8a7c80a195f4280c4c4463c7f5db64a1be074344ab6b03dca90f62a992791da36e5d19add1b14d6b814f977a5c90a279e555dccc7f4d052cd3600ba585b33ec3e1b2d02ecd90c5226d3b8b629051e91bc346792a66d3f04978d2df394c1717b1491000cecfb1edcaa54c359206f8d41361038dc1c9f7a8e5df9da443e87fa93a5f0c13b060f26b581823e321ddbde4650cc61cd1524633c47660350859ec4a2510739113ec66760a098804a8b6310cf0f6202cc0f046e6669cc7c90a1501e15bf9d2b1103e9cd4c9e14a155a82fbc4da2dfd046f9f5c39b0eecbfcc6b192876e290ac320540b207c4eb672d7ebcae293aa9a4a37f7f75c3154cfe7eb025c0292d5b083a0b0f01dd1ed9e0f7766b279ed2b006ad0860120a0e9c75361ee7fc0b1b0b780cad41050c7f407374a1219102b1e7b2802ee68df601cc8cdcbc2c3761aff9c33d3c390f9be3b57c2e0c564a06ada17fa381ac2186479555327247a6a8355061c324db65af91497f4593f2e1d80df6639362d36b76c807dd1cca2b987c14be52601c773612f671d8ed0a112efd4fb58d38068d99e731e343c4fb230b78a43ec3766729c58e00ac90b65ec2237326567edfe8432956142b55b407902c052b0ff72a1f2fb49be792dda65d8748d99c63ff8e24401196efe7383730d595efb97c4cb7f5fe6c07da0ca17406fb7b4ea04b3bdfe841d9c865d49419e488b0c4564aa021833b82b03a6c6e8cbf7e52008f3e662a3112afdd81b08a3b79a3703c91b3b20739de8381cfe7fc668176c1653b79f4285f255c212d576504cf998b41d707e8543c40ca5ad2760e94a222c71f90a5044c7904e5ea36edaeed92702b7e385e755212a960e45113da4742ae00367c64d4e86978ed8d67ecbfb389c76c7be1233a113d88c694929f2e84baea4bcbd757ab63893bc4e1bfaf30199f44ef6a6c6e1d5ed58092d32efa67a6dc354cde012640320a6badb2cccf25c52b7e9b0fd87aca0617974a0f57d4baf63d8b1cca07e3c8d27f3a2ce4b0e88e886335eea0e9fedd0062585915d6c1881574545357e8dfa63bf49531c18932faac3c7565cabae5d558c6b4a3fb826f62ccd453b6372cb417cb704736dda595948ea06cc2e8b861859ed498f667660565ab9ee7d6144dc88871546f33fc52ee550a4b52b8a19226c320e4fe4233102cb788c5b9bbcf21565e07d0b44bb755feeb556747d6595236bfd8a8e580cb7d26a61b05ba60136e8913d8fcdf0ae839694af58f607e654162ecb28ac18f718189d281abbf33bd611055167d790551ae7b58b82fef566278b91189d297b56ad062996270d5aeab049b12295b1f686ac98331477857887b4d3aa5ccbd1fe6b0401df0da547e43520d9232f017c983234e376ca7bf891ecc5d1fdfc70c2fb534486f6314b1b924146d3a189bb4ee3f0b04c3294cb1292ac06f8a5418092a2c11bfc202750768740ec4edf1599106a681026385b776a976005ac896d17f86b270becc0c4024c87bbf3e4d6acf01b6104ff95e5559d66b40ae22af25275e5951b4855f71ae11bb649ffc768de50687cbc6c388e3b9953cec5a8c71a9968e0ffe5196af0d44a934326f497d680bd11f5a5265bf5c7a22fbce2f162ef74e2bd3227d5724f95c2db727bab3dcda3f43169ea78050e7c48b2caba32e5316b33d75b15b6b4e43c4d276ced882bde3648e74a31560639727f11915486818e70ce2868fa7f9f2bdaa0124184ef1f95c4ceb2405790db396060b2915b84876512024f1b0f97c594f25a43cda66368cc44b8c6ee033ca30acb0774b4101e0bfd3349c48d32384b06226e1f2d4e72b635d3872317c7ef110ce4b9f0937f51774ff76bd5cc2bd41bc1ea14654c43b0c932afc0adbd05b12143e17f9e96c6b867756d4d9aef94cc63935aa37fb153f72bec00bb40920299cb793482493c25c5677821a43bb9878e55fa79307c916879841662dad84006c996bfa0b700e4ddc6cc14bd6e7fc1c5a04d25c48e711cc409b30b73f74b9e369535ce36472a2f0bcd0e1af62d1637a4406014a567eafcb3e7dabca68ded99a6dce5098ca5e357819eed3992735fb08dca984ec08e51a1c79923f98bdeee6827fc2fa77e9b6d2c8cfc7639aa3ca78a2e4428dbdc6b88e0b2a4cb8af8652b2244b50db57d5c3fbd6b4837606860abd67d2c087efb4a4aece66a50f2b0bb57f93d93fbd9bef3b19acf44d7447ff7eccdfae45a4cde9548b115c2feb2242fa4e01697edcf59debec6d53b96cf61ce2198467026b505d047bb28a3451cd136c0279dec5101ec7319316f590172da8c777f0e606bc018bb6794a137659954a38beef99f7c8f3043050d4680262d6403e8454fb31a33dceca90dce6f9fab61798c1732a51523392534b886df84336c09b015bfe34e04168810ed47fa3ad3de1f55695f64aaf8f1bda0a9f06e5cc4cb35fd5880ab510add9be3d8e841876e37b503bf66fdf3ee81ead4b6c5ea06d1b16c047a2b946441fba6a04da5262fc47f1292b3849be2e19f864026761d525a1a86331d22643081cb278957b2c8b411fbc0c6525d52bcfbff8ef316e7e986dad9e71b87ef58be4dbc79456d2a5ede043e96e12516a05acd3deb48084a9a65b64f61dfa1d9bbd208598d6b0e7fb7f79607b58101feb1267b2a2eb37601d414220b69301b535f34d2e11907889ce52a20768787a5117444bac0329a5c7793475ed5f14edc88b983fe07d7067a19d003217299badc08bf63a86541e1f66482e063e1ebb44013d2d81830f45cbb81664177539992155df35e91e2cf176333a6e650952686c4489363161e1e926205e26523f2dcfaace296570b6edc9292c6bdf2ef22d1638501af784ff6f28292ceb883aa6877c54a7bdb70c763384a56bbeea90f6f43af33012d5e86ab5f64b64563e36ef74c7d85a0028f0ad7529067f56f7ccf6425751b30c4a5afd23196df44aa23445d6b0384f26491306a02cfc39c69e836bb6c90a5d4438d9ab11a00f69765f283986771ba0b81378e2c3ff263a091b4c3e20c6ab4526a8f4501ddba91bde8aec61acd4e0e7b20cf7717c8b3389586a8656bc9e0de393355cfeb20f9f15fd2b87278ea13ca6d86d6de55376caf4fc193fa6da61d0af21b3e9f3d48b090aa7969a0c73571fe5f3bb47f2fc4024b29e167fcbdbe57db3c5f6bfeb8061a2d0b8e2374319eff5db96a5038d309b7796b088d6910e1ee7d857cd18ea24557618945d8dfbd2faa0f018b4d22a9057c9d56d22fe10f70b802893edd2abbfdaeca4c1fff6db552415d83bbf2f1818d6a07354e9574d7beb46749726ada08433fa4cc3136d7f8b32f52af362c9d969d46fea79794affa1fd9ce75d2ab7d959292c0efcb352259f4f4d4a234f0598b03281bd302433d5240dc84b20b73807103adb06d577a7507d65a226c033516a8bb7475e4394f54afd88f3ec0217c81d1055fb636cf0a0aca8fc087b9c71e7cf07983f6dd9d38a3831e280b85ec98e581679e9d55810f57b2e7e4d0fa6ee14cdb1137f905585b9471ea30c8218093e1326d6a6bf79702689be4e231ae9f75aa5a987126307191eeebfaf8caad52960ec2bd86e90c17fe25656cd7782b25597eb1a75e55531ae37370859301d5282483af76abb546e6dd743f9970d697225951eabd323d9c881664230965985e82179186fe54b8718220e08661a2b2aa5e58ce2e6cce569197724de2669e67ee7257d7223cce05ac8938adbe2aea080bd79fc8a66f28376701e2eb2faebd4a47208730ce00a612df5733e3c37ef1b39a1d2bfe4d8399091bc9c6fa66545d210dbc97d4a9f294ecdd11ac1f032ae19e4a394a2704657cac3d4f12207815b861d480f0bfbec0cb61a633bdcd6834febd1b25827ca089224285b302ac69ec2122e1675c9ffea337a30e9b26fbf4d9df3ba785fb2bef2c494d3af5076dc16357ffbaa0eeb2e8376792dc8efb0a95c46f8d2100dff3257225c8ddc59270a31352c8070a45ab199e480054a843d1fcd592a25f194afbef148b9b704da1ce114215b44d632b68f4a38f3752b90101600ba6cfee8d632434273628450cb21f1c4407362179a7f58e61a8954ba408e952812daf5693e05c28141776dfc399529e0074f90e2b72e5399ecd2947337b9636b4f102f00bd1f947fc41cfa5d01ad2b754af1966383d315a149d51a8f152259f00961197ab087a49cb223bddb1649bbaccce7dfc5799f325183d5c0e31e72339488a0ae9d2c653b6348e60565e7d1e495d0243e8e2f8d39598fe4c1cd5965e40dddacc1e9b4073fbd7ed1c8c54a070a7d80055c017f3b6c9faf200180af76f495dc6c736330930fe74e73814dd1a23d4e80cb5856e9e0e52a505f9486c1a8b8814dbe04322c0a66b310370a4dbe294c3fd672ee840ec6a2ac400460bc3ca43651211145f55fee9e08bf6554b2e2b17cf5f92eafc4372aebc3bf52bf63fb0b3dd9325cdb193f59feaf79602a8ced25918fdbbfb2e8b88eb9f2bea8cf5950c459eefd0ffbde983b711a7c85dd589a27d9ab7acff3fb0fa160436941d54c19037147af1b5b749ea1b2d07545e87db1a9b8566f5f5a2b57948102bd11e07c0b15e760101b39e297c3595b3d0ea4c840e2defdce391f08ae2ff31705a961726ea946608182199c5d48e43f922539c60aa619ad60f11f461f1350c6024e18d00f781b9b0f355733927086c91ec864f7501a10bb20087da6ae7910bd9245e4f78e349ddcac5e59c3ed857af3f819453f36bb8bf15f2ec796f1c5476dfb8514f7075d1a40b28004342b521fba062eb2e855043403f1655ecf665280442bdbffb76c7c8b5805a310a1beacb3d0506c7fb2e893a3efbfbb2a8bcf0406b5a3c8db83454e5d3d4ea3de73db1da073e2699f3081cc5ffb4ff02bd451a1bbf1d19e0be1ca95728ce138653e798f4bbc1e98cb07d09356912db07632d7aa558429fbfd7162ae9af24c1d7ff19c21900f790cbf35486ff0480d71f4672774f646ceabe57aa1ff7e619b0e93dd48b2babf995d2117db5027f4cca67f58b8c01ae72b187c87f2918b74690895e54304e02d326c1d494edf8730ff3158e87c90aab43803af30d501275ba26461f93754d72b7ad754d9f69fb1ca473e66154ee41258b83c7d468d8ddc70fb8f6d4d33c7aa6fafcf06af6b3d2832025c5c966a3c301f6bb11be87f0b5fdf0581e8756f64173e9fc9f8ec46342563764c5d35faa5fde1ff47c1d7ac73c184c9fb433d601e584e00095a8ddfeaa420526145476b12bf61eae09f1304a9ecd263e0efa5e020e631494e73275055b41066cc4699706e17421912f947209576dfa8411be7be4925e8d26440e2b76c435f6dc885c5813a1920500c50988334ef32ef9c007cee6950c639b0523445f26959b3c5068f44daab637f75bb705609fd86b30bbcfa0447a6816b978bd4ceb65f9472928e1a5d9f66858382be7268a1ec5a20df74a1f4eb7c5885b245165d2e537e31f0031c4be0e3bb5ac7bb858a1bf57ce92d090cbff4c047d25876633ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
