<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a92249e209340c89331d54e5d5bd7132a6b5248782a5581babef6bee241026bf02ddef2e1a1be7d3f6a5aeb15bf8ca53740d056dd1a48a5d51f1d21fe74b1038d02b23ce708e5d7841298e26f85190ee6e5fd02d912ce7f9a28555f71178c51e3cd386748fffc1dded865524f54a8511459da5214ecd6a3383f154dfadd219b228daf628eaa7bb066156fc8b9f4dc5c01033b3949992a281d2ff71c3e084017b5e430c78dfe71c944efcf66e11514946bbbd09600d3d2bdfc08fccd94110175bf7d23a0934382eaecaec19653a9140538f6749f6d8b9dd6d304f9b49ad2e2cad6ec5e0950f2057e3f47babf00b15f6a20bf7b4dbb328e5362a03fbdd46cf138be083ac438e24484d668779ebe2538d2454352a46b6a69780899f7bc43becdfd9dd4bdc6c0f0d5e069a25ee86f25421fb60540921fb49a534790a2c887ea9667438857f757b3f4e9fade7eeb6f7f67ce7d52b4b83342bdf2ffc2c2638e54660ea65adc1909aaeeff4d9926b9b250ef1aa5f8c272caecc6eb63f43c3bc47207edbeacac3ed58eb3f70a755c9b8d75546fd7b422c6b820bc63ca62714b166e54d14c290a34ccc5bb97c1c9b227383f38910919cd3e0532ffc79e449470049f859764157fc1759a86708dba2d01eb5706ece9a5ea192355a8e030b0bfe5239d96152057ab391bcd8772acf1c63ccca9fa45818d4ef3dfd686d4c56b2f776e40d2ccf01a233e3b39df25a99ce8568c34546fb204fd9f3f4bd4b26e7363e55e856bad4a6dab14093bf514f8602c8a9ca57b823bdf9902aaf24c8e4ae5ad87e0ef57df98caf16f061f440105922b1e45122e0aee823a9d94fbe2d95b33be38ef3fc557fc67ea0cb2bf22ce5e22663d89c22c216aac04e1a0f18b6d4f8026170ad446370a19cf8d7574b0bc81ac773ac138e91ca37abbaad18308c6d1f721cab54ab263f5c271481f64081b092eb621171720a8e6c837a8aacac6a39f8f8cb7bcbdc29f0493e9e1ee3c850f98dfb4cabd3ad6bdfd069350c63c1804ea572a6a3fbb2b11696ece3690c6e9ac2b24f86cd70457f6ff9f66c9a9974d498385eb6dd9407410e2ea1735ae348f1d83937d0a317f93395add69d9ce5fb73a106dcfd66b9dfb3b76a17b3fa61cfb79e194b3b9818605afbd4f044e63eee4364c47ff0f8ae2a12443b386479b011e3f543cb401aecfe586b7a8fb28fea8d8091a808bc48391c0b3fdd52ae414b01ee63c6efa5fea48ab4824be6d92dc186935533134b1d53675f1edadd55aa26d3539703e6d634ef100c0dc8218d4e04cbbf6886086b4a7393fdef29f655e95b2cd6da8c5117a3e15447be6873ebf035381dba713e05d1026a8f56554d8ac193ce41e7e17d1ef2d607a982915f2c179759816d10ee11eae07674cc1d4e936029ecffbdb0bb4aeca86d3507377cfda4a4cb3c6c8a9234cfd7cd003bb21afcede69067c691f05a8689e41f3ee9665d4f2925e133e862414769f6b2d1eb40af790d265f67b318227ab1c3a41fb4b1ddf549768e25518ae63c5508fad9eef7c88d82b76009b4ebb723e6014e94073642785780d214503e4aea44a18c81fe26ed1f6b3a45f42120034fab58caa8b100a61a6fcbeb590d2a0d5737e9f22ac235066ced998e66a822ec7540ceb8a5f33b338f45d8a0239a88493a2dfc3663f42388aa1b423f5d3f67be391f658ea1fa7ebf6e9efea1dcb659312aa31145215202fb10ad4b53076af4186e36a4d74e3f95e97876f231d8ff6debed7bc66d65dad4b16714cc23df46491a8c679f789e34edb3c56cdaaf45a7950723d351f1fe446e47e6810339e7285dda68bdb57a18f8c1f310350ab31341de2eac5393545206b73df35842babad610ab2a70c6afbe03241333c00af26862697fba5f8284f7dfaa836988178225b9b0413dee02d035008427b2bf7dba985fdd99bd842a2c0715061f13a1aa57ccb0a951fba91495fdd4c5e6157ee5301a9e9f5c33d62292d89fd72b963a2e6fae37fca01edcb19b87c8f9179bab5b4cc5fc6c76229548a9c63d8ffc4314b8188f37cd2feb90da25719c98c6cba688cd9d459e51ad9cb3b65f03e5518d6fc56670584baccd0b812a19d652a3be9ba126d2c3db9146df847f593b74293100fd5a00d08b76f303ae150ae4244bb6ae189e2a6133c53d6a5137d8b410206b0b99225ef11a5e3d087ee8c38927d47edf14fbcab87493fb9aad6cde9f6fff5e6e7ece24357638b20e43c0b6cc18180e83712fc2d7d45e703b90b75744a0dc5d23f8aceee8bbdedb25022a806951af02a90db1c79134b0aef1c45516c6a507148fd9a1763611254f39cb48ca019c186ea289953dac7e17ecb9209539149b26c1c39a8ddee638afebc1c59e00ac622dbb5fb178ee200a73095a5c276715c45c4d79edbde45da44e50e5eeaaa5e782356f0d99c5759cc83338e581c7361b43f11f9fe42031059f8e5797792ea75075b00c4bb62ad8007f7f9e7388fe4d3e373e501f1c3d348bba0db3366e4139534340fe2334d1a93415cce8481d317b451d42e93dda5e3d31d595c7239eba7dd90f961df9060a9192a68aee22baad7ec94e0ed26436e49e246902d14233230ad08b4c6fde6bdd32afb9cf9a4b090a47235c1b2b10086969616c159e9a2da790ddea3759cba98a3918964d6935dcc60937fa5b165923ede74e5c890edb2d4d41a117f17f6a7749be9ec45e840794f2e8a2a99e8f0f5a22062963c83ce8b4c8c70f8946a4c7ee623e2e68aab3cec276638f0f3dbec937a3a1390fdee7689606ce2f159124cc41b18e1ce802849e19d95b9aaf316e2e13fdd4372fb6cb4841f1ca347bb4bd7bfcecf96396c813102576d3faeec67e676bf1bb0b02098ae6058ff1cf8dfec8dc97fea67bcb1745a4fa0ff3fba685c6f8c80dfdc176276f0e67eb9c70d13d3259a49fc02c89a45ef0b2bde2404e509617878d1572757eeabab0bfda8eb8779759256fb45706de333ddb9f73c5636ffa43362a47d5a6eae5bb4bc3da919addac25d3ed193be05572aa0e11b1e87845991dc7cd634ff0ee26fd83b6fb9ffd19ac7cff2652dd047fff14463fb46cbe0b442b6006515909a32234842e023621a6588c700c8f0ee353b0553aaa894302f973b15142ecc09fee9f1b0a4774293e750b42657d328e278ae35ee87179dd20f8962b5604441e4dbcf181f29fd03e09e5a30aaa0cf702cc87cd0b3892bdc2c39e5e73b78e9fb87ca79da3deddab614ab1ab16457baf01dfbb935d300a1ad9c4b696c286c1dddecd6a1f4c91f1d5b57f24da461a8dce5821fc8c22a98a8efa1b99946660f1d59daa76739b52a45a4b56d78a354fceb4bb7368131204f838fa730f2cfc7e85e1573ce34e1a7d89ec19d982eda78ed927e3503cff7fc863953afba63bc777c0395dfd78d19f030cd87c2f2a58f53ee3988ec566154b4a6235d042458f44b0f176261ebaf834266390b4d0879f96b4360ecbf9c287c126c6dc240a4f8f404090be412f4faec791952cbc7191cc80f840a882a835fa00cc1f5cfe5d71d188ef4db018f1a25b189612f79362d70b9fbf78671c8a0c36f77c4c757898d1704306a3a595aafb0e79d41d6ea8c31636b400b6f8b0c48b60e8a66376b50482622b5218d4bca62fdae7f2984223da1a9666594c1efec2dae864778bedf37b0bc352754160ecd6451e333d3096d750c1a5be36bb7a100ce1773a57fcf433d7369d1e1ef22788db629071addf81799da2d080ceec03641dc98404014e4fcc2ba0d98d178d80e8b53c5d9b55e5f75a803ac795d8a590970ce085501c05e63eb70c2b4562e4e4a82e7bfd7b390b996f07fbd7962cbb4d0d0cdcec9390811e0ecae6961a2815616c445f18dd23f4134038d751c3a8145f60cead212d9da65830921138733e627351af8a88bc4457f5611b3b08d2d4f36395b092e7f34432a71078decb3c2c0124bd9b1637561e8a62b869fc1240844dc2de7821e848d91ce060271b7c7e1d101181cd4e176ad31d172f28c01506a9719929229c15dbe9a642a12f990fd8fdc66cf1e6cb5d8affbbf13a66a1a66a52caa9886e9df4fe1d1f36cf845d01678d16794a7c2b853d1aa6a0d94c2bb17358ccc37073948757b289cd80dba9ccd5dc0453272d4b4a764792a87bc81dea29f1b10098bb0a0088acd3def64310a1a309b8a05128448c3223679ade250f12f1bae730cdf27035f6955777dd37e467503e390214ad485987f29e766a3d1c8856c9f512e936ed25b0bb3c3aa5a88e1e7a796daa7bd5aeb7566d72028e404b9625af82313da8a134b1957ec2418652257b19cf311f1197abc4dc8c5b76a6c74a68ac9296c680b15d9c94e6f96246cdb84f1548a8122014a90d529d16875c67879f6a483c9c71c8171f2756fcdd9bdbd703bba500a5b9d11d18e055a812039632fd3b302088c6bed5180d92a20ceab9cc506fe2a0555e38fcc40fbe7594b818d07991459469cbcec2482358cbfe1692030f0550b7dc7bff9970f8bde2c3c5ef1b5291d496e37ed99921207db721ce187d8dc330c80e859974f6281210abbd739c9aad04b80df65a40c3b83e089cd09243f55b96464339c0e46951caa2c3ebc184e51314d8ea1659b2c4dc09c6a2a5c523cfbe010c2fa25dda1a97884feccde1520601d95e1fcdca97cdff1bbb4e8a675986a1aa14993563a9dcda8cd7551566a2df4e7a0c7e5ce84df5ee8b1382796390609914c733a8d38f05d22cbcee24e1e09bd12dd78e59efbd76ab498f3728eab46b7f8e5fea12310f10f7e48b43290b462f85ba27a83ac37fd3524d91c4c51b9b85862da86ae38088a6415df3268ce58c55f5f56b3da78426ca26a34d77a653663d55bf7087cc88ec13e626feec6a34ffb5a9c25a981ee406140033b55381c19270b0ed053f801cfea65fd6dc69b8940d727370a2992be4121605a564d0a1ba6bdb5c9b90e392de15c2c67e183892781436155ff01a07c9faa1b4284d0055826b12cda57e29dba40884056a23e1475798887f007103b5a3806a2c2cf004def8398725a0dcf78ab31cebcadf0a86fe4dcc2531728e6e124874e3a042a7ffbafebcc3dc5c3d71b45a00082f72c5a1bd566cb8ad5deaf449c19276996cb3c86782907f7ccfc497c158beb68838b9caf301d196065d3a82f146d4b29e78721be6ee533630560c3d99677d1f2faf5fb73eaa8977080635788f9a54837de5170ca61068d55d8e6561d25227083975e56bc5dfb5932fc956e228dd465eea1ddc3380ec3f291ca01ee66cf3828188f288cd506e146a0ad65d6da195f760d05a07cc7693d16f6f5117cc0fdad74661740d56aecf3aa6f3c41285ecde24d13aa86ac62626d8cdffb64ffe6a6593a7ce24b153ff6b2e12f31df742957eb498d41ae411707ecbb668a53d8109154d64e097c011b21d07cd70a3b83d7b1bbedc52723a0839b0b819b4537098ad4b6b5c7af78774c4069bef211d947d20cb170bfc9ece4b0e9597c090b428e328b8ee78f255ef9d711add35be9388538cc8fdd0fdf06715f46becfd224902efa913add68a93d597c1a7b4560b30f341cf455eff379742ad12a775c94240df643b30106518d148dc37b7539a1975ec426c9f4c1644c53d16eef42e9440bec0951f4fa2b2670803343659ace76460ea7f02835ea5db3abcac667bbe1ec6ba5efd1f00178f73214110789d74543c889d2af0eb0bd51788b5c7bdf1ff3d9191b45533f211a5928c04947649b97df234e5e4f6832c2654895061e8bf13d8592bffb856b8ef67a25bbe4972b420f699875fa3179fa948ccba59e2c21d8ff87e5c6baf19b9ee270696898b7bf2c72fd98aae43637333f7879afc00a2e888ec565d234fdef9a59d2c0db26368fe2c73858063bfa99e1eda6c5228da5d623902e997acd0975748c5d30e8d57c1cbc4abcaacbe688b258bc61986e9a2de370da0290d821eb2a777a51742df68a144c994f38b38b6a47d1b242454aeffe6954c5ab83dbf3793d4ed291a338b8c7094a8c0320f279bd42a6a1d03c68705fc4875904f4f210b10c0513df60dd2f093f0e5deb70b9b70bb0db773d97b48c4c0298dda5926d67c2275bc02d2de44c1db525c40086fe539d5ed897b8f3ecbed4836e7486150fa0650ba6300f0e6c2736bb49e4c60281a833f297e7b7e0b4d31317af7668533e529138340dc5c2054f08da71ac040fc584d9ab5b047eaac61b243ae05b0132a85cb40bf4f51ac4022f55707e552fa0b08b540793d00a5440090a49b63ec5b5795ec956e214f8f8c53ab5eb8cc8f979bc8bb2880775ab8b38af1cf70e642520a7f10bd7289f85fc2a9d6c929761f3ec4e445d68c45003045a3ea703a5b7ac25a0dcd70f31cae731d383712399612763f795254ea9927205c06f436b3c93e2aee735f41503a5d3e0ed7f8b50b7306a93e95eb665ba5e2020dbefa206ed82c4ed6303187dce4a1b09328404e927fc9877627fe7cc34c56d370897b3a795bef5ce3b74a5311851f72549273175de275e445af44beb6a232d8ce8fce75058af4fda25db59dd55e4c936aadf18617f3fc99f95058c311fc02a2893bee64c6fa61cc3ab7a52e143651553d038a9b8842fc648f895eba0fc620cabf0d8eb248b82df24dcf874f86e4877394cd555f790cde064aab8b245e0b369f7738eab655ef6beb9facc797e8112cacc3c6d6aa9787c4f94b6244571ad090ba610a6feee79aac69c351d3770762aac2192470bb664b8f6cff15987c6a98230a3d7072690a3ef67ae2c7225d36e66c872bc1360007145aff8947d82040ee5a4f5977f1bb05541b120ba0549fc3d43fed64bde77e91ec62e824e95e29103913397e127e6cd7b46b0a8541654629e0fb6c168fe9c28e8b06b85d490deb7552a36df14488555c4037cff7b63ab73887e617e688bcefd013c00fa1c5240989b563b227718ca71ceb5ac80ebc90ccbadb2e52583792c1215714d6327d794551aa56d2530402add3351e3a46e36cc1a92be6026a288161b35e9d2a98ceb755c60daeba0a4a55ba18a77c31e5070ffa8b7bef83f6e498b818b05655b181f8f73d479a84b3b67e787af79345b1a16369b8d932faf9cd4874dcef31aa6bab3d52034f9099da7429d7d2fa63e321d0533105d418a49a09ec3d23e1221e124b4a20e8e8ed5a05e2e29e7b830418776576da6d228030a4692e0e7ef8ab611cf1cbcdc1a1da96647c76b2f15debf89eac2ab8413d21a7dd2ce389b99653f1b082abdc7d60163651574f97167e90667ba044192a1bcce1df8d37927f3aa8d3c294720f412525cc03a47eb55f3fa9cc5a68b18ca74fa5c35076d2f4c6faf769241fae84010bd18ffe2b8627694dba98c18e1cb14c02c11ac32276ab9acbb16c7211173db6fff26b346204c7e273bed15b4f3942a255109ac150e3aed2ec0166df1d326c66e27a9a538695888cf437678c98e6e9696fb43601d4b46084c1461dcef6dcdfc454251fe014959dcd8a4edd18e79134491e8d9ec1ac48ff566187b9d3e5d1fd710ddaf98253fc215ea7c439be1a513dd3d109aa874ff68aa0dbba01b970ee1cdaf53b7271d29c8d700c57984c07487e72e0fae89bb663943b16a03c1de4aeff6b4c57219ae2260390d3ec391b8735b326c370fa00d207f8c7d012f50197ca2f349df098a7834e9df93fddca6228f17282913aa5f7c746e0f28ee09489adf5224936d56e557b7e6176596186054cbbbafe44783e6945961f61fcba0b28819c6903b509b12df311d6ffb35afa2308337fa08e23ce025c8cbb84b0a0926f06091d8eed5eeb959c5dec85ce8473bcb2c59991e45821fd10981e703052e0e176c01c5128295181388377ef01646fcbf370aa54feeabaa816b7e4fb6ac393548ed3e33175041b96cfa745b981c72f34d5c88dd83da2c4521a65a2476f48ce5ef147831551dd7538b598f34fed0be53df5e042b426cba7e1bc36265e27e2594ea96d8865d68ab0b6e1abfde674567e3be1731ce19350483adca14aedd57642984fafe45dbf89ef91dc84bed672143bbeb8d071d76296a5ad870ce833b84ca606c596610656c1c436032f34fc6eaa8519eec0de5727029ab7d54fabfe875da36938f4c5986457bda1ba5b0a71b41361142278be618103150aea0eb37f8ae75bee6e102b76ba9fa2d91b8e613e97af28b26a0b9873e71c3383e16f53f0f6a2675c283eade8188f3202401a08b4a4575d17ca519f3b2517463f4d1133359334261d5198b1e93b2d54df1b0ac060fc79f773085c89792fee467be4f629d368264adfa584600e99332a5bf31e9e98d7d686bf80fa8d49b9c26e42cc83c6dbb4aee040cdd0fbff828dec0d2d4acd60a8585f034c40814d3227a705aefd13c672de4f818d6f3e9183ecfb5e0605d32c7799731f603e435611ee46ddf19b9da417a3ad3dd41ab782e8c1c05680b15fb23167f4e879973fed68dcf4d07990e3060612548283d2fdb8ca23afbd1d704f19bc25ba11bdd5473bd14fdeff8f070214b20c17c04f3ddce74fabf57667b4cac954d4a2d33b850f59200e61e68036b775da8ab51534b04dac77dc5018efa97f5d0f35fe8e82818663c39e11985f1f895eaf7cc5444ab1ec89a1e7f7e5ef23d732fd48106421c9dc0cec6d8b61cde9c833c79b28ec56e0f0366c56813d2ba2d01cab420021b7057701e52e7ebba12dcab18ca10e4bd2162530add97d1947fdacf40608178c39f06fc69847b6838dc1608d3478dc5265c7280657553ea624615e9497e00409a8180f175f9e276c0e3ac853e08c3131880609f198069a25163128c78e5e32752c71216ba8f7e87c40f209d6e2ef3df594c16180b335730aad8ea511e4c1410b85afdad951046d7d4f8b707daaa391cf349cbbae3dbfcb1b6576f9a414781a30acc950ff315a8603ec3425693b18690c27020e1f8b0ace0e254b5f5f3da0bc70357866f10c0bc7d0915d3e9518a266aeae2c4e96282dd29c215262e6beaf8e054803a91d664e9dfdd965f2aeefe13f63bfb41bb114533b808b1d3127bc776b86c827e936fd7d07bba7e2a0c952cc6d9efba3b5ed0b37b7407b0a334dd81e9ced3cb31b5e52ddf5d5669ade998cb0caf1e5df85cf757b058f58004d691cd3df37d024c0a604c07f262b66f300d7109033b0f014365ccfbedcdce96d9038b5a87bd3ed3ab1f8fb4bb714fc4b43f2168e25e5d8a188fb021b40a09b5e50549109b3052157cf6b90c42ceab304fdef4e4fafaebef46f82c857a0257f88b1a4d685ee15591d514f7a065075e376396f1358a4aea1ecf8185971adaa2cc585dec1c912a265f1facd284de3f9ea39d44a9023244cd63c48985f90673f6df4c655161e75e646fa694ee0bc803b3d494bda1179d83fd329202f0288d71d58289bb18f17f85841b79c61c7ffe6083d0cca95f53f0e4a65f51f3cf2a88406267f654c6ce5c0c59f8901f078b5fd557279648f82eebff103c8a9702c97a534ef0fb81bdb62ef54654b6dffe9379fde6be8c5516f09803208fb28c05feda4fe7b02cb2b894106cd2395e2af6c790e3fc2e17516dee92d9261fc5aead19dffe356abbc28f9b16cd7f269a51e792a0f6ae21200d28d1037bc9575a1de6a9b8e5145f8d01de0adc54b07e571bc1576b6403f48ed1dc871a8da9a144cb8908f89f29118890b3eb4afb469558fc1dc4f2623ea9159a24f68d0a62b7cd113028d705eae8441a2487d99522a27f3de598885bc237f1cd47ce0f6aca69285da56837a20857633f17c98746ebe45e7a136d20516ca98abcde35db08298e32ef6e0036cd91a4f863d5e4d13a1ee0103d42cc8d667785c47d54673845c16f3791e15887b4c987078a6fd4998a762899247c7d3861ecdf191d289d291f4f2cc23569a02e2e8e6b2f6e9f19b40b44ae38329f800cc7f5b5eeedb821030f06ba8bdb65f8bfa7f99d083e71ed7ef194295068c24e8dc0034f310e4f7e145af729192b448658645e90ddd0b1578a44749cb9ef6bb79ab1351743d1b4f62b6d10cf76894a512aba5143ff08cf22b4b2f1d1633241b14a81cc54d4c9faa8fcc87e340b1e7447727806ee276e4120ab5c36aab65f7e7d951ad4fafde62662b761f9348e7c9aa53018ba73e09f11e96292d44fd4f43445aac1bfc6a48976c4bb2a125dcc1887e6ea946f1cda775083bc3334f6b07fd3f9ca33b2512dff96b3431ebae00f66dee5dbe3ffdd76a405bab0999a82cba95190c93dbad3680411e7cebe4c025c18f4d71fc2ab2a941310706eac680c15978ce9a41ef45bdbfb643b13ec8ea54627d79a131f6fb224b3a7ec89dea8adb7b84052808997b6d6d967fd475708c799741c70d9a3d7e73b48c12342f7fc492528780887291a3af402e63caf17485db4c13b0c8c9aee3b3cfc07eab64b43733894b8a5b200a69f9597f930803f74d91052bcaec2d6d9fce51732251fcb2a182848d3ec9db19ef305c89a0717850c2ccab315931f6c8992102db558578c3daab00aeb82eabfcf42386af64547058e82184d00b107d9b4b0b72628d06cf1b35fd7d4675e6b4e80125934901a465819292b7b5876ad5955b271b178bf4fbf6e823e4669d7858f98f9d815d9d98c5a3f7dbb7057f9a9a4628dd16c1486a426ec11e8017c3b14407f416f7f4c3853dfe2bafc02344680ae2cb7eee38dd77ad77da6e2c2d91c0f1f159eb04b0a2ca9c725b55f99ad5bd33a93ccb2df99e0f184d3a6c2cd6c6b3a403510259582aaa055d7f257409d9691972f3af0d3bdfd23612c770a1eac088cec09008a91cfd9b4df5f2afce7acbb74dc624f44861ca3a3f758578768f393b302644792ba909c57bd2a5a6ebd83ce33d56f3da09fed7eecfa94507638dbd403ac6dd56d14bd5b8988005a1b4160f8501bb6f43d81018dd7efc92d1f0b433e03f12250318323ef2500ae1a36f4d8657b6df32d522902081a345ae3bd9eb00b30ee84d3c37ae0c5eba90d7aa2dafba5ef4f3a1863e02adf7c6351ef5a745f84c23d0ec9aaf51cb15c2f81664e3232d80fc00732a8268d7b918f06ee436ee78e36c4076f97bcc3b91bb981271ed879617c56f301a1d58f2f8eddf87d36ee48716462d8161e3310e1f7e68b2a2ac78cb32714c9e3a0c730f8b08ccf87c2f4005cd8e8c6bbbad1f610a7962785a26bf89a630875a2f37cc4a81c7adfe50fa0d402ce61e1b734bf059824556b7ecdfefd39fdc60126912a787ae3cbdfaea6a83922291d15633527ff8bd970f326203fc92d13a89d6ffc34a8ac4831187d118bf3b7e8f3f7f1f69bd9d405019fa3a0e6f2afe5ee234d3f71266c9755bb563ec912ef06f311d7f2660eb74829636eceb5926fc2cbd9fa9ed0bfafd1deb64c8a79acccc87009892e9a4386f431dd14881fc2947c564fb6b5162e479db812e56e2cc931833a551752c33ad2656691d995a608a130fcd1601b0a59fbf88e66de3834d6bf4a4f6abad76d9f01ddbadf12d3a84bb4ac54d4b4c8732603b92d770ba4253768315f5595d5da21d044b4fddc0744d9c9e35b67649075bed17a77518a1a7286ae6088c237953d172422049eddb52276c3d23eefbb62501acf2260df8910b25143e53e3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
