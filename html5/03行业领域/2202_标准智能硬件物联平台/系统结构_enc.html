<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0d9479a2b2131960e4ccf5c6f7b19db05de14cc9c045372b00dc17acee65a3b3146ab9ef4477c187e9de5d3f9d66a0117fd8b310c262a278a297f45b42cab417c3c783a6782324743a2c4a5e1245757b17aaffd5b1682e83e3a4fe3249f7355ca838d3554fec6c016bc4a8804cc277a08bc3c8377943bbd63f95f8bf9a3bced7d6d881c8f31a896e12fe39c681cff0608899438353f5317580b1d013f948d4ff44639b361e1eed6b13cee23daa45a9c01126c6644178627865ac7b1f5a671930446a838ed05792d2145959fe805b3d42d64ed5dcdf4f15d2736113d12a2d1f97835d667b3d724585b0202c5d65353199438e2cd1e1416d437873e548095adc81597d350e53969af9d0ddf4509303ca10c9fa8428ef3bc235930db5520ed4c95b04b36e798657b9f928764961975b3b20cc93804b9eabc9562e77dda775e15db8d5de641f69876015a370351b9a2e45d40adaf0a521578836a3b7ce666280c284cafde61fb3ec6bdfd8f2db40c37ff245d544b8a89f417b5072823efd2bc92a25ed2d3e17cb2c2def002bcbbb255f40a9add0cc77103504b6ceac7754b0e7e7e25cbddb82232ebeffe302d2f4f24246f2ea11f7075dd4da0ea0cc08880a5e68f246762192f3a68329040b4234103c72d92bfa4e0f14bafdc0f400454a5342807d4a6110f38d45f3e7e966f5aab2650a0018a86af2c3c72fc6980e4eecf86bfd00ad42562402a11a29bc41bdcf19a36ddb4da7a2a6b077e10b7f3c3ab15034a00229148aefff7b4ce776241fa20c2cbf373ebc9b5a7441c434a004db4b440b80a5e9a8dfb33b676a91a4431a808f07985dbdd4d45306aba1e63e2ff8a46811ae931f9cc36d596a5cfb8ad254acdd75007bef08086bcb819b9003610fa4788ce3cb17b2192093e2ee91aeb7a33033b7edfc969cf2bd6c9fa86a50db6b5b0441ae4ad54ffa6643a4d0fe1a02dc3941954c82a38ba28bd97525cbc23d8c9cf2e9c67c95354e4db2432d2c1da117e0a054aeec0008ee28c99813f0d7c2bcf0e4898498621bb5d8eeba043dd52a03d8d148b61e9f5cc8f030f96756e2b14880cfaead600fe006a53e27bb077d4dac6eb0a3e7ddc380d1ee22d5b77804550033070bdce6c13fb9da860d18960982d731d7ca67c6a684b5003419af9c8ad6a6e1e40089aaa078a0d8f4dcabecf79871b7dbee538d9e86727cf396f52a690b3fbdc7380d45a345f61d7bb7f0f1f378f0223085ae699d226d18e30cbe7a4b84e51d2591a9174dfbcc8f4c3e1ff16709ff72ac59d51222200e64f8f77c2d305ca48e9b2d1244958fe7fec4f7578fa1f149482971a936721dc7e80dd54fd2b2a51dd46291b6576c938e25566683d9de78f4e07793943afdcc3c5c0bb9c6ae6d64b9beb93c0f814ff22b1fcdf5f5ccf241f5474d85656061cdf964a682ef5f214ac3237ae628d8be7a5e287a65b989c1f18cc34780c05d481a121330b34d518fe0d5ef5842b17159435d0607731910865a87801185e32e4f3a88ef6a1acaa7c54650c582aba1edbd2f934cf6e0307676e5d1e28074534c7a4819a61bf623397543da80e9737c72cd778c697be5d9978e57113476b73cf747493dbecdf04c1abf1b090a99e92359cef0772f3f6f4857a87035245d3b1f6dcd17171cc9ad3346c5944949f1f358d65801cc99cdc6d1823aba63b6e64cda3cf02f195b5693e6ae7fb04c72cce78d41af5b5b0270e1aac8b034345ccba12bfb26496fe72927aa28e864ba45579b3d7d793e5c3269d646e1e5634aac382501bdea382363106e8d5b01fe00d5e8580e789280ffa28985d0f9466e311d031aee63a209cbfc122ca49c8c6db7d99371e288eec1ef472183f635a347fcfb45629cf914989cbec25ade0ab2485c61f241a76f67427c9b4b27f566118b62f00c2cd3de00610a6d4a375d47769d02caf8eded1195b409560eddef941df82eb3a25ff93d185599e2749a552d48df727e4dae76d5db5fa051614799038e02cdd126df71d523c13bd534ada7715f1c8c5805fc33a97f3251de7d7524ac122d4399c6177fc3d1612ffe11835adee34e21f9317bc07f4e889fa61240b2fa89a75de48aa21b4dfd0f55827f237bde43a8b0ff5b7d822988519b8fedac5133fa1e6e7730e819f55c82eef7561d1df5dbac8230d6073d6472a06eb0f9271aa6b29f56d8df75408576f733012704e6bf66acbc7fbb75ce1726c14e2762bce904e6df196b047e6379e713cb03de8b6ff4ace2d9c50f801847efa2d52dcb800dc6e2b2669e2bfe81d4e426b04fb8b13849d3e8ae71dc97f4c9769d75d16e10057d20ce2f05bdc714c2522217ae987830910b125a0c14bc430803cae583225f9895f359afdc04990dd9fdb5dde63d2b991a39e03b49c095ed6373e8b69f2ebf3d1bb8440d485970a748e9fde1cf950150b5a67e467974620193b353b141c5b223652ac95c95341b968ce22d2c35fe3283296985384d4261cff82f9794e35aae4535229f2f42ee720c89597e3b460d369c4096977cb6ae1c0fe617600e4bd6bcbc8b7b774766d141f9efa5c27c86cc1bf8cbbec4cf6ad9d9702bc4d54f2e8b43fc6fe701c67f0d1a65adaf34aa47b1c63e3ed77a3614a94deab2bea44114f9c93c294d4bbb998e5bb515210d7a85a679d6c1ddbe96ed133e8983075e33faaf54a5c2ecc9be9266aa8685ba54518f45707a362cb8a8f951036d4e4663a65522ed94e8346ef5c123cb6a4c9652e96353e4bb8732303890fbe2cd304a89db7897721e3dc5908a4cd9a12a67d2a7612960c9a9e7f82f91006e47dd87f0e7b8b53d49e5895bcd5e4e4837469b2e3556d7cfdfc4686244bd36be3072e7a8067c02ed0a75d2dd1d362223b0c57bcca2ac4d9167f769b6879dcdd6024167fe6790f56c3e6a68e6f38d359c08cf65ebab006eb42484a4e26f16c64b95d8a37fe774f92b1bec5242c4bb4eda50689af60a9eb0f1c8457cfad064d3d808d41fc27bde2aca49fdc5009207e4a6e801f294b3306a057daf27240dce93f934870f196d42609db94310410ed7af5409c81e76772b20fea6739e9698755c7ceeaf5cfc84ea9eab8fa5007c84f64fbce91d34e1bbab11af330809995b36058ac2d9effacf0638cb4225eb175fe5d8ecc18aef4b13f3a78d17f118232ec30c015bc6f7542729a9b6b644445d30db8a169b7f42b3df58f26eebfc1251267c339540bbbac616e0b540f4e5fa8647b0d51f3ed67bc1313b008c99101581767d0898f629d217cbd76fe9a686521e91072c6680a9e0da5990b2e1fea5f0ae1d990657d0973e3d4b43197c99a1c2e8c33f054f0312a6c08eafc3092632d5f2a3221f8de68f7736f5411a4bbe3f984edb80e1ff06725e50ca0b67dd6deb0d342ca868bd8bb60f631458e2092b9fbf79d1b7201b9a11508562352b308f8e8b1a28b9c1f2f532317ed8ada7c5113cffc994cf0254822161435126162d8143b78d9a23ebac615233e872847f9879b936ff70aa914e45e75017b00b1656ae3ba42198fa0adee7dc088afc80fbb25b6e8e1cbffcd8a7b2b77b83959f0d9bc2ca8f97e6a0d0d4bd0abd2253131a90765c90a1a870e67146e0219712d284fbd70b361cc659a0d1bee5911769c2ddfd070a7172e98b863206fec9879ba02eac69229132eae3e01c8847684300641bb98969acbb94dc64b3d4973bd966b691275754356cb8348f19270558af69eaf95df44df4b5b8b5b64dd9087b1c0340858c8064dea123a726af22bbc86e54ce11fbabcdb8ca423688a6d5b58ff3ca4908534595a4ac10b17bdcbc483f151adcdc6c0d872a19555a76993cae9ac4636158bd13069086b5e0f0562c0bae63e2344f9974d61e3d3c404cf3673fd17a99b0f9addb400aeb387f1d7526b821f77f99e4cd38a13ca6cb527a4b74164f2622d64b19783ff072261dfec37e88c9b034289448cb0fec31107d6a283972a8ca97208a212753c4f4cf3f4eca351cf8996b6fa6745244b6d08afee879bd1510f30d926795b60acc98b7a9dfe60445b10bd86856b075af4a1897c3bfc29f60990ba1ae8e2b15974560f633ea45f91ec915d46da3537f4c90dd2fde3768107f25184fbcdb2f59f9cf5e2e0990081efc373a3de95222b56d82202392934fd12cf99eb103bc0feef98594160121fe1c1ef320791c0b5297897efc666456dbf5bbec263f54679172f86486444de569711733b5bcdcd2c5d9d99a2e9615477545d47401fa21a00398b0c40d88eb47cd06f07b3457393a8f28abd687f0ddffe9165cd7b3064b2187baab0a97d6baedee8f7776d11f7c992c97b0d1839a1e12156d1a0eaec9f1582dabad53a8a66862eaef51150940c43ca1180b4c4ecf6d6f8113c244c0d57b63996cd1aa0d7582397d408553709576711d1fa4399da67643a62eef742e9487326ff45de3cbdf0aa22d4d118188fe162b23526b1d3ba5fc069369410ece119b513f8ac45657701828ad1d0870947f60c9f912440ff9d00d7b7c7f6ca4d72a52d726d3e2b3df58d2f8d678af740b0faa51a670e80c5559772c3b9e2ca76793c3ce9ce56c5dd6b5ffd6db7ef40f33e9535d537e2e16c076ea4535eb9bdbdac56194ee73ad4e648edfe063638467909f31344ab7ab299d0b4a6fbc4414350415d8d366c9b976a44c32c31d2b3309c30d9034e50a984aa2a080f35a41adc98b063ff21ba0b39b45b6728afd86d65eda44db251ec764bf9825f0b9310fec14c0b11d8ffd013e55e0c50d8a291aff81c70b03ee26ac0fdae64bc13fe0cead948813112883e261614c795e9b5e4d1ac0b8a607cf076cf7c4eee8ab0109f7749dec9eb01df10be7ef725a8f7d0035878f32e78516d74bb33a6a4514308b16fe28d8b9c82906984eecc511b2c670b271b80a8090cd922ecb6069e50a4797884676e202cce5150ed883d143e728a48d168fe88cf290e28c57030c63efa331f110f3a793188bbbabb493eb185b1a0b1c66212459d4455fe097148761dcea5741710078381c8091b256fddd1566f764540932cd72769e28dfdb69e32a2d880904a6ab576acdc46c10199cadbbd702228612b27539b78ab6decf9d0cd7d729fba010764944296cfa5d04209b4a45e56d46f59a030be214d96d7338614b7cd8307067fd2feb80df1918d2dbba1c0730cb96f8c2b08db928e10e46c2b7baabddc091c45817e4e376b5c9a391adb7d7a5cc64817170f79c994d6b42e419db89ea0cc641b6b6b80ccee6fd3019549057d04039a0f49cfdd29aa42748a9b62c70ac27bcfc86692cdc85274f0278b6157fbd35fc74e5a32c4dd83288aca0cf61920f10ab3266eac9dc52fb54a2f1adaceb489a0d191232472a45100ce334c5f8f00998811b2c730b581c56d6df502877087f80c907730e3c7c68327ee66cfc8bb6d36575960ef579028fa609a52a1d55841e97849da8e9952b8a1d0e0d221a8e90bd527eeed0f1af8cabe1dec27ae815087bf2e0225d1f49f3c69a0aaec73ff8276ef7ee35bc2c4402e13d4ce7e77e6194abf094b4117b299ed9d1218089bad9d873fec982d804ae022d0201211d1831bc13bf939458b3adba480c47d6f8ea45f53fe89726ae521c50259f5c1872b3b9917805acff5feab11d41505656007487fbcec5eba958d0065ab0b97aee722848433fd453e1fea63d888e7a92c6232eb43f5eb29e7292f8acb69183d785907ee2dca5456a26257c8e0ebc35a7e6fa136b60c91ca310c2e5e24e034ba1203419804c4a6fd73fe013b2fa8c2bcc373f8139b44ec0a9de05fe28813e51e5778312ee9237d32fd9ef2dbfe752ce50579ef7c3a86fead4e581f306f5de2d3941f95e6d31484c8ddfc885a11f0f09507fd36f3b1e1b67a29886e770713716a3ffa12923158d9cd59f8f329ee324a3e65271cb93e99d0bf434110d3361e83183a53fc4ccf3e9fb1ea19a6be6645bb9cd9ec3b94e4afe34225e3af77d4c6b42fe40d15f8b8b7526598b56b87c7547f1a4db1a29f320ad5588c05f897f1a4b5cd9bfabacac1c489bf32b88f7701f2eb3fadb45a6be67f2579f7c58ad66fc2a8138e62d1db9bfe2e5c239facc41bda6a6c734754a5b7e837e4e3748440bddb9e88e7205427e584f876e7f6353017ad3a95efde96e84add20a71102fc80d944cb767eab45033d9a2cc6b2dffa5c4c793d9bbf9652b85e480baed0206c0d009e9d7a06919a7fd6b3a5e34c28b069043d4e2b32ec75fb91ee2182fcc236abb171a68cf57caaa7695004185dcbf7d184604833398abf100ecc8d980442ab27e2481db112576160f0c4cae6fbd92421957e36008c31c6cf3669f58ee5928ac26fcf4adc255a4e1b724546d173585e9cbaf095881862b42593faf5399ba61dbb6a9f3d584b58c5d2eb6fd5d73af425ff9de8a4d5fad64b06c3c0af480b1ff100cd4795530920e3e8e8ec2de9b70187e8e786f4b7ba80d082544f820dbc8af36c3fb9a93ecfd279a7af9f47bbd0d6703474690f90d75130000ebabca1fc5ac3f68d979654ce686e8b7c0b18c4dc10fa37c1379e02f09ac377f770ced26f3459e47874e3774d2bf55924049dbb1cd503cb35aefb820f5d4204390c9f34ad4b41d3634953815ff2bb456e22fe23d864348b86ef2ffe0d3604c9ef029a7269a76fa393601668f891062b51cf526f77ef43fabad529bdc2400193d607ee30122253c58e9cc0cd0664e27a8d60f689341ee0ae4f0787593f0967ed4f05cec51ab58675f5744e4c6c2323b9b2004b6a8d3c789df67c28451124b6fddee60e2c23d7891ab88b7e8624fc38ad1099a75c942122557202a63a62cb6ffedd9801b7438fa3312d3931a0e405d53eafb4a9fa26694e6dfb10703eda03cdc476931477d7b94b1917cd8edea6d9b716027de3febaa55f412d0afcb9e1d307ba4fe3780b5b2135f3b1768a1bc40bb6991649bd3dde66dccb7d48724a5bca833787d93ba14ad4b9756e20d4bd464706750f7e7d72c09759659d1db03d65d2b3f78745cddddc7711ea186e4ef787ce8a8ec555aedc158cc3932e213bf1883169621cdff1b27d79d31ccf0292d0e1708b4fad246975f0d78c6c2659c8d99822110038928b251df538b31c3d58b35fe010864b02aa9f79a729e6e4bc8e3127fe4bc48026714b8fd782ead370613ee3151ee6dc29c8dc095ac2073a49eb513b0003ecf0a714c4fc1637adc9b81fc60715d4c1de0822dded49ad162a6bce0f5cc7a144ee7621c98d1b8fda8fb156a8b1dc133795246313b9a435ff2ef69f5e2d8f768436b6f07facb8f289e5e8be72ce1b25d2aa46f2cfb350f0526424e73515d8fa2fa6644843e0bf2b9f7034a807015a0cd6a9d47712141546a1e0f677cfddb42125f980090860617dc44ee8c706119a1b528df044e1425baf86be87086b20bb3e753e1b9e45f94c95040e789faffcbb752567d713ba3fd1886bd72731d1b46d892b55afa4ccb444e880bcf0d07ff574090a4c2b3bf402f8c0e8b620a63967d29a39ab206931c23eb28ea3d3dc822f9c178ce4460b55f54a9d31c325e6b3a3d3497ff45f65c3816ccecfd66396734769ce1a02477883cfc87bd39a9e733844f102ed637f701d77378233529335cc0b8ebe74f3f867627fbeecd50f96ccac12633c68c6945e55b3bb43753fa8f35255a97a14ea0cc6d3c7cfc431d23062f5612e45e5a64e9e4c32a250a39819d76411ed83ae484623b8940543494e82e96b052507fc78c2673235703e1315c48ea400b3eb4ce8c8972b7921fe99cd1f9a36fa95d7ac5db12a3dd81e48a1330f32d3059eb25a78fc7abd6727573773237469327d5c49cda234a919137c536a942680235213c27d391ede789ff5a8311c2f281ef3249d2d1a5d1b139835b417081b78e1e0b05998c7d77ac54ddc3c7330906892c19db50514741691be299414b2910cc7745b7da8f4fef8737c79eb7bf957e65a78e94677d967e5c09636d38a52b3a5deb1ca743aa0ac03972fbe4051b6cea088528486126c77ccc6816af3810ffc07d401e2efa1470e002c835d2e319653dedae6358460dfd54853a76412a6c2d4f04d969cb0223f202b72b858f80bbe956afe63ffeaeb6ab949240536a3ae72bfcacd16f82babcf7043d6ba9ab3f9e6fd9439791c12e100e05760c2025d678088370bb28286e05d08fce30eeac934adb905c1062663f55d7e428ec7b8cdeb14cdfe42d1a9cc4487ed646748c84ec416f9424772fa0b2456138a880d10f195bcff5f426b1ab8cabf7b68ace36f7ae8a347b48a93c2febca3a2ad9ee11f547bb42848a29688e35eb00cfea351d202065674f70ef4b6fd1372ddae4f743e8d9e20d880b8b3fe0a3e03400f687dae731254434681b5159a8a4b13b49b9d12cf10547f71eba68e5547052427a67cce335838145d6c476635d2e806377d40ad01e45583c8298f08eebfa55edfd6e086a3098ca87d9efdf2723b68e5a0d2047d7a81a5794a9f8b8e5ff9de1b2dcb5a00f2d2c26dd4ad0454dba59a8adaca807a6271997fc0f3f326c571e7791926743b3d2782bc9a64b443e8d5322b0507e2dbc4ccff8421772defd671b46e097a7539f797bd518dcce11ef5f615d7ba832ee400f8c19440867d9126e9b9018209289c856b0ce5ac8cd46ce327d00be09b5f997cd51b92cf1e8acdc3af54b29580e9ef0d1a3a342437facb2db434aca75b040f2d3c18c877640aed1bbef428924edfbe776b92300fd868d51a1360a28cb9c859ce07e4dee976ff99994f6b60ea2369f98f930f29d26d4a647274ea2af2d336af69a077216b44341d47d02e94fa4369f87c8dfe057868f919c9ed87687f0781138992e88c76c82d11ffe1bb6cc60b0f8a3422bce6e540dd414268d0d8aa0b399c43acd03ca7e4e7382568d4e61837a00def30528ed182ae1e1b3d53c632fc398c1ac25292bd4c3347f835d27274108701d704ecde4900afa84cebd1ac430710824317617bb28b745fb6ff8c0b857d0ff33645091e6ab520a04fc42cb45536beac1c0dc142a94a498b955ce34870fa0f7ac6ba8888a100a799dd42d0a4c85f344a1f0d86e48096220c879dbaacc28894a9994a4f4b90884b2558166f4494b6c47444c8efcb50517214ed2cde9e1a111daee797b8d6a61b46c5d13504c8c573d0b485871500409bb86ca9940e8234c528d01f178d21cb8c8bae17772f04aacadda6955dbc18c99725864ba7b31085c77e0a3708ff83055a98c01b5543b9fc44a83c76f5bef3a29e703fc44f7e096a5293842155fe1ebe98090ec1259627759f8454c5bfc9c57218866807397fb30dbeef1461908a60148939d8a1ada5e42955e1612b29e8f3239027e0ad7714ea002736763331540d557e0945a751a82dc3887c33b61c3c1cb4a57853e0da255dfe3fb06d87852f999450938c2163726fc9497f07d4d064164593c7b56e4d5bbd5ee626ab5869e79ad2efe98ac3f6008f41c784b8310c1fbc9a3e57ba0bf7f6776fc72a7d6c906c302c908eb75c2a4cb0a378053c9e7caa9a2046d8fb8d15d8c4c69d71c50c9acbc7967bf4976f10acf0888125bc2b5075485909f3151c614f8fee428807c5f0dfa9425efbf7aa068c27a42455b59dab9dead17b9f47637ea531d06aa35dc06c9329f61e65354bf45cdffd0bffc74daad83d95984652eef6df93fc462c64f25f6bccca5c3166ebd3ccb87748e83df755fc7742364f4b8f7b3707a0984ce654450eb357a73c5471dc4005185b59eca621fffb9f07924d57370c4cffdc7c03877737f71548e26a427d7d4dc23a4901c3142983052ee0b54092d7a31bb1014835d683a0802f7224869fee7a3206e0d300a6ca24e06b3cd6240a288bba853bf09367a3de803acbb3b19253403f683a9d35f0408c87d8971aafcd82a474e0f2c17ffa54ae107b202880ebac1af1c7df9845c6f7e4bff13e8e3abeb38cab313b616cade859ebe91e33e03657fa01738e6dd990a58544afc1dbb52bc17d0d2ee68c2ddff21e2341ad0330b499f870bd945126bb387f731c28b49199d665fd9c01f422f383565716e5ec458df0e2e5bfe80cd1175d6fad63b529dcd5789d9887289425c3f9e3c531d5758352b7ae4583aacc98dece566008bad736afd5b068a123a6380b2381e649001cf8da7c7575fc8d1bf9929018095f65487a420c68daa1f4c4312889662c3dafff095fe0bb03881b57ba2d1afc1d0b32828e034da2e08a068cb60d337ddb79ffde81d886e4a73f9f22dc881849e2adb1ec288595ab2698a7b2c8c93e574cba60da132b041cd15d18062178c31a4173f8f26dc950e3de41f5990a08e7d867a936193013551f0ffd92642fe4fcd90513c60a28dec5e0803b5297a8520922f70818e339fe2183bf4327ab5be36ba485987c69baca89312b09b31697b15507eda674b57aa61299a2c0747a848c2cbc54fdeeac0272404f4f9f1956cc43bccf42ca8c9ac6542335f302ac644376c77585d54d029ce02c0717c3cf8e5e30b3bc3cb11709831292437510d227e8b57426beb5d8523ff85c0d39eb7370b0ba74e8992586bce27ba6d146aefd8cc3c68087c026ee33ddc8242598c96a140ffdca963cd714b7d92858d6939f881a408ab270b5a5b1115b928e468e9e959c29231ce277d75d611c9024bb117d604e53e663b7b1cc76007ed3c96df40e6953d32c03bdf6da52bc54fe02f2a434a900f386b9b8c9dee006fe3adeda7f82d2afc2f4ccd49e6a5eb67302ad9842eb8c329b6170c4d84747fd7eb624d5731d840dd2fa65d814d23b54620edbd7d0943d5211b611833502038595fc5bd44a4b0a3778da6d02ec8d7063e5d0e3c5ed4a5c3ec53d82a4eb2691da148e3e7f1be2610fe25debffa3bb50e6d3e9fe7235722b9721f5cf4680a3b26746ee1cd8b8a5cd519bc7364ce0058f1be789a72a352d0ae7795f097648129fd890bccb9b5cace14aa463d09dc182ed77464682f631907df50f67d6d4d6d2f1cc62e3eca9cbe721e993f30b5662f3285ac18c60e9122d98ff54125b51b79f73956ed093b4c091eca00741f360b7ca3b541655a1be3ce6ac3b255cdc164c40b78ab111610661f6debb9d1ee4f1a1c56bd9e002792c377455b504c4ad93c8c9d75c731163ece00bbf5bc190843be5dd309988747a609d5053658021d0d3d7136e51cb4ba4d960a9e1ee46cb57fc2fdb26704be2ceb16e7edfc49498a3928a6f3ef22408c1bde2b881a9ac7eb2473689b91ca5b5c021ed4bd69646578c03f4b2096f4ff0114b5051099b803834c40bc32e8b82038f7947b3cdc6eec7586f1f29b75164731add51b7a5fd3f632d0074468afd779c11a7edf5e46b2b018fbef0a3da2c31dde57e1d10d0337729c51568bfbbd9aa961b089a57ecd728e45c7a4977a42342a0b825e9ca6c65ffa7fe2706847859c41287971571dd661ec41a28249e371bab71d07eb18673099d3739f975ab10f97805d5de9d39ef7b144c21b150ef1bd9cf766d4246b0ca1db714e73117c5e51a2418d62aad78fa219d507eb28b89f7affaffac1694891865dd60c5d42b9c78609deea87f2fb4e66035ab1f973b7e03ec52b078d113225f1ceff901e15de71b0857b00467c054bdb15eee019f1097382d6c927cf97f42c32eaade87cca25ae2d0e76c3c11ca20ced81773ca533fac3c8fda2abb5fdb9d33f929680775db5099c2c8e1c0310cb6b7c763a3446d2055362a456344b97e8eac05bbe9d08160b1f62d1714ffe500502454cf7d4bf0a1be970044013053a7b167ec7e0b42092050b499ba709282032fc98df70d10870f8b9ced1ef35f9f6c8b728afeee54e8d144d88037e116bb86bb40eea1195109f55be98c3d79ba8e2ee1d4037bd6e777779acd56bfa0ed9609363c1f09d691ebca42e2d1899b6016a1cd5647ee2afc289a21fccc46440eb9687fabb138b1c03732b769f5a74d9224112a4046fe699ee3ecdc1b1e079b9c8b9320b698129c9d437a66592ab4b5a7fd3078176530f5c568fe1e9304ba40882b03dbea3ddc9af5f3f4630dcc4c8a08987cfb6f86749cacb5d248a25d46b79770b84338394223f749259360a46d1f7f606ea8aedaa3369ca9aa164872be843e1e52497d68bc3b08fb73caede5af7e26189d1f8496019b2e310a400c4047ee6a1be50b3054e1f79731023efbd30551fb2a1b5d4eae61fbe3e41272d31a279e333d46554e8a75f3fcaedc82c1e9c25b332cb9830bb163f5ccc39f114090ff6c4877b2959ef77c0ed45dfe84397f36a7434a11b7f99aa9abdab790a051985bc87aa78d8b87a93f0827f3b3e03f2a79a7c138bb0408c86c3b704baf621372e1a82f4f8ebf2c627112d964eee384bb98ffbf2f8d20781b88441c3c0fc5f5835d4e663ad36c2952b1de2793ddfb879f9c6f5bb02aac7d0a2e727be508c22d81b2d726c36708deea2fa05ca4e3f5d05bd09e5e8d0a274be486be070cd9059e45198475ede6aa78ef74a2c420239dfd65cab3356e3b7808bd64390d8f595f958f48e457a31ce0cb1a7dd726a9b09375e2ceb0fb601de1c07458bd5cdffbba1f01de40446627c03eb1ca1746ca8f33558721696233d766da0dcb033945798551833941d75045ee510033e9b22d5158a3bdcb680e64bbf0bb03d139c25e31cfdbdbf3ecd80f2466f8966ed894c06d63495485b0ee93e0e40427ad463bd5736bd1d266cf3393961a7e3a14422e9e6a85161f6b8bc694110dad6d44d7661dc2105e039e2d9d63471a140e5ba36570bf887a37944f3fe8bcb4de83ac0940b5eec4cc8040fdcd3504b74dba99500fd665b09dab7b02a7727766cea633abbd93d9f1292ffec32b717b865c4640a5a91656e526957e195e9ef430f3ff2e918a0a69f1ff257db436fe795396367e61e3bb5363e9f6ce5c94343e68ae7862ac7369c509542ba01216591268fc1ebc1f621437b1ad72828048eb4917c4fc8a25a23102e4c02a55e759ff67b33bb81d2f591df51730210188d624c93f32ccfad4cf8e23ae4a89d8c806778d2e6633f872878c8c595f759501459dbccbd71f1cc7b5131132e9a55d6250691a1b355da4a49a7869a196a8e41d31589fc79d235a678a8990622f6986b89c48f3bea5b7dd7488f72e46440af4f515d9fe6fab40370c1ab71ab9eba2b49116c2381a8c5073910077202161e82a2352256645188ce17e485d7a13e1f81b47b01a4435b2c3b09a2b1fc5c7dfd7790c9ca019d664cc2179c349d8b8de308f7e1304779fb197bbbac0a856e5dc94da8521ef05d86d47b943c64f9ac304028367ae177bee1f7061ef5dfc9b206783f8ccd4e90a80519347b2ea49d6775eba7fe38fa654c670bb59c0a1c97c3f7aae9555b811b43cb3feb9a0573a39e54b2ff28e68cc822979f24d1c983ef12a33e5d8c046feb7959591cd81e18f94c73be76e6ae4a42b12cca3acae3f725d0432a2a27e19c6bfa398f11da4c819c1334be61b83595609a688fc556e3c7d7e711a824f341bbb1195ab31137b81292af152761c3b9de943874d5263d86294b32f3ff00f97d95812027dd2b51d85de9e72d778cb7b25c1b84c922bde3cad656af1bd9128bee5064ca59f84c88b8658e90f9e1ffb500dd62aa2331947bd69e03a4b0ac35ffd876204b08b7496e01c2d2afc6f33576e1d6f5cf1d1e6958c4aece8377b37d40c2792c00c60ce9ad2313860a062e791e1cdb8284ead2bbcaeb6e03f268fb6918067d74b36c62b006eb3ebe765060fae129c78228c9a99997b303551981281d3e290e45886176562840bbaef51100dffe767634d4eb9f47d260df44ae4ad074b669fbf60369e79a67b95c9a9d9f92ad46e58460e7021c58bf691c9c23c040c6c0ad2789650ae0fa093a4ccec9138e5dcf8e07889c8a59ae09d447ae84caa751724c69288026b5cbb819ebe0ec6a6cd708858d0d3e808c2d7c9760d929c38c1d18b537e6574ee1cc968b12174aeb017ccd2cc00574fdb214937fc507f00aeeda73c6ded840da5bc047b5817aa5d45c06c4231efcdc6e2a4d234a1fc570ddf5f0481df9e6e8aa6154171a6ced8b805977a2704e8becd84d7e8c63dd9966500f64cd8a53d9cb294933f547d3a84504bee357e4115f731c76eff063fbfbc3c481bd502e1e838b77ef6f34bb0c3cea264b7cfaf62cc0924686b93f9dc76361e28eff5130acb5926e1da8e2910b2f58b1d28daf2f99de5f75b22be5ccfa2b6aa95205a59fb5b76c01a3028be82f662ac4d125a5f570cdc342555db8980cf42ad66b97df445e6e7e58d0c06fa01a1ba13eff367bd4b8537ae6ba8e2339df2417cce61faaba996106e6032f9689a582405b39c43156dbcc2afb6bf35c4dd4c08cfe5a4d034048255e98ad930c8e142de236cafd1936277980615d2cd75dbdd1e43b2ae034c032a7a182389b17e031f9cb6aacaded20e7496ef9ac661185304d083ceb2a29d5516c6140bea9ba21c3127e1d6bc0ed706db8f70814ced4eb971ebd0096fc3d0b13485a620b0c4731e979c27d5367531d1fa7f6f71cf4bc3b5e718557ed358c8700ceaaf22461b51b6c1662b009f18f6cbcc12b2177c4343a480becdec0c1a99cbf9c3090f504586ac889bb5f5c36130d264a56ea1162e245acc9bcb9fab93be3181e62e56003507470ebabda507488b0b09ba1e83be011593bf754e9c1bbe14bd7fd3bc511d2593973d7842a3d7fa13028c55f3a34912b8d798a049c34c6f30df058eb83a044fcbd1a028bba8b2a2ceb2b6da10003fcbddec7787daae142f5ef6da822bf1f259adaf8dcaf88b18200348f4e969016b2d8aa16a9a6e802f29c28768bb76afc5a8c312e20bdd6ee4f3137176a8ba538a501e9f5d2fee4712b2adb52c39ddbaf3dccfaae35df57b7e2aaf650bc0fc79e2e9561cbe5b0d869df791e021b8aa1b338e9ea015fa9c8fa916eca22650adfaf0ef7311f38ad68898908e7ddc622cde0a160ef472c9e1e238f9c96b7606c02179aff4ba24f06d7ab11f4a57ed49e8baa391c3ea7823640f952d1eb722c98f5ef5eb25ec5dabe50f83f8975623c90cbe35e3cfedcb3e12a9ee7bb601af39708119f6b7949796ef69932764ea44b35f9d75573a7a32a431fef0e73dd580efd3797ff6b52b2bdf9c4d60e6234c3a4ff1682055d73df9037bec558cbeb2dd145a2cec3e37cb4858afe4e29264ec25cdfeaea8a33bc8843f5c77be8dde80d5599c4720986dd95841910124844fee27ad6b4bff9cacb0d5966c1defcbaac28540f55df31642eedb0ad63253e2520f9701aaff857182a425bf2e47ddbc94a959cd16a3cddb93865d480e5d2a331dbba5616864b8f7dd5790bccd49f19468dfc0ec292320ed174793583430ecc5d730324c0af9b0eaec352d28cc55a24e9d87b0d5a160424446e8f0a3ee19e8ff255dda5d9007f55d7321b2accd2ab59185d84d170dced1066bdcccd0dedf283401e3238ed3e9fcf4f8960e2a1a8d44ac504dc3be147f85096134a22f2394638d4617d2465a420b04cc8f2ca3d9203aec1ca4b96bd3b65b3d7e8e1d42df350118cb38d6a4c3a50ac670d3d67df0354d74b4562ec9683ff3a787a618af828c68565388294cea72624b10773013663cfd7212ccc754789f8e97b5a5500833d1b8a0d734d3accfd0ac8671a93e3fadaec6d7e8b62b1704fb3219848bbe5e4050f8088a85c0b32f253763ed697a3d66432755ba858731adfa345a3322f0b2d2dc3ba3a62dae41f71d34fc80d4e067a571995e2b63beb48de6ddbbb45bd153a6f52757dacd88c5182bc5d2e9b39697e1cc92edf13aea7a9000c8492b438edd90c9337777f77fdf3d7843258f2d0e1b9b267e0db86d50a4064d5485be6185e265ca962bb278d96dcf38799635f23de2bd80ecc034fd551e629abd6eae5848113c9533d424590bd6e5b5b452fcd79fe6b684c1789a50848620edd3bbde1979595d76bb46c03d012aeb0de1f42bd0682283081de59933e5698bca518df4faee941004b6cefb5065ded9ece68a0aaa073d22e28a07ba24990c6dc8a36d4e394076513a998cfdbafd1ccc43cf75032ebc25abfb6c24c5636bea7170a60d4e8e218dc3a15b2697c52fba23d635dd7a4e7efef1d2340f3b2da7b0b4a9d0897e610da17051112eaba5d8892aa864ea5ab1c4b1ac47e5a4b214203d07f473bbc574125915609dc9d076808fe5ae6ae22bb8010b43002a8c6a4794c24943e6c3d2ecc6908a16e7715d82ef73add1b4b8a5a73f3afe877b63a10545b4adb63fa4b9c0e7676c36c3e97988a3254d69205b761243f67d31eb5d73fff5ace31371e686cb71d9bc0ba57242999ed14502411eba2e635c6e28345c36edacce35d4d8bbc0142ce5ed7e428aadbe7ec256e72f81256d9d0f8e6a47e9d0317ed0805a702d017180a72a238680b72645073fa8ee59eecb0c08039de0ed0127ab5aacf2450dfa0814065fd1229d63cf43ad7c00316713e5ca48685b8f581b9337eef8a47d64c3a3af3b3216774e0d9e093dd3520ad3f4fab430b58299c481123a5e4e8f22ea5c9e5ed897281a655dbfdab37508066aca4c8cee81221c2c78c0795c01e3287dfa122898c3778cd134824fbe246691f77958dc9e0d4b68eb8ed1edc310432fbda5968dd3100b668b5e47b8bef81fd751b73d682e4295bc1153c4d8b3611a56d86149d7ffa6bc3623fdc659c3455eec0de5983589d71f172462b9d3b191500544d580588f4b16a81fc131e823a1ee430c775bbbeb387f4750f9f8ccb45b9c60b228ab97cef4cd17f1a1be2c7ba6ea4dadc8459e191e4c6cc77dcd4e8d144dfae4e6bb71b62593a4c3bd244a353b40cc5311673000cf011d4b2c19317bee433b2a92edaf9c5b38a8fd51fb388a06116d8ad90d41605b640862aba82bd23a797d0bd4f2c362c8412f9d26ca49131b12ae11c4a68f38c1b4917eddf9c75752cc0a7cb9318322e4fb0c3184e91e03d78c4c49ae20f415efeb005f5562d5e6a5b4bb75d2de97a51a94c58f627454e01c0ea61d96f9143344b0580b29192061ba81e21355d8ca6ba32059730ab01b6a96007b14abe5e7a047f305a874c2ee54f7c382cf9295b6d74a821061baf5a925ebb20e63a35370fbef4e5c3fd49d3cd540caf73a727c6cb3a6613b1fd3debf6b50615c963b8c074085d58ac6dbc15aade6170643bf671f7a5dbc68457d7367206f0b693d31537b12c8cfb93e4767bf5ffbc1745c5b5e348fc908c0052895b1c27999ed601f9ca0a0d88e06d3c3d6ff36102a47035e558c08765ebc76b3f3e51e442ff9b9ed3f468522c6261832b8e95bc52e8abd41498d77df33ed7379a00ba58b60797ee3a133b546c2fe2fcb9a2ec08816ac6f179481a7506c8b88f4c5ad96698903fc80c44f79fcb345f08d49252ec08358f15ca02f76325fdf2cd8006d8e0539bd1fbcfb8cf51542517f51337897d7674059832381f64c87d4349d983d7dc88ad56a788d935500a62c8115c4f212e3d6e3b9b27f8ddd63f679ed357f3435cd92250e1734bf1eaee762f00b9e8f196e63ed1d27229cf1d0fc029c991137af030b4ff3ce454cb17a454cfdd14d477cabe4ab549650714b56ca175c788b029f68c74bc242182ef4195dcf7929538e0039272ca9ccfc0223e2e8d1c3a38b4f17ed79bcc50f846dd04a5cf3165c5cc1e64a2242ab69c54cacc4fef6da5e7d8b252d100c02263593f3443ba74740e4182416e47bd971cb55346a4fdb1d2a5d9db84c698aaab430f324c2436bd5fde50e5d3eeb185b3380f9a0333591335fc5a1ab523f92f270f5d7e97e43c4a8b6caba03eed6889ed90ca3ce4076fcc919d091c86b9a450eb9b44af3fb51785f05a57db3798a5af5f900092920e1fe8d9d8cc56bb991d485b12056f67719c51e6ce08b7a8f3c4fdfea6ba88566990282d8877327864f0dd384285867e0965b1daa068b7caf6b2dad5d981122f73a71a1bcf723c7b869e4ce4ea2cec0e2b398c8af2fd54a633a67e7306afaeffee1b5af5ad7924e632d3288112891afa5b59a09af2c20afe108cf4f63891ae3f7a20552405869af9902f45dbf4b432b86773eadec4bb9e5fe5fb3219663c15ff15b13674a9b38ee4a6223313e45ef6c9ddd432e4e9ba4cbdd32c72293615db86700176a45d765f84b218c7a44e83b4d0dbfba0c9fd3963669843cc35fdab0cb87ebab6a11f29f6f4f6f741c2b5e22b5813f0795ef6050328c6711e7194ece8c72703ca3620973c7e95dc558fdebea0985e3b6faadcdf07e476de702e8c1529e9395b568ff9cf2919c03e6973f7d6a28ddb62356429b4d116fcea03e4828b9fa75522899198dc808da785e41ff5ea022e4fc562d924ec9e1d6dc9bc74a58504c1e94fd8787eba5053067c0623534cbc0915f33af3283e6767fca09619556aa739d301b81dd206d811278563a9355af82a5e2bdc10bd33f093313f4351c76a43f1d1660b62bfb431780590580dfff010595a65ae2babcd61fc58a8e3ac3d0330daa99492a196a78a10e1568a97cb113a9fb4c773d8a7e2cf3aeda98fe5659b8451f7b86e60f4a879e6aea328b5c9c552208ccfd938bc164ae8c31877f6506f2ba78cd8847b18431768df868026085341717b4c27df63837c0bb000a1de640cdc2561deb7958f54d6b9c5bb6fc0663d56e7a32628147c7be972241e71852691a852be8c33ea1aa2c4c32ba0ebed6bf0be70816fc6d9220f73abae770a0ec33dc6ef9c1cfce202813c7de345ef727070fc2d0a24e60369485fa996433fd797f74daacd7567cb9fa370149fd30792ccbd43d9db1f1214b9fbf9cd16d7109654b8d86c16f7a7034c15e4f930e869bfcf6ac8e3d4d2faea34e67fc44588923e5d30d535a1f41367f81a2131756e314c2a8c651ca71a526a5112ec17ab229db4db2e0d38ae6a7b2e8c46cc0c90ed95eaef16de90f84db0a3df68167ccfe680b1d547168dde3284852eee5ce60a0d35d77fcdd7b8e13aef08ae8ddecf9daabb04e9726e5717dd8d9fdbb733cc810524e67622f87f0d63493dbc62e2c47f3ddf0c6cfca2a3b77f50bb8c41db25a517e30361892576f7eaa002006171cbe4bd9ce9b9228c1c2de33ecb840eea1bc570c975cf58d09ddb557568be8c73bd57e36b298ec779436d3922d21c39faa865a94f24ff2a9376ed9ef0eb6ece8ef0479886512abe2825fdc36e6e1f06f707f7e074db24aeea4d600986f595f989ffd4493ce6f7afd6f7d145837e93304a2ce10fa58ce4fcd5a8597c18f21ae9e3bb0953c76080df324c3c41a43ed6fe1665b9c28a949e1183a16cc1b42dd7364e715997497f21d72f63b444f2041b7600d944a403049486e8d5b4da2cdf5ee7586d2434a00cc4d54d6c9ac0a51c3b00dfe0d290971451b13b23c11a11b30d6b61b72181b08d56773b65a8c7d18a7c1ac33119102e68bf2e58b0a5087aa6eb166d73f8ab76f4f519bf1a5069e76346d0bd6a1a3e6c32ca42e85ad734f4dfd36960e33c57364a430593c7557c7eefa0ec2a14e3cf99bcbe4ff169578d8e1299d3a9a87b69b7f135b3a99173241a9ce5cf1fe054c1e8e9d5285bfa198beed8e4a169e88d1536916619b6b0eb01880d5d1d781b6592308e6308ef808f2645fe5d82e1191d71d4d18a32b05c4023cd1b8354765de7042c20ab27507e4b983ed9e9a44f7a92279b36a1bfb882d30b95d999215890196065c0af26d3846b4bf6e27fca1aa7ad241608bee650c056ebedce1ab5e60a9427cce87d636e5d557df98c1827a6dd5480edeca1e1bba90674dfa74f7c44c373683d1d6c18c0f5092eb2b7e887026b3b4b92a712ef5f76f7a41c4e124edaf5c5ea20c84aa804df2ce0d4df2f7571ef0ac872f78dc7ad2c4ab595d6e763250070c05ddd809913650f03ba19ea9958137e6d2c6d068aac0e848bca9c06b3cb675d1bd4a1cd4a70774f1feb5fe0d0f2c55fb3302ed491339adeafcd7ce53ada9e8d1dd279110bdcad74577b06ef32203a51684355a8eb5e36ef4756b54ddce39109cbd5c79b9c2a633f6b25951ff84a5516fac839a0ac213e3b41c0cb8e25263f2d429928d0442adfa807cc49e07202648baed35b3340df40aa5be50b9306178cc06adca7875f5f32ec697057aa0d259328f3552923eb296488154947b769ad2f983e5205a02180490518552b089649b9b70672c61001edc2a6be912bef611b64391cfdcfaee966878f2c55951357a2f124b48688899b3250e2dd6309eeb794b919545ade72aca880ea5d8f0581b907436fb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
