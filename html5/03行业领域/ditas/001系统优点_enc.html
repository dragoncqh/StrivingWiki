<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3fc60fc96f4e4e3ce1ddfba0dd4d70b4a61ef275263099cce6052f1b885d135bcbe79bf52550fbad80ce87aaf32aae91105fbd932cfed12aa974cc971e97b2e728fc594f3a0a38d16f217b3ca9b93083bd0ecfff01aa204ad9ebaa12d010b363a2d008ca35dd02b6e86d7e85f94ecddf3c6ff5b7912b7b5a016383a08d8eab0d5d0c7b861446f4aaccb531ad40c6b37249039b197ae5218d617e59f8d386e8edf53fe97f0c2cce6265c6f73d7c3a1b79643437a353f9e0ab0ae0e8e5acf1ef6a2223b3b77ad0900a249e24285971c6e87b3289a35bfab71d8816b36b757cfaffdfa07d6e85ca0e58e2cf593fd6052b57f4c8d8a862acb6ea58e89f7d7ce57a82c5bbdbb86e421f116c5ca4e2f6afdd7ebd66247f36a942d4f6df2fb6b596ac229d5f4c2876b483add7d247fae50481d79ac40fa7296dd68b141c2b2c085fd1d0321c1243bc148f3875a363e24ff8656e3dfe78d3228d964a9d7bb3b66f6bd5102c06bcde0e3642896159e72f4d1696509025aca13abbae66c5bdaeece1a246fdd84eb568e23c6b59e0f6fc123b7b27233395e750dbe15d4bfdf2f75543f49a3ee17ce579b270fe8d08c0644bbf4aad74dc45b7de19346aa57d70f8fadb82eb591d910965a2cda30481e1953b1828b26803c4998a66baa1485227c4e4d9bfef534bfba0a02c3449c5dfe4c83ec5419b9e7ebb9b6ff45528009c6ce7984c94794c286de57b31489f9b5bf55790c1969108dde6be1443dfd80a165cab99a4bf1a3a06e942cac479136f23c992ba0920d731fb273d37966d1ad6d4a460fd97c30295b5f7758114666508e586349daae7c684730ce9ebff52289228a67311e21fdf184959489b7fd535595857e4583644e4df1917027f6c71f457e6a9af65a80afd21646594468f974224429695337eca77ac4331860c314cb02cede80cc629a5977175a29c0c5692582529bec8d6885bb18569d4a91a9984932dbcd01d68c2542cff74caf8595e63ea2fada91c8c547e7d538b24fe4f2d139167d747915952271721951da40914fd31be0bb863aab33742eb94ea7504913e4ca69b43c171e0d23d62e29e46f0ac41f0f44a58f60bbe2154d46aa8be3b3076f5ff1c64af6767ef8c2b25b2d8b4e0821d73866526cdcfcf3d636feea4471ebfddb75be43a5d46bf695004546da5b14e5e30c8121b19c1d9e5d370f4f19ba9186c56192c982133943802197b2592b5619e7f4c0ba8578534bb20f408b2068b2856d649f76fdfb7391c05a3787a99765b2565ae10a6db6b9e5d6235af970590d7ce08ddcccd725e522a480fc77e46b7330a2be31a4e3afe142095e2f8c884e300e27fb9872e5ffdf68486633b12f661a9d78a9a9d94eb1f70c700cde0dbdd79d3ad07efa6cec910ec0293c419867c74d065acb04f99ddfc9e6d678e0f233790db4b496d7120ccaf4e763290036d4e7828cb6f07447911bc004a7e5a5a956fbc75f1495cac207bd89d62a4e0c2efbf35e2422e9e14b46f113080e3ca122c5bc34aff078375e4565c6cb2019133ad84ab3c7a024b984c557f753e240437d5cb181142f13f9944fdff2dc856386b8bada95b0fa071f7e2bd5f808011b45f1e823995b0adcea84e739e29c262f548e313aa6002cd82ece7bc1beb023e50bbc50bd2613d15fee2aeee01685bbfeedc7188f302e41424425be70a100f5c041e520ad9a6fab90fa12f10a7adb486ccbded2fe5470376dad39790da4ab68ecd836b0d6dba911e1ccb3b8ed45d52e95b521f02db2f5751241266877a9e0c80ba75d88986520753883304a87ecce903e8ce50e9b55e0e5d456950a637850e62e58816ea558d4f5d1e18a7210818791b79b2200b2b2e3e962a98eae2b8d8e0effa439b6c48a5b3defa691536ba82e7e11a7c9cb538738d81392542806ed3e089b5213e944d820a92b918e9fbfdfe4c39a766f1f23454fdf1479b716016d38cf4a1e1e662d12e8a8cc38be5dccb7541f29f59a0a9623058bc9527acb81a3e312cc99fbf2b47efb48880defd27ebfaa85ad6392ef07d58379d9c7449a17ad06cb92c8e8078aff8fd98bc7bc625d7f7be1f58b85d69047acb64ffe811a43c4583f7c7d84a3b8f03ba52b502b8644b2573fa1fde667b4a3f71267f15196688ce774db7b0c87f1d5e6fdd48763601a2c496e7ab38748fbe8c6f7857cb1d3eeb35cba29befcc4824fea339d5f63145974fca57d24b4fab101fe39fa8d7525045ad55078470a23c79055d444f27563c7515a0900291dd927f55e517f5b74027f509f198f5951b805199c2d6a53e4e64079ce95f9c60479e07c85167ec3573ea816c45aec199dbfe28253006093f77ff2952ba38c08bdb3e66a7e3512b4a1d0746156729ffd3665cd2b5438407b284d1c6e916311fd8979d0536a73322c3b6d0959616563e986ee201404c68aa7af02234c323b607c6e19d46b86dc215746edeba7b4e00a5eaac9cc65220984232a83670f84c49a080d4f63432fa683b5b520f892e8f4ef0ccde4219dd817d4d5c5028896b6eaefa955d41d41a2374624679e4e77621631c5af8e65b3dccb17d2ef3222a131f3bb61c6edae057d4fefe480f97142016b062476eaab5fcf0328c627c39b1a94f03ed0c693c7256b4e780eefd537a14db623e7cf0659dcb80a83c639984dbe2bd976c60e6bb7e2b97fc60ccc0d5ed12a65b75c07823cfeed98224705cc0259f23b45368ea2dcfd1fe1b90602e162eeb8796a7f55ed4a341b40e0e1cee8e3003d749ed37f353f8818dcb1cd2c1fa12b51171703b85e97bdd706e0d4202b320b2e89772c19f98fa07d52fb4cd573dae88a597244fde1d4747a14b11a2f7ffb1640341e2b12b93b8d289eef7f9461259e7e2fba6341d1c4d871b553b878d1cdf0016eeca7ed17fe44d1316f249cf8e99a77597f89bf4bdfc766b5afb4e794c2b959d5263524a40e9bba0b4340aa71a32fc8f59290b896a806dcd75e1ad91e69f10ac2a0848a2f0e48d2eb062be81a6c91881e0396f37971180e7a72d068bc04d514017841040a70154fef6ca8dafe59a27ee2e0f344319389e1e71bd70fd23fddd60010b3eecb53f7a0f704508294112eae93cae9ad7d8ab8961b5c9035f8c3bbef202299c5b8f0e28de2599b8494f7ebf42cd6f91cb9b3d4eb11d18fa50cdbef0e47fba3344e5b6d2a84a1caa433d5bc5d5bdf681a7448176cb2ca14b6dd871d7200674d79eab815a841d6557d7df7e40049ce5cc8d106ab5a78fec8f003b81f6e3dca828d2d85e34a4f478686644620b4f9cb2408a8c30aca44609118a77961b470fee6e67b3e7fcf69eb8c2be114a2ca0fa9d5f095ea522e5660cd14aca24ec95afdfb3d871930d2b141b77db4fd9b9b778899de0b1af458cd6e2a801248a0a8d8f24fd9daa6251d372efec8cb4f91733fb186bd50aff3c3e969421eda86be6f04c40af7df43c5f6129ec702517280df40231906c7a69f7c4d59976250ccc0a94bf386cc5b6cd81e5d9c5561e376fea6ed01b39c5125a29706974fd3db62e22863650e8f4870aaf03623172d2fd764070ded9f727f4f64712c938cb0de374b5f26a123761b3930169433ad20f61ebc6b73789b4ec7f6c7ff1b1354ed0984a8c3cf1deacd2d818ceff5fc45eac9c812aefe2e6a8aa3ad77b1558cc47a36f4aea0731cb56ad860c3a9b1aaf1c0cef362ce1b5524cb6c78f8229cf3209b982e08c2afb246fe65675b5d427d906e933240bcf65e7df60e69cc2fef419c6457edfdde503faf7f92ad1151cb0d6a01bf8e59b886bd07b00275893697d225519c2b74ebd0bdae60e20657607ca8f995043c5fc955b6f3422b0e2c3db9ed1ae1a599d9a914eaefb61f77b7ddf5c6c3cf66c924db924e577f0006882d4a1eb5b2561738ef006b4184e805c06f65df705a23a2d97f8a646491e28963bd6a6d4f5e0d09b6ace36b249717a1f53fb2c666621b416c08fa87a557d97dbff38c20ae45211c4ad278b61fc1baf84e49da5437fda966ff221c3501ecb19ff36c59c9dcb35e0de412577a934693e3f1f2d5807dffdb088d5dff555f966c8efdfd8871314156a26cc023717727b54ddbd5ce05ff248cbd5ea017a76afb0ee434577a3e9f0cb3c10ebae09db62fd445b7a00b31e5e7057f971746294cc59488ed4813abd777088e50165063f343c9cfa41303fa2b08bd4df43ac8cc58908e5240ff5a60425f323a7866fe766d99be78d26da07721367c28e1af7b60315523949e9ca8fa0514dc818327e59a5f8472bd9313fee5fd1fbb5ad6022f74fd3db9856dba77a361d46530744955dc525593c8a6825b0ad262f609281d5dd2cf11cf312eb0f9f1956c75a46064d8894ab2f97b7f538687a7e608ebbcc0842b0454cf872ffd93c44df5520825682047f7d3aa287ff1e3ca67685a336712fd970fb02915c20aa6dc47c1adbdbcca419b0171bebc236d87e52f7d446074b95cc93e50c03de6a2d8909bce40c40dafe40e14731b27502b621b92349b749503c55a5d4d4e1d562806c304a7e101c46c39352a0cca3d75b60c00ac0d63ce1ec85e499f152169f5e4e1add813454648e30627e999e997b1c2a832af3a98ddb3e6c5b223be065b42000cc2274fb40bc3fd77d36146f62bddfa5b26dfb30b409e7689f5439cc6ce40f35dd61d4c74f5d7d0e69a24b8e703f3256b6e1df9dd8f712405da39ba788ebaa98879f29d72a645746b542d39cfcf43942ce685f81d40f194a50a9f70f9a65cd9d14fbff17ce2fe333ef5355affb3f241867baf91b6d890cce227c49d9b4aefa987db49b1213da71ab71fbb88a29fee05420a2177fa10a9c626154fa90e44ce94c9ee73c726d56bf59a02dd7faf118dad6c7aac9de8371fc6d8bfb438995ab21aa47ffd91f3c6f2d073ce7f49b2a1de145cb0971e105d595b189a998a0175b68c776259966af21d9061f99ba5436d2df35b3a4bab73c50d618f071fa17f8a26ff8124886ef58a9924f8da5c3a7235d995dc8ae697c7022dceeb706a8ef3a1631d4beda1b20b798b604aa76170e3dbd1d0f15183d3f003af8b9a07969ed2640ea7af21c8d3716c6fcf313c38966a378a2741b2d07cb8b3c520872cfe862cdc29c829565891f9f8e9fae948d719d8aa9c763ecca07be60cf15235f1a049b8a0887f43315564d3d57edea166c8dbf13c604f19bbf99b155521d2aa4ddee8b37457a326ec9764110802f7007193db22524d97a4e85889f894d0151d7a6dd6c1b555b305e8d81e35e1c54202bec8e41828d1c26ec18d97812805cf6f84c1550cdb71c0435facdea116a7e202ebd524961b8d4e0d73c324c2846b79afce21b70c42896c32e1922f9880bf45bb742c33a5fc3535c367051ae73e3b279f25251dda28663fb490cb30180dd5ddfeb3630f1db9ca358bed9bdbec6f07c8f0806d942e253b61cded285c51d63d14d4e88c5b068087f4e54c041ed2de67c3a419b7754f7f79d6b01a6432a899346f2b522f65a8b4db797156a7517971c4453a694d247b3bd071d82837704abdc9560f91dadec5a631de52c1e232648b0fef021a8b0f346c7eaa9a60ee6815f182fdb4c172423ee595744029c1e674faf23ba52ad04232d1d0a76958050a523212d4b1b52ea1530254da0f63752ae6522e6117a915600e795aed77e3bf1ce7bd10016ba7d7a02412078c77e70d1669e464d6a9317f19521eaefc32d87fcf7b3bd0af2170edd431ade54fe2f7d96bccff18b76af88f07ea2bc21349c85ccf5bbe583ae9b079268ccbb14b7c984a89b1edfad244392d2c6ed89e280917f152272b07fb188511416ecf9141ad854f8666c6fcefdf4c9520e09ac993c1ea0e0497a8785d33215e695fe1dcde43aa59104ea97a8a1715d216c9df60eb26d67860b0c21c0ac187b97e2c8e1d274c593c9ec82fca79bfe5e48ea7f03d8a5a0db8c73a4da6a4c95b6394f8685f7717c26ee59dc3355780548f3d7fb3f7e68d9d517f62904972b761b596c01f5aaf310bf81739411c4969121e49a1ec5118ce09f00653dfe2b52cb1604b3cb71c37c738e2a6be28acb08609645686259386020f55fd6c8974387efcff2f1f9e4f7804280de22fb5e46715a93e86f17a6acd0819e2c98e7303a9a6ae5f1d2bc3c600a1d0599cf37fee3c3be6e9a632d0cd590f28c8e7c24a9c1222f9054456d0fd1355422935c5be5cc6d5df7ff7e9455ead6b10c1cb5f9714bf9982eba4dd2dafe67592f498cbebe233ca3c64116db18b0e38cdb9581a207521a5e76c48982d104cb68fb1d255ccd8e4236a3d28d49ba1db1db493416cb15e4aef8b2d8bc34195a3bb4b6dbadeab243b1cb7d0c5ecfd05b5e22a9be141831edd417a0ad423716dbbc7e53ad53404f99d04636957baa30a494fd169523bd3fe771ae563a2f6b6a08f4ec8ca42ec58ad3a3db6a9ad9aebbc9a79c6a29ca0fc16e68473f9c9551c59d68f0f37de399ebd242e3ee7829266bd8985c546b3c1a313983bdb128f8837d6e6b31e57b01157807adc0bd424b9564c136379362be8198fddbefb9e4d5821bc9d3ab25f6a6a20674c86cbfde0322276ebbfd989e4adf304bd3d67875618444b263c74ed87d7e66ea8f775f6bbde0f8f2b3ec4ae00334cbdd90387fcb27202b29c53a2aba3769be84b4e6447cc60dd33fa263ced44014ab106a8459b3fd8cf32d2e4648e4609af6f8c4c65148325dc5822b81437f89d89b52939898cf42fbc24a76fdbb7cb36d0c9971c999bb5d04d8e0f93a59bf62093db228ac7477333fe97b12eb9503767c080a6282092d2ebe569c86e72449ca4070b832f42911da495fe41c8b5d2c1e106f10a0698e15dc915f30ae16c97eb23e85b2aaaeba1e3d0fb5c72b305a7bd016222f6017e7fcedd04650fc2ae0bb81a10b519debecccf5e5d11c7c3064c8a82280bad57ef04f8d382161595d0d5a45623786000b17122a52a3fbd7a43511e3f4f19d3440e52d20e5eb752249fa11cfd67d6251e1f0e1ab6cb78497b1301b0b1f18d9e4afaa856950c1bc66b5d0a82d0f48560200a3fb2171aa6d28cb3b02969e4e603e601521c46b1f24a8d41b9e4b57803cff114df7066e1b602d97bd8be775b325a5dabafd14dcde4703f4576dd289390ab9f0d37790f279532bddb7d50d2b172934e64df06485621785f0590ba90f32979375f42ec5ccb96169527edf67e6114b6ad42399e88907da28f60bc6fbef6210f6bbcc121c21f8e8dfccc223e76857f921d04437528eddd72ad820370c29c95a67fa3bea9be575c4c9b11aec7444ba0569ded4e35dc109c8b2afc0c8ca883716f69ecedc336eefd250f73c873c20e6a5f8cfd68402e45b7ab67c0e8b4a6e357aff07fe959efe3b4e8ca7291a3f3892ee73321de25700fc4f80f94fba044cc414c629654c3c6957cd48d334a3878b51c2ba1e6a52a03d7e9bed9e602376bf7f63cb35acad48e0fde2da79c28067d581bd16180f43092b4a3ac082dc123c8cf5f4f1a87ea0ce4f66997f93ff10ab5e95e8e2d4a6998344215e5d848554feaaea1aa0963cf30b9f97978faaad5de61ef1ea3f1bea6501032816e286e5623b581fe76d40af45ca6c991a0c3b0c270a685368116ea9de6d377680cb81cf4e367d3be2820854d8218d44c659d1e43d17ed8cad4a29580d9251740dfa79c78a493b5e69f9878861596e8405ca8ecd47a55b76b4c4f45db9f17f8e5a2efaff7ff45a941489a59add2f30cf81f692e686fd21250260dd2da8e84d5519f8caab57cd71f4871692765fe9ff16ab54436618cbe2c91bc1ca24d676f84d2b16c4717ffb1c5d1d47c515375e938c1c99a84eacba3b6f62b1ab9173706e3256e3364ace21f509c2cb9072404e6d8afa6fd0aaa230c0bd73c364d148b29190ad7e99cd8cbdd20da5b3e5e1bbb6c42356027ccd76640887d31a941f2e14f9ca78568cccc74e4c536f9d259f4fc1e826dc777f1915a5bc030481ce39eedd23ce710f620e53bba165a8e7aef6f1e6fd1d24b046aa58af3f62c562c25ad5c680a51de036ade226d2a2d7bdf3a2e29bf41e418f4f073154e0d75cfc1081c4b824d4e73ee84b597276a31c982338cefffb2e586511034bd6599d6a987e141c227e4e4a30060dfafe6fd563315b9f3bb5e6999231cd6eda51fbb9c6aae9774e0f1626522feac7c100f430388ffd70d815b8add16505b60b62480ee3d8667ed7552a96752e61ff9c6e82ff64d0a1ef6e57067d33b18334b53a164822d61777cf22be65d3c8038ee04161cc365f47766b19ddfd18a8a345b9e560877f720dddc0b102c1daa2159899a56fde9c388b3065f983a80f5af26e22a60beb4433d22ce60bb885a05bba047a2235b6e948dc66c806719cabd8f434974bc3a93d4cdddbb40e1e8a3f00e50e03bd63bcf2921c89a51a0c8a9fdea986213974ba693b121d018eff94b7a79fc2f10ddcdc39df3d253d1ea2199f5d5d2748a64731d0d12cea384f9f130768735ff098031f496ea1a7ce3487178c92d4502928fd2ddae28bef3ed319c1fc2216d4abe8943178b3b649ae81a87d76805ac89a7b9f02b40787c9af09b85d68b6a860db21c481b284d772f337658f7ad4eca6e79dc3ee8e4e163e91400aedcb41b24509051eb02ff9736cfe3d11b1aa032a4a1ec6192c50a1b507692a5d38c7fed8a6e97c6b484e24e3762dcaa9e77e672e601ad26b1353ba61d7ebec6eb7d6b1c0a844d4560470dd62ccf9e182041bbc776e911b3c3bd1b7ba75984121d53833fe59b9b2442aa9fc5584b36a6a90a3bae93a8a480420f63f257210c386756c6eedb835394a31dcda6729ecf6cfc3930a43da364af316f00eeea801a0799c7183112ba1561d33ace4fc48b00dba3621aa7390f50cf8dce134a030db5caaccf54e73e5252cfa42bb8eebf59750b81f9921a1c6cd0ba6bb1ef9572cdb0c26ed53a138c4309d3c82cd3fff006ff0bdb697aced8a4fa0db0f2f8dc29c8c0d93cae1e9ea802ea90b2725c2581bb3ee5e4c8fc7a1e0a5bcb8886315314deaefe54f79a5654f6df5012e6a699ac1ff1993a2cd5b551232004ac3b7d6fe89e71c7504fcd19ff30115f6cbea49ad22823cce985d03ab7d66bcc3fe215cfc378c503d2561df8962e5fa15c11a88921653f42ef4a7eeb948ad88c649c100b81534559c3b364f0c7e8dd9768538dd7da5bf593d2344ffb0fcb9a183455ef903e222f5044af97787036866844fdfd1533cb166cfab96a56b9973eb6281f568969550c8a9865bf2a203a8ed9459654f0d1d6e713a1615a70c63ed88420b9e216f10b56c2b8ac8d98f2b28b30f118c8ca087bf9a156a3519514fcbc1d173361e7ffc266da63727ebf09a8ea7cb31a59c1539be04817e8077de7b9702cdaf5d1249107fdb8b542b773184a97745495efb9a67413b44770e43bff2b65e18295acde46eb2358d3c92903655695c77db7deb563d46b32ce4b0ebd479524baae04f762c62a47bdf0be8db9e5054331c62c09df80e5c0bbbb8b1176a5754e4c1c859a9a5f7eb8e60d0c30b8db4e4fa3665d94986296245465272ed0a4df1f139a1664606edb2ca46afab7266c218e36cb82f4b04d484bdc3947a188330dff1ca26909c8c181b778e6914f1901d2513764b601f53a62fea6167fa3073535b46380df454905d0e09df2b24e29ab278016f5d02b5a2ec0d5b2cc054be4fbed76d472966df4c684ef96e37f42ef8ae4a1972f47b38d8f19634fb4a979a973a6eca07628ed90d07d500f193579578a98be3f9a9eb98bde779d98c7408bf64866d23047e47d760984f278ce962d6a3c90ec9dceea10007685a20dda057819994181ff1d188832ecaedec06897785cd4a95302988c27478e401708b4b3589b18229877b21e9d05675d2b428672798bf6acfa96ad053694e07dfabc2592175aef27eee753914a858d97d386c121a7d0a91d1d792c91eef05b8ecc38d010a6b10514a1050105dee9088db0640f40855c3479e9e17aed66bd3cb51efd6f01363ec109007a8ce1eb4db07e69f34c84198f12dc0cf878eb23d89e7608aeda4c249d83ef28a44801f2077540259c6b080657523aef2b1fa8c9bf829a934eaa6f2ad7fceb142d0da6374e734539d690b10f97d6f6273b609443e7545ccb67a34eeba92305efec7a7a95817f7692ae6adda117cbbe5a697d589fe559a6099ef4ccde4cb8d8de2c47c467e9f8d5adcd675c880977d3fa4a2c280087ddfb45fd29b402322f2f04a86c1f4619963590b099ce01311426b6ac3184f5a627fb81d13c3a8536bdbfdf5901abcac92a7c4e185478019005a66db8d2b02d3323eff6d0f37ab1e56440e8840e7c035acb64902685b0166e2ce2ec64440367981d407a1958b0530a7fded99d94602da378b2e01e241baac96a9eae96ccad7cff460b20e8f6e6771e4a58278925249649a0d9c5fe7a2fe12eafe699c8fe80775013d83677c89302b34d33774ab9f25b8f58cb3f66c402bdbeb30971a7d7bbb813954c8f828492eff5a0db11e8eb24299d52295fdd283bec54e332ffc22165b0e77f4b2376207b48e687a17cdc36ffda3bca84b76f68812ea2c4293a80c9bfc0f37ad2f754ca7e19e339e25da5e03551a1329c03796946710306d8549ba6d5ec2db55fbd1e4d04afe35fa07ba79810dec05754ce870407e380e9dce54fe7fb208d617664329dc1ed978eefde020ba20e6a799bdffa8891888e6c28fedfbf0dcad8eadb37d4351a077919fe862647946a8cbf71420d3cf4341138ccac252070dbea922e3b779758cb4a1e1e01a7b043e44716ab9c9ebeb509580ae7263aba67824083c0fa4bb4f09c29f0bc927cb7fa5f28a2426ddc89cdd768465226b9eca924a56fcbe3c0773107837cb735ebc1523a08f3aa49b96b5b65258c39296fe1b2154704e9928b2c6fc12c4abcc78681c22b7357ba5cba38d6d40ba2b32deaea2107b42dcdf650534efb308b8ca9316dad9d4dde7a07ee6b6295eb6a113e01605995ff1d29bfc9ba9054b1910cc62a17e080fc829da0f9560cc04c6c29f95e4ac0f29771c266bd9f12d8f20ff928ce3aed70e78849537617dbdf258302e6086ace164671ebbad5725f52c407d8a90b44fcd4163933d7522af4f106c3ae654975cd81a978fe22621b2860945938c832bb7c6485485090614d6e9344e0ebb881f2080924086f84873f727042fc27e793847f155c8a20a15c962575355b6114ae7bce54436e74409d767be7b42533e3716c4896cb6e3f78d70298e339466328b055a9b95c29f3403fa0a51d89b1b1852ba65e843f9aed804a4567b7de1666f8648311020517bd231ff8960a354730fc6dc3537a20249f6e99efab0c80dc6db28d4c15518b81d9fb85088d47717ebe7cb6a89ad9419f87278454908ca0071bff04f0cf96dbc2378712876447b7c1e6126d785b9d1510184af0cfa65d19978a180b59e3e989c622e287f163a9f249ef0ad374ba9a43ae858d3f002076f5a24a78ec2ffe63786aca685386a352e9a63fd06b6c141fed7eb5e91434dc1b0162234fe17c0ff8ccba0981bf1e825bfffe1e1ce165170d0ae1b6686036289a3ff849a0fbbdf1d5ae078d586bad318308ac85e8c1f59ace0bdd9ac2773a585be30feeb019173f3363835655cc08022cae3a2c91bf15233c3a5218251186c35f364f1acb84437ba917abeee1b0b007bd1c93fe5eec165e7ebef268910c6b45c80e66ec2fe60dc69e5d82c32629b7034dbcabf70921e095307dcf57b4553e0ce4f6599d700b3d37dc657a277a8fa722f78f9ae30c0cbbd7e708979c849ac9c5a6c8f33439ccf976baf3af3f6dcf8abe7f584e663d22b770e7c71a102657affd3b7bbc64d8d7fb95b5b3f655f6cf08d076a672490750ce1341da6aba89a599c64928e6ff43b4b282e080b98f375494bdc08e082fc5818ca3aa65dbcd8eb0ea2d01077977f8f5a501ecfbef7a63289b407528e29895371e98bcdeab6835bb4a1b9d026a6ec99ed3617fcf845f17f4a038157bb9f161be05f3a98446c87de44d12e85e5c0bf93424de63f3c1a478c8f27b6bc3131400cbffa91ddd4e00c0ea6b6fa880d9a8c4c62146380eee69491239db817bee4fcdd1826ba5c3f8fd2282c246c6959adcb498aaa8eeda634460f40b2b74c99d72ce3a20e3637f9cd6edac34616d82a7e32d18224e73cfeda505957f57c5ceeaa26e162ee36c1251f18f62f5fa0b84aa46840316636ffc231591b90c0ea6a7d0416165a9694bda98e247902402f3e696910275466df53937c64460dcc0ed967be6a58c21307fe0b4d740619f673db3c4a7303e5a7543e029cee3ac234c6893a33c307903fb19793cb2882ee757ad9d98ce5b91efb619136df09ee8fc41d0099ed314f1e84fee5c21f730df183b54891a94cdfcdc864863aa7c4a5e5f63e3713e36b0f26f6de31e04b770510df8a26a1aee647e3b46060061ce873bff9830745b99415d100ea36a27d71e4f861231f0b86f0aba68f0779a5f7810515fddca942841c366526f4262a21daa985136802ae1a4b36a0d7532e97b80033f8c1e225da247f0042540d130e7642a3142d58d07f5f0caf3fcefc602ea8c2b1dba5ad3290bccb043e3a9f1c6ceb474cc3f5da9e5a2dac83a8ed338e3c1f0f667ed0cfa8aac80e2157400f5907fffa52d16087f181573c07ddf8683dbc6497cf32f63e1f4d62f6823503d1fe219aa7fcf1f16435e77e2e899e2e35afcc2f72edbbdb1b919e2f7185899158586bb8eac2625e8893dd8b731d6380b029c6b9be0995334a5cb05f6360328c9f9b1b73ca0a5eee678285471cfd861f8db81e0af5e61f862315b4d23573d435bd370c51bd8392e79afdf8e331c0f109f95ff44126e165e07a7a4e7fefb6a33755ce993f70517e741994d8b9771bfbcfc7f55afcdb952157a769b4e2070b3dd2989504756935abbc12a7ec720420aba2799aebfd5f13471a4c6e76b45c3460f15a6e702396ef074f405abfcf1077c7d3f09d6c703a821ff3721fef851be8c28e0580f620fa25400af48e88855ac18aea6a12d25ec6e56a2b15713dbe75d258aee40dc2f438245ec817f0fc81e56cd1a08896e96684d57374546e96d780546a418249f9cfb739cbd63e7a3b4c1c7359955a3523656a7c85c4bf642e22f79d568778ad4b820e27e720f943176e95b43c0112a8cd3151642bedd0229c271dd2480f73d600be7c38a2aceadc9e96d3ce3f9283a7325654999f5be0e9fb044ff8f503e70d03c66284869a0b2d33c971cb689fad9208d37f826ed2121815d194b5a88e06f055569403b52303b541166862463bdcbce0767b18d9555380efabd224eac771a17bfa9cd9bab305fb48ec604b96c47afce4ce552c0fa227eb7121e176b9d32913edbdd0b4c8629babb314db69ab073a4e72c574bf69e86ec8aa206de4698dc0d076e2e0289d28e97dfd6efe32ef7a5df1e1dec4a7e07c6b4c6be2802ad0b3ff080cc80fd742c3cb3d0ea866d7c219f5aa6ce7c061815a08a61ba8699c5f1bb75391b195c90971b57bdcbc2aa8ac384f918c73c5f61941776f561640fedf287c4184c45964e9e1aecf7f3f95e7cfc2d390ba3b7baac11d72d3382ebe0cd1ba30013bd2394dee9e279064f6b9581f8afe28b6975c04b542a42d2c7e0be3f6774cd28fc78ea3f7079052d099b6dcc77d99307a6a4310c852d5f2c904259dfa145ccf1d940f2d44077efcc8445b9667eecfb6d56b07084bf40f01196a4de5a65ffeee99c053fa2669214469ad20c9300b8700103814d71bb298617a9aa6bcc708cf2eda937bba654b1b1d579ab3fe93944424dfb0cc8950d8e360ca1ecb0c824fb41a40ad8aafdf936daabdfe4b92a7b2e0adcad28a3ec346b8157bc8c308599e05e8e4caca5dc082378f14947ededca96fadb80aac60b07c65f0aef915562ed3249d185d057384830e59a0a9f9f7d1665c329e9e76b8b008053081d3c638641cef49eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
