<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93b7a73873bce5c3e6e788df04f2d586f3a5973d1151304a52512aeb90d891f4fa4a958474d7c6c529c7892d8c92a2062780b73244bf98a66aaee21d739180b2915d3ee5b691f5d50986a40061a6db03016aa316d9b1c8bc39bcf2e5375ed181b2db8017c81413747892aa535c52ff465752fcdce27744b27b6243a866c1aefd706a69869c52b8ccc73fc35c950599881365ae215d3c0ff18d4532ba5146bb4f820b1c5aad44e1b73824853bb4b3da43a724d6e67f6e48aced5caeaed4e2270526c8a0774e4d4085723191c1313d2fb5c809bb2b94728a7a78b8dd4b0801a198644e842ec6f4132cd7fd9d8bb8b9ccdce56a4ee53fe4997fc35965bb311572fc1417dfa9df789ab655046860cc8fc58684a7e174c052de43c140b590362cf580d17ebb5f222d992f4673b9850561391a4ff98cec3e7aebfb3db821914643b0dc83466dcdc09222d117dc5e2e4c4a7d8bbe0a696a6b0d1c3326974bc967858a6e31247c2c54494cb50581e67dca8ddb3be3b92eae92247e2275f1d896c27a9b18d8e8b8d3c579b614e1c70b56b395bf59f5762ea1bd313cbfc9ec7f3011c9b4cdf5bbf1a424b4fb3e4dda5bbc788c8eaef30eae9121fb75db695720d2f035df560df697a32a3ba377928787ffb3b2b7a8a8bd7de6c76776c21bd526442316d7e7b2586b737ebdb0b9c646334ff9d02dc85f3ef4a8033ded0770a7395eb7320ea30b6a6d51be1fd6c51d26231efed58d016be8b204b35e7e17c04b03753f351e04a07c1199823d69e28b7dc30869734d4695a53f4457875affbef97be3d0bc1010a37c3844dd62bf725121d12d9c9eb43245907287219e6671e416ecbbbcfe21619b3149c6eff601a8d0fb57b0d988f6a0d2d35f129e9e8905a2489a00e82d946908c5b12a07dfdbb5784cdbf9a8a84050991046ae91b69ca63432062930b0cb2b5468e4d922eeae22c1a586695e249c3008c8351b02d17e5f972d9c37afb6ed0fe680b332a9724f84fe61f30d7abe0400ca77dfa7b4e081a2dff7f68dc23e90feb26b9f9ed5f191b98f4cb48f6eeaac75ecf82dc6ba6ec68b56c762f54e57d5cd904aa64ee86d2b3d03058e848df1c24732d3d32e7cf327d4a0abcfecb28d46b3ba13144157b101ab3736b0ab1b286bcaee93397b603b7fa7b7630d74cc790a47ca5ef14924a7f327c70ce291dd5910bcdbf0395f3a5baf973de18bad17cfed429a1dae08c47e670d3fc8e65f9bd76708b5861d0d6e11fe750b92565f626664b2aa6c566a392f7b7ee6081f3ce9f9e60d279e537a1d1ec6348f560da27e7fb8ceaef635f485227b3b206a53fa3b18d8b8ec67429c183af8e1269efe47df5e1dc21c2b0b45b0b546595a627c3a62defed95375923e1b7899e8357ad99fea3ffb9bb232beb567241184cbf5018207206aec72bb924cd54c064c69ff711950a88193c6b7affb3ef0692222630016db1e4ebfbca04da73a9b8d15d12cce5304d71164e3f1e6c3738a146c05259bc5ab4e56d9d224c8d24660cc9be21b1d297239bc4f841259a9186de597a8d0cfd834efb5f266d26effe5ffd6822a462ad56898e97c2354ba6a34b4d1b7685cd1d27770ee039ba0b135dad6b1294d33dd11fe9b19c159753e172d48dbd87f82ecb253a7507a0221a7a077e2fce77a02ff7a68395a524416e14f32f27b19632879bbb115edd51f83935d01a147df4cf079f2cf124e7ebb943d77abede43173f355ae3954677817cf29a322f5ded65b479336c84c97dd67383726141c33cdd227d44364e8a87c0a6053e016455ee99f2527e8d1fb866e0f1dee599eaa492d0e105383674fa70db08aee2360fee8ef786314f1fae54581b4ec77dabbb3625a20b70f29a151829e3dda8094f55cfe2016ebe6e14b7f740780cc8e2abb4f4cd3fe20236bd3e70f499f14148b4f04fb21e2f96dbce724252873f381f84263a68b2e2b378cc584279df843e7eb23eb1f092813517090de76b9cda5090f8f89c1c0f198405c0fced57e5e1566110af38a56568540416f93b4662d3a7601a2e315f94c55fbfd5741a5cbab67812c0e32087a8a0d0647d5b68c006101281fad3e5dee52ec9976cf8af159d268ccafbd82d58fa63377cbaecae196ea56e9316d12e2101cc8fefdcc0a807c2536e2a4d0353b0c4f8c1d63dbf00276373820017e6cd904897642b2a4a6b38dec496ce371cbaa9433d9757d22ea900d1f23d956205276ca0abfc29a731320c0da986f98d50767cfcf1d01a3f60b2f5050dc43552ab993162ad3b5918dd71f5017d98d2778330afddb2648bf82aa5c636e374c180243ba7280c6bebb0d22ca85775cf6ce2e4e8c4ececbf74cf020879f722be31c23b7c5364569412a576bf396afae5dc83881c78bab5e10568e9850501cbc5294369728883fb7a718204704421561d61d0ed79b7463d6d3b86ae0813778971b3764190840c60691939a12a7058f43f9246028563d0667e694b26862ad38fa74b80e8f03a5b2d2684e100ee41561c11621d93762725712024b512b585b3e99656231347e8d0b2331b9f7c1578e603745ab09edcb0fbc0ae7d0ec7377a3b9f045ad0821ef6bf71967d61d1f37599e4051cb61e280e9a76c21a271573fe4368b3122cde48b7d7b076ca3467334cec06ad55fc76816c91f0b8a227830630567979b69158d7fb25f9fb0beb215ecb04b0344a2ffea9d1e279f4cf8e44469a52844151c1191b7b18074bc5556e52d566dfef1017949c95fc882f5d04170cc9d92002bf64f4dbfc01535674b6eb80cd45b9d669ead8b9a3e9db565acc18888286cc7885eee53c3594bd2561f96be47499af6b849f9a5d2e553c5b1df0a32dcb8f918828697df5c036778c3fe7bc8fcf5afa04d4939055ea2e0131d8e7e6e9c1ecfbf9416df04b57e1cf4fca3cf26fe2a02860a7b160829a08b124d09cb96f74c5396c60157d8a73315ccbe1ff1499541460740508eb92eab05a805b91abbacefe13c9ccf683a16e7b8a01e231e7c87ded7e5414fd80138e741bc27c5d01a5d97e2bd19cd38d92d227caaba8d687bd4ce51467c7ac6728baa38cc41a78cda1592a7205a41bbba39b88178a51f0bbac61526dd666603da05cbccb7fe029d485c4707e237805f7dfd45ab8b879676020569c1cd78a916d8fe4ad6cda9426319d1477c985c22b5b815e8479d2055e9b50d99f67eb56e52b5c8afc292a4fe356bf02689337f228bdc3aaafd533226ae54408cb96b08978f8c0d46809f4e0d8b85ea88a7af1af50badb94a0a8d2deccbae7f6c8d572bdeb723c2cb2ff60c4185a09db16740e12b7a969f7c85b8831568e406e8a8b158b57fc667311ceee09fa0ac25ac7cea4cf92ce988e1524181ea22a4782cd8a36d4f09c86e80f867a9948cf473ad7213b27610215c2f71ee1b42133cfa35cf08a768a8e2374311febb8c824950733a696b25712862ce9f8479e399f35da3456e3e3e494304c72c1418dd6823311bc645a14ed32f209564495128ecfb5b2aa8c685ec0c24d1210bf3e98e6a20245eeb8c0153be3c60b3bf1ec7e59d42449cabd5893d375f346d918b05d291c5f51abc253a963aefca57891916a834e721e67eb99dc35a705822803a9180d40835b38b89c967743f10e4f724bd379ed2619e4f696a968a8ddef11e0f4238b07909880df0400631f9d7e806344ccffd111e32e9561a7d2c23ba80f16f01b73e6228379f9606cd2dcc5b669cfbd889cff6df87309aea7ce7aa238c1c72816b94df690296dbfcdb95f7ca0414a435997281658d1e88bf4ef92131c82b218c4f0ad0530bde66e9def62bb8bddc4048e03c3c9e1d4bfec84d10933dfd6ac2e323bd821dc0c9af7681cf58aa8888996ef173d63c613f02af2a935e274293be4ac69c7c82894b22b44d094e3c62940ceb9d76fb4dbcf9f8fcca0250400885536874a95f1704045fd4f1e2d28b190ca2ce345956ebe45d3ff05c90d8559ee807caf8e90be98e6908d2b2744cbf564e9af3f22454ed8d4c2d05cf181dae1c679db57698b808d1e6aae641174ad2062f3f4a90950330bffc4a6a148abd230da5513e07876574462b752f9b5c7adce791af803749835e56e45d8fd582d56da25c9c7e327c8657ab6963813553c7092f42a9cadbbf06357c013e47b520e631577f29efbbbb80c1fcdb2e906d839e3fcbc95d6ec591dbb97cc8500dd14e59309c9ac5420e96321c2fc99ce803de8c17c634ab16676fcc22d2e0265067ca0a3264abe0e755ec33363c7714a23c34887442d57bebbdd0729be530cf08da1c103a18f4a649965d6051dc71e200ae97e486e3f7e0cce0ad6fa79d1b9c8130dfa8c648bcdcce6f922c4ae2a75cecc2787ad6272a66875c68b5600ce24145c443605b476b1a7d4489b69f4326a5b10ecd442caa2a5d86d7893e9055880177b642a47f11f89b2440529dff6783aff27c527d099fa9032ae2148711d7a0d3e282857251d6473c8f625a38f9516298a66700fee04a88f32fa528c63414a52e307a371b8aa46282bc452285adc0c7c21f937b81d3721f366f022faac82a9a3226953f003018f04f46ded7bf03d1e0ec6d2428bde36c9d7cbf4cd5147286775c0a8da7c0a62a7a730e44c67a1b60d1b133bccefef19dbe7a929852202c2efe2df9eba00e0cddcec385dd3331da28cc90936843a3276b913b4fdf1b6114ab608a15eac3f5a4c4258c1d3f8fdf963419395e4f961c3ac3a9103b846ef9255ee6c4f0746077d76d792cdd667f9b889fab20edcc38ca7a19ae1ec01d75abeda3352784b16a49db9351e76d177e35b6135c27e7b9cf6e1ad450f7158d706e9cdddcd35426c29a0664e092febc293d1bd2cc9661b7b268f548039d0c438c6b64005fef00fbe29bc82f00d1b7cc796e7f0a12920c3bb29fac944a95a275e61a0530f87334ac7a21cb34ef4f0af1cd99247eb19a0d836c3ba8a9e1181224c95b40086e0db24e1c1ab2dfc2730110936713ac4f6c3fe697a15e57a1a2547d8df41f1b3938101db22e195b5fd2aef0152a41b63257afeaf10d8a6bb7b45f4bc0b2bae5e0c336245d61e9329d1ea685dcb73003c20056caf13c591138941112cadd12f198e96600f313cf8f881d64ee8ac2a08387e208b1a508d9e7291a4def1b0e41c68f3820aa0ce9ab59d0b5563547f3a68be2a37a5b18726221e3733830c037bc8250eed5684e93c5ad9150e430ba6cb5aea1c4d1dc3c6a9dfa281326249899f0de9c28a9dd30d4aee64a02689420d39289ad8f7ced2f9a23f028ed02fe527368ff4c8a45ba821897e080f26a2458156ab00a665a79c5f0fad9566a1b72165d7a9a5308a857dafb83cb906b36b94dae7093d1cd308010ba2d9a57187a353680fb7799f84a2578a792a1f4505eb021366ab02e1bfd65c87e3449725b5f832e827104a1732ccecd8f445efe56dca4659ceb95fd1f293644c1e91f9501b1f1ed411e218e56ab16bc378f3132186c17f0afd338c63976c0a23fb6bb729b421ad728562bf1e72fca1945d8d5d2dc7317305f2bbf9a04072f6bfb535bcc5efbba2bec939352c15a2aeb6af1f03b4003e6b3722484d29f89663d6eda57ed84abcf837702500d9efdb9116b3d0dd303864527486c4d64cccb002b046b797e644ad0176668f631ce5923b16a7ca29f346c901c742a34ab0fe1fb8dd60e0027be44848448b01fa2f388ab188bf684ab3ae13e6b889412d56285c9f46d496b01c8a391ad9ed4856f60d290f0cb9d70dca17fdb52fbf8e5aa6e3de1f408f0225f6c1f222f13324ff6b7d0940a3ff1cad5ac7fd143ed7d4dfd36b35ef49abe8af8dfdd90a92ddda542cba85499927e980273a089a6be3b1cfba2e297568f622c08e4fa9e11179e567802ce67ffb2692a6c7c3024fa20556a321259bcafdef625382b3fa0372da954371aaba8c8776223ea9328ebaa198f861c92ed7b25eb469c248d8404f9c84dc105d0c1cc7e68c052b6775fa0fc6ade50756c38f7196acd3c7167260bfbee814e344d007b09592113798f841f0b8a2f7b2849daeeca31508142cc624cda27c6e8b7b8a294bf711c3367f3b04a15e4cad3b53011f2c188302ef0465da6aa900cbe6a899ea9de9a455e1b0c2bbdc6794b04a1f19c1851cda9fcc7c6834c1494d4a4b7a07f61e6e49a89375af04d8e3e7eeb4b81754d556e3cfb59306552d6d1a1c67257de2781d0ee861856aabd1e194571c2b3dd42c28d07a057d07d4a94740f3cebfe79805548bb3697029d341984046b302823d3aca0a85e0cc0f5351294048ec4f4cff344436e98435ab44053e687e0a7889741d269a1bac250dffcf765db5cac7654cd89b39e6118fe5395c7c3ee9212e6f4efaae3fba08ef4521ffa057bcd873ff7283e471ff12e3ce8c1445e927e6b6720de3470fdc33451caa3df878775c1285a93ad84f47e742b7d73a452fba70a0cb60fd3e8589597ebee6bcd0cf0412c7c92e39db24f4ef9ebf195f4a18f934ae970200513944efce3d990c8a6221781f011ff118b632cfcb31e4ebf0e738638665c9a750fbefbfb984d0be41f25f07d5178c87129006f140650d36516b82944bca61d8eb15da1e68596424b278a91a783321bbb1a66ac26d3d7cc5a4587d365234b51876ddece6b87852acc04f9597eed9382779b9c28b95995dcf31142b29199889703ede47b2caaabb2ca505a7c7d019ac9921915ee0e3f3209aa9642b887e340822062cfab8a76a51d942e5f58546d30dbaec3692e83d668c7c7db78b6cb39a9e2075ea024d7e970e3518ca63514fcd2390359b7ea45aeec1f5d2117ab29b3351b525d2608d747b3eaf3d05eac76393f7b68846ca309d3228cb9c6defbea2dda8c03788b6515bc99979eb9968c100293a3938d174cf2f6690bdbf9c497b23bb1fc8fdc0483e666623db3072986a3cf4140b59323f7aad468935c89c3c9f1752002fe41590a2e3368e8a3ee549732e25f80beac00b6d2832e87ea45bb0611e4117dbf8322afda56768398b47e5305fda2b7f7f61da46792f5cea214673bb2bde36509c40670d217b36397fff72c395f781d7ecc3798d32d7f3e812fa61a7323a057357245baf23f2b6d2016206169e5298bbf93c077d78f1621a1c8f57570eda7dce0bed4c0c700429d8c1efae43e79753a7e0478470f16161e822987a121386da3313781fd45c3256d81cceabbc5344155cc3f3663535515519361ab476346a26a011d6fb68ec107e23b3aae9029a53fa53d650aa94d483d9fb84d7412f1cc7a91da04dcfba8385ff90e1cde58e9b5365924ec3ad74a45bf0d776a1cbb378e3064e333e2453e693e4edb543f088a28c1ae2190df448911804cd5e052beba2eaaf82477d9167f017af7a3390a2db3679292390770eedab0d9958788b4aa014c19cc54c5502f1135fa88c19c53df71495229510fcf8e8bc0e1fc8b0691b04a1be4923c318d92d3706d8004a19a34da2ee47720c74a179dd688e7f764d7aaf35006d8ec6c1f558508890534b314892c63a3d05ac85f2714a504c2987c8d3314eda9f39fe0655e981826167d69cf6d8a8f58640de8d91c0bf98fe7e6d46e5b0bf3e9c4b8a9b4bb0de2c60fd53a8bc1f59a6343d37e45e3f3458e821a9a946fe357d332544d625229b44ad48890d1e067db5feb89a815a6966d5c8a98b60a01af5877b5681bdc4a101d9cf679622ad1437143bc14c2c2f7cd52799db7457097e80083d43d58af84ceca486659ec8d6deeee23cfb53ac809b2be1c5ef7517450a562662b242d170c7d5f18743b11c192d8162f165d68dc57a6c440850bd3c3a77a920ef16a69ccb4ee0d3c257aa7d49b563ca1e79f5d2c8a4fcf211b9bf03537eb6f61896dfa4b6244c4928ef3ba7dd1a73c4555c1ddedea67ea1a54dc6e4272a7fa833acf9f123a217f29972fefdae95061eef6ae5c1773b3a3921d657f776ea05c0437fc87ef2f1e5bd311d48d49bab8b36887baa03ed6ae15e6dc0501bc74e7d15620cdc5fd0fdddf8801681ec21f32076b13b9b6df63fb2f62a2758cdc9d960d7cbf19645a1ed7dd9392f87d457485cd2918f2b92129616df10bc096f86630cc972290ab74fcdda251969d7ff26aaf99311833651d5f432a43ca6a829d6acbee84aa4d6d316225ee44a4278df7a85ce466a6ce26074345b50e65bc36668d848feb39eb6c88ce4b5296383d56e27ba77822fcf9a3d31f5b73c41f17f38f8fadbe638a6e945d0e1054211705089b9d57ad5abc79ff1bf25ceba96b4b6a0cae3977ce10cc941fe5c413612f9d94a3bd311733a19a4deb0f0628d9299c42c10bd0e696fff01eba1250ba9ff56d3caa7e65f7582a856989968492ad3c16a381af75472fc023f2793f6bf4c7bbf69782b37d44ac805ab761c0e4c762d167a83c150d89052303c47a7c3a4f9e4250f612f5e41c4af46ffaf604c782877bb6e0b0c911314124009830a666b752d9aee07f3c2c2b80664c38c4267fa62e4d73e3d8f08d66b9ee5bab1ef7b87f7216316248aef01fb4908ee748c2b7bd58a822a73da41099f1064201c7622d68b17f4f5892f63ae724424ef3333f36dd0e29a6e2613af2eebf92e89ea44af45268e90ba9a917a2683dbd15dc6320b7dcec5589673f680ed1424fa48974caec288ff968dad9dbca2d2ff2e0e4783e441dee895447673f5e77da04fcfab3c6013baf67db38f7e2063969caa4cf83c0e8375ba44f1494df55706709d0cdc7603e72a1dc94e3a4636cd14721f8f3c43e2f95f3a73d404e2bae7da82d5b6b1feb0da8d6ce4690ea2c96e7b734458907518f5b552d6298666d7fb47da44cbe685836230b34f5907cd1d87b41264d9bd5e6e7cf1e2e6b3d9667af7ca8aea064ac36cb7ae9821e88f6dc81de5f6ec2d5689bed6db3c706d1f1beedd4e23a782e68dd8d7e0ea71a21fdbd774fde44e685108a657b6661a223ec6e4495b885df194b4507874da7cba6c4f05b679ecb99ca4631bca998cb6f8d3f3bd790f44648847e784fa75749c65db323db201c746df9338c3398e3158e7a4282e938ff57f9286a6f275ff11dbf1ac979707a3b337dd7204d5c2b5ebfc9c7d894b0ef930d660a2a4f9888de6353a15f11d74e4f53c27c27f1f1b6883df42f2cdfea8ddd45f93c57d48527a86e5641f35199b87e0062c9b6efc284ef4d00d851f537f45f5bf0e694b61a22fc01f22f620e26b384839353fd2e9adc8f6393c794b68fbb0a825dd60eae615adf239e1be4cab66f002d205377400d20e429321e0d48","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
