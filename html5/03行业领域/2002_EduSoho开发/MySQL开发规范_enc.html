<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8d296affda6eb596548f40927c0353ed14fdb76fe8f86bbce43c7186fb1a3b78b81b903eead532ad232c9eafd63580078227cf52cfa76196a51397be5d89e19b4b9e769de67ed39b17321b3eeeef470bbf76bae404f94fb49c78668f5f58e606964110eaaf131ae87092bb7f18de241bb4df6bf3b6c1d8407c2eb98f420aa4917dbefe20761e1fa14343d9b3c34b60d3434b4ad924d0bef3017fcc35ceca56bb49fc4d737b2e64447dced83340e4de48a45ad6ac0809f57ae345d06f0daec8b6cd0a6e6f7e2c82a1eb2b371ae34be1d52e1d4b8621365f92b0e5426c06cb2a9a6f90a61df1088ee675af640288cfda0393feae6f5c1172a28cf1511ac68871341b2b9155918f0e46c8ca6a14adb15b1307bbb61c5568b448f93fca14866327cbf9beab08814071f83ff040f1736337d7f9652feec37368f5df1e2c88581adfdb4a7447d8b3598ab154930ec7bfadcd946afa418e0c0e64b58af3757b5839d86e46481d6a23ef331b7c438944d2ff4021b5c46065e5159cbdfe614449d13f99de8532576d63bbe16156075bd3180a611c5f0580de88b963c221f1291c068004b96efea21449f71f6249e1c33fd13dd9aebfe5365bbe2721c7b1754faf34fc23f4b291331adc53ed26f0ed16f8733873ff17d0fde2d745a2e57829c05b786c51628c0e7e2ebb32811a804375399b67860a2189834c11f148f6f0dc2d926a95458d5219dcb412b7d3d5572e5abf1d794e33192b37e2fe197a10be94ba046e1bf60c7f6116884b34ef169277620da2085353109b74fd14345647455ac33ae1c4a023ddaab2f1f0081da717f2501b92d9bc96be0e8241ef09b7bb611e542b654d564b46b26245d4d3bcf48e68a08e55cad6de5bc64207edcbb8ff436428857b6250e896191fdc4a01d714bef3f952ac81f1dace01215f93e5d7f9283fdc1262fa3efa70d52085626a774d8ebd68dd6d32d2164870988026ef86db9e358130884de76a77a2c1919432647547c8cd1040677a673397ffab465cd58c602fa7fc1c7400803d36897a02248e075397884a99d714ed8e59aca6ddf8142397707017a45162a2baf54a1da3b4c1195999c4b016959cb60c755e478dee40e4511ea77970bc3e617afa475d9c741b8ea25d40073e3a8ea4dbaa90d213cbe998db027f509b87d4661895c33eb8136d870308c5c8371bb2b24774d01508e659a802a3fe2d0a58c427b24d077b82085c0372558a8e2c83a37f91983fbad1887244d433c874c818b0f74defd0390312a6c3dfc3a3ecb02235fa7092ec40b046cd0bf69ab59844cab80ad2e4af71a10121ad141eab417547341d257ecf920f76e592790d821da7dabc91c638a5e0070d8d5b38394c6c22db1470dde8763f92362d428a0819fe9623989a51aa7a526040c27c61b67003ce65d9f0a756a37e1cda596f4f3e6531a4a57394f915c5e90572e85f95a5b4fd9a016423ec1f0abc21aacd314d34baf75603bc2405d7156b92b4d6a7eecff909fda0ff8947f016d4fc36b0c3b574a2a0779bee5c8847cd9b49d79c96f4ce3968321dfa40e97b1563d6a66f5466ec7007c202a5c09d022bf19b453eca47d1a47358e8ae34d553516f5cd226369e77e036610bd91680a1557fd0f6066c099624d574935360817017162b94072be058700af4c29cece9a883508db4a699077bbb304cc5282867765aeb7e46e36bb101fe5fa94d6919226d4d85af783350c2fe50b961720c9ca2e9bf1d82125b30bc2e9c79695b5c9b12b6d968c14b789779abab1f07da32d0ab14f55c882bfce7122050a043e61ac089ded660393ac5ab4106c1b91764af38c5dba63d0ebcc5dbc3fb569b5e44586c8f9d82c74328022ec69204be9a38e211320b361debb338d81fd8194b38cfda598e8825966908877db6b0be82321470742f555c1950c765727b517d351fe1f6d44ab9a556f89f8619ddf86a92677174bc9885ee02fdaef6193f06a910cf2736d21d3bd6d4d8f0cfe55bfc02e83dc0d3fcd94a04d6a570cf6ee8a6aced7fedc20b9cadb71ccca29735fcb1fea42fb5781c8fc38d4abbfd2d3050290efb05c09e481cdae817174ec46aed0f35e2060305df518783f89afb6c019cd24d7b7947fb2aa3a01d08d8ed5b47c56f7550218125c3c45d72c799643264c994a76ff1d1a9fdb4aae1a6ba9f938c9bc50df1fe70babd706511843e2fca1e208f7e38e02ed2b96a3b556e560e8468ceefb5224dddd6a51598125fc190526cfc61849af5062743b17abfdc2b63a17efac1c329904bde7e3e7384ae1d010f158a9cb15533bee59a4e2aa0b3f3f8bdb0e8e9e202a8857abb5009b4577045f73305eb8ae9285d7bb728b408ec49d76f980515d39d553f570eebfee10ba3e2d098aa5d24782d712f9e7cee4f98997f5b61a1d8db445486e40dcf0d612c566f1267cea4bead66188f7b4a652fbd95e58bd76f40b34fd226caf5c83b445917875249e4e76e7b3cae2e8d7990f2c78ffc859225af86860e1aa0e078076568de3cac8edd4e8ca637a39750fcf9c1e139b125b6d1e78b98ee0f918113ea5f6caa33b04b6467b3e8194039654bfbfc023555acb3f5733a8e87c5dfd51f6702e7c5eb58145e10b0548d8f2b4ef911ee83c7f0854a0236161eda867c6ac8377457842db3105b201d10e3cfc81b65aaa1cb0919359203d4d6822f16b2f3d25e65a70f9a130e7e3e3c57b0ce766864d8c100d6da1d37f5a31c0f0fe58ed2da58896eb42da2d13c51f337c8db0fb54431e1dbd19ad9503c1561645e31e23f3d8c924cafb21e95ca8763bd0a715941398f763d46b5ca45124cac6bb5164acfacddcaffbba42aa9692caac6d31b493e0a2b4a0b0892be5a78e804f27d255bf2ded3a3105fdaa3d10e724503bda31b0b7d26470dd5cbf4d610ec84a5cd835e1b13dfa96d09dd7c30657e8854ba6dafc2491a56734d1588939500522cd182fa974cbd63279bd3915fa67d1e15f1b0b7feffdbb3475ae50a80adfea7d8855bcdd9ce1abd74bee68066e2f25caa4f3c1d097de74bd651de2c6a17dd30f9fcdf40cc062e8a63e440806408c5be554a172ab035ffeff5ea372c79026adbfc0c2cb88310ec2df4f000b44840186ae3548adfd62f5f8acba911b7ef3aa3a657ce6481a25940b1566b226517c2f17bd9d357f3e9a4925517fb32a8bcedc6240c5ce0c1ca731e58162197df38705a06accf17b95e8d8a31cfd5b7ff62baf6432cd695a6f049d6a5334277d3bebd7a782831235088f359f6134a6fdd5bc63b4be1f316fcc9e6eeb5a69198618ab32c27aa73be488481462364dc477d64411fcc0bf96853d99c82f427138b1291c8b44774bd98b4c5463dd333b8c82b03e9a20dd9cb4142ca6e9b30b71c780099ddd35cd83147b921d634d729b6d2efcfeb3c533f7ff9a369a2287be9fe914e5e7a5326739b3274cdb35bd0b6beae35d604c8b03a201b9276e8475df5ee220c49fac06071d73257b645a80f1a051904171a7121c12f52d0eb97d34478e3be6719bd2023f0f5ba433a3401dfad6e8ea5481417814d08cad139cbba63ab9c412e5a85062c60c5ba82aa65b7563a32f23a6fbee3121aa986e2826d288afcfa99d652149393793fec7569c400a8cc1d29dc71be2d8538a301e3629e574ebd25c6002591b33c580e8adfb37e719b53eb46de5afe6ee52e81ccd28960501e3571caa02a60e06d7f12dfa72de009716a767e5693377dd180e5f0b6801612d78dafd8413f4a1ecab7d4c3ed3372bbcb7d000dfa1bd38baa086cd962506c4d558e2cfd35e2fea0ee6764c23d91747bb299591e28d1841db5c2c8e7af3fdcc6af3e624a652c85be79030f7479a06c0dd1ac4da346b6e9cbfa4274a8c18240bd972891aa4ca6be79ea1a5ebadea09f8d781dd1e9e20159ef39171be114100aca1194709d033c91c575e5c88ffd22a8f343fd685c4f8ac1d874f7755c5196d86f38f5af59400d659b89e91aa0dfa3d2c318b3613b86814da7b3793f991d1e4cdebae4bf68a99102cdce7a01247ed77040dc3e8aaa4e39b570c523538be1d55c1d5251d1469187495b6c348c2f45ff2f1315d98f8950f0677230cac741ba391a87ed7d6fd44675419809eb1d8f2a939d29ab3873a268c473813685d20e8e8e81ce5f81a3e732db98ad2a3d7f20d7ebda0f47cb7c47be66e3735946e9513f1b964a67913792c38a228d84ed5d6684794ada1cb4e1a7578312309081690c0597eb2e270e393145942c80166392c99e18b9370b7e46f6fe09008b7800137705ef8d68fff7eb607272e35b2f6ddb188c5fbb2a5c8ea2d6b1e343826929b865ea7d2c302e8c1133d8f8cac8ae4eb684a6ee9d909fa04b5df73519ff3e6dc7cce79a0ba3420315c44e196d0aefc5e7c0710e7017299c617c95c513f59c4d905cc1c4d717ba28a72e9f396c880d96213b668b6b1333af9a2b857c6f74415a06e7cf7754e3a1d8f39faaf45784fc145b675abf7ee9c1b3b34a8480011e0666b3c5dcf1d63b698bb5bbd164977ed1ce2fe4b1b1ec2b7689bf97446cdff4e9a1819b9078a385a070cf71103fea87477a33734661f78e2d77c977e9059474ab1159114edcffeb4ede80e22ba6cd20407fbec43a4f92934192b921fc9ea8a3a692fb27a50a42e29e1ad89041cc23dcf2a4290ec775b1365bd37a3b2aeb54ca5f0d06300ac6d8eadff5fe2ee36c3329a52bcaeef4777b59dc2819f47002ef16ff7d501428811dcd2183c4703ad006b01ae128e9f3f8ac263dbfbbc0b3ec716a117dabb7be7dd35eaa5f87d500c9f0a3e909e779c31d9efb8367470d89333c440f64a6ca3d5c93c11048e5598613477da1aec9bde05d08559350eea0347bb46701484ba9c3d6b91e3cdf630ed42d8d911d4ce299709ab59d4ad0dd81c9d8fbf25d8bee044a73d05850dcd1bcb216ed95e950bca564311f2ac0850edf57500ec50b546577c179782a0275111e5fafecbe9781159d274cf6311f6bab7b558ec41e724aebe675e7a0c5a28a78e7887521e730039250371eb0309213de42cf0572b1eadb187522cae8643c856f99087498dfebf403174b5f55fca13bafd48d14234aad9eb43926ab65cc1eed41c233a10c52c2cace5a178fb667d6e70d9254a00c047c173fa225cfe077cfcdb092c4bfb0fae76376f00d2c11c97b992396e3a67d8fe3b895bb0d400c1d371878013650be80f5bb42781c50f78dd551be04a8e641a19568dd40fe598deead062e89966212a29aa8a25d13e1178c71936c1442493983e7139fed8ce2644e8a2bb459d8c701d348a66b80077af90db2115a5771acc0ac24fc9601d4cb0cb968a17b7d619b38ebf3a28bb5c7db6aafd1d4d6791a9aeed6a1f514b609d8a03989e4379d5c9e8f134752fa515782f0bb332a300ce53462420a89f330b5444f12a0c082e0dab9c0a34dbfa6441f58cd033a79b8c64f2ac2c976516a4aa3d2b8b7ea1052519c85b9fdb3503598da401affbcdd1319f8995779ecc2964601fe46affc5b334204ef469ce09bb767946c18a409316b63296e5312ce274f45d882ec9ff132986446bbc289ac7dd578409adbe23d314ef68261271c8e4ef77df896a8a2ac9788d5ff954d42cfd568885bb1b6bd8e442c1bcc9d28f0d2452abcead7eddb1570228ac3ea2d7f3718267697dc906b5fed6c22aa4ca03831467d843dc7841f0e18d0059e9fb2979ea0e96d4fb4bdbd2a58869edc99eb006555b66f0980655593eb015256abf2b97d67e1b62041f2e8ccca6725cc96e838084887216b78c39e0eeaddac67ed5480fab1535aba4c2bbf8dd99fc015e07e188baf39aaff3b6c0c033bcf874c5a653f8f99d9d6d379635e73f8ea6b4a3aa91cbcf01fde0c71e279468d48118c6eaf4a86eeb2b9f86490147496280ff947eaf072655d50f55f349b75e847ee4a205c79feb981961678ed268764bede68014ac81b2cd4fae22bcfda7d59673d0ad220587c6c2124dcbba6307b625b26904f7319b8ba3c713c63b3dad3b6ca9a98e4fa385c1e2beb3ff65153a22bdbada5f47cf539f2e62cb044b8128e831965939c4fa40818f09a9a022930d309ead913a09296d8d54f8365b1dbe8044a27f4edcd6cd77b4471aebdf216b32b88acf8acd40c4bbc86ab96cbe92a6ae9b29c4ba9dad59d78c9401b92cba70dcd4c888be93a171c0e00e2352173bc1f05d1aac402aebce296039275e79c3c3cbb2322b062181013342bac8991696c49121ec4213d7b581370fd69fa6cec63ea71e44802456888972809a4a6041ae4607a0906157531a19c20b75257c570fc4ad98239cfa080729b7363147046507f74f64399c0279361b7d6b84d945f13a9db5c51d77b7b90a63d0f36069f9d2811f5aa04a9655e35d323d49c78ea79f512837ef924f854d9e3964af37a711e651ce4d86b69fd04f8e4f4a09b460dec56b90524348df7410035a70ad20ca525896f5f3cd4fb1bf944dedd941e6d92d7c62e3fde4d7897985a97113af1cc3153c71268693c2b6a6d159f727331d1c4fec2423badf59a438c516e3b73239856f2b44239f2a53c860ed284839ca0977795e200b98f6cbe8793be1d31f7d72601f34b959ae0e70bae80b504032a3f7eb7f79ccb7aeba3e4bee56d9b41e1cb77e6e5c85b94145a14f9ffbedd4daaae5b05a896694a3bda982a035db56dac32b21e107542ccab6252012a35cef1a90aad9f2686e86b0a277254881fa9f7c1213b1280f096700bb360d47f816c93553dd6f38c9aa3333cb01b431893eb16631d91cab972ee11b34c0f5cd4840b07584a922c3826eeb764a4b33d80bdf4ce9503f29d8ce4c72c8ed247a163fcf073f094f9947e21954fc83a04f01bd3d34aa96a1e46f0a3f0c97178efb59d025f49d4ab0ee459a29ab4b45d1682e741d9e1bcda8c61d14a20330d95ced00e2894c1c4ee449bc39aa4e8797aa5d6fa9f0c7212962480c5345854c267eca67904422f2335ca25fe5a163847bf8b67ea2cb71f152ee2e4cc36bccf21e71b2e5d11f23df3736215ade5ab4f0896292d219e1a9b3809a4840cff31dc347d3666df0bacd3ec0c0d4babf37b72496119c34b4c45b6a951fa9a244b23809579822a9bf342ce849513b9ab17c2cb0f85dba5931024b4be46a56931fe5fc98f367e04eceee10e220640e08d810481ff1fa6ee01ab43dd91ee0d258c98dd9461ca3fecc67efc5c01e3e1d05fd982da8bc8dd23535a2ba6288677ddcf0f7aab43a124f0d0d580a72afb601629a68e866fc1be9965626aad02ad592baa549a801d464b613fb268ffa75ca0e6b8d4003bc42efb661bad1d3535a58400e8a1e46ba6bbb3b6ca9bf57ee02c9f5b8bcb547843519df46a0c16daf4670a5a4e9c2f7334524e49e4ab69baa8a2253d122236cc76e1e9f4ad995f15c2380dbc11abff29ed84b007650ac14c9210ea4016d49abd669b92d567b5e92238af827ade76a83c54568fe5ec7efc47b7d79b708fe6df84027772a6efccd2657d314c01bb3d1fcdf0747e619b8f01a082645f8d62ba63613e54d3dddec816363ab77a18169eb80796f1dabe289105912be07607f9d08887574a1808c78826d75a61ddb76d1988faeb3be9c65ece12765c37eeb135bb2dde9823559e50ee4a354ffc7b4fce8e57cd173962dba7b1b16a8bc9f404b692188e7de8224f0798b29e2dd40e55816505c82c11cc410de26efe295188e4b92a8b8368154a2bb3a0ecb2c7537cfb03e6ef59baf295ba1113040f9e0ba30321d0dbde86de42c82153e8d07b8061349853fa3dc208ceb0c8f9c629b672e252bb48f95d75732791833bf03f57bc94e47c6a6e50c2220b7bf606f6b2f770a35b388d268aaa758a6765c782491f4874c68432f52c33f5fb62740404bbc59076c8cb5e08406b4e4d2a8fee857b61e35b4e690c3aa79da60a908f93308afbc673028933c24456f50c4cd4340a466d6171bf09363e0c21f6a8d408297f460ca011d40c177fc4b9f58b0e40f6db03cefa469a33e2f14e29a238673207928d5fff3befb8ae5be8428001ceff24df0a0d95e2d303db3638ba7e33de56651e08e69a305eb335c2bce22eaa7122512d2dd8bba9a0b8b05f01e51218b3bb2110cf3288c44d70d99033724e225eaed641906f41707ae73a4d4fee20a95f6b4788b6eb7756457f483f9652e79a448213e0aeb275e64b99beb4ef7d261691477aed651b0789741044afe1c645ba1c25512a1dc429c8498c0c21d77738b29e2c2161b2448ccec9e098c7b19f60b67be18b92588c1e185de2b26b90a7c8fa407d2f3a0e3f67e4481d91829855bb451009feaa29c76d4e042158f1447188a9daee4602ab7736c7ae146ab61e483cacc81cb9f5818ee192bd66088eccd499fbc63fec3addba982c80b7169a391679f0e28ef3e40daedc5d11dd5da1aeb2542a40bb53c19771a863c313b350c22da450901095cf3c687f38438740113612b73baf626b6c71a16c4a4feff6cad460907c0146091f485aba0e0b50f36c98c79913f446e3fd2075b90396e42cca197c4be14735decbee31c4f90b30a449db480b52815b3c46d69d6fc7b365d401d84dcff0f69b8487c8d2b533904c3c467f162e6f9564309d54f9e138c0063f32d86b4985a41ae134763418f03b743596de40c5111d825ab959bfd8335c7d2ef8e998a26c9c888565dc4dd95598b41dbb58b994f9484ff27aa2c9c7e10be8a6be60a92c32e8244e00a10dd11277112f1d31946d7a28429e59210661c5f2e8a15163f75632f4ad50e8b7d3593796b32fd3fb45ca0fee4bc421a7c5f2ffddbf4d8c19789b28356190b37f6f043d53e1a503822b14665fcd59368a464919f33d63bfc8efc758809ade297d53ca1e830c18551a6d7527a67feddffff8bee050284e0701c11ebd61f62fd49b131dcc93ecb1d0be9d50f94afde9e18726b53ce3eb77984d9594efee3219f4847130746fbd16702564a345f7d2428668b0f12ad50f806ce52dae84887db406076dbb39788077eeb387ea5ed6116157bb6095e910da7d3790b6750e7f40c859e03850492f4dbdd9e1ee8d9792549e4e66afb6095f06afbdd084ab0e894bf0db66f2cbc1c9f759422bd6faf4136c77113fa905cf7ca55299e34e2461cc68e2f1144e856c4d6eefbd10142a349ea9f2ef678341eec08027007cf17c8d5fda78716873ab545188f2a24bf154730f4dc32353a677140f3ff14c914ee3450e8c93b16ef860ffa66d2c4aebeada51867b62a7fe3685ca1f4c340436b3de88242b0c68c27b4cbede1b2b37ef6db548e29b4fc42125a26f95340d1ae6fa8229c2197902b1b16ab2817bdda1274a224bc86f8ded7744f29b5a53f0914c451573458c2409ce99a6af2a041200e4b813789861ba8ad73ac6e2e4d6011fab8b835e6f72e4844ca26ba863e1a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
