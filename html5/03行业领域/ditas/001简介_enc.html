<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56d65e9374e5c690a1fd938f79b6cbddfd0520eda06b11de20e4d295d7f70e856ae3cc1288bc1fa91e2bc618f1ff4c70caebabc32023e3eafae6a98c6cfb6d755abfa1ab3997aede459d925d3581f904fa75dc1796db78697e1e803b90a5c0b113963960bb7836c337863153d5f23e41c51b917f2d7bc644146bc059f4c8f99ee5acf30ddffece6ef0f4e87d9967b92b55b578f6845834cb8747489615f87cbd62fd5dde45cc587f6cfd44d9d7589487e841036499b812cb553ecda810cc386535c3aaf6ea77a767eeef041e59cfd9d33f0ad4133097bb09cfa964b7d118c8e8d84c9360d58f8e1093c3ad164e9f16b762dd6584253a59cd8fa7f35e32d6a0f160110e372917014892ede16aaf89050e9b25710dd2615c6621822910a4303fd22b9e652ad10df163143a5c04f0d5adbd8be504fffa29547807871ab88796820a43f7dc233dd84294eb45975633f2a4f1f6f22ea556b88c3e58ab73bb965c6b88ea31a5309c170cc999b7bcc486310e22c968d7af0396a094a5903b4844f9174c57999975c9884f53227521004bad6ac5982197d0c28495f46e7da1c5b442c3dfbfb2ef711e53e0e54dca51c34a1dc1a26498424e33935235615699e84494461a3fbf495192ece0548606df450e8e2b080706e9dddf41c77e898c497f867b0b0c7882ef8e2381d276c340ff7a4551a63d4aefb21ef3928a90dbf15ea144ff90857ce5815d623588c28c19fc0247ffc8f13678768ef1a11ea20a6d80950be04ddacc0ad8b97933757f9eeea26a5f697d3e12ae1ee2a2e22870efc25d2da27ffa791e5c9cf31beff40507b082bb93594ec26264b1928e7053c82a8c53819285338f0e9668d8d302802bb797a9b3bacf16623dbed09c95c3452c78d122210f89a6a8ed8f7fe19bcd8d99a49a693cf900ddca395ccb8e75e9543c1e4f53ab055fb95014be7bfa90fa4bf377a02093777bfddee25201a8416261587b6da1ae0ccff35d7e48174ffc47fa627fd30eb004662b7789aace25b68447eb7b34f3b1f052a3df55f2ec09dd45ab18132e78ecb5205932cb7fc640ef5c7f698281e3a09665b4d36fbf94bb118e27730b22214d4ae97086386e771910907a5fc7b8b29907174ce70a06e2c0a179b66fe9f1443ea39fde81420ce92561dca52985817cbf2f024710e26ab57bb8b85f18ad7dec3debdce71c2781477e008c4cbe9886b9fb1a1904f4f5bab6590cdcee4fb52293e6ba1051adca21f16ec11ab8fa6ed027a22c0614d85c87e7569d965e2a8c43bf043231047b33c555a3634ba58fe53a5a08d88f70b0af668860bf99a6590fd8b2f1c63fff6a7a0e10146e864a9bac1fdf56d4f99037f5ae72c64b3df580d14dd727f6fc94eed0ba0a9686310997e63c9057750be60f76d3e42308a1ec5f4550932bd374e1762266312ae14299773c706dab5dc1f9445f8250e9073d70696aeec5a3ca6ec820f54399ebaf3d60821056fa1d59e62916466cae0794a68bb56430576d958b7240fdc296f0b24fffce09af15486c5236250bd67ed27ae01427cf75cecbf30aee00f6875aaeb553f259f719bc431d5bbaa6d1e528e8f92fa92d9e515fb345d4de9242ba6ee77f60bc64e39ff7fecd9cf0e9338b6a45b18fecf6891e98c75f0fb4002714f9b415c94816954f59f3f685f0947d21cf5652d491c633c7a80d4859c357d8c1f36545dcdd035828dc456db6c3100c4eb84cb23f4658a91ca7557a892a5f66f4f9ba1375c9480f3181710661fad3ff72c1a19d7a5f1f48b52e521c91ddb9d217301a9b685aa37ddf1dcc25d9ecb74b6104fa45b5b1df3abcacbb58b3330ac3f044d610ed18541227f6f7e90c664ca1b1b63cdf847ab9d688e35631d8569451e072d270024d5ad3e486eeb3757a0ca34872bac15278800b8986a6df273e265177989f38ebc582935ad401362933d7eee35a1a984731852203a0d39b5de8f3575827f9452d5e3956454cbeb5c3826e6c1167402d7bf5428a3894bf46d1cbea83dec98e9afca6c0d54719ea9eae511bdf0cb0af9c891d75e48052face2ce333d6460704101da188162ea9e1d26cfd8c634d7b6b596f204c5a413a71b8f0cf36d248660d0366d59bb8c39e1215d5b21d3f7ab3174785bfbf4c2ec96d3a4781afc183ee871a18686b68d8d6060aa6e1549e7d74cf57e2a4bacccd51c50e98d7ac76bae98d321bebcec51086f38c9fac045f375f049e0044ef92f4b831433be698d2731814c301e74652fdfa6081a6a5f0db69d9e5e4c611f62ab8d16be8377d8bcffdec7aac54f020b0e2fb4f0739bf3be22284f90e720769611ad9313489f3de93fc8718bdfc3c98b141b741a34e059767f203508c607c3c0437ac750b4eaed8707a045c7eeee499d74d139c0416e260718a2f885fd47aef5d7675cdb9dcebace8aaf34e0d69806bee1a76d632c2f469a502071cfab193434fa95bd2d55cb94f5ad49e748dc0327e02889d3b8543a844be739abd8a8a4876c1c30b38b6d8adc9830cb8ea6f02e43d1abd3e60ff9402d49713b095273fe1154c7387b1e87e7b535538871912e4dc7a3cfdca8c9b0db872f5f8a6f22c1c5ae4bb1564cc96f106cb49fbf63c0eb68f94b948f95c8e75c7e4e4cc111cdcd1e4b6c21f640e615a20b9433dbaa3877ff039d2ca4864cb1bb5e9d4792dc12457ce9a123e133160c93662c1896900110ac08d31d8625cc5ab201928ef5fb5dd8c16bef1f5a2555445e436ee8d7da8818e464d89a59b78b28ed0d72daf219694ccd3ffc5d3b2872e9e75920fc132db14734bce52e0524a20ae0548fbaa54dfc884dba5d73fcdb5a54024fab88c7f18b7ad3856de0f4bbefc480c4ad8cc7a6b20c994b1be56e338a5b67af9cb378b2bf66952eea477fd2f15b5f57d6a696d075c3cd8a70a84c25bf7bdded26b72fe0c57d5de1d7bac1fa488bfcd7de05ebff2f40d9e755c67c8760c3fa8d822ffa595910eea9fceb0258059e4b465fafd5a581ea1fa0833d756e4aff6cb8705e0d2d80e61a1a107c5cf9a5fafaa1b5f14103f74724b9248eac4e4da1025861bab3da4fcd51d99ea793eef77df34ba2a803d077bed5a68ec2d37b1081c6ff31044becaf18c8675a5a66e89951d06be5d57ff11e79c20f1d678bd484b06563951a557481113b615e5b958e596c6c8dbc5327c7f8f675428bc6e275f7b35ce47933b10d3be8f8576c722adc511754986b269b232ec0dd0d7e34221a491fdbaf225cf040341c83fdde17255b7f5f7cd5a0d63cabc0f22f9cc0bdeb281fccd0ce22deead1188b20e2706dc49d023202cac0a8ec597f489f1197090503833565420243463b17b49b7b8e924a1782c3bb22c873437189b0f239d0d1673ac2e7ab3cf4ab678c7055181c1219d7d6d7d5838ace48acb7ad825a8b3048a0a7fbf6a21d597268104191c7be62fa3a367dfaa48168382197573b61d9b73c77815a30646f9501c2407c4de3bddde250c07e2f13ca49944bd4cdc452107ac854182989826c72a50528af57abfd069e50829c2ae2e7754df18f3803ec37ddb63fa20373b978994d74467a484a60bfd2a1447f14c5da8008457462eed6280dec166f7e6e80853009d936e3345e3ce4947d7555a3458caa2311a0c899ec40ebc655e3316adff4a1a8f5d5e7081fc0de5c13572f21148f8ba84f2e0150b74a67bb828797fe2e105393e08f35e526572aadce88c9279f3f280be7d9cf52f138c1446ec55505fc7f0ce6948a8c73dd0dbceb7e72d8a2df6aa1ce855d624d2572cbf6ed6f162924da2e823410de50edfb42ce624153a0a0edbb9e4e4b55aa83e25fd93ab67994b4e181323a5d3288145de565c2745ec03b8fcc527e8fff41a0ff581497a5639d2d407b166abd9231d5dda6eda51fdedf4f83d3c87ebd0036b8b0ed02034fd128c8986b548f9c26771394a993c42cb23b30d78c690da28c3eb51ccfd70e266b4e4c00599ecd532ce480f8cbe305e6a73f673e75b1915598b11ab78d45383b17f15eec7e87fc5db268de176bac174650f1c403f4b79ec117e70f4f33974105e0da64cf9ffcb5ca7ca217458705615f251fa5604b0d949e5c428374aadd93bf9427b71dc206740584451eeca0fc661b2a5bb34bebe564462525e595c44c54825d2376dbeef1d373d2c71002ec08c1d4f44175e3ea54e912733071389cb7b14e7eff6e2ec94753a9d2aee25553c8b8251fb266d6a38a155e18807eb5b3ba1c0b1e271f2a32ce8e1595fc209f684652d0b9837c02dfebe4e44b281cc8e6a4b766c56e837b69067646bde15e176f258051a40c665cbbbd1f138367420f986b4b3990d4750da11ca6b117473defbda75536eaa25362d3fe2885bba9b7ae7080f475c905cc75e47b6986f47846c288483a70a0d86044deab171cb2cccc4c16c45680e591869a5b289b104305f4d330ad2c7fc3ca88f642b103857878df45fbc471d04d2c41f572bc48df3cd41aa7a0b0da3cad32a7e167ff5f5622fdd2320ab9a4bef42efa17c338323978977fd9775c15bad700857c69359e1cebc96934d655abf59971af300e0d6da3610032af73bf424a6b32f644ed00c2e273e5fee877f7b37d353d0c664d0ab23bb2f8447ad4cc960a7e591d8a7a0b9edb53c60407f4ee01c8d0bf615335eb8c94e2eb59a8964bc221b2dd3f4afff35e499fef138d9f9e05859bfb813bcab0d2bed79a1cd3861d4d35183c1eda80ca696925c07ff5609705210c6a523a8bb2ef60b09aaf4b63ce41b730fd28145c0e6c01a5dd429bb3364414b4eb4c1b36236793647ba3882601533062ade142accb87ad08ec560201496ff93a6598e889859f90c654d6982ac201c23dd0c4c44c520449b9d078192d2fbd15d907c104023da93a1aed09a429772d639115db25804ad1bf93168d82f33bc64c17efd654af24587ae23095abdc33aae33a231dbadf55867141ec4f80e6affedb97aa162a20b8311c81e882b8fb3b9869751bc162381fe5c407cfed647d0bd0791ab4f6d2755cd0bfd2717a6e05e3c29f361defb86c7a7b8a8b03a4a56785c0552f0bf6d8d0d78c1ba03b4cd973bf01c890ea0066544596a80cdaf42203c2ff2875eb060c45d9da7e2050705362e8c86a4cae3be374ebe29584aeeb9f4fd8258a6d855be7eb9eda929a53f8d79d149ecb97fbbeb73b0082adc53dde7e3cab86995aa403ed5c3b61f915cbeee1fcec53861cdd0da892cf0cb22558d4132f8888ee2f78ba4835f4e782a31e9ef5bae435408aeaac09f95b95a5c4ef1e04e44aae23b3742a7fc4998508c0b8b55cb15bd0ad7e356df93c130cf3399d0534bf6ba7da1ce1d6ca5136a67084a3c4e8a0f8282fe35807c1729efe69a1e7c45b80ea1ca43c78c828dde16aad32d86c6db7e1bdb2a8da9f3a9495cbd069e3bb781a6741a6714d1a571d90043cbc996e41e6ccbb0a74555d9fa1bb6e72846efc5493f2c7b5c1b65056750233e0f3c49ace94e10bf843819786ddaa89ff8800865c0763f97a918379eec8a8d90f4771a583988a7c5e2c2a8a87602f0ae4d637ce91242ccebf3a48c7db3f57718411d7e891f74bf55213e6a51ab3f1aac462d9f98b4614079be5c92c268daafe0605175f14b5afc2c5bcb2aae976036200b27b0ec9127c86dc9b97ec45c369d95d86a9b83a2a298eebbd09cad8725f2d09b08c82c316d1d66cfae7bc4fe7477380db111cea572698b30407ced831df7b257d4f5a2e6c8763e1e03a265cba8de82ae861a916fcd96c4a6156976bec4776589f122635842070fcb0e22698b5f7746419bb72f382b5bc743704068d057a49b38ec64f1c1c0dc3c872abb90d66ca02403e324988d1b6342e877c909f7744ae93fe61625060cb3695f687e2e2d0db27adaf95d51d4793472d89654e90e672820b59db126a149ffba9cf8f9a5e81e42b01606d6434ad7cbdb11c4057d1db99b1dec66b9038bed38cc5a9ada477434e82f0aa104d4c608035939e8fdf4528817606d3b47fe52077c416b3949b8a5a028f3158c503c1275235f62830b173e73700f71167d24284da8a6063d87c62576f3da55a4b4a45db30dfee4d1501b0d248d5743e3bc9e8d59c4c694caaffb717fc226592278e8d1f6fa76e34ef0fc7b2ae6d3f1c6626b9e031cd73a21306ff7fcba67eb731042e30ed92261594b1b55fb3ca26739c038a3e2619878807fc64975d47e0e6f2d502b83051904840bce0e70b9f437a7d29df3bff49aed9f4715b4ed916d1bec9560a2938fa97a83f44d7bcf3ac37cc35b8fbebd67fe91a4b3d67f304997f0965abcbad68085cc27e1183d96642195dba42381c3cb405852bc61c857bb1bc6fa1296c912c54b9c42bf15693825d1fc78ee92a76cc1d2aae5f468c4ea687782ce4a25879f1a6670e405623eb4c5e821c7a6e4e545aee71ba8544453f9a831b7330f12204409b2aa73904c019bcde8c7f758727b637cdd51ab90245dbc91afb3f8307a93e77d55e022daa6fe41a6cbe2af74ac543c00eb2278aa343b6423b6da5cda4f20d958c5a27384e79b8d14910fb7114b14f211ea3a5e4c93f5c74135c02c687577bc9a7f8b184d671ca07e20b39a2843647922ee8fcca3b36fe6486cfca018cd6f75733c0ed20982db6ef06712688c454e05f131f54c35124a5e098292620433675fc9369e4111bbd2d940414b496a7d985937c8101ec6884f3f8f5e1e34edc3e0ef8d41520acf380bab7746189060fedd4b6d1b01b81baa848a99e3a2a8e99ac68dd6a7b504632a5e203815a38d6c85b80a294a4a1934e2cc5656efb223faccec071ec7e53abb9bbe85a04b295d0798e549ce9869a6300632847add407d1d54da4436e342b33defa9dd26189694a80e670509637f320be894b82666ed7ed3053c535e86269c3958cb9b12c932d24d23499c5f98565600fd50c27206e8b2414bb8b80794ae72c02f8ee0d999763af6a92ebcf83f2af069c7bfad6963a8da846d8572cc62dae9ce4ead50a9baf6189c3794b1c5b3c8e215a4a0d5dc868ba1419a68680358abad63aa376f17ac9e45ffe7c9c946b11df9051b36795ae2cfac46980204984ef640e32539678968b18e9ffac711b3b142858786691b7d7101da1b5a22b6dee251a3530da880d004e16f87d5373d99599d9a2c23f2d58d8afafd815d4ee6a104f2c7cbb2d2ddd10018c873bf13794a7cd235849d711336231075ca73ee9f98211967502068cc2fa7d6a932a62f941d78ee041b397cb16ebe0de8926242133c3ec91691f9f9150d9d1c1f4b54a363377fada55a9c6d1725deb5d61580a37dc94d9b87075ce8ec3a57f04611bd32d8bcd3590d39056cbd1fc30138a671a6eb1e7facb72341b5dc5b7ea42d1b70ebec4cf89d33f8b3486b879cd701b90c9eed5cad64a6efffb41dfa4d473c2a56dc0d37739788e8f7b15c7a7ac183c84fb4edfbc6b83f19dec0d8f4c67a9a31b201e182042ab888e20c6e72a35b98ff2be9837d37d4048e4a039211b7cdd8ffad53002f3649de49ef850a5c18f3772423393a470d93c652f92d567584d49e4394b8907d8b7661d002d6c57e27cfd436a0ddb267676ad589e0b4a4c62a9c51076a39f8445bcca46a8a70c7fa3e9da0e53ee19b68b0f274588276d471aa9256b78c39df11c0c4d35b330662f837ae4f5b225f17fc2b07174a3c778e7d24a1f788908fa11010d5705d731abe6131497d826beb27b18332be1f1d41f7fe9478e242cc8359f8da4949ca1c351acbbc64291faf9e7fad94b7a1876b8fb493c9490f2b8fa5bac4d4f82b799547e67e42966bc951ed39ec0b57168b7cd569faaab84606b677950b4fe64fdea5c0c76f75c3f4342321686b9fa2b34ba1e0a9d31f3181aa331a91d6ca0d7163036915a756a99e236aeca4f91a2c3f3ba3bde6b828455671923f37912b97411225ed16bc5d91d6b6c101a712d07c50d210b637d27937db83d6cd90fb2686e44fb93a5ecfc72797bca2e97224701f18825dae1921485201038ba2d7074107b59180e0f1d62a0d2307a6fe6555afe48c56e0cd917c860f92a655ac299e90548cb6d4ac868943d6a927cd69768b3134f7a3b601cc6b271910c292cbf40e3f456ac1b3e758a1a2df5c9411420d89e3bb930a50f83f17c9fccedc8bfd1fd767419572ca5e309e44256f5175ee6358d2930165eaf1be108cff3d4a3a4c91b26b0bf7e0300ea6dcbdfad12cbfaa712a04fba685182594828fd166cb2aea5960ad26f397644764b125a8c32c015e9731d3838581e38987c3b7b0507121c6dcc36f4bfcb9a8b2de40b08ff320d6ffae64c491205309778aed7a719b7cbce5e655fd4803dedb98a140b3b50f40f2d6abfe95421edf76be8bab6976032ae56a5462a2bfc9b202dae1e1c805a9566609c52e5a64c5c224b87b85a6080f081247ff69c0aa6339a38a4fd53b8c31511c642f4f28b1d983bcaa4dff907f52c4551b60210accc7f5bfe78c4936b93ba119e29d88bebc2a051fa3a25b2f8983f905f1352b18b75088cc78f5e7aa8b14c4d427690d76b8ca3e04a3ce7384d26102976ac88e15b568b4f988e96887c4af9b2abfdf857b679334bc1620be876774ef8e3c14adac722cd866dab637f4b694639d31b3d548d340474a48b13f27f65803340ed362547f8c5729e1b10e491b2fc9d78f5e60729a65aac480f8b9500366d39c7e91509f39ed329bba1f258bad158484b691debaa81e9c5f202cb87976e94d101ba3c6ccc6e6e8498125e80001d8ca15d7a62d91ba14f1955f652d34b3dc630d0ef71033c5f422f0cd30a1c5e290f2cb11f4ed1ca25ca303fdc9574af907eafad62c1ea9579612501ba92abdac8faecee9f757a9665260a7c51fe415481e73f17659acb810e865eac2bc7d7c20f5d1fab84d0b6e6b71c54f4df9c4bc1a03f74f23b80750b604e04f724cea77db5aca3651213184b751e4d1a86659217e79556403d1c0a7aa3c4421cd5a7d3a830792f53e3b4675a0aef6688021bc924688f39e905abfce15e37b7abfe841035446c482f9e3ba7e427bd46e08c7452202b0dfc4e6ce1ad2cbd80bc0ac7ad0b3b8a383c7d2a602a23c17f6bb71102759ff8b04b269458c1ba8bd564611505ae138878cc05b8cc77fc0cdc879a8b0b7191f745f7e4f0ddded30a69609fa92bdb93458ab6b71d6be899334f62a528852b229f017d6437934e4899760b23ffe6ae04cce88734ac2f7ad1ee6ac52b6408bc5c9e2ab18573234a5262175b6707964dfc2b7d6ca29170b55d1ba331712c2fb6969adff2329b586d09df3ccbf9675b73a6a587711ac912858945706e7baac12f6a1a315a81223f52bda5fae35e0e03810e6bede6937304fe96c9faf9df8c6ee26ec0de78d044a987f76f407e51633fd0578f58431340e259d94a4bc208bfd3e33c72e9ee1adb7f8b6cdda32838f4c4fc844763a9d5d8e29c607cd744e3611181fcb8fb97ccd1a182a6f1113fed93364be1e316bfd12b37eef0373838a0567efc89d7af9d400cccf5b7825405455dd922da2cd8267278a3f89555f8b1868b075cc81a1afe5ff3bae216a176fc1025578a84e37dd5b4d76c01b1b924d5183709d2b6169a6ef7635879195f9cd1318cc95c306bb5d68a7527917967337a9ab32550ba2a07ed7173ce6f02a8a5e31fb664cc846561e679ce30f2af730b70b0daa6568bae810720de90c131deb3ebcd197b6041a83bd9a90b028b13f2c21b3460829cf37b06ffc5c21d6343976ef020ffac6288abb0c74729cfaf45242f8c33a0da433d8cde7427dfdd619d4d169a942e861b3e2f76781e5b627fd7ed0441190aa2ae1f124dfa2d6a0629af806b4c81e3e7c36d3e55f74b137a696c847e0766d171390f9fde76aba44d440423450abc4fc6ad74669337efd000469ac9daa6cf0bb861bd223fb36015f9a73ccbb5d2b27a8db03f7c7f488ab9205a069167fe706a745ddc2215aded2a477933361e5f800eeadda7278296ff39284de9ee8d4bbae58162b81afc2c56697570960e16c6d5476e254a4f6853e316e883915e75b4b5b89b59721f62363362042babcc0919053ad8c4bfe93163f6cf9d7c24df3f9b3f2954525ae88b95869d558c89041d674e0c36e5aa57a273ce310a7faa76f97f76d203039cf18620e8832f5cc0b2baddf96476b9b3173f69d177d0080091051f4e325a58226456315b3360808add10937ad0152056061af1407dd233f13b35d5f3fe8bbc504c17baa3d526bbc0c6b409fdccb00cb7476e87162b916f1183d021c33b766dcdc68c22223d1b3471198f5cde4760496617e06e1498fce0daafde3c52c4543149add40335d0cf1d254c55eb09ea084e55d81d9dbc59b590210bbe4342b013c3aea43293056abddf5fd96d2067ff2b6f204dd7cf0e2cd78b3d66abcde66f0167ccd13700fe0f1eada9126683655bf19bea1ec6e8ff6ab8cab3edaf8c84d1be7713c455ed537bf342e45402e8e1bf696a3443c17ca7c63386ecd437d4aef39736c4777cf67bfc22477ac4927aec05e968f69af074b1146834e77c59ad3cc20a35e641b3989bd4bb81428ecfde9c99189d450cea06fd48d6a7a7a7a6c62e8b6f98b189f02d8fec4b33910f9404d9204baccb8ff55c8a3a4ca942ec414f877425761c9f90ee28bab8599d52c9de66021bee70c57a94a2554a67a2718041c575215b5c1073544ab9c6255d0a6d1ac4604cbd94996bede74b4f98632fd306907525b85635464059dc0bbdff369e40a33006f3173fc0ab27f1b00bf27324278ea083f2b2caa7999d81409ee435c6cf76c9b860c2944adac87654a76b6bcdd867ed21fe1a01187e6e9b0cbefb0c975601dde0efc2fca033385afa14d65a7ec5cb3c1c7b6ec8a3037de3f3720349694b2b93943cf0668c95ae47f77601b54877dafeee85f6be561c0aa0f6d6f226a7c4195a06a1f6a1d9f642f28ee4fddb1ede9774ea757349d06030ee876eb488b6743a3af3cad468be9bab74c2844fd15a79ee047e139c12b58444c27aab422967a8a4d89c5048a7ff5a2a9f9197388e81d0971f142aaa89c82f646404c05d82d902bb2cf04ac934ec01e6bd10812ab04647ec34f7ed161081b6e2ab743802f6d4608fc819b4ad5a1e00331d24b0f59db9ecce1511bef085a84293c117d4a5b4cd9ce1025be3312165c155affff631a549590bfaa5a990efbf5bd8d4eb06562d212d62d92fb65ab67a938fb063fa4a706641128f487fc64e974255b138ea1538b018515e36ac63ea969844444ad24c47ac46f09f1f2e9f29fdfc49ab6f5aafe86bba0ebba4fa508fdb77bb67f24d4eec290fa58f9e09b20d0d1d1356ea9f1b8c4a86fa4cfdf9ad6e3375e5013e98410d9c730d78a7485c2be0ebd22315b2557f458d870085dcfc6205e39cd71026022dd197a086f617e0231271c174a36708102e2cd928ad4aa7b5abff3a6b1f67c85f9e9bb486f11af1b30405817bc576c81115722375221dc283798468942b36faeffe2c927376e8521f5885fa366c43ab3a7ef65e7b6ea6d6d301736eb0b6b90cd3f9984c3d7ae3061eecc04d250f70863913b84c6eaaf661e09f584556438c40ad1b94d61f6e53bc8c0670aaa74e6cc09298bd1632422ce51d41c6a6a4ab5341a456ece04dc56fd2b24b44f0c487163e90fd05fd30f4a93906f1c831eb8bdf856b3bc0a2109c3671a0185d0bc935875ce2f5df110e8183757717b94204fb1dfab0a548abda3a06a5cb3828fd4ca1d072da037b43af7845f84dad4ae4bb5f0e562ed8bf2bcafb34a5d8f1e1c2f882b4f1d8dccc36367e6d1a5574edf96dd204af313e09370bd745a4ff7f73d4644bbeb1f6ce180bd8f43ddff6b0dd26dea66b51952d405c3e5e939d568b23adb57b84c82be1d400ffab52109a2784cc5d96f037083345bc0302a19b029351104a0d1568e74eb1ff9e72501a6689754f46403df722b4b18ea9c2af1ed2b590897275d87b0a617ced6190325f2b359d308e04541bdee08d281c9529f2d297abe6053d7e2f1bb126ee37f61110145b4c90d8b3c039743f8f970864e5a36c2771407da6fcdd81291fbf5a0b77b3e0c66dad3519133e50f17bb124ba26274319be409a456abad3482617fa15dff0d314a3b1fccaa69f4a96f018961590945e218b71324a1b8fb176fef5dafd35226c5a38a67e6baeeacc4b7c1f6907bcdccee26bfa9973400e3ce276312df9ac38260a2be500b28a10c10c5cb39a1be0c8632f5b9dad8ff4f2954c9d244b55821317eed9b322bd73bd7560b3d2a673c47d86cc46ea8bc0f6e287ff26c6e413e2a35059f1f029b487aed827fba9b1ad91b12087b6c5b519191c5a647af1979a06c1f431c2f91e0aa5c63970a75f8f48e16225881cc2c8fd881039f2d3a50ede839f2144d1bc332861d46a224704b4a28f6479790b767b43ade33336bc632c621922eea0e92053d4332f0c427251a7599b1349a11719f0021b0833f409d831d6337ca8b7e02e5cfc17eae5958c074301b9867586f22ddb356800fc7926bdb7a0d633dcda9e853b89b7260b302fde5583aef69ed2f2846213095d88f062374b49e6b2246744437f6e5d7034b8946e042e55fcc4007e960f8ee18b6267dc52f5e63dbdd6e579d01eb5539f1b4eab01fc4c4012a41bd1303143d7217a85b1aa8c5d625bce210cd1512fa0c566e54e0225fd9c8a78c988a8ce5d3d6011beece26008f66b35a6deeccf21a470dd734de6beda42e927b252e3ab59947874cc2e3374cc64c587a7542a71023b891af9d9278f45846e3dd818e64d346a2d025cadd8bfeb0395cf541e0d5cca20bcdfba114ab6a56b5facdda72a69ff73dcc79c0b5d297b5b85e189c7693cab33a4c406f80db02d6380327a197019c68086bb20f9aca03cbdedc0ad7bb85860a39966f625d331ec32e27998f860255ad2c48366af7e71641d88e07de9fe9ce312c687029b2b4ee4e95ae68535a300af466109a400b0d55f3d3bf14b2fd0222f5fe8e175b5c53a106f8158d9b6c9cb459405f8da494e424b51e2b4b3489a4693da87ecb6ca5deae47472e0a6d94358cf76d8c5ea0774ad94f459385781abd127b13633ed5b56eb7c5630737f6c4468d2728efd3ee9ae6b0a6bddf9d2fcf54ee80fbabe672f98a61ec09ca26ef406d596ec24bdef5ced1d45ce8787f9a7aa3784c440d890bd47991fc54604bd8532a923888bd1e6180a6c222ff07539ff0b88dcf161b385fec330a578a4baa641f3dd77d147805d270d97951d645537b8060dc2a24824c157c152e427e63bb51fbd8cd4e4d261b61547f9ed0f649ad59648bff4a671457dc4611579414b77de60c19ec5b1f576e10484cce491e3c0468efa1c82cf7bf2621a5ed14c1f2dd3146288fa9240e1e295e22ec76a7d7cb65ccaae47bba6c25ba96e608d09d6d83bcc084a4930e86c4a236b18c960bc32eb8df6bbe684997eae51d2daf2d8c32fc876093275015dec45a521fb0cdcdf56122cc5b3f76a3fcdf261f59bbd14f91bc64202ad5632858a16374b35cdd05a22e5fd1d563ec197dec0728b5c796bb0bc740f0d3d338ad7df46b766d4bd45841e0e1d77a54cad323921828ec3bbd6212dea3eabc56a59493cdba2bf332cb5f1f922eee5c828032952bdb1ecfeb6701ce1c6e7edc5c58802a8740b802c2d37b8fb3315707d74430132f78cbf25c475ba79dbdad85ab04abcdaf5bb4427850330accfb056c41d45a24b710e1780209450356e8d6ef5a19e3a3cb78d0b98c9aba6e4ced82fe776e887652268c84c0d5a3c5f73615a0b7a3cfa74eb092a80ef777305f2dedf980c7d30a5380b3f9bfd95054345783d9747bb55d28d50c1a604c08543106315478f77fa927a852f665b8ce436e37468f08bf0bc45bcc667c2c4da959c05a4e76f24568dac3ee10806cf9b87d1cd51e93d2463630713637715be7160e15b9a5a65d7ceeb4f998d2aab46cef72ffcde22d7cf39eefa9eef2f9ab0872722a68bf0967696693832977a58ee5e49f448341c53ee179f76481930890fd244c7198ee6c736a68f0df1aeb69d1d000cee1dc2bd6e455a26afc92f085a98c19f74dfca952da221b39d3049cf879452ee186386345b7eb6bf06a6daa33e24adf3eb91c1d11e49e6d9ea1972f1dd89ad1d231448008719d793f95fe3d3a0dac89fbf8ffb5cf81e3c9ff3e33e0d71f33ee2580f06b14734febbd5ad8a3143bfc18c46a6a824dd5d6b35e833deb9d73c22d1a67d85687f275e73ecf8362d1302adac9cfdf91b08d0313d6def073db538bf30cb17aa9fb0ddf3bb0f75d228e451b80ecb4473f6431854fcc9ff53f2537a928895d825e2e4abb33359315f3dbfaeeacb911a3482d16146d3306459570e4b9a7d6a5b68491e208075d0e0ae55248c22346b1948ee9fc387a3952ee98e09292a431eae99d594932e8fc213c2afbd6e43ea07aa1bdb94eb2a9e4bf87c62ee70890cf7eb2578b01df1d035d7d6634e8edf544dc3bd49d65b2a99ef91c015ac61b911c204825b8e5bc7228cfba794b9b975889efc9c7c7b8eecb89fcaf7186ac8ac7709683a1060642f763f0e1c60a98d66def10108646ff590067bfdded6e0067f1fe7e8c4984b717dfca85196476fe5f311a6ba52262ed3a54f4d9f66a2bbcb5920f20d0e231b0e8114e347f8b9034bb1e3b49b2c21b0c2bb9ca7dd1066b4fcc8fc7746b2fa02be444e8563522dcbe0f00c74cca1c724090eb63d83ddcc82b1f097365df5e69efcdd97fff41de3a4a483e829604fffe1fb78dd40d2358c875cf060053264e2d51cf056689289210e1aac07ac3ca8e150e134e8d220ac78fa396c8ddc0bf8dcba44cfaf1a89220db4238bd240f0c4fb8daf5de9bb8bf553f7f5f49ed89f531e90b8cf37f31cc8d821e6f6328fe075ac6e3574eed1a2c81f924802d049fea6f466953b6100ff90a6404a31fdb7a012bbe21eda85bce9978e0ee7c0d98e27c7900bbd2b066a9f05d236dacb5ad9ed2723834f1b98e4d11544e92460d30b087e92c60edfaa35cf31c46d674e8d9d778fd15384db09e6e8bd2f066849c4b83bf2e2a515f5e5e31b51b1df8c0c5915fb30fe9c3a41aeb307dc5140219c4bcae9994a0ec45b31f6ced87e9f0e06a6a2d96ad4ad9236d1ccaeca61c45f8028d855e60e48ac11d5d46d8898278ccce768f342bb92b0b908027593ed3c6b9f490b5452a73c0805f109a33e657bbdd286eb3a435b50ffcdd17da22398144bed9e070c1cdddd8dca5622a159746f6dcff8219894cabe2e92f0ad678821f3e8b1da59f83d2ab9433c120a9f5c23d2113d4a510989ae6258a6484cedeed0ac5e894a0eeb4f0d7ddfff34114f8f1471d8b3b05b7bfc402483cbf5f0bb41540ce59df94469b483197fc3a2b93435a114df9aee33eb3c805a079a83cea6e51d634fbd9d8f04c1f0979c896ff3956d8d64016358cd48b1cd79fe9b77bd83565b9282a4213b8101ef6d3ded93cc3f1a5a0536a03dbb639806ec83d1f7ea77c373809335c751726c361b1c6bd487cc3c042ef4bff00df0437fd4b5b248e44aefb519bfbbb5e3058fbe453a2dfcd605a65016a7c2a8407828c634e9860d937e5a43d3595727bbccac4862a93860b9b3f9648f3394f291458ce90e1636ddc864f1c5584f7d83e975ffa60edc722f09dcb7304d057ded5fc91f9183d060ded6d68f55b19b78d736aae31e6347edc9095e8ae52f523ffd50446b03d0609c41cf73972723961c8d0f15436e3f1693f5835945ebac8635393ff1d077b75d3d0811f34af0700137fd01a0132e19b8ed7ad65ab0606327ab504298bcc56381b4310ba2f30a8a24aaa61e6cb41ec22540b83576465e28bdc65f96c59d4884ca966c03466af85440fc1a60c0ab3ee88059d8a7d142d4a6466aa92c7adc8705f4b541cf66ad3797bbf804fe0b94d5eff9a2dd6577986c3de411cf50dc577221a288b52d353370d30abfe0c07ac271b97c9a5d43970ef1e3b381881913f427fd660c96ae75591fca59d0a4e56d2cc36ab8d86a9594a6c81dd9cea5a05a371f113a734e7027e1ca164ef0227d4e8046178db5250fc4ab97b70faaa1752307fd7b15a04fdaa9adc0ec1e4c8b9946f56922a8a42bce87ddd7f53d46cbefa806f15fe5b2164d79d7692a17fee24ce9b442ec2eac4eb19c87feecd6fca31f0a31bf2777acfbff9c4b9eb632cc1c802afba90042a4077c2f74d87bb0d7824b83540f8ea1b611b051d5f288e5810bd37e80fd94b287606803050d7d14bf74c40cddb33025f67481fa724d0aa16b75795e663a415aaa937342ab07b860961591566ad64051645d886a80a5d5b0ab5675c7384f04d0ff8302cf007c40ed88944c8e7cc6b786d00ade521de4c5718beb13ae0fe302e011ff2cda43cd2303df4b204aadf491a7334fb9d5eb4326514dd7ffad6a99d1b9bd2496f8920ca961bf9f768007cabc39fdf8640afe1b526ad6ae698f4e42aec70a575d6f2699051a305522ce18b4938bd7beb0fe640449da9844ab3914407968139d36b57e9c63e0dc51c53cc11ba5bd136955144cc500baf2f1911dd6d6f0705aba1b4d4896f82e91c86db3691fc1e8628cc69e36c905f3fc24964a0cb86f23f5bfcc0dc40041d29c4444e99661d3f48063c540f0e2573bfe0a58717f3b3861616dcce065ae517468547e80d3fcb36a57c67ab859a2b19e7979a6b544a169d4197b4dacb3768fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
