<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16ff5db12a8ebfb1b76bca85dd460adcf39443e283c59fd9b5c84195e02aa45c5458caecfdd103c1cea8270dfb5a3b3e480bb5f0924fcc92fc8cfcf4c4257e5ea1235ca8a4071eb79908b9759f99cdf84e1a363699d63a5bf2b4ca4bb31dec43cd9a261574c30af193240505b0c3e6585d410e22c9e2ca27050e6d400d3d299aca33beba689b08b7e9f34bd4d9948f5a4a68e856cd66916d7681cc5dc179a582968eb5f8aa87743bae300091ac00d503f415abf18efa62b5d14de23434112c0c914ea86c7a3d79571a52dc735a1b9f20e0b6bb41d4b48c853d18606f1f57146c7feaf622f068b9110ef768caedda4e7887b3ab3e862aa4e92df19184dcee378aa943077060750869dfcef48d3eeb6000e598bd61f02b7a03ec87779f713f845c6c71649e0827ee8eccee0e21143afde582888753daf59d9f761a7d97388be5d39c620803cb38d5570e365fd04a32cf8fdd0fff91bef15118f287b8f157f57eff389f6025e4ca8b0dd354a677beae0b6dd7bf3e9ec4bae29a8e145002c434f9cd81e0ff7f5d2727c63a7debe1cf97b07a7c14e66ef0eb101cfe9d8753395ba71d5f29dd97675e6ce63c0bd756e001393a27a61cf2ae941c5210e3873741b3254138f035f1e7eb503892599a4bd450d87d376c41e090b1e738556807dc8379f328adc289160e8a48ae024ffcc198fc56b223b4417eb64ced65ee7c82680af6597d557fd60d9be53920a9a34ee4f91455b0fa6eb6c9d8d2e0719332e36b9195192feebe1e3f3177b4245907d8bd522096609609aacd2ad18abf76fbda4d3e82e68d62baa276dce505282c40e0025c7a0bdf33879d472991e7d522fbef106c0a7eaf784701d4915dc560591e0c30b327ebdc49391c57c48effebf8498505916fffbda2f615c76fbe5c227a29706b604ff7fbc697176e384bd4b88edcc3e9b54b495b7ddb6c7d2f20612ea01aba0b1249a309e32076929044341ffdc423443dcf7f4a36ff49a1de2dff6540fb5ff57c078a551a5bdaafadc123fb7a98f07e6ebc706976966b3367e954057a3aa92d42e121eada7445fc793676bcdeac2df006bd870fe123911414daa4fc455bc55f089433599f47c7025d7a6450e0927027e0f6bffc0f74caffe4b81df91c34cb67fa0612867375cdef173b2199989cb04d98726dd183fd43088d90678b950a2a90260e305037ce313d57f93e5f4b3dbaaef5ae9a03434b5e21094bbc2a24b7fa5cdca1d1cb48c3f7ec373cf78893df486191dd86d29516384d6776751283091aa35918b623ee88be269ac9dd80b5d79ef57fba306889bbb19ec2e790b276ea98a7f2eb75d1ecdff26ab1380d7ead29109f4252321eb91764852628faca4204ea64efc756cc39a8a2076dae68547538f211dfa1757a5a142175e9d116479ea19c5b0f48bcd2c83b7cfa801cd2027c9a9ab9ce671dfccb6e240beef12106cf09c805cb652533c1a86b64b7c1ba7be5f319b9d639526c785fb62ddbbfe8ff3a1ed37679a4843691f4c68411550071ad5827d226ef0e3490a209177c13ee78206967da7b386f12eab76941eb58358dbfd3c63489308ff0f60a496fe97361a5a3b6c71d582b861768bbcb4f66ca680ee04bc8773072a572db158410a56e3807589f762b1bd99835987a50334ec5c8f3ed33f986083c60dd3ed0e1d4fc074c5359bfe2ae20a27cd9d4758a3d2da27c29af2c5661fdaf00e2da1f828855f24c4b77768f64ded008094ac2d54ae04fc4d878df4925f6a8682bb506565aaff3e3bdbeaadae55c2f018c6fc6bf083885abd92855d79635c551ac7b02292dd421c7dbfcd9d10649f3cb20535c68b6d1d34a3ebb93a36b47ad79873cbcae75e97f558c23ca8342ced6a7b371eb026549227dd5905a8f8a299818e59a327661df4383aa9eb193b060109c7a1a1cc6c5e5d218a6be51561e3c66c55cb187fde7c372fdfe939136ec17a1089b8d7c696059692600b2b47feb8ab5701aaf30510bc692adee87fd4b6bb1a4be8e5af2f811fc6517fffeb362aa1a9a417c1b75824a669dbd5d84e8d4fa4aa4870c0b154cf102653f55d1c3f14799c5b235b88d4455688f366252970d3d81053468353cbc7de8c1e56922a5fce049cef39ac47926e6d0cf4552fbee745f86278cda83451efda8704c6e57775b127b4ecac58b98e93497b0c77ab1dc70514d4fc623800da324878f09758047e4906dd822d357d0e40b2e31e10f6b391d68eb9565c93b9184a612bb03357da82109ad9780a679c626e26d38b68a7312abe14059ac684fe5dd76c89b2146cf4eac7016d729070be2f43cdb0858e72dee9920f68cb54bb194447c7bb0bfc62b62f317729b4cb1a0091ac64017435b377b34bbfe48569086fced0b4b5a3adce50d8d4d1f8caac021c92f045151a74af98e6c353186f9e6ee8ab1d5d9ee90aed8813a95fdf8a5432e8ccfb4ea18b9cd09685976e6acd191985d70c06ed6685f0a7b8746e1265d255017376906a3b7e670566205df20a734648e199f3541fad9680429492fa60a306cb6739fa3ff599a00483f602c3bd6bcca2c1dc140ede50b981d3d944abaa8779578b4e370d7a14a050c09ac0f33ffee33c4b8ed4b8061a3221dd26a82be2ac6b0a630a7a3516627d7905072db16894898969dee2e34071a4649c4b7924a16f026e5bc82772586e350dc4496cb2f643657c9515de0a977eeeb19dfcb75c71a91e80dc880849733ec5fab0dbf81fa90abd11062dd215c3b677e5a8fb90c71cf7b9f649dd5d21be7a0fbe8186408d5c43cefe3e601b4f414894db9fcdcf5d20e693770641055056ede06e0d34e79052d5f4016f9f46c879ad18eb55ea4eacdd96674dc562a869b91d7cf55c4797d08903ad2b9f89058ae8efe1c2f09ff741b8fc92c4553c5d634e180d0fcb70eeb0bccf80695bc40b4185438126a7f071e8e993074e1e2ba2516e49d1c315efe209976aeccd768a4fbd7c41aa075217665d621f053a713a7c6676452963e0d3dd73012cebde78da96fbaf22328a514c33f875d7311eb13c9d1b5462bccd05342bda49a40c6891cc3b9a8943bb16eead9a75c1d6e11d24b8ee0b536369baa1f7a09dd2c734616d2a5ae8d2a95fe6970f306d3325a336c8a41fb4496879fe21c298b108c13b7f1c1529c2de60bae83f4db077059558343417fa5c6235dbf4c84f9cfbdd80cd757a4a1b66cafb81336462482d20b3fc486d3a7051a29a571a4f0bde92864f1e1015f37b5bd659fe15585c38b120a4d0c88fffe4b1b35e46394989eade3e0b881ff08ec644cbd2d9859ac5fa548c45fe0c631666016cb18208c066738dd6a7a1b26daa4f282c55d7997d718ec2e3d04ed687d18b64d3411957921a20604fbaf2f49b8e2fb3e564a872589f039c03f2061c947c7b29a699832afc6ec08e19af693a371a6da2431334eceb59bdc82c15439831caf7c8d54402a63ac4fd3da889e8f4fd8c7aa493c46d3d5fe1e4e39d7ed60d8ea68003ed28185ae5aaae749a6f7d04d791bc3fafa9aa966c7956d976c3f0031ac44b0776096ce48d6937f6142b65fa251881e6320294821e0fba311cf4ee4e259a5df7d9117fc5da3ba4b0111a093634146fab3ede14bf4d6340d39e88deb7b1b63934278fefbb510f8c4b55b8bdb6998c3372418aee1099baa15c41556560f5e66c84d4eac9274137d79ab6dae639bf5622871f633d55e7abc56c8216e6ac41c736d4436fd314c23035a89586171dfb67f792f5c3c6bfc230e8b46ef7b3dc468890652d0e6a0c09b562d09d03842e7c9aa5a7fde1c4f71e463401998cdd0ad95edde98a2599833073d0fc23ab907fad37f6c5bb6c633828730821492e2dedb6e95ca9dce355f6ac29edd49fe47ccb81d5cf27c13dfe7cad7458279be07913a390cb23dda280cc80e905f7b87dc141e90272d758b3489c0e86124fc76e320ec4e9eaf49c82390b2fe179afdc3b2f808fa30415840e4e8564505d62ba17a355b5fcd2427ddc96a570a68467d1b3061cd848bd87adb9c9ff637ba515121718fb3c4e4a352350c6ee821acca176a402a98330515b6ad0a5e3d600d818e0cbf23eb9ccac26bf619f2fa30f4aaf65c49eb232441aab73f6cbcfce3285174ab87fd3fed88fc99b17cea3283b0a41af480600237a33fdafa2239c51c190de57ae9605a06ae2f87b418773929f535bebf85732bc708212a794b4b22f8f9456f5313ec95128bff927800bd7ed3a237028398ed8d62bd06398840df2c03860efc3fa47f64ceafd82989d510b78682c4e58a76783e10a018193b7c718a460f81745526a0c5b4d5a50277ee980568362f0d5133049ba3472c08036f149c3990bc042900d51c54ddd1af5a2254758fc6f6ca8685b61c744ae48f5cb57b43bb26143d3c1182a069b22bcda86581ab7f50418af109d8081e747d934d6ece9d9b1db26783a9271c8e0cf0a1e921fb4fe63dc8d85ed5175c2dd3bd58d9ca7f985012d99b8f67c289a1034c00ac67ff1bbfbc169ebebd89f7bc5ca3581cb5840af41be9662d5cadd7e753c79ac6311e027cb0dea9327d30f05f7595aecbf29d449b37e127bcf580140b42bec662a6dd1f66f2567c219125ce021b761f7906433bf0c8548552087b56d0c864767bdfdc18fd91edfe48d7050a407e42f32b2fe69ba077bea3d6304a7d11df21c05bed63d0c50ccbb30660f0bc64fb8615977ae0d6dc7c28f2f5c5285fe1aa4931912eda7e0bedde63dcc994fc72447d8984d2f493fbb9ac94815d7646c7bd8d5757890629affafa6dd109176c8d8b88c6112c3581c79608fac107a43167a7b9e2e2ae3c3b2375c65acd181241c988ef1bb1b39aa4611158244af9726607530811d263a63df312de5dd774b02f7e4b7b3ca385ef1e516b38eab03b797d483a984a551a3183297f23683199d814bb622968cb5706b04ba6deaeaa4c2ba84f4e198a34c8fadfb2d6bff14943f4cf16e94f0f8acb66a1fd54ef7f376ef9959ce2e34414aef4f93d5897606a9c76f23043574343793f9f5dcbcf27c5059572e14c7369c545a97df55fdbaf4ef4c1a5a625fba81ab8493c83fd0ea1f7c0094ff7d663523224c90fb6057d1f384217f7d84c05bcc8d264eb442e73fee637b9fd46e5d85cf8b46e81622d3a6c8cad5e2bff45e7f9ad4323256e2c1708684fea77a99934660b6699771b6f315112f89aa570f8e32deca1cfa15c59ef71e0122d5c54bdaea772eae4800bdb98cf6511475ad51469a0a70e8eafd8c883d4a4cf5cc4c9df1fbe43aa3dd3c7881eea0058039d48003a47ea2df528b43d6c812e0fcd6bf9cd1e5e3913e9f69e93576f83a5e652f0993178de0a59a7176d80e2f59bd8247ea64840430293f5b72d007aeddeab001ffc81a9517d392dd696c4f12bde7bd8328a7be87471e8d5166f70b2d7b7879d15862968e12fbeb457a24ad40297c96d790d488090c223fc6da3ba0322aec99e29af89fcc2d1bd0fe4cc600b3aed3b2541436b26cf5c5871ed59b51e8230fe5601ebf8b4c84d1e631fec90da1ea66467a7213f0c377244254e2e548290fc3aeb462bfd7323bcb51e35e8fa0057a6f9f58adfcd1e92ad52ef2aede19984ddea239ee46fefe4a107ede47cdd1c221cea7f3a28595dcc5fc5a8c82e2dbe5f39354b9a19e058467cf83804215ddeb17f8e01ffa9d1a54c4d65dc54c2c9e5f4108203e5adf92c9112d229a2145d4bf426cdb215e3548128159af48739e90066accea31d8b97dd4da23a9ac5661ed2c9586366b9d4038d60aaaee0c832a1680d0982aa8d3507eb732f6c9645816193dec6a38c4a2478c9b2762068d88e42576ee409ba4f88ec30b8440130a90610fbe212381541f1a23a20d0fdb8cd0f58ec1311b6bee0dc5e7c53b4ad2aa24fff29bb329c716ac091a8c25c28a19ef5ac447f72ffbed06ea5012f95bb59f4920bb06d284ce5b0efef56d627de3731601bbfc918af3b7d24c6d6ede644afb68ba9c77ad05b4c92b374334f47eb3ea66cc4203d8e4b893012b3cf5b48321bf904a0f0289f15e025695c26f173af1084fba28e0ae4643fe2090889e9798b86fb4a10bd6afc453c47b29387331d1fa15c2e8e44623fe8acb4f4db44a1944d29b79175eae68ad397bf620d16de4e7bc3ba7431751a62f88de7975f5eac6cf04328dbf9bf43851e00e58194a58914ebb44bbf6ef3a884944deb5cada30193da22a6d09d9113574b9321caeb4e6ecf070d3ee5b72ed7f3c2306afdde4923531a756ae5d784e4166c728cfec08c9bbd8a198821b2c3a3e32d35d23afce05c1f51041a45e10bd462b848bb473980e5f0ecfd14150eeb87c9d6d668e4b34b3cb071c758db2a6b77c423e29bd0dd72f13cb07f2298ea25c4935a0b73104d24ae5fcad20d6a3247dd8716340039a2b07c1f62e0f980cf25994b66079c2c609a2acdcebec0019f64a1e31c3952426335c67df322a79187b15064992bda50e8f98a1e69bb3e2f02195e9aad9e95659e15ebca347d536a283a1bc6343ec9f80a3b022d5b51fa148dccb93ff051cc5c7b007b2740caf79b79e7bce9a793f828d82bf0a158088c6eae029507b6b6b616fe8721d678cb4e12fb920cd5c0e5afdc4f8b76cb3cefa65b748c672cf6a098093193874392fa6fd1f8278726027a9dd8bd74374227f3f8af8083dd7a4689c5ef0b17821f7aaf0427509d0e2b133b414d708f932ddf770460262901aa2e8d074afd1e66136c0051c440ac3bd83e442cd7e33afc2bd1bcc273aa7195ec01e3b7516ba7f002608099daf4a78b648fbe5c6eae582917e4d7d075b12acb8144e6de81b29ed8a7b94dec95f79f4b844e70ab8146fdc58c8e11c295bae68cf471181ada99466698bbf45596f260dbb7bb1823d9638afb40db0f5e4e0af7317912babc1e67c3b2140ca4fab38beda541ffc7c585eefb963ff85e140cd66fc154adc7196488007394da38be3a6ab7fde133a0cd4879c5b152aebeafcd8fb07657f0519bb6d4130899e8616506c35c6d2873093ad75afcd182d9d74c7e3e7b9bb810753a2b51f8f46cd5557a8a4ebd18beffd9e0aa07250351e643342ca418c891b8f0a10fcad2614dac3ec802dd317636278768d2733382f7c3d7938e328f688e71af2dc35658c6070ae0988994a2f5ad24558bdfdc0368dd87e4534b72b5022eb3b2e31f55d4176976a407c220ffefe62642e112e4af339e8825f6a32cfb221d2e0bb6d07348477f47fde572eba68c965b1cacfef311be77e421f35e65c868dd0d7ad190c119ef8b058073c1efadacb8d5c81b16381300927d212cec58a7dd485534fb6a000b62bd89e1e6630b9a70817442fe1fa6178fc03e1f48dad6be2917cd8328eccde1bf630892b2d84a60203d27db53504dffcac1017c214625d05381cafa2dd6a8caa72231b3ae9b0ed398e7cc553443799cd695bf0c6b13179567fd9ff9f801dc91df321c6d5c540982d9ce5a45d3f381b22a80fbf274d6fba629213e9c27fe7ca587ea873f84284767d239ccbc3e73ec0e15f361bd58359560f879619324fea6d0bec7b0daf3fa30e411c8a13543d6a7a9b92eb2b0bac5c09ff7e9f7b34e285b4c397ac78404b90b4eb43106eb99cb8c4b804f5ddea51159adac70ed173413c0d7a065fec83dc47e71a278cdfcc8f00a84c0abcbf452d4ea494895f9f19efe7ffe98b124c12896d74d4b2edcb12c599f96de3b8afe2d164ff926bbd9557c6e53c7cbdab769eedbf99288c12ea430ba95b82d63591f8f9f6300c8bf4c24a06fc190306e1e2ca9841e346ecddf6507c30b3cc1cb767c21372826eb2651bc2a8c1e6e0b68cc6cb0d78d1b758da83775917339f72a596f73de7e8155f0edc02d10c85d677dfb894eae96830159c0192a3a09a9cf17220fb77f8f84840665e244b43a9e8e063479ad011c742e99feb1c33a2c0111d88b5f8f6f029944e3ac0b81717feb3e6477646842beba46bd8cd7aed3afe8aa1fb6afe19f4e2212578149deb6bf68bce04118821f904a36ba27dc6759179e659cfebfe349e32504d99fd093325e5c808ff7b5c0eec4929ca9f494d134ed39dce09d464539247e650d45bb98977d069071bfd8593853839bd0a5d1da62dd5d48113412efae4beda1a77c02a7b887c277e302bebe0cdeee150d2fc4076a1c881f717e12f43589e50172c3f7f24b7fa55f52c21fda1fc32dd85b9769facf2100c2485706abf5f3133dd6deb225e82cac9ffd8398151129884d66a8be9b8437626c8168981dc380b487dad953cadb7eeeeb7ee00670d3c8ba492f2ee1407992f57b61a330bfe56eed8970bb4c544c16d54c4ebaf448643b7a7118bfc48d7f2798216194c23fd82539f8c113a1718006d4a735d7efd15342d24c79a2b7df9da9e77476f08d12a4e2ad59d1ea0de5f196b1e5041d4a8f89b2339e2c097faa352e8067a8e27aafcf3c18ff8a2469f606bf7b21ab8ab0e84fff9b1e3a034534f06faa943f2b3a5153a718a01c37db88ed47c73309f6291f8aa199ae6638b4bfd1b495b2caaff13de7f6076c6c1ec0b19381b39125029b739fc7c3e27810c5978ff80a421f49a66ef969d496e5a8b8ce7f224cb0de0013df59d1157a68568aef27c8896d9c80d4044093126e3852f341131adf007922d46250daaafcb564ee5788dce28c972ea812e2531163b2aa7bd66497ccde6191f292cf8d908b3298bcd73a2763a0cc25881744c7ba87db7523618e6b87e4aea14e37f72f5d53e6b0eda255853a81e00f3f2538ad666d292ae185d34e55ac46d80435eb19aba91a630f0b5119908b48d21e9b7c102936278ddc275c2ce8686e153fa3b62958b980798976e554cb1626cd12dba30a4197d8589949b9c4bf8377721b1d000dd936199c91da44c95b0807409c36c3ffa63d072f6bff96313760d99ffa77944c596f7c65bee0bb77a4d64ad7dcfacce67a6aef5a3947ce7b8eead7862cf26e87cf5e17a2082f370bf9c1c2b3b4a75d39ba884e17908134147423878a2b3264ee634a116ec95f24fe346af0ca082ea60bdcbba7613541722f84da1ece960b82f68a30360ba69b924bfee6f6a460e2f12acc484c5f91eb9b820ee5b793b13508c346988563ea2ce231df3e10392e8d4bb69af7be1661a8d5c30bfb1c8d659bdef12cf9277dfe1763d5ef07e0ffe9016b13905d77d59dbb7fc2facfd663adfc854c37f91652c8a0e632119ef1d02c92272ab27213aa22cbaceae98f93a0fc289da9a4fa76b01c4f279110fd3df5c49437b3f421b5fd72088803f8fd9008371634f29c0ed7e6677edc36c49c8cced646efe51fbdd672921b3c1430b9317d7f4a15f92d9836c3539c6602345b1654ee1d3b0d57b753ddcd546298e62cbac601932a36dd853d06b0fe4ca308c092e8778fdca92e9d0371daaffdfb5a642c54fc1b982621c2e9d015413b0d0828a76c59fdfd95d3fae28fed4a1b4b018adf91ed1c170f9f4490d0a9d6e772bef747c7ec0d94d6b2e8cad2a5c7dd1c8f0107c88422798a80e1aef59290b6c6d033b94d3d43e5c177b8c52805cae56cf0367ba12f65fd17cda9b0e0a8a5cc82e0400babb66227741eb9ed5e7865f1ef7867ec443f0c420090a4aee48208e228f20f9c4aa3725b7800e2cd287b2c25d870bd5736211a3d55df08d449d6a6e9f7bde0e25af9c370194fd50c227638c867bd66ed1c623b572d2fe2c2c6763d173cb72e446393b1f4988ab6a3fb30935268f94d29511c8cc352804ff71e78a48723e1ef0d1afde47e7056b8b535e11792d1a4a4f1cc76ea4cda3b4a440c3a27f0e08d4cc5f73ec644fb4a1ed65b5875f46ac97fd9259e52cb3e4a805a59b98f81ba295d7f3e82278a66488f37f9bc2e0c6b82d2f213f362f991d60bee65d71c1bb17b787e0dfb7e8103ee28065f82be4ff0bd4721aff213a53e62862b339341af002baea61a101985086a5c19c05292609f212f899380d5c5b47794832b014fb636b4cb23547320b599b2e3ab23d58f6e1217b88d8ee98087623ff436ce0d4165886451c348cb0dc1085b7b27cab6a6efd6a518dd041c77ea0acc904cc8722c18395e55c0e5222ac4ad02f7446236f1c2983c30dbdc67a935817d782c7cdd69ff50eec30a0aa06c2792d264ce897aafb8b080d8645be85bb1ec5455123a7a851ff7f5ae73aa5260171e0e80f002128e5c7181eec128a25fbb201351197c2cb64758c7e6e4f35118cc18477dbead49ca67f6f78fed82112dd7efc72e54be77619b2907c633273f97f490111107ebc5948e1cafb7c6348a5dc8674e4532c15140ac2875e75764d50cd1f60d7b3ff05ab9e46d190c30dfa1d1fa505439150b3361ba464dd3a15875eebb83682f7f7b4f82074199fe670db7ed0daa50c80bb19bfb24fb2991e83d6532fd2ba1ce1c748b0e99ce3b772966ebf04ada5e2307a965bbca814cd8d5efc6630ddcaddef9e8070e6ab45302fadd4089af1eef79d244c8cfd31859bfa805e45b8e4a33307e4c8daead1c6b52c74d945b798f56d1b23a922d6309d6c4daf9bd476310f05cf59a10df20fd35367d286b40bc878458a130316a51def21ee7dd3dbdcb355931dca32b369a38097039355dad33b00dbfeac5eeaf843ad0beb112fa2ee9c63830e79f94cd019e44e4daea711d529de58a83d0ff2bdb4bab93afe972409a6d207d3203ee9d8d47c46726922d3477a56fba59e735f7efa0da7f74feabb5b897a3b89c8a7ae2bf164835a9ba4de78604f1cb42ba3ff25c5689fd31222050627075e658dfa180fe0feff8bf87257f3be716a0be25b73075079aff8338727a5c49a313271f3404b6499711a63c173168d02c63d7a4dd8107dc16db931efcc351c9b7d05280388250949e311a753e3000dfbd732851f04ca9280fb5ef455f2f0efc1c37b157cde19751cc03893f19e79f7d0144c7407565688610f277b548c59716357487b6c2a2d58440cccdef65571898e52649a572058870fcbdcd8aebbd00378fec3550a5bfe131c0b0c83ecaf32668dba607c1bb2287d1ff8b9059e499a10d10a6a1f4dff558c311095cd714bb8a3e7e9c5cffc33e3637ba9c9ae9c7df3b365aae1501e5d8191d0f8610e623ecb5f49bd2a7a5b45cb42e4a75e36b5d756802e41c8e72f9dbccdcfdd1d523eeedae2d2595020ec937dd0e4c6c337c9e3f1340d4b42e8cf36b1e7825545764fa5b9ea7d752342c595f20ef5a2a3874aa9617d89e475bba6949edf304994c630e8f76323cf795192d3ad44f479e40ec1375402f7a465919d4a165fa95c2b982f9bfabf59f30d939a83b610ee746f4588ad0ce88d8bf5b15812a93a466d9d8bef869ec04aeeadd63d17e51e0361057131a2dc890b66fe6b279c9ba42691e33ae43247c0d7c8c8e695e7236b0b5c611508ac9b3eead70ce79ee4c9005acd3a50fe4647d950e48e93b1a4c2196d59ef7dbdae1c7cb4e190b7f1c9c91f89e4f2083128f86ae7cce5a8ce9625806766f718baf17fc31babc16ce941382fe0800702ab76dd225486b749f31e2382a09ca949c05cb75751a7d398dd4a9909897a8091c4ae0c054508bb9b96ccf237f36a1ec35a408edf40e41970bc384ffda37fc21425fd402b89b78997b8ac8b4d4419888e6304d7af650d52189c64ee358d19162bbd7c772f97349f5346b4bbfa1765b4806faf65c2e540ff3200dd77dabc7c6cbc04e4c242470bb0008c446bf54ee78fd33c7e8881fd715e647ce19e0463779af17f2877e46d8e8ca6e7a1cbab5c46b1431061df884a2c7b24282619abe0e8ad567755ed41deb22da460b0805fdfae649dc5859ab2fc27c6d3acca4d7f95586dfb9b3a9c417b0a46b18a51130cbfb26eb2d7873d9b3785aa35d973741bffce792a9fcc64ffa52aca3aea4d21a046e188df6ebf2ed00c09e32c64d93c6280df012d9c8c818cce02a014f7848768367162bca5c3336457d7513d393b72213228c9e37a46308e0c8af12890b8f80fffb3c85774ce369303b253ac09fd8960d83889617903e5f583b8a72d84365eb0b6d3a7321db885e6acb4daabe41bea508a4a4f753edd519797e5717a34de1dbc659c75f57794654752397fcc7a55e5875c891afb90142c7a7d9e6e5f514cd6ed60fad5d2233928cf83f9b0f619bd0a4a5556193ca158668074f882c7718145ebf2dc63a64ec9713bb75e96a1c6395e785aba6155fcb9d0b3462c9a263e75400ea58744dfc29848ef12eb96e175449253b70ba438215dcd3eb553900358b9f7bce78c8a278f476a382566d23e2250cb8f55e6fc7264c337bdb5211eb0fc95f869e8d526b882bb453777c33b91c6a7cd80b133e8971ebb0155eb4eec0372a662951224105076a6cdf589c642a7b29cffab900109d68e7858a62ce95e62385c5d9e89061f568f9800747687e996d8f48edd718ac5a4cf9f8094034f72e8bcefb5b959285f27a6471ba2337d1dd297c505c6d7f7c4bf6dd29c8d7180b4169122b9f733b5aed72ac3b325d9e13644172754d9a077086ad6176734700777c181974246585077ce5e5873b2aee67c0d69f1500c7729a0eb7b8224adbedba34fa8971be4f7fc3ded777ac5302ab8efe62dd66e7b56b0e1c9aedab99025c06c625fd5f60b7f0928a984d22925bf2d06b17ecc3e0b65986c0eb116354185440646a68935d6ba94b4f1a1b57c4d9d22a10e6af0f6dc6f369155348747bf9ea0914820aeb1b567cbe22ab02ef93fbe6a15f4302ec0fe72372dc33f89325002f0ac63eb11896f75798d270c075aedb123c032c0d91bfe813e8dde5927592976a9e29da6502f52b57489047d6ed30406968a21fe1295046f0fe898c881bf98875eecf31c575df603b1404b74411dd9c9799375613bcd6d3cc9af4f9e12d58e1416497abe24482265abe776485c2b2872c6b16c5b78747c4ce84c21778a2f9f96cfb5ef024908e0a0bea59ad59550a77bd4e0cf0ed60ab4a1cb8c4d09e4fe8782f4ec37bbf9652ce6d80db58de03124b9655a46b6501911a7105ad25baa52a2a861b5437d44282ffb78890d3788598c81aa4172b53f2204065a6c1c29fbea217cba9b6a19069897f99d63483e6e8e8636b582f78a03c4a063b38458de28bad37ec7c781e3b79b3507e0d7fa1f688e5d0e498aae308c533e59ee429d1453f834fd950afea12460485c6f3806ea33256c06e9f2c232a58b69184f74169957b1fd37abfa4c4d1e0c1f14bc4348645baf9b991c2b18c93649d4d18dc4d8636f2674c7525d0c466eeb4b4af4f02a9f96b952aea00f017c242390149dafe3bbc8ec1cc8b96642cfc7824da22a3db7b9293953eca9412d472c3ea6eb02f30b880b250aab5013c7d888ae17603645bcce8dc5d3deeedafb84323a9e9be775a3dd49ed72009cfaa2f2321b8baaa09187e85067ac735e7e9b0e0ab41b448c3353138504ed17a27150ccdfc3e80fb70ffd094f6551183d708b430c19c0efe1a7ba01f297942a8f55baaa209f94342bbe250a264993d6d2a71f8d35ca773e7f125fc724638e2bac3ab52408da5f440b5e3245bb15041cfc9712bc932b6eedfbbcf78d14f09ee01f5291d88c634e21561f7a13775f327dafd7943cfb5ae0fa6762797611c2eb5422483c93c942b5a0caadddbc24299faf5b83f9dcc482c58595ea57a639749e536b72a0279eaea4779d869ecc4f252fd4e3a86876ddcea422154bc1f0715d05ac054ae12f4f6dc5e09153ca8d78559658be943f27ad55545fce49f9641fece548ec0eb5e42cf25e41b67841f1198d302bde29eac59f51c42982fd02a7b47e7338ef3f6c935ddd2d8010b6c1344e8c77a21ed36b4a1dffb4c4bb1c1ac3b7c063befe5a919b4ca1aa460d04ab6b73c1e55125442d9938793c4264115c01393fb39523531616de98c3e8516d76e224f11cb79b052b278a7d083f4520196ee765c9131ffe9ba96aded76a63b3efdbe2a08a4460bc89765d66fa927654c424ddb9b402a483ae3a13f733c00628e81488e402ace4261eef85848768dfa05407b8c6c75207f1af94173d2a13a03f94073ca504d61e473322b8264b2e6920f07a198fda88f5b49cde1d64d08db14ae707f16ad48ccfc62965ef06ac8684da9c986a655b03b1f91d44837cb5f797ec66f9495e055b7b9bad2dc2fa5b5e22812fb9f47e1a9ab6c244f49e98d72b6eef465ac615034420840c92ac574655c1ff244b11bbee184a60545bf288db3010fc0d65d2d5fd325be87161fdc9c26946973649961532c3e15213c754144b3288b60751ccd0b116bc7c550d1f0c48f99b1f4d6bad74502576d67f7329c71d753042f0b3722f05b49d827736e219849d66bc6422d872043f4e25679126143d9f0c760f3affa38ffffe5f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
