<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c65a5b805d33e7a05aaffb9dc9e9790db150e9240aa2500244c0cf85133b57539220ba6be1a343f61e2437a145debe9e0d26592a63ef5688c5df9cb2f4bc7e401c5af61a7c6b99e795bc82a60860ba1d0244b83f57b6f3d4a5335daa05a087b49ae2d52a1284a446591db353ee57d6ccb5e095de19f11c78571d02439ae9d604c5a5078be73371a193b938a8ddd8411c5e4b1efd6a07a4b775ffe6f0e79c4162f5708e03ad297912ad4d6c6b713a186f91ca41d337f9cdd7934255878404ffab7ce09babbf835a80f77689a332dc24f11b90cf2fcd6aa45a1f6483ebc5b56b6882516a0241fe03873f9f77f01ea7db7050f846881714b09794df21d4971127850dd82d85365f97ba8b1b52706830a9e53609431086f6ffce9f6b179935e11e47b7bf4995fc7c2d4ab2c06ad9cfc4f46253efd7b9fa4bc36b5d39f6688e6eafe7d864bd21eed131daec339c69bac713d0c2e8f8a63e1623f2eac613a1c0037527c6d6191a2099ac314ee991b378220c5620a3eb69bfda538239967b9acdad850b04dcbcb89c666a5b1ea6fb4f8f128565e809f6c7d7556ad2cadd75a7f39499773edfb1dff25c0ca46f7199a3498039a72e56d474a3004c8f17210023665f81100af9993615cf65bb03fa0449deb12fcfb7635e2922f2a02c90351e82e8a3d85fdcd6953fb0607b3ee3888954d319fc4362ede6e7a61cc9af8f9c95ffd29ec46368e05b286394650c376f836a91f3d45a955b8ae427fd8af7082ee6d1c230e04a895b1b4161a1caa00fd421b5230877f86a87c075f3ac8d42a57758b7797424cec4f761221d4083e92353209f42b9e57fcf49c2b80d731169616c25fd42b08746f8de52f680869338092c38546063bf48519b3e613f97ddbc33deefa00d4f99dd5b4b90d96751bed71cfce7584e84e5787b15898810f3f59bbe326e0d92ab6ee750c93fed789028107ff1c71116946158ba7573de2ab8a0c5ecd5b4fc9364a8597919aa74fe4f9c49a3e986e34a13d6ce71848d9477eacde9c7716515d0ce74b50e5c79d300b00f0a3bed2679269eee28caf07f092db3bb784fd526d866b158b0a6d9ee7c4bb1311a6fe9e6ff89b9731d2356f484167c19b668eae67a23e6661989645c021fbbdeef168557dcfa61ecf8d4e9ac0e19eca03444a48adcf0edb0cc14185ea8d311ef4e801589a76345d31d5c88e20003f017b70f59f3dbd1cb4ff8193aa425a312662fd345b1651382bc45b8bd84a3e5f98d8659711a12a68817ff89960cb5e448e4bb3e8070c8e47ab5e3877a0955a9882c748a7d543fb9c223fc00f47a4ed0967534826c5431ebd501ed0d7422f2b74ba566e727b68c3a3203f08072fcc5a1cdcffb55c62ddc972394ce49ad0d812e903b5f5d35a4e658ec84837b7747b667c30bc9c47b8f2ea106a70766fe9684f65dbd6323c71d097c0b063bc9785e8b5e47816f6cc70197672304ab68a739be0572f1738c5a4e9e32108257278c69026f3d335b7a6f7eb87300a71162c34a4b1b2ca1d2c4d260adc9acba28f12c0945419a06edc4e865a57893df969336b98d9769d57c7592510445ba0e9d50e6e65e522e68ae50d310a6099df37e5b0e4177532d5a611cd7fec0e823617627bbb4b04213e43e2cf78a9e468e6b78ecf1054bfd93782535a8ac60fe292800651c4154bd9bee7a9c660453ffe99773c04b11c0ce9fccd8405d125970082673299257dc55034062f184894ebeba214fc22b8b7eddc05d018fd2b4c3eea6957e278a1edf9801d3c3db84de17bc70b05f5c9a2e7f4db9bc030ba1d16ce781d0b66b9e5f374d3cea71f4c267d5a8fea7c879c83b499acd2e6822073cb1c50d51c2497624f72e9ea57b6c500a3bf1513ab401108e770c152a17d0fa65db7ad7f150298062bb7b58f8321c1ffa8d80e3c083100a28620b7f1ddd79361e2324452b6faa6f9f669e6728665ed3b4614febc81a2839367aa235cc10fce8bac519734b0eb29b2a312cd6be89fc5cf322bcccb951c7590f04b5baf226b20f6566ec634d119b5435cbd04d02ae6f552bb35144034f00db66a4e1a9f5fc65fb317efa246c2d76ea890750437a54729c8378de2fb74d156257f10dfb44d18ac372b7f81165e6e573943d00bd33f99f1c045c87bec0d2250e0a1b198defc3db1cdbf724edecf23938fee32a8e58415cab974bd8b238264d45a336643b065e64d23655a778fd78a4eee86dde32c0470a830c02cd097916b43c49fa4bffc52469da853181ab76b1f943bb7d8f9ac13922835f240fd40018357bfeb49bc9c565ef1e74ac24e3c02eaa5a23e8cc08bfbb7cfa63bbbb138ddb9f6ba31c9d24dd36382b891d3307ab8437936f9d5bda8bf85c27f26f6a8bdb0c410883519dcc94bfa9f063473c8d6901e70c4d5faaff84e7a225d4cccb111c4f0585aa3cfdfba4062f96e9d03b30bd6f7414a234040a4d5c7fbf2109c19b664c8b6966d54aeb69c47fd20291fa18ef2c255d5665d975304e01e3fb56937a114b296e9d47c30763916d66ddb4653e923f7619c05da239853bdb9ee11c00ad9f3254b874afe16b2be47c3b3eaa9aa012197544012cd198eed25ec1ac68fb54afdd987010bfb7b343cf7da83bd84ee56fcbb788ddf1b1fcd38694677d1db8b87ab4dd1c05780a3624811241f08acfb876df2888983c3c44057356472da4f25e78ab5616d9251a0d85322772e929c38e2b1869187b7921df3efbc19ffd65b9e8c4ddee7774f9a633d907687df509585bbc2ebbfd5529e1e43929d5d0a8b47580519dead13e99d887fa2bd2a12712ec84acfd8b51132ed859e98b77ec738d8004271ae847c953c7b35dc9d7231f33b4904c031b5ce07716f80a8254e0589de829c7c4ae5e45cd8a367551c366c3f3f6dc440dcd90cdcd9fa5b269af8812f2116a1af2bf34275512c0576ead8865c775bf1f2e11940dd669c62b67b9307268b0eb6609a714a23544f74646ec8096af9bf4e3fe9125d34a84dabe6acdc387ad60a501162157ab6f3214da67032dcde8952a528d8373967b522d2952db8754d400c1c2b43647f3a05f49091bceb8ee6116dcac665c29a375d7db5763f317927b2ceb68965d0ce3e37713d312fe35a8ddcac1830b418eeb1aec0c863da6f1f40b51d04e3592c7b7a2fe5bbb7a615c89a18d5caf3c2485ea0be97f30f249578265c0c45c165a5ad38f8eb684249316290059a7a9bce2f5aca06a93a893ec58f8a7ad3298bb48b52d80674618ecfd162fb0aa7491355c90d0a72b16b53915487848aa7c2a56e2ff453d634b7b29f1feeda69436818c941e02e31bd51b679ee589e6e77ff4b38d3d10eaf363e553a50015faf56158822c0f9018880f141275071bf5569396221ee6c4e718d7dc83a56f79d462e498fe7e965f21cbb25f13fc24c4b6061907747f3d2e90d9cb7d332e203af6d223ac34aa80d5a741e2d50f2dd68af26559b6eee07d396c679747b3aea54d5de5a0c82f89c3aee6e9dd41df6787ea4a0e516f398180a281756c0f2587b2a4906ba8f1a4bd7aa1902765147308ac9ae1a35b34fe059c926a3354b9a5f1326d28afa2e3a336d64504d39604a24205fc69f21cba2aba85849117f02b1da67da2dfed4fde9c1050bc7bd2691ef52b4f991351e79c7e20bbe6f09cf42894ea51c0b7bf79aea6b7f493cfc7123606280ad6e5c26cbd34a050c2bd700b8c04a8ca1babf6e8d8e5efe265f2a8eac492d62f4ebe8bfdf796885999fa251f845c164242206954fffc559bcd08e5ebcac689615ce0f8b8be9fa4ec88c8df5f805a76b6a158b9ac852c3e727c90672f49fd21d569dac8abb630505d8bd20a81f24c466239c980d28e32077b55be6dd515920c5812e450b7c5708a51a59c39659300beed3a99819ca2b7b45fd28a2a2e48c5e00cf602c70ef4f242d167d9d55885ceed3486120adedac6e0b55c0c873bf4924f7a706a3c320fbe36464f3bf1bd0a9fd9392825073314a1d1a2fa840104ffcacdfff8609761963eede69b0721fc06768a1d85aafecf1d70c946e6228e2b3fcefdace5788dee5d7caecdb317c4c981b2b444e5d16082a99ec388cb9b7cbfb65f24bd07e9f0837c099a639ccd5a1295c2f717a1ec4ceae42d7cc0f95a771fdb28081f802c4b6c40f89610d2b9638103685f43fa87198de7190b531b0aacbd6b8f422a5b0bb27f627ab4a507c558f43b34bd22bd9a43779d5692306aada846a85c7e158a49539a68e22fea074cc0c89fc37d7712e686494b2475fa642ea79ce84be661a114509ab8c7753c4ebfc1971acb24b8871ed8bd3e8497e11c55a8d893041dfd1187fbee6bba41254ebed862f84195dd29e7b6fc22c995dd07a297d1c692e92b08379f696d40aa0b171fb84daa223d9075bf5dc1c7d8a2f32c1b2430175f4350916da71b1d2049b384f6d615c262abe75a34e07799422582c0d130e28033700105ed1bca050b6fbc225d1c36a2700ee2c6301ffc70819885bebac4a644398f88c3ed35a4962a433d3c680c84999933e7923a45810786fcbae068ddc781c29a358800949fe13e80a66b8b5f00558b3d288b8fa5bc2024d8f430289ee86721c2d17102d6b80351f95056cd893d19bf465458080cc3f2c3da453ca107bd55d7c3230948bbc9e0a64ae0f9fa9a7ea78bda32be9e648760a3053243f8ec1a7813abbc46c547c7378ff9b4e48762444fb645bd6b52a0ad5fae4ebb3a0d09206d2695e1f5b893ccd7f3900b7358574cbedba0e2a9684de0c30e2b461245222b005809b14847b20209c0b4126ae6d59568fe91181f914c28cde6f03781e811a2ebd31048ddd80d6b182cdc5c878ebed660aac56e3cdc478e992f3d61b545ceedede09d6d926cda28c2c14e896d5b4129cd1470769f3afb1a2a1082518e886185906148005524362b64554f6bc8ccca0e5889b139e5654918b4720b1f8b1ec031134cb550a4de82de0a16400ba23204f37f7ea74980e349afa34b9ea22a678ca46d7a0a679f0db3ac3f1f56bc6ea115cf8085e99ce588a1cb80211e832acf072cfc8b11c21095f73cfd7489d02ce4322526f71120ed9359d083fd0ae127431b735e6e2dfc94bd541b63fe99b39b4e9bb48b02b5f3aaa781d379866e84c43ac2480b86edd668b7074887b47c93f9ec5b0ac01f1e37c4648048241947369c458537fc17b27e53b16fc083ce3178181b3d0ff0a0a03b4052d475c194b3388acde36c546db8afe2c78d704c1163566e24a1e78fa84670de0a29c0c12e3f9db581f1d0a384dbaafc2cae31ea676dc46473086604d6771a8b1c4ee58de10e49acd6c03d4dba43c4609b8b09585b544b070e7d04098c9ff75bd351e8af6dd6e50315b53f5938bae8c506b806f671af7d2a26f92699b2b95cd9d1d5adb656f7b94e70110c4104e06e35d53db41f710365531f9127f386e4681d441d6ed46af2efd3069017f07365829593bcc34cccc91be3883709ed38f17d449ed7409cf87b60a5d4f51808a34b9cb65adf6797aebb5f0cbe1b1938fc08e9dfd303331016520138636cc5d840a757203ec38308e87bf8ba8193cb3273aeba560d02160092cf4bf47192d4b2b279d909264651bc61d26a8bc1f8cd05083069ddfa0131b4de155869c4358ae2dd94f83e903194d0b8ec443ad1c6c7786dd579078bbac278f55501676988d619cf17dadb432f6cf3ae4e3184e3afbb278ceff62a577aeae1e2be2c22f75dca474461e84be2be1d0ff5babb7914a6cee5bd3f865f4f092c4cea1c76e6925511762ca83f9751c2596fcf9c09dde2e1d7575a67627d77a8fd62e2a5a1ebd6058c2554a519627747bcd29a6c0e9620b5449bb30270c792f2a1ee266116f414dab3ff1b88ea8ac76ef727614acd35a61f0d8a609c023a7ed824f930b7668af046d25baf154c4d071ea59d9273be0732aacbeadf67993eb3e35fda3b48de9553aeadd6dc81e905f2ef6cb64c23ed91f7209ab8a8e17984577652e7e74430d1e6f16b0cf94c2799e7de3e2e43c0c5396519b1b147e41742a2faa64db27577579c089bdcb5deada271ee60c2b75d0b83edcdf743940009af37fae710442583d02fc308e945e7828aa97f6d8168d05f32a7240f1213183084352f73995b0a2ed1a88c726effd86a7f713875824c9309ecfc45a4337aa5eb1ac82ec3aacf9a6d74fdb31f7722d9574a29f981e32b895f5a996bdd4c1d1b1a5b2643817d3b02031aa44f35556d56f0e97d303839d0abf9417dcec6c90f6457569c7d484ad9124f4cb91e5012e0b8dc4029f53f7ee8d017d91db8553d7e9ed54a3fa2c7f172e24344638104cf606bbb072315a0232b5571a415c1af06b9cb9b2951830933e95969dd264772bc23c48f24a6513618ff7ecdd66316375e0cabd59cd68273c17b7bd64513667db20431af69d164a065caa5234f5481e721143d27aee92cb923f9cf9c33d85feb10ea60df020cda8167f2d62e9523884ec2b695251f6afd01edd82af51d0af5af02bd2a662e9e4fd786552089e4d0e21a614465d3b79f0ec19df8d4b3c5fc53287c737cd9cec971c7aa9b7f577a09ef981c5ab130085a2925f22a4fe43af99e5ac79dc684a588509cf7dee6af9b01aaa096ba1bd6c7b550f82a6c4d6a640bb11883de0257d133a165398cd80be294a8d764d5fe654ce6bcedff85e0092776228f2a084b34907730145d6a928f7de29728e48e17e13a24067dbf543398adedfd50669292f634952cb632e79cf1129b3fd15e6692e369282706574f3de64b5989b7765948e7636bd9876d6201f969f19a035be8c98ee8070b519bce427fb58d9f72e0c2e182c0db8bf87e113a92a8ff9529b5995a2f3bf8fe513795990741a5b1b2153c1b2290aaca37b9c45900b92980d9d98cdb6d58cef16d4f2a08a3d795801922030475fad3a797627f354a53028263913d6c8a09d48b25cdfbca43aa1abf95027801309025866f28c467d462686aaffe0c42080671e39da4c7184123c4752875c49aece46d949340cb9094311e49d926118a4f2294b8e417202115fee8d1ac677b3f15a24f923423eb1e6fb7d49a9a88471bd359c2d95908db859b5d5964927ee90e8f8529869f8f1aecaa3174867c0b2580f96afb28a1792c4378ed864734791ae5b11485b879c3ed03b5770b94c73ce9719e694e7368d144084d75f386ab6e42844da8af3ae6611e88edefa6ea89bf0dce585737af74369f4d8b0c35c05c81be53b148d770552fb820823cf2b26d12bca1ec7cac01a7b314b95e4ac9bdaea94eca2b208b9d2c3248ae604755997faab4d07d3335c73363cb185e08e6f6b5d16a5ad84d64acb08316f09820ebb2a94f84a2ed3cab2f52900709ce34b95d016abcd7a97a66adfcc057f998c6eb42ea3510d5059ed48338364d019cc336c5e866dd7691de1b66953a435dd415313a98cf141dee9ea91eddbc3adbf4a0948a746e0049af95eae5ae00fb50ec92cce58f9a05ead99302115eead938993ce9f9d735c6f5780890a0613e03965e7dc84b547cccbc5579456954f6080b463593fa36f5e7b6a4033969bf75e311b6047541cb8422ba424f50c7cb0de8e0b083a9f2a35b4291eef1feb4d4c0a0a34ce7d2a5c5e06694600dd382d4987a42ea94b85990fcde5d09bce54cbb0241fc8ce9c634911679b8657e7024e123d431bcc2be7d62705b45b84b198640c971d2a0d1db14d33bd4fe24900a825403d33267f1da59ebab9be0880501e108554962eba1a69854f05cdc83c6da192bd561c38a7c76471baf6d7626237047fc0ec4627717694e2db095359bb3a44f6b96d28e8f81717583e5cb81d018e7f7e9fa00e39179d8eb1e1e9c0c30362af9067160c3ab106632b11adf71f210056c35fd3ca9551ac1f72db6a1c436c0f6ce812fcfe48280196455be63f7b919e2bc93fbd40290186f533f5f1d6034dc4135ec875e65dda01eb619f4d2cc1f2b13c240f33e860672980396bdf6aea1ababc29245e306c47bc6eeb5f1649c43fad8f3fa656eeca51b90da7c503030f32b81f9720d680b598529d7dc068db3ec8b1a5d65a3a3d5b3c95992ae737a27b4cde77795d06b52c526b46f36284b60eafca65c79a4b6503319612a185a553bf5144b55fc0e98eb148ed9657915713cb78946aed4b54c5d9220e6ed9b91e83835b45e6c80357dd7a07e941890178ffe98a527c52c0d89b0abc5d2a8a2512edc6bba4e2bc3073c40e9c266304367d24e9d5be0e7b0639994a5dde24b3d4e99544bf50a0387c410bc093e1ab55564698ac8ab093de7e1a3b4d610bd9e880e47474d3e181bb5adf817f17393baafb58d3be56a16a3f0aed587620b50e1776cbaea673ea0b496dbcb0a48d60f274abd3057d64d4e3d6d5c7a4e32d354544ddfdcff9c5aae71786b6f6285549a5440a924aaee6f5605682c8584ee6f5192abab0ffed70baf0be4a7dba5320a9a5c8d2cba425edde873e21e208b525b78808839de309b5dec60a1b362a1b2f5b2ffc02a7eec800b2a1c66116a9a7e368fbe9043f0768c7ac054a8e7b65cdefa173cc615e5b38b153cbfcf77aef371fc511e6e427f3ed7116540142787a5ef66e0642ed8db6db00a4e05ae208af96de66cb9e983137f297accb9ac07babaca2d5d58f6cbecf5696f08ac5e709af0338fb4049cbe2469ebf5a7885ea0c22f2d3162fe7e70e3ef0ebd462dddec21197cafe9b7d4cdd41d131e9cae4ee6fc1a299ca92b43e6c717af8abef40974372a45ce79b872c81ce2663096e951cce55c8c2869edcc94d46ef5e086782ae8403ce858fb90bc8889eff703e29a9256229834a76f9c19f3a1401563436fc3bc497c5ce05b4f70262474a0bc8a40634e3fba4f7866c1270348868ff0b7ff24008b5d9f7609b8e9c895e76eaa03bd87429567a18d00578e9332783fca53a344854553ee645dd65c0098cc4837cb4f96a55068d75da31cf0664cd17bcfefe1c42b6b0ecfaa3124bac6ccf8b73e9571a6780a2a3d6f3d317c582d8eb24e4d32d442a6fe6b0a6a9db2e8c95934f2de3f49f90bc6c354a00a1770cbf740b90a764b95858f87cf194404c5d399aab09e1e6a25495749b631e9534d3987b5b3755eda324ab41ada53fdb557330d12a068f1c7af899d6b7d8f9bb27578ba33b9971f7668658b192aca1e412a77f2ac16811d7d4279285077e033ba89f9291d2f478568b75d096f8cad43e73eacbe6fe5f43ea2a9e5e3e19f1af68e1fa604f058d802d9a6f2397040dc71f2dd29e12603a490d697f95b67db3cb6a30afe7e579207294715b1448802a866d67291c330d06e970587534c36e57638527fc442d3b6e3b57a35372e6094ba022dc2b60bbbf309decede8fa55712bf03654ea56fa7891adfa60bd7acbf172bdfc06d0f8db068f00e28b90e6805af64136fe2c91dc40ae8e943a3887e27492b6af3a5ac641923e43aabaa5a8ebe13343eebabc8236bb73681f010b8200c8c44f0c9400205ccfa06ba4a47ab257124f4245ce7aeb5ea39dc17331796fde98415e2ebe2c387751267b892c89637fe938bc44ead9e5f612cc5a85c7afa26785e2e91b9894d469325e988330750e8a7a36424dc0d546f9a52c31221442c353d72fa844a7ca3f0214188beaf6f42b3b37872c400e6a879ffa633b07b901e92b4cc5617bf9920dfe79de15af0bd84a5e6a6b80acfd443f60b955815ad99731d7ef49ec7045d60e844521882f03978b73919d3c49b3d560decf4da1d1b5a55e303b2c8c3c97df3ca010ebee7b5fe0d37e2dd4e8de7f266be698f95889496180cec7f5a1cc643711514ea44b1b76d8152773bc9179f4cfc6bd253aec9ec8ace2d09368b6d7d85d3ef402ab882303f49f018390b4c76a0db92329df87d9a25c1df257ea2c41d41869708ad5bc29da0ea1a0187984489ef15bb882c354d90c46d06aee23e0f608760800516a87ed45d571ca2622c449411a3640299960696e6e71b551e9768692c3a162b9e112b1a0904dca83ab937a5fdf14c142b8838be4942eb81ba93eac44ce60fb1a9108544e0a7158e7c90e3f47808a3ff0d5ebec88ba2fc5b1e43d0fa10094c8c845fb6db1673662036f71636027fd151d28f540098cea602a6500053ada376ee6102ab9f691564a3e7f88b9ceef5ebdcd07e175f7105208bd0ebd9a46568d216859f192df99dbf9da50154a6d57afe5fbf1d07a746f408b1c535ad8d5ead60a745da71ea378d1ea5cdbccecbfa68f78952e86f74c9b482d7db40da520cbced34be4540d67901f4f8c12eeb0db2ba4c0f65e3d3f2d57860bd99e42b50e2cec145a80ab64a7807e1d062a3b509cad04d169dc8e638586eb564fdd7380781c4e5670c20fd5b1e3ec6335b28c5f087b5904f0131baf78dbf4992de0936cebde67c1959e0d3bc474add08c449f28857c301726c9a43e2ca9b1e1d8cd14aeba9dfd662c330bc4cc363e7c9b1fb4ec2b28d041e29eca9b361db0bd385490c1f66ed439bc53ad5f4d5272856aea7a43fa3bc7a5d999e023aba4e33c28ce7a62468f7ae02f273b4453b9741ae746461cf76fdfe19dba0beb1be18dd3a301a217b886c60eb2cc5415e54f796dc709a5ddc67d23a4c558d8589b1e688ec426ed71fe674e81bfebe3f03378f3aaab4bfdfdf863969d6d8406f68b7aa9356c7e680ff21771be6e9e5f816ef42a0cdd311315464fb2b6e8d628c883f9987657353a32efe14dd8ae98e05a93df07bdd8e43f4b011d7e5b2cb28711dac758e268defaee6925349de88a093d0e0e66116ea30d9653ff25de0dd8314e17ddba9ac8f3bfd56c7bf4f895b2e1a5b3a68f182f4b58f87b233643d7518e72ecbf979bbebf6304983523276b8ac7afe57a8d36226ad7e341baf82aebbbe336feac62acbd3b0f4654c28185e60774176089b420d9ec852533c767372ba8513b74ac1825f11d0adb2f76edba3fc30f788daf9ea0f25f84725684dbfe123cef5c331a7ed67c7f8c5fa93adb8fe2a6346dab9eaa508443a259e92e08502eeef06ae35792303e23ef47d1921e6c65158ff099ae409877deeaeccdda64d0f14402f5b6a5286841d38157710d2af54a50c1ffb110e1a39cf78c1f44c12b6c7afc5134b2988d3c089a35e718759328b5eebc192b5ce538d019442d913eed6712552d4ecbd36ae9051b5974e816afd71c53e46d6128669094d663ffe64b3c5bc87768bba6ab1ebf5fd77b29b6d6e66ccfa9c7d46e8ce333b8e67fe74302d5ef77c5854c90992df84d77434b44ad6c69b78e8efa29874661f829529ec6ce6b6b7c09eb0d58521b811e9d3da1ae8165138f1d07390d836592e6a3676ef266fef4fd3c5259fe805744780c383ae8a8d5c162e5f54f4195e784db7f525c0e78b47a7fb44bb6ea119861c302fba3243619521afc436383a2a4be6436aa34f1b040f5a6174af34dcbf930668ed9683f87764991c6ed6add7ba5317698314450f47f17150e2d37973d347b4d30aa1dfbfd4f28141d56ade37fcf33409ef41fd8e312657a98b6d72ad692ab11c19e4db7b42a903e015408d3d8a735db7585dd59110daaa3f8bdb1634db42da9fb7c3c518a48fd2f86ea3d049fa6b6bfec716164dbfc0f749f31064b607e5ea5e9f286c1e4925f2bd5eb29d1287084699d502717f821631a2b0e264725fe39bb51bdbcb80f4e04590a0013bb38ac35455bcfccbc48a94b978bbcf982c25d0e8fddfc03a26216bab1909cbc6711c1a0cc267373c73f62735f51a3dd77bff6f00a39845727ba3b58aa9c58245430ce2143ac3e90d4cf71b573a3c7991e8f46b9c2a47ee3137ab9a26daeae56ebd3f44dc284ba26cfdfb3fdf1a82f6d6c4ed9766898d193851248005017fed1070e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
