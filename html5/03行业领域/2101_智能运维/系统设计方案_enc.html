<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8550221b69e36382cb0e83567c0747cff6199fc85ee566d318b108c7fa52731338026413266b262b45d5eec35c06b476371615276b91ff111cb4e858fa376c78f28ddced38b9315f278e75500990dc6f8a92d8ff38610f3820583af48f2bc177b5be5ca0cd66005a353b193d6f01bb9c1945cf40386b2d8307cbe50c3f300eb271dfdebc8fddb5b6c9bc49d3d7594dbc59a19253a58b17bdefee32a258ffb962eb84ac8d73669d713b3738bb5963b6e18b2cfe3d295350f9f563c8d819eacd0fe6c47500412c8a01e77d8bf8d685c2de0a9b187d8e17b64187914b0b05607327ff2db6aa550574fd9124fe2c14f896dc89b9e08b17572e7176231240c7e9a94f8fdfd0ba1a7bc9669de02699e3efc8d75a52d961166f6604bbe44d542681a369c8ecab6edcf0df6949c9e88521474c41f57107e47882faa6702676d828f2e206f562e9cf718d5309a8f4fb95b30777e60daf3f2c3205ac81895eec2b696301053775e30ac3ffc4f24583cf2bdedabb2a02938f6bebcc2641582244568cbf5a38d15883afc46caaca8a06f048de03fdf27d2c0c5e5a593533819a2516347b3293bb73081417305a0361b3acaf2b7ee68d773e77812fc006591fdcd6a89f3c9116f5b5268031f70008a20544775fd55582afcd23edd2324d9f0fe1376ed02d80e45ec2cc6666b37b9bd6c1da08bb9a0850705b997a9d7eca835d0f693af26db03c9e3bea6958b2068da7ee8423fee5a9849c8af437389e42ce9406d67bc2233bc54967855a650d09c07c780800629a493b52b7452fa34d1112a00f5e38279a14ea87d5e8dbf9cb305ab3bf14c3b711e7c19a16106f1a8dca202c37a80ba1aa43eee214ffaab7d1f16c242f3cbdc8b61257a393825aea123d3d737e0223bc73c577650e24adf1034c9e6b51f9d1ec845e3ad050ace05d49205c7f91c9d8ef481ecc526791ce1aa2bf0205800f4f0cc5dca94f788ffebc28abd59b282e21f71124c87c6e59ade149cb31755e45967204da7d056feb1e5cd4f59779352664b91c7331e88f18561a7d13a4c03c401582c31ffb8b050070c9cb50affa7102d4f82a76083541476f7e068bfb978291585c9ba1e68458cfdac3617946f3dee66f56c64189215cce81cebb10cfecf998e527f3519e24b8e788203735bc4b1a2c23bfbbeb2f56461d3a6ab7d7bc71cd9150f400f5545efcf2685d1a8854c1cdf172dc942add5ea66dd60d9559efedba1b3246e3aecb556892837df44883b0f248dce329bfe6f212a18eabb30edd6ef52cb93cef4f3dc312ca75d36564cc1b394de9fefe76a7e60e7275b4cbe8e4c911a9a61a3392b546a01c1b14c84f8e10a6bcaec61d90cb32c42099fd124310db8d6ea56783a17884eb0b02284748c684022671e3b92bcc8e6c472dc33ab101f3728be4cbe5601ce45d817fcebdb49f760669859981ab9f08f7b5a7fcc4012fd4a7ea3f0f1d6c17c42550b14d568c792a1ddf9d6fde99f106f111dcf720be8d75668204ac6b9bdbb37097f2cfb64610844ed1e2293a12f669d9248959f7031595705e1675609ef50d735cc656b49e40140bef74cd35523d84dd01aead815f2082d3b6e8b0060230aa4c72a8cce635d9237d647f232f6bb12d234f3d62d515b6e10c7eb3b4092778eb9fda12f58861d394bd3c347cb1a3a3c96bb426a3d9ad0819f16b3dd25be1bef3021c697ccf84d94b480ac634ac5e0204f72768782f6d56e3d7f89740831f2a23d1e527bd8107c33e17299846b3056fbca6e1d6aa58fc733c6fb2c646816894ecd812e87cc3ed5246d4b42a3745c4ca3f577b562b97f07d2fd771a3264b16bb71d11373baf125643e8a652e56cc4a1f8f41d7debdedbd05245f7ac785999d4e06b87c05511a1dfad6e145c468133e74d9699eb2d0e263e001150fd84cdf9b5399140e09a9ad734be1a20de0dc558c0b11ea09c4702ad222120b662ad3f618c5077e7fb5fad91070074ce1a46305af26e038db5398a12f65137e2efa2f8f3a73c3522899334e4c5ff765c7c4e16fe46cc18feeaa6a424d4de18b8d7bc9fd3f440305d6af5f3e46cb58c61b82bbf6abdee991dd7376aa3bb1078cd9870dc85aeca8ebb3aa4b12b90ea9393fb48c2455c689a97f6aeff859cedd61cef20b687abb2ee3456472ea4492d24920d0dd865fc981f4f7b593015e508f0d1cc5a97454423be7ebbc851fbaccbf9a548e082065f40353b6bbe5a6de4a8e71ee6552cec5dda66cb9419a450c877b5d3472950a88fa3072ffb687f134162b32a1937cf1c3073178fa7db130b75c17d63effbd31c3a49cfd64ab73deb9fb2bb7e5dfde1eb20723df2817f51de50af9e825840b0c232b61c2d7f18267022c7fac385cf503f45ffe1eba9215f571eecd20c4fea0314bfadbf303342c0365b83d8c9ba9c94d0eb3f0c0900d51567daa2066ba1021a57b2fd95a48d0140efe3d73e7b8b0409dc356992ddbcb1dda38a5ecd32db1e6d251cd74c3aa255e4a4abd90e494bf74bce4b55b7b4afe7b690571d4260e43ccc9a80d48dcefc92e83778ec79169102a22a56a752aeee34699b355820220cb346c2a32453fd7015f97ddf0efc0fd3b10d2fb8d92fb34616932964d2c59036078c19f3a9513cd8ee0b39baf0c07b506c7133638257cdeeabafd1293ee06291dca65f968aacc8b7fd59efd81e5a618e81eb4a8782bd3af73040f6c8be4cd7565b52f5a0b011608d2cc6bcc017188853bda93e79ee05382a4f9270b738f23227641b5db36eb3163a300df0f4e4e8fa11e541a3aae2294a5d8fa14d9515e322d147340ac3624d2dc3ed4739da091277fef7782fbf4ed48753877ed56d881e12b61b31e6f1c7930ea6ded7e130eaa917080a212044e06611c981af312284413d2423f9d9e149f9c794c23b2950d211d4d52b588815ba5ff4a03a5f425c79bcaa809a263859f161cdd249b704f863f420b2258822ce32fdc854def6e2614621621ca436a30db1284c6ac37eef47128e5711309e4f53e58c8f72f31189f9bfa4fd48a7627563213e33a2203a94b68e0f5b5960bda22c89866c81d7c26af6678b25b6a45e7618e8b175be46ed61b5627b34629b078369c45d1065862a0b5cb9536173ffd37c75facf4829863009830979e30ade1c08b60b95fa7d118474add5f4ceaa5b362176080244200900e0a17c8257822ca58ceb7cd80f8b33895543df814ffb8ce916821cae66de288918b50aca6194e13ac5941ab582bc669b149c1ea7dbec4bd636bda767dce24ab792855ba9503f7de9414a05ff0512eaef5c1d2c00390232a76d578acd8a4e0772c1a6134b5278aff6b37dabdd0c1f803bf05a13d5cfdcb01359b5eb9194498137d19ffd93fc41c17940de04c26f6168bcff91f5672fd0faa1bc7dce7d88cc49fc8b6560124a237bf9c8af3427812d2fe449c439b6e36af632ebc4e3a214d816d6fd7a0f8c15481e53a0a8b7e4d6a754b7e8b4383dc33ab7cf3683a0889658c7e04ebec5cd81961d871095be067cec610ca772de659fea07386402875ef4f004ec98064e5fad3e611b88a0d98b213cc318e383d00cbfe77cbe2d83961cbdc719e2396abe013d9ede2e404ae8e2b84fe994a432d2685e3fc51554aa89db3fc8d738b3b8ee22c48f2a5301c28c301deab89db72c41ee9d36f4065f13ca381a0df8b3441123bfc6b765b971079499c1baf189aad81ad9a13e1561b3c093d7a9b52b90ad45721a59f9b47d0d8a5b5a5bb453b28546b30ae8bafa5807c70add8e1d96ce97f5901623b8d5158ab5480fb043a9d6274f7e7452e4d1ee20b54606da07a0a40ec57909daf07fa71196174db27bff9883882c36567efad2c24c7cf1074c1a8808767b017524a753acba768a1931763ab1a5b531c8483c566c88c56747549ed79dc2261ca2b08fd1b92f38e7b4f22332e0d97e1c1ec013e53a5141d117537cfa51d2f20cb71ce82788a3e5787b4444974c868518c389aa40c469a5010d24e5b503c17c1f07ac8692c6c3616015c16d4e370f5e1b8908a7bf453c65de909f5d1770a665480139a74090b3a739e1529d27e1f5642207d26cf1f2bbcc322fff2de770c8275adeb420fde8c7c92b4bcbb12ff36999673a98a004536b68abaa1f02ee641efe7d424d11c85d4551549fccb04c9ca3f4e44e7cb345ae5e926d31535b89d3980b4e080c431706a96c17d3de5a72ae8c6cca17779576a165c63b71ce2d7a9c86543b00fdad321eb2c4ef78c8ecc358423d119e436cfefb667e0f59b17cd96e4d9fbe7efac739a40f6d917b9bf0b887302b95b1f229ede2bcf01438eccedfc45b73a61beb74782887ab293100638bfaa22047b9ebf9411eb791df695c4b9126058f8109ace1b9c48fee739fdc55776ed34deb8777e1962f1d5c0a82348caa5fd1ae845f18c5221b2f76194556986b2a2f5d073298fa7772909ec80b752998fb2ae5cbae6666af217722881df617e5968caa1163d2ac2ae8363b1f037d28faf5da154a10e3e91111a139549282bfc15d23210d3866cf44d214bbc96ee22642a3e6c911351659b9ecacdf7d157725d8d92c5c755dd5bb2d25ddc33b0c49ff51e5a17a513fe06fcca32bbb89fd9062165c3b0ed628ba7ee62b6b795e19e5a5131ef10887d901a2140c4639bb223ac1ea458784532178db7837358d717d9e446db27eb856f1e55a2472bc55e66f4619463ed3684a7d63e5c8ae7cdc930a176a0d2ac9bc4b5a39d5ae751d108f75ecf70db86b089fa3b844799312ddd2fb94f0dc5797d10e8e11b6d7b43f8ba5e70adef3921a36f4bb36d0e4b94492be9a8b2c9da219234def69bc2a7dd05518c4bca4f76ebfd515d23d05d61809de6295543b1965827e0f8c8c16fbcff1e0573f37a7ee7cd2735d8f06f31c48db21a6b6c34d320fed1f82f3816b434ed429713f4aaa4691c6f30aff7eb68e2805c3ff5174cacbc82ed431c2ca2bc2f22b45cc273e4376c540491be9ce46ad4acccce747a7a233beb6f669cc99da6db2a52ca76c6a6016963fb5198fc0e7c0c1d19c551dc73ccf06033a006a6dea930b90f4712971523dd5aadf78f83ac983802e63b04ae6f59542e24684e1cfec23394819b2434ee1d72aaa21203fc35688b8e6bcb7cc940fccfde96a2bdb6fc569644217e56e88047fcc1a8764a55b7fc63ddfba3c3d6438034cf77a23088f6758afa257f0dc5ec104f45cf2e28bcc1c03dc7f3679c78a438c194d83dcb2f2339a48a8aab02026fab386d11d3281b4b0719bfa3ae92f4f6d057e7cf67530f239447f6bae3712f9786c67442e28a0fa797adefc3cdd6af732c9bb0608819d83c64822bd96fecac376e0c4155c2c578123860379310e850f64bde18064abc428be183abe652204e3f75c87066508d26f3d02edc723b3a5ce5cdce6d045dfef891a3fb86e5956c386cbcd7a2aafdafe98077f132f7372096dfbc90c79ede47a9b1814380f9c0cdd458cabd8891dbafca6ebb428f53d194884fa9756847d85838bd45a53f99e9b151502373a803cb3d49211118084d5a8b05717befce95653c79d439f79357cd7e00a59bfc3dda24c3ca88a8c8d26ca7073687ab7de199624370230f1a64f87b20320b0f110b066199880dddfd37e4856ea9e688caa52bce0432a5d1599fdeb3db43891159afb12446d4e25116e33bc83529bdfdc4f4c4bc1eaf197237c72901fdc8b728aea57083075d59a99a29175ef7da3b87975b6a38b829ae33cdaecf4fbf606a212fbfd511460768086a6954ee8eef403a7b6a04457135b7a0c6cb0326a40bb141a2ab436a63c9b3c5594ae63c5820867e3c4175925382bd72ac24af887c2ee8755abfa3fb40aeb528a3505c3979757d53093e8068efa161cbea138d91560a3b03946f205f4dbf2c51bdb3692150f64ecb9136f20c8da1370244c7ff2c75f12cba3edec56669325903207eb4239722b8389cda1bd6407453378a8ce7af18bdc0a695fa2fcd0c0c80bb4132b8aa32087bc5be4a9860acaaf9b4defcbc26498812c40ca8b92ff47c0b2a43afaaedd83c296f83a03976837936aad44e5ba1b2d28a2d6289c6e1a8f3f659431db535c5f357b71e139b7c472ba43ec7ca6c287d4ed0ab3bf7340f5209598452ac6ee3cea049403cf9c605ffed1df3fd02e935a49d3af41913ae6f0df678cbd6331bfae0633e9ddd32a435fc7667d33e8507bed3da5c87197b8176c956cb4edd15a4fa04a8d580048bbca3665bfd5e0d6c4d2eb640bc9ccae3777e4c6ec1db786893a662418b4109c670d558c5ec15decb3c1fac87ded76bb9b273e3f2c6c63660e5764c9adaf6c4e67b0038c4b8f1d17cc883ced3867a566ea4bed873987a3894fcfe0c3980c46dadcd90b68100d2d28afad291643bfddf48af9b464692ae2eac1bf6aafe7606ad93e50672052a1618f8ee510e65ec940c418a82d78bf47b2228bc60e23c35ee5f9bedc7314893658ff7da345de71a03ac355f39db5ef269033212eee492e6c5f09acf400b256c10fdd0ff051c8fad127d6567ce857ab95d328c15df9bb190859ff825e3e8e3c10eab137e7318366036ef271502da7575be1ef29bd9bff3d1bc1dd93e3e3e409b4ebc235d4264cadfe12a93072441f6d0d3e6c75dbe4c2f22e2b52d873432ef158e799c9f75c37f9979dfcc2b94fff99a507ca7b9dce5bc4205b5e70347be40ff76583c097d9215a469251a0645b78a339cdb9e4a041b5a604997b14ceaed0be9a8d858e3c9c999e75968fbf8f272c8f450fe69b2640bc33f6ae5b9a415318b018cf2425c29eb24e445d55403dfe1705e1ac607b7b916c46930d5d540669ec0a0c8303ec286c0bbfff3c30ddf28d64c99acc1d7d834b5ad730ba291d8e1827567fb7740ceb0b0a10ba35ba99910d87f7bb80af6ea54555092214395967c8170e5e683d847210154ab9900f401677dcf9d20544e6af0159c35e0c5e8af0d2021571081761355448ef40cdf5c3fac2da87541183af341d591bb749b83e6087f65bb8f598557dda2980f18350f0a1b6f2bdc9a25a060a4ea9b4115b71ed19cfad9f838d31bc8aa052dcbf24cff9a64335831cb2dda7598f002ae11c676893ef9e7f52ab3ddd48714973368c0f4eb08e17e7f11b838cc8dcc9198d8424b72546010a9552f9c83a67363887ffe6df087ed51a3c0718206780cfc6abfa7c5c10c597dada8cd2cb15422e83a03095b5e7878d0589f722b7b8b8d8d61b6e6f2ce58ad0c76528195a434f151a73b98e877199e5bfedc679fe6f4ef1adcbb516f4a450dab795c5f4b789187e455b1ed0e8532a89d93939c1e596c4bacb50e60dce415e69ad6e9481d94224c43accc0b1009cf5ba610d27e99a59127521cf695062a51259df96519e2e59b30807a252ec008e0c16fab8c461cf7341e81745edf3448282e434a7b3acd3372efd4d2eed2513fdf5a43879a3d59ab4570d09ba276db435f44be7491a7f30073eac997473a041d8a98286e03f8e0e3d58b575d435e49d65a8e1df1e80a558730831465bcf0aded8e1d9242bcd856c0a62f533802b04d7693ee03e8c6cafacaf4dd21fa29d8f00f06b2d5d40ba9d063865996037fff8fbdc3bd735cf0ec6173e8a398cd10515a874bafd9c963675d61a735d3f7459f33e8fb3220685dffef9af0b291a2013e71efd9e36182a987f3726d4a13595cf81b33b4c7a06ffba476244dc2b08ec7ddbfb0c107e8ceb3358f5e1f0bb7543534824a68f7ed66fce4f7d5514d2a7d0ad20ad51a5fd67a5c759d7cbb75b3a1ab738d322809e4c2a319e3b7892583428b3a235fc225b33d9145deb1f77c84d646f75b829c548d70749459aff37beab765bfabce55b66e832f4b6b9fcaeea794a3e845a8e2889c0b35d83aeb38f0fa9bb823454c92a00bfafb7486f481b5141fe3cc65c257fad0e9f9e139abc52848cd83a94f7f2efba620a0bce6ee0470877295e5d56630e3fa090a237cb3595c17ecf76a9123c34605feabcd409cafc0f961e7255bccb794ee5408ca51643a1a7ddb45db7ed04610e21047a8040e07c7fcde0f2aea2b4f2863aac0c64bad7ae48ec599e6bf470e883db92b595e6ea474c0f9278b6b928a5ba5d9f3ef9b701c649f9f638515f9996dc6a8b8e4813a8c1498e6d0ff6c6064b6fc683683309181598616bc64dfc37cddf407c3a6a054916e38e8a3de0e3ac5e5d7f088d2777dee39d709a361dca61a564926a91c680258972b1e046168b349a7bdadfaea3484d86070dc002731f3fcfb84d303f5befbf184aa2cb4bdbb570a788cd4d429fd5b3d0f7afa98543c68771e43dc4ec2dccc179e270c1141847d735c5bafdfe476824776693a1cc4ba18dfb5d7edcc0da32f5d106c7b382809dbf684b135334b11f79a0c5f8e55cf516e5f80e2e006423ed2c053dbbf398b029e008759765f25d3c3c0ec401b11d9b35953d8d8feaf304f13ea4e8c18d1516a20095eef7f6a32ba7a66abac6107206e90c886fe46518d91ea53ac5a5ad4f39bb591e66737f5e518f458bcb0c7c2cdb26d5a46e1c370f8bfcc19fab512ba5d81f555793bfa17ec844f795384e6b93fd43782985c0dcb4ec8199c457272440fe8befcca80840bf3d74780ca1cda991372821a237cc8e7f805306ef4ad7aade28fb7b9e8bccfd69ce0484354c9a4bd958a8110232f85317b905a6c3b3c1b7acf38678b6385cd195d5e31520412cabeb394f9785264c1487b441dce00827a210bc7eb164be8330c15e51688ebda29fb7b3f02e2e2fb297315f18318316680b41c24daa5bf43dc0a637546e5d7f2ba2ba954920f295da25ee2a1700f23166a78a98835ee70549524dd3228cbd41968c9d865a3e991e47e4467b79a2291796e3067b151c0f37391ddaf93c905791fac2f0384eabe4dd52789c956e0fce768e90f37f44adfbfb012a36e1c0c4753231a69b5fba07d1accb29c0d3b956c753aa8ecbf069ce50f3ec85d2343b6d6ea8b7062d901fc368f974f5fc721c1d2cabc34a92348ff495b2b3d6583ae894113d7da645872ec9973d3c9d6380f9a121bca22ebc44741a529033094979e14cc9da73e881b0692dc727eb69adcb7bfb347714a641365f7447e3e043442b5fcfca27b0fcb7f446a2f41c6dfaa6e06d255b926118d17e96a9a65ba79951cc3b3ad608bd7cc91289c653c5d1da2ddffdc2ed39073bb0899b5af6826b3b79de8763d795a4919fb47219ff5ef00d630f128580be357a72f1a39b7e39dea6126df9d3b152fd8d75499e3bb137b0aa1ed4ae6224d9d70934a0c0659fcb5d51cd724928e978eb6bd26da7fdb094ebf91387dbb18d5ae4fc67c1142a7702a43fc2c24e27458ccf696af65d21dae36191a763ec2de8450bde17cc6d598e0f7024cbc9980ce65f2e0915e2fb7e8f2bde450350846a5483ef8aa499ae0c5c20ce41c65963dae48d4ea91d300b362057bf8526981c820700887b7b41b9e422c3c2a41bda95c067667e5dbef3099b9a32c1b03f23652bd1fe55e1ed5a4aa201fc3c7c46c919c455d0e5239370e77859253937de6fb2a7c0c2560b5e084c8f993ae91e61aa42a447ea5517f605b8778876fc013ebe5c50aacf93c7cf57a35cb4de0f0a745d7394a49b0adcba5b3e8fee213dc5d42ec7336666dd053095389f53c528e355b5c10cb2a4cdcf8d50a32305f97cc3e9fdc1d5a4d6d50fca9bb427710fbcd664cdd407b94aa49c194e2ee9c74171292ac2f8f52502508509bc5b02ecd7638570c354dc17846f7ada1c6431b00cda05ab54c368e33c4f6a8925093d809ba4e3ba978f0f1184af3e560cb7f9a239b984e9f463c283ca7343682ba67331e86489ec67f3f5f079604662fc04958a2a048ea723245c3ecaf00a1f15f4527377f476096e91003acec024276e9916aecfd143ec9a6d2d299a44376e65f9b8d457609c6828f89273d50578ef4a6f06d93c684bbaaab52228a9fbd1b58e61f8b86463e9ed890bfd4f4f8ddd2b07da391dcea07604c076605d7fa9c1982d049b360f5863cb7b13634b7b6cb70b98cc7fd1b0acad73d80248d97475506aa89c2147e9748804aa01d19c25fc2d3783546bed2fbcf54591e7c7bf47959259fcb610025bd2a68b8e3c3748ba4a93523fd0aaa7fe64d4761bb85ddcc6f3fc0eeb8bab2fb72c5d18bb4a9b5d47ef20740fb657e40a6ce879ade2a0edcb3985a65c202eed73023465c7c8356afaf7d87b0ea858e1ae9307e53ba82a6c9612aa45d91c5ed8319afec5bf83b88bd75007d7cb43967eb2ee66a04640bfeb0dc42d65a1fcf45b382b6dad4ce62b1e176a3665aaa47c28dd1bd6f6a3abb1b3d921f102319895621e3a978ea0cb88549e81c4498ced602343a39de7698cc70313fb301b769a162999e114433cf47ed320f453ca5a4c105c70f2a3acd446e3cd30703bdd3ee8fd4f65961ebec2ef8021dca98ef6c6d267c6ed3d30b8de70a7fbc19bff66345814469929f94e6bbe2a35970cfea53f608602da4763a234922f55e0e151e599a084060e1d4bdc77dab5de6cdcad5b7f1154dae5fc3b8bb46a4d629eb6b4113a88076775aa1d30198b3500f0dc0d2e2a0104d24981b406c8d7b7017b96b80912eb6041c778b65858431a1019f8e275f9256dd056676a0a97d4df3b2abed327c092dad263881d5bac9a8c59dfa2504e1825f681541de5acd48dc3dda79367c27c47b5cd0cd551e3ca05d1e52feec3720c825f7937db3d3cc60884322b39136d276d3d2c9e7ca10ee6065ef8779f0ea7b4610684e9a90b3aa068479b3b8e3e992d709be49590c9da9c19f091ff17bac4e82e8dc19dad97cf32a3930acff8809af74515d987712ff49aad16ad220b4f9475cc1c8eb8a22ab98dfdbf405ac27e29409a76373f0925dfb9eb79d9714d33e5d259480e05dc173c10b72fc96e93eb05054877d3fbcb83a45e95ecfae55c49777735ce8a3e9889b15fdfe6510751ad49b74cdd04dbf22e2a842c2ac7ab731c32f39a2720a8664ef985fb8a85a2f1a512f855c0cc9ad2d1d9ba390a941fb6610240db84d86da8ccbbe0567dafc152e24539b51212bfe1f5ee6256ca70e5b2fea8813347e801be41f3cb325ee89afb609f7a03bf43231fe39debcb21aad603ec30bd472fd04b516529d1c9e7a2152615205c4354413c152a5403523f9b2e5983ea0812c5810ef06b48f31f5c58d8bb0d5c18c2d4a3b4522c62fef7add690aaea2fd791676b0c79fa13f5975b23e8668a7322ee8313fa8c9d7bbc470b6c877997cba07fbc0475d7245fbebe88dd254e5256c63e2f903254f7b8ce65a6cee5305c6b24ece7012645b5e19fc4ac8347dfc2f128c0025e78bf090b8d834cfcf0253546a6b30f3e505394f7189341a39df967d9ba1c1bf955b64689dd48e74b601861291184199929f1e5c78f0cff12429d453c0422e2db8c8d83af0c7cfeadd8f908ca223eed1d19b6895f02f4f5305e6f6b65b9abb9a4ae9614c7a1fe2dad79f54aa07a262d28093e80a0361d250890fd56d27bfbe308bb0c6a9154db5edbcfb0fba655ec3f24750575fd00baa7530e21a44a666b9cdb74ed9e6b46da6b17e98faf2378cd3a8c5e5d930c901cbcb5ac55f07b1457bb06e8616adcfc2cb2912834245433e5311e08424fd1324c87bb520718d0ca3991a4710622198a2bceeafd567255859f24616890286c09adb987233a0be623a4b27c56cdd48cdd29162e48728fd74d08a98811b5a81ee0eea8f739ab363635ad08cfa0c2a974b411f6e21e3e32e5d4c1cf931dc5b12088f8a92fe927774267d34854a1748f24ceebce402423f6240fb7d6e2db1616b42d97f72870f67f1cb9e29d2a4545458ad93c13006c4a6d524445935a6cbd8c34d55ab04b6c3028a4a3b7a3d923748230a55837c2e4663859ab03c7ad15a73cd1df25be76e0207afd1f40677fc91c06103db8d5cc871f2d829978761ba7ea8ab9e2849e14dfd2df90e576f9b1061e4ae0c8ee464f05d9df3bab79c6e53835937586bb4e02b75f471f044dfa0d1eebb766113b3ece8e46716edb9271fe136a6f2f4c397be222e7bc702b35bee0441dd0e461750e290e79f7f3cca08d65852a39cb28ab200d6679f7a81836ac53d2b03f035641850f902ad6ae9c906ada4a070c09897e18fb91666d3fd333c47055fca5b2632f58cdaba46c5236617cc454946ad9e91607edd11bd69c61a75f7a83c0dc0c2d915d61d9422643be1d6a2b284fe2638a781f64d579eb0d4252b1a4308c4a86db0e91d5d70ee27ecaa7b301f52de14d7c9625883c0d35ef11d3eb3019b433a32dd4feb6bdd5d34a29845eb7fbdf457250a3f56dc26ac04bbd60a161fc45b1260e9107095bf992d0f39edf84ad4a01572ac08afa2445972696a707218a173a27861f956cb1915ec890edfad48b7182e110e5deecf9161370a13615381165a19eb27d7a533c3426353b82c2d9893aa4b029ba7293f2cd8d9a483389bad19b8a436830ca4bcee44648d4cc798b3b85fbd37181fc0159676e495ab6175edbca2e7319f85547c6829417bcb76c488a0354e3303db1e43e2939002d57d735d066cb2f94cae1f2a0e55b312b91710a2e748f84b3c260139552a8809d65c29847b65b3a3c0d606e78f2d37cbffecf93514492f98f973d04e41c88de55b822b3f668bfe61503c42c87bc2834e842adf7925a7d8017e91ad02421c109d0778db00796c3577221175e740bef4d894cea6834ef6f46344272a9636b3ac3caa9fbf7cb5ac644a12ccb840fe9fe45d66c8321d31477309aaf2685e325d538c775beca7e836f054cb43653f8021cf6aaa9db6a58af825bbd56f9a34be0e410e1edf37542900885dffd294d5a37f869bca71a88395e27081cfa60feba0dc64d791ba4c28dfe0cc51f75b13fa60e7d37f97a5d751bde4ee824b6df681d7e890e9573f640b641feed1805a8b68da9671655fa5a0bc74e9049dc66baab42999e1db2a26e51ac22d85b56e814b11dfe1a8b0a592e80ca6790076d07e28738480a7debb031ec6ca67ede2d743c9167b0a8d98b42c22e719ca81c1be7c6fba6e11b99a98a3095b5b192e6198aeabf6aab579043f20984e0c1872b56342c71dfb6ac043da466077c1f301ee697ff65a9fda973d3186404cb2db3322750442816dc8dec3b7665561c594da94ae3d76b46a3227fbf957b843b5905cd58f212fe4e5c85b7a1705974ca39b1ae1a09496c67b25b203acd1487595de42602560494328a7f6be3a28c68a128e3268dd3718e81ca29e1a0c4d0dc69ab676bde4260b7fad93cd87f6ff6b6f656ff9b15857fd5264a348f4ee8413dee4e8c8d3b24db1a2721a365350daf0e9402fd370a940bc322e9c87021ac1809edb30981a55a4245c0cce601fa4448d7365d3ef7164bd608b28cb8d4dac00941d097ea85baf24fcc3cf87ab5baa82e2169f7a666e5a149e9ffc89edc0ad55d050fe3979d652de3d8dad2f1d16fbecb55c61a12305e3b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
