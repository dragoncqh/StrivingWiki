<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4bfbbe80b9dbfb9aaac64d67fe604a9b8b7f84d1cfe4ac46fbee50b77cc1bc6b0327cf076a23e8a0942b6861cc53547421a6ea14d06a2759a192b392eaa3d6db460610c6ec274565bdbf8a6e31e96d67a11fe509a4f52579415507987f3b24ed3568468517b675cedf9147420e2ba1bec4d1f1b6e56cee089b05387a96982928e0af3eaffbfaecd6d686424279f04cf8568765f3f2d3089ee5d5ae0f223093c2540ec1034545c8d1a20b6d8a9959220027b97eaad317e25a4cb438c51debd9b767da597bcf17f3d6dbe779b687724eddc437cfc3afb9d2fcf7c46e20c93d0f392967d3582c040e71b136a530a682786ce77bc6f4319e42d1666d787614df74d94936ce1bce58a730830a02546f2f9a18096e0ed031df5dc7854269b1e270e6a70a20d2d37df60d16feda1f5892d9b93e5ca3e67a3ec564b9645a7185b8258e8bd284d0482753a11e804bd51459137873a44713cf221fe8978e1833f8e495731f0785630b508bfd578bc833985f9be5d2ec1c2833e2afaa90947db7536f8a67f5ee4043c18e56845f574b5d1aeb2dc0daeb11166d538b3c1808b66ca813039e0f768a64fa581359ceec62d8c9f139b2caba66059073a5b83a80470cb8cf82995c3719ee44511fc79ca328f9b56fda353e3698227513315b3685fea57601b19dcc17de389bdf20f73c640739458663aff19d97e6cdbae9d0f7d6e2f1a9ca0d66f5878460b74c67203302f5f2ce5be32ceb6294ec73f38da067fcd6c00fd02be3d73f34e05bffdde2c53af48cebc028eb517fafee6acdcbd635c5eae0346e8372433654262f095acf506a12cee3dfc4e7a87a92444f53f5dd58fe1353f303366c6e75163e722e8635b2303506dc13c459e08da2801097e25c19d9ebb8894c2e82511544eb4b473d404301e268d90b7cae6bc1b2628ea8c6f7aa9d54377c3931c7e5268705831f531fa84d94cc951614edac2092cf70a2c8db14023bd466542382e3e14d7c0f8e073174259299a11786521c8c1c46c9768b77cfa0f43a7bb619f49a39b1967786e2633c1880057baa993556b1baca8a5a90a156c92d7bf21ae9f62f12d80f911dab001750b33fa1bc775c2a3819159108cbca3dfc37e5e9085f008a36a9f5c9deaeb5fcf6c3cd24a8adb95f884a65a2bf8336e3bf3b4aa52448242ab9512bf62880d22e7b7f5ddf8d32907c25450909f9a0bf5ffd6b6dda207a03515125a40a9cb47827a2bf13f39073afda0296c565f486dac6925ebf74bdeb37bf14ff70867d58519481d3c4bc71aa574b7337e9fcc381136b0c5d1bb1f2be14c499ffc771c21426053ad9d0e82b86c343e1ce58a49b9351d639916f906ff417dc02d147c44695c98e701492fc5391314501918d68ea7dd5613bc978391f384e95fb155789db8de9ff010deff87d115728a1189b04c32c0b689ce250fdb4b51099ddeb55aea9257ccb6c31b5c46af5e545ae91688e646510e4fcde0afcfd0a0df55f10d70f87623923b012aca0edd1f4ebd40370357878d16d2f1a921bcf5956d2297e052899e10fb287b91cb82303cf946202cb632660edb9691d47dcc70b76b06c9a130b6fea1064c0f754e50c66d58d13b5edc74eb5763fe6c8b32329c11d02b33e1aed3f8262ce9a3c494683f231e8dc2fd49501fec536d7db4803ad7caa10c19e11202ea253edcc41e0e49543c06ba75caf25a768d9a334d9481b305a6418ba5f61b85a350fff834027fe9bff7592918d03250793c97c686c1ef1daca3e84c766c9efa0f98c7b002468b494e93609a918a57a15e36bdfbbef1ad043093ec3d46356fa0394f68f71e4426746043223e90876a8bf907a4b8c6a70cbae8f53b99e99ef8ceab388e8f729d1ea7119d848fceafbd7bd42b4a449b06b6a58eb016093fc96de9c83020d44c1f0e9dda23113ebc63be361788e9bc7c8f182f69ba865fd2df1c03fdc54199e1057ba0f974c1d03a5f7f0d9421e25e7197c70f2f8abc5e57dc61eb92807fefdb6581aba1f1f7b591c0dd84b2a1fe51493ce11edcc7435c1d1889637b127d332cd0d5cf8b701417c8b3378b3fd1db599bdb11e0b4084369997e018370c8032d6acda63e40a2256dd88afe6941f3e7b28f56075b31cb45d2e185cdab90c1f02e53db1706536fb18f793208109439aba6e392b082f66dc1c176947cf79de6856a5f9ceeafd6147ad1f9966f549150ed797aa09cc6fe57b34536029eebdc6ce0586dd25530214a6407d4e4abb13b5b95b278c595adf74372b3f5ed6ed330062195ceefbd57c00f4342d7ae89a482cc1051e6191af5df29ab9c7b020e96787f84f73bc2c6c0c205f4be8fc03de3210a29dbf5549eb35e61270fc0571b399eed36bfff3d1300c759cfe8002e0fc3197c9be5080948674f2a82ec2e96c47d0bfc13319958672f0c75de3a2e1a3d73f1e13fa72846432804ce16e548a2e44126054d27abd19c6d7784665055a5fad9bd2bd92821651752b177264cdbb55b2f458f69365f44547cd79486d25b749f8d3fcd757e610156d57ec4da6bbeb319661c8863dca523dc583307ecc788ab69a92f980a7698c402ddad5666735cc251e2a062cb4939be81621ed9c9a1cfc64c1bb3ac51d789534da75e54b7927d00ffc8f4af66b492f17275ac549cb91078623bdcde1dfbede3b4874a8a6f472cbc0ff0d8084b5361ab8d0b74992b6a90bc674f987db047357457b9ec1e8b9df7c460141ef8cbbc0528585b0b8584bd32d06d8aebfeaf51ee3acce0e0b1cf7d397c939719f260a5156c9e1f00254108718813d51c29fde11a5b6841bef63f45a243efe52a21312163e19a6ad8bf0449eec2fad6be0dc3ada1df8f0579770f5188709443c820d0cd44db99c647a1eb79e6b4ea9738addde6587c337e0695d7dee619c7bbc3678b5b823c10f03361a22433072e2bd5c5dbacfe2aa5b05073f94b9198cb7465b3eff87035eca9f9bca69cbcbb6af56fee255d700d2d99df2ef9accd0fe6cfee2194577633f0e16f845bd97bcfca0d3d225ed7e320ee2a13c309936047d9773be08b03a1d5cb420c80c5fbd354d884041a2b6552fccfe020bb8fdb861e97b9036f9ff2c2149cf561e30114d99aba024fac18780c3edcd97bea92f58a41e2e5e85e38087c5c233148e1936d61d3c80bf79622bd98e0e3927839a7c670c8a070c05475d9d67059a424edfce314d39100ebe3ef65fc92aa07348546bc5836f1fa5de0d168bd1878734d9f3cefba8f25de228f81c62a6f404e33ccee5e9542f3e4f2b384318cad2e04449ca1a146d8d23047581e07852b83c5307e1d916f38e17042dbe519f874aac15639bf09652f3fa2bc00927af06ed805fea6b735e59c533ab958064996078792c5a3a45ef1e146a1b9bd697b3a53ed521e921b5c35a4d5241023cecc1e922716f23b30d851a66ebef61937464e6f58f8f2cf7a686e3bd087f85aa3e8a5fc7071182c3f0dbdff4841eee11bb51abb4e2c6c78a405d6e11d61ce8ea14624e7b0c8c68db6121b5a5609d9cb41d75bbcaa056f841da135f6a1a0e11eec439d76233794a43e84e87dd0f06dd9bbffdffa972628aadea37828c37095b75d353a1391e0cdec2a43dfa9fececda62e3a90ffb7dbe8f5ea920be88c5b71084ad5df217d93e254857b428c4cd380905c00c20e7d598e095b61cc47ca0871e368e0fa1e448cea204eb763395cf1caa9faa8cdb4b47304fdd3b282a92755c2bcfbe9bbb0443fab39784fb14b4ccbd877d40c1b94564335fb0a200f00f3068fb7f234ebff9d38cc99be4fd8bf245422e891e9e74084996522fd12f32a9ddc5332b50b114f7762d91a4f75e258f2cdc343cb1247cac7ab14c56a0c67a1ce1d2f360c6eadab096eb27e41c4787d294036c7ef9853bbd9b12f1bd37a66784affee77e0661de854c8c5022b63b968df2bc05878d6c388066bb3e63efb83442a53ac73a31affe2f9b2f50c8fdaa45d129f38f14dbbed1a717a4564325d143a8bc1b18391663b19e1c199eb9f2e1368452f11509ab686950e7acce7d0957d922f125f3776534814a952f28c8e75dabfffec53696323a93256888291e23ac2b55208bcc19bc68e57843276509d3702c7eed1b3334a4b7138443bc11598e41d5615a7b1657314e593b36dbc9bf0554474a0f7047f0279f785079ba8d8abb3f8ee54e46b69d852c63c2fc61ddd2519183af7a57862cc6330a2b931d40fa545a3a60661fb1a7185bc14fa047a4307b6da60e88b1d7a82427455d3d5c765b4190ff626f4d669af28e6d01bca15135eb31043c30c0d931395e0311439babe7aba40b6867c09ae40e53fb03da9a4e5b317ff826b7e82b7320725423c8cac2097fa1fb1074dc3a9bcf64417b6f040838c536a5dae63c1c1f371a2070cccd62215ade44c9c9a3e517f2376c434c0a806921ac78a239c0de05622610d4c92e054dc5f14144d49de71b50b17b01fa5a516d3e6027aa226f8b7d6922856420f92263f16a10604dce864ceb89d70e02cd837cc1143ced38c0334ae4fccf091e2bcf99b826bdb456863e5afb5b21cbdf9d7e891637cfbdf0d98fb5a9ef089568f71c7182800f387300489723c511f390d0b78eedd3c872371b2947229833216b9f87dbeacf67ecf5f3e1e47cc8d47fe072cdf0f80e5d4d56264d96f88b6e18ec6513e0bafd3be815f99e7c621806f19e589ae7bbeb2beab8a0f6aae4d579a34255c7a58f943e7d0112773ce2e4924fdddc1028901dd2c9680993d841d68eedfbfd1873b674b8f6efd14b30821aef9d110e84cdda684f1a095e36379e03b8e2d0d18775882d2ba4567f0206bb75e8a57109eeb8e59581aa30090d029553e915d7d791187490ec0faa8b840b9a25e43c1fbfc6825f979cb6f8ce591cdc8f9d42c1811e31cf832101ffc439371716426833e49da13b112fba7b56181b9cfc07b3417f05203b399925ead800b1f9e7c612defae8d107f823576b31646b31272525609baa491d7b81991fc5ad8c690dfab0b0c9523fd43afdcac16896744ba6626f3781f4da3d1147a74f844c816a70b3dc6b4e564e65c4a9938b9e6c4a2f8432e75a22973951cf3643deb1a53bdd6b030c8d766aca25dd2fad71ab5e142cbcac3f7716e85194e8d860cd0e54c1bba3cd1d53e07d947b72ffbd79a51f41c8d0d661f9a905a5950bc2457aa50d1fadfb807bc9c98c4d08c8e02cbcc1c3dbdec9cc35a864a7fc3bdd22249b1153dc5320faf2466ee50dae36709a1483ecb3407dcc70b0d7e6874d77e1940e795c62ab832cbd4ed07dfdc6223244d34ec01fcff7d2ae6fd21ef0d4f0182ab26dd8ef517fe9d2a720200b18426d34944e89dc4f15a0253ebf90e258eff38878bc5dff7e10c7152a22c4598cab636e8fea04a338b7044779b6f80fa93e27f3d76f50dff577f32b299e27dd0f4ae04932e1ad9d27807db517e8ce8d406ebd9be42ed9e0efe9ad9be1cadb917633ce5bc4b7762f88a02b125bf0bd0296eafd4ad0f5be6d5f797bfdb6f5d388481f0b2c820c59a7776c70b08ac7c93c94a97c17653dbd08200100a9f483447b4e9aaa6d4e24c751ce12e119c267c5a396fbf26ff278ad28e6c1dfc6d49dd859d6a8ec3cba54decaac86f31407df6b78521a8d7294057ef3db4012aa9606e19474a3d966e389c550ebf51562db4669e29b37584940d5855965dcf88082fa0becfefda9b173a314aae7f00b25d16cbc5bcbf143adbde99b9a7c0e01f16c5887f3a124d0406feebf10d8b78ac44942710a87dff1f631055b8ce17eda7b87aa4b395ce818b9404db571ead90f3f5b7085f267889be8c0b1b0c27edcc5d5e6669d81e12f5b61ffde468c7989ab2efa91566e735900493ef0c02bebea20cd400c20e3b3d9901fee988e1036c7b7593e812de44032ced8ad70aa18189a07731435f63e636b3230eb0c2f8312ee8e392d35e00a6654fb727b45656c175bc1e2834e135cdf8ddb890199231717108f40da530b945b91c4d5852bd5d3bf3b4a46e5ab1dbd1b4b3403a08eb0875f7e53b2f119da6c52a7e3fd81b43933fdb00b0958f0863ead2decf01da0e62f6f0b1f08d19ff85f672ee40bdf59e2230f26445f323df295b9af6e80b9db1656f4cc6ab9da3ee23c5505ac005374b04f447105261d45000e5883894c0187bada2284e1bcb1b115f568f9f8ca49d538851221e9ba11140a88d2dadd025678517e68ac7a1d8cafc1600bb9467fa206197508e3f9460a3d77ff09136999a0f94a9d2c4fa56b34cad8033733ea2ccbb242ed2be1f394adb01547d98eca98456425a51f32889eb43bee10b29ff619e9ba1da384a8cf9561fd9a8179cac105c48bf1401ea8c8f88ac663963d79104925443b130a9dd25b1cda5e92579cac889ced50b1df111935a33c570c2989da69e7e8b92840cbfdcdcdd785bec122cff123a2381bddb8bd7bbd124d4db8ec9016bb0ced883c45cd675f1d9313d84917839f424b848e59cbc92ae037daf867370c4d453453ef943e5b160c0473e86df9994ebef12595745b0bffc8b17f544ea165c9bc8c1cac278256b7e320add979b34954b8b44caabacdc98994951f46a9f7a0ac0f58ccef05a0e330b7741621a1abf186d1ae5dfcf913b3e455357d6834f36e8cfe8b221381f4a4db00685a449369e4d87884aac91270a4226fbb54b862db9dff4bcba466a70b223cfe3754b150bf31ed1aa80f2686233ba083eaefb6fc53ff7345714ab5d860ff87b9adbfcfef0bfb1525e94cc24020b3a53f35b62703fb110b240dcbf18bbee15fcbc730cfdfdf7a392f8c2816a1cd27b30c4c89d1840e1aa89b3a56f3da62432b4cfd286648a9164345ad19ba44c4cbfc585a1b3c610388cacdf8d0a16596d23033fbabaedd973f69d6177460cca6d5a18ded9fcc59a8eddf699233e136d604ffff18ab7d2208a09f036870ba36f49b0665f0eaee6304d4f1fc51699088787965bb1c4fae8ece9a287f88828be68d3d4107ea10f8e382c1f19d2a89de34aa99278cccada2624a93661c1f1f87dab229384b045a6f2cb6ffde3457bc202cf8b6ddeabcf558026a98d17ce1a23ec5487a210599da87373f18367f02ae14f38c6ffb96e943c41ccfa8bd64cc61e51cddb384508737d7b4ca6326452b7f7f7117a69918d1b2fd5dd8049284e6d9c526627f1120a2794e2d4cdd6ca5a2d7af75c34915a4d158e95af4eb8052a112f05696981a9ab439b2f1d69a48c033ac8a5a88f5d93807d5236c7682bdbd45fa842348121644157beb94e524fbf9253b9cd33372f0f17a3b36bbb95ee6bdee31eb19b55a9e52723036e5e973d4bcc6caaa4628b5d86df302c3d11f2cc34afb1b1fef6153a0cbbc4bd203bb9a6a080084fb782247fff96b245bb464cd41d3ea921c38d142b411ef85dfb6daebc878829ac0dfc208db3b9744edc4dd3f0db657fc8017c5d7fd018a06200fd5229f5482e4c4c6048c250dd4c68a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
