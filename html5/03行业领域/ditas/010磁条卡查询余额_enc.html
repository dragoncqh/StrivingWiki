<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"823d6633e5dccd9fb41dfe518d0b5624c1f5c1778e3340efc96211d2f50abd8d5dbaa548933e8a9535320aa79d75098a1168e978193505fef55708e1fea6edd9938dcb42c5c0786480e3eb17e6764d5236dbfdf1e2e4e73d50063491587bcedca7b17f146a5fa271d698dfe3ec837b846c863328962d1947b2ac35a747f1390c9a5ceec7cebaf4a080c424e5cfd0d360887ba651a8759914631058ebb97f08bf5104628ab8869c9fa34691d6c9e8bafca0c25b1c8b9eea4f32814b4463610293a24d34e7fd74279e1bc752c53c8d641bd575c838f62b746389d0f2bfbd85c949b68f9a2210e37db0cb25360db06a4f528a3f3fd7550f81fbf1b78aa2ea7d7b4042928780658442a6de342ace01bc944e08822fc10f84d9ccb8d7632e1d07576cfa10789fde55e13308c36e74a0137abad6613d02b6026e883a67ff78a58c9d9584ca9aa26ee76144d4a82e30b3ddcd65eec854b3e942fcf16d854dd5886f65d393938553fd9d1ac649b154c9ea628ecd9d6a879103d262274e01f159afb992a4fc7b6a83ea40086907237ac622f835d4f06592031ecf87fad886007555859134da83ea153db2943346709e8f2b7d5d876197a261bb99f804bf855c699b9aa7b205ff92651fa7310b3875ad57d49620d6e1f0aded351887ea733f9c8724c196f822fe103ad81cff6c0f377522e4e1d0057a6a52cbe78239bf8dc70397034ed7a366bc0a8f4945a9951a6ff3a95cb469a842d6be16c8d9fbaa68594c6f94b1c77b373656f27ebad0ee7b66dbea8c8eb7700dfc79d1c105a6d128d83ed8e58acf81af900bc5c08c5dc459c0b62887f402dfbfc12983a5255b701ec6cf62742ee5f48e2b4932228b54e2149ea7f014416a6d7cc391929b910482becac30af48049005b9561c7b6c69afd124a2106569bd04d8fa29f8711962301ebfbb718766881b0d021bdee11e43ca62f6ffeb6713f1fce0a55431dc703638ac894fd80b3b3c4ceb3c6f90c69a942fdf92797f78f8f4bc94b341d3b8577c3598efd6d0dcd9416f445fe618b72922d751f6ba1c4ac5f484be8a5a2b73ef26d377ded61ae72b8865f87898a198623626b915ff5b44a22cd5ccec75ec88711943ea96c070f06ae717029b715b9f002416a7166b944273d05ebe2ea0de185dda10b64cb6c90097d4a6f3c105295054ad9e96189bbfd0e7e38042d1ca4d3ae4d80c81f62318d2c955062ac07d33079984f5de86b780981306f27ba6f7a57494b7fc4fea3e7cdbba4d846d1564d6bca6357c11e00bc543321a6c6a217b2a43f65f08b90cc9bc0cd9a08c1c624b222f1cba4a2c183ee058ad1b4d76deadebdd5162fe0853926c99165810405130c9a179e94ad3a298764b65bdb746daa5c35ebbf417bb3b059bc2998e23292e2e6f75c1bb8fc91ed68da8e1948943f882d756126c2a9b43d6d02d05455b7693acbd7cad7099d4e90da7f9bd02723beb7647e6657d0940548cfc92f6ef7b77b3b4407dddcd1b4010adb153547d8e5d15e5012cfb01a18126f60fd0988f0826b97ed85e645e96c7b4e26d890ae7e1775499487e69295ac9dd99b1e1233942fcc8560c0528ee3cbe564ee727e81946e7cfb04aad594115c20d6f0915c360208877252d66d896875b55a3b4c552c8875f23efa6200501d85b1276f1bba4d60fec44b7f33be2336af0c32e15a168c5c3e41e58b6028a03209496e7ee09d79445ad83d4b0641a5e0201bb5f9b0c986d768a4fd3438c0e1b6e67ba02a760d28a5f0498f2186dd6096308d35351906d2394fd510918c23a2a8195a768847b6a9df0aad5622b9e2edd2ceb07c581905be9a1566715c1924f246a9d8aad70bfebbfaab4f3c2462f2dea82f86ed10aaded1ee1031b1c3143c564912fb79f2769c385f36398069e27dd838a7cf08e34c06648e41963a35e12e038f0d02f08e80f1d69f3e36fe73cf6c193fa454484f09f86d6a05e5fdd424230f063a87413906abe93030a77ba245f3a686da939acf188b246270d55262e90f6a25de20decb395816ab4273d430eb30bc7db4a2e6078d0b6d3b2ead40f56ef6f8cf0199e2e13c8ab1cee88e0beafba115560da13ae91e0be12f3038e061563e9a93c15f6f0a05db7e32b15e7732094c0a64504cec44acb7f5abcdf7315ff9ab35196745f39da50541204d3fb38121ada352f78a8f2e7b3f613d44536115439ed77f0873bc3dfc0eaba8a79df4957a2b6c4a62a4a3c334897bc2d5be0b15664ff06df3c761f38eab222af270546a68a7875420704ffb0adda3cf1dd92a938aca39f57a847ababbadaaf6090a277e6341bd7a0a17b5cfbb5eac6bc0934a762ebf1181f8ae9f78c6cfed8ac47b2c36c0bd1ab1beb64664287b2e3bf458d2d7ec11bae7ca635ad9e6099db5abcb1ee3eadbdd71855c8c7e383dd577a0d8ddb2b7807b9e383c7779ecc96894c58263f1a056033311f22da6ff9ef90f4faab6deaf61089ad81ab463ef7cc51d2864094f578740c3c17ab2e2155979598aa37d84f58a771dc05616a39294e670f49fe1bf739a83d2b942ec9d7d84c50a721ee5156548a3c5cfbca5ae7c58466e3013783299c46bdea12b7b5cd8ead308d64b5ee4b5cec640f24e1fbd3e0ad713d8c57aeee51cc07328f659384fddf5fcfdf75366fa15f562ed8ec6a06bfee996e49b0ef46ec96e0aff801b72996fa1cbb760918e8c59a22b0a9f8a497d7fe3ce08df20f07dd1d680e3634b19e8093a5f5ef39408a98f674b786cf3928e0f877039a49bc11ae72c191748584a536109cd48b2ae939369ee23c85a6252649662d5d9c340968dcbab52871ab0fb22119dced288b49c213ad43fce315f091e932dd958ee5681d17048ad4cc068754f4d7948e025f192902510691ba41d447ff0b69d7f62907d1c161b037dd7c3bade5c96d96c444e193dc1da6f4772c11ae98bfdbd5afd7eab83f74232bc5bf6ef00b453c0fe393927cfb4aad0a741928977c82a46774512f27eb543a7538808ef79b37aeaa734787ec6fd656ece1ea8f83902f1e9f1f693397dcc9622b7961f68e94feff683db95bd9a0474798dde5d7f12891183655f0ec77683a5a79a62dd5e18a688b8a8064004a10a784e0ba2468de8b3f3648594eceb5ea1cc8687ad74c28c1d68c6e6032555673e4afb43acb6d55b9f6682ca93c34f996b713f8c2ad9fa84a1237c9273404a6077eed0d9713182bc435a0c9bdb673841b36c6a7fbea9ed5be7036450e0d69ca632cbfd75aee86be9350c7d5e93ffa5672d5ff9b7657976f46c6645e51adfaef1610eba8e38d18b3fe55d222d4fd22916be8d8c6aefeeb32ce03680bae1f8d415126260959078040391c2b3c67f521073f45cc8dc27fd2113455f3586cb0ef069a57e9fb3441837626d9a575bdca78d682808c9acb1ab38666cddd7489328990f7b889df0dd61104f3ad6a0ac695045ee30b776cd2593d2eefbd6343cbf64ea2bfee1d5ef56c44cc294a8443b2e8fa04cf7f9becf2f7edc72d4c5599f8585e376b311472fbc5257812fa4b33d70b51be0d7fcaf1f3083e44483a08ffadbd856992910c74d49acd7e6e4889bcacea8bf51cff94c5fdc2e5b0be83f2cb28b16fcbbb62c12418b86b24bb5dafce64754063cff5e1a7f70211487f3d4831dd952675beb5e90350d735b40019333f51ad90daf8890c59cc9e8277f51f39a377af7f37481d86df6edf75e8a08e04213ddaa70e47bfa3bd808a6e8b841fc77df70639c1e7f3c67c7892d6693347b37e779771a2eb715dc6d564b4c77b9fd08a56b8f685ca0b9eb90105b9a9771faf8ad47af775f614c005de6d2dacda0de41e480e86fac6ee4eae80c33f1612c1a9a1d1dba0f3d48fef1cf9cc5b40650c6ddd6c46b1f64a86c2305ef4cd36c0b64a3a020825b2974fbd4614aacfd7069b11607754928332e230d10b695835358a7d1bfce8e8708baf0bef22513578ada27f109da95daba463474f2ad2b60785ab21d4f960cda8e311600adaa4834ecdd1e2d6e4f8968eebea60b2fde6ed2ddafabfceff800f79cb6d59af78def337130aeee10a73a2977ec556e1efeac839e075af67e83b8a6819f4682d44ffd5e68e777c36999df8275ab8c8afb07f0bd081d943d680a650086bec6dbbf7ce8f25f2173d10398fd4255a47982fe82562918fe62b1de2f6c98b8b5d24bbcc328ec8da1ae173ee6234cf86345e75b84caedc9b936b7fe01d30bd218eaeb723aa6d2cc96375dc831f456b884b5958dc2fdfb0a29fcdaf4b1b510e1f92e01632341e793940eb3b62ab1479b551907364ca59ef181a750fa1f47fb69a8219f178d14a6d422e59d65370e621b1490c488fa8ca3b7f62445693d0016f527ffc21d08a3b6173a9e118d80bf297c334531fcf0580fc5e6f1b67ea2512c32568c9526d329d5b497f5ac229e8f7dae057e82ce5da2fcbaba7c88fec1fe32116e16a88368a6f6257e48a24afec57bd4a06b3bc9ebb6acd9641dd2b8eebc2194baeea1cdf37679a86a7f2c8211d96aea2ed533ee272344dac5430279070dbbfae3687f51ea07b0ed963b28e3a2cfb50fe5864f0064ac8e5f178571a05a8de9fe48da916d2cf084a91507aa8c62ba3900e4bded34971e61edf4b1cc52a1723a2ace1c5c9f0f228910cdadd5fa42fa74b7a4ee1df55f901c887a88fc21c7b52159d24ed2bc9d5f3a4e95b2da4fb2a75ed94ac7f8a57053c2c69302a520d6be23bbe10e7e66474c5636c35799d62c9d14aa5cc1c7314259d5b01b4e8c1b8cfd42da87a2ede2f0e5ec872b55b2b5e12b36b6ae80da94684328a7583a2379638fcfbc31066465ff4330fe080c27b456c1a09af9b2c4672584a60b1b1c099c9e9e002e6ebb99be064a0954427edb256bc95396364023410c2cce5ee5a2e3ace79070da87bd0ad0c598e318a20593402b5c136c16df8b7e107962539856abbeff1ef263b8e7cc77407a8732a694bddb93627dab83f984bb6ff5ec1a6f8802d0504cc0642973311647705d2da7985c7ea073d083cf98b0f75386f355aaa98ad2532e2d85ee683932967fdba411ac183b13504a63d4e4a95881c2e683ef4ef10eea36d4b9e7a4c3c5587a8fa1109cba0b14c2af21bc4e8380616bd266c25212a1b4c9d71d2a61874cb1aac067bbeae8fdca0a26394514c918c2d7336502f2f0025129aaea334d31b120598c798578712b96064f8a0f9f087ceb4f3faa26e2682ad917d18f11a7c4c625171adb7cacda27c197e2725e64ba7e85cbe411e0e0f643740f9514fc5c0468141426ae8d44abc205c5e2cee8991a0209ebf5ea4bf7be6b6d29a000cebb2fc6daf768912a8a607de00e87573d603a551858d80e8a7cf627d9b034db392de4b6db663399cd5a7e0807fe3b6476c78841d2c9015dfd47f20d5d955808362ddfa317d80d7b49e68c5fd4f7855fd46fdb4a7531a1678251ea14a0e7dab7b36b676c9589fd5e5c9cda1ced427f1d404ed5536b793fc7102a8f27e6e28f5bb0c48ec860ee9dbfa72dcb101e93128093c292c46fcdae3447f853631ea756b61271136c75f250162d5e0a5575939acad1b7efc75d3b443ae041dbce25696cce4b15c93f61d1ca5b1ac0a08ae46767b57599c387fd0b51fd97d8399f0da5c341f933b3ca94b87958b90eba4b6a0021f788fcaa8f2a5cfc315ed3cb3af29f3aa38b8ac6d82dc329929721b2b7011199f984136459d8c4db927bfdb174f1f2abf389be395000294ce5ff08d04fa5e7f9b9c9e99c02fd62e14143642a6c7c3711ce35b6ca0d3a2bf85bfb60b1fb6c786b81d983aaa15a874c3fafe1a87ce94996477cce0f7248bdc115ead535281a8834c271f4823af8d5fffaaae7714881bb5ba51cc8fe186d73baa99b4baa6b1d0bd24a170715406f5ece6be725f9ab8471a7fb9531149e8a40913aa4da23f9e54ff296d981cc3d0e0ebebd7ec2ef98569ab4e248b44cdc6a6acee7693792ab4fea370215b12c90c1faad1183df2800d2c046c651e8cd989577c239e197a3a3526bc2ea3cf0d04cd1bcd68783217c74a48b43f22e12d336ee95accd5230bd648bfa9b4207d5a2ab862154e60c4104f0da7944ca37b9f361e3c20a42202beab805565964485e4a9befa2aee84a104bf4357496ccf896f5fe8d1d2cb1ee9c056901ea9dff14a694d0d1e28f1a0ed156deb379a06dfb564d652a0ac08c28bc5c199de1926ca1a452e58c21aa56edcfbb95e5fd06a64e8d9235c6c273d08a7871efdb346f609669214828033daa77af8a24590cc79fc0d28866b6e82031fa84aa97a6f4af5722ae1be741bd0fa396d7e7c2e87838e88e1674e397d46671e6fb6caf3d3ffe8646e44240b00fbd5859b408ee46a2a0db4f757e416d3defbe449360da2583a5283d107ab3fab2aa2280cd2076c4ec4c98778090a68c8c0c8ec5b771254163260b77a35553e333f462cb35b41677379d838b02b90347d5664b843c5fbfb09a919a23551acfdc79aa77560be804fd1eb916c22f1c350a42d60bc9b265ea38bf9b858b330d524f3e7ccba6d3ccf5ee0dfd0cb63872966a33d20932b62c007a90cc6064227ae8626d2a0a5bebf5db1842b554c1ef15a70fbcd77528a3ed141c7f79a2113247bd17cfdf0fb7df8deef1128da051eda543a2de5d527173eeb1ca94baa89b551638e61564ba820a3b1ef04ecf1ef9399de40bd4c95589a37c1d7678fd4b42a7c1c13c2e72c351bb55ffb17628bd675422a485309acad7ce50c1eb1fadbafb2bcf185a3611ea45a4adc9bcc76b375e8b1d91bda1361f895f1a25acf3828f39fac1b822c86b3e31ec736507f102ea39b9fb53d254b3fdddc6d04fe9ac2e487016efe1f5875347eb41fd8660f88d038d8edfa8b7730f56e740430c9c112b731d879bfb01af0beae4e9c778eefa75b1a5fca690788a1ffbbf4f6d4d5eb001182b4ffaa0c3f971795664e08c2b7eda4e901d3e46a3333f6655a597d0a455b5bbbeaf09c3034f8131b7f218a2e48c9ac0c82db56efa5ab022a0bd9609826bed044932a125cbd4eb3bc4ebc83c91ebf4593614d71e6b378a42e67b3e5aa8f83ea621172a7cc62fa7bd4f2493b4b5dd2ca35b87d6d524c05c1cb74720a1a3c8ae5c7e34a3b596abac3a09fc2bccc3b4ff60f80a3f21bd29a06a13fa80d9321516dbb9b655fe00466d9d4fee58c94a89510554e4b87e6d9bee99ec81a29cc63776e3ad3045404cadabd502cc8a72024cf1cb66e66b77bb52cc4e4d1a7baa99a011de45484f06a8e39301de5cd5fa0177147ef7e15109c2dbc808b9ef00038759a2bf1b4bed5252c6cec54421803f3765ddebb762fc2e17dc61b97a4ad1f642b7f3372a145d42debce2a6bb6aa67a8c0ec4286c60a11f22b35f68ecba14dc6976eae31f03a7abf8be7fcdaf88ff6d5640f54d15c03453b695d707f33647f252982d32ef41bd2133a55af3976815890babe19d018a8d907d4f4c037479b728d821a3044b6366cda7ddd4d4e658bb8649f85049270ceb8a6d0a8c1c74cfc41aacaf4485170b6b2123885bc9e6398fa28b1eeaab98d75817f480157ec54a964a821ed480b0c0cd177070bc88b742e9c8333743335d2065d84e1cbc6894cb68616e7b2d47592b3417e226b89c37ee09bde5c8f4092b2fad5d3ebd457a835f5bec8a090b41620f35e4b250515a470833dfac4b4dda48c6cb787044464b3a3ba049de984bd18a1b8543df0013d40575f4a05842d23912284e988645b1f63f3ffbad6ef0a70797746c725c9af2ea65a6d246b0bc1c658215f5aee9abdab0ddb626661c75294e25b309cba7a1041e9d43b78f909d894a7f3d5663e2eccbbaf0864cd7083e09028dd566d62ec1d3ec63e0df67094013ae31218ffaf3d9a19b8186ce093593e7010595dec61aced61c28304718f9fd92fa000df2c6e7b64f710100c56c460e342dee10be37a625a604148d88cacc9641a6081b9c8fa86078cebd500fa23673874951c849784e577823816005e3715f17dd11fc909883d4e539fedef09e900e477c5186ee1f44ecc81768678a8e8216489a06700a7ecb7f9e1980382b53739782023e9b111d7b11340bfbd4a465d4a4023ba021661a2d69a91482018020c70814361210259e9780e81f6b38fc571829f4aff93ab7dacbd37ca2e20f43ed85e536e0a65c783d03c475c787a069e6d67f1e21708e9b93002ba485b63f3911ca92d187ecdfd4d951a613d2a4fe609e5ebd1c7306095a4586a625bc09e9b1f1a27cd18d78ae933274a4daa5c0e4964d11a8fbb39055b281b6faad5a461aa439901eedbae3d94cbaf882bb0853561c863a16d776e05d587e69db0ed6a6f008a9bafcb4367d7d1d04ed221eee0b7135b06b1e7d11f6693e6c10384492e514ebffc159689e5c159ac43ae0f791ae1fe17324d84a2a66ff98ad9fac5f76fe4c23fea1e1b8931e222df3c55116f271dd3dade4fe851e7ef7ca14acc40f717a1cf28ea493e260ebcefda76d981b59a562cf5acb52200ad0472dda9c79cf489c382ac344fad0382fd60c8ee558900ed6a644f8c26d53411e2d3a86aaaf46fa3a76956fdabc14e8a0256fcbee34c27289829cb5dfd6e6969097dc06292a2735822922ca337fd971a4702bde442c1475bf9230c029a723e1dae8d61199941772e0a65e94391860e94888dc344f5814d19509c685476abd050d0facd73462f6330e0e628866e1c36635fd018ddaa6bb15c8e9e75c4e5503f22103b2ca0c37e51dc731b5c9bf567dd2f5c20c4c2a3cae9b971b73baaf9d9584857997b643de0a4497b213c94a3acf7008cd906bcd328a307cdd6ca8dd95bbddba803b445a400cdf3446676ae05ee845d9d497eed2555eeeb4b5f00492cf36385cb8909f9563f814b718431a7912d62742d753a14677848dcebc03cfac3129e999e8b0a9dda5bbbfbf6260cbdb417d57c593e6d776b978737d3e8dce8b8c7d9c14b101989488b4aa9336a96629742680b8d0b750d09de3ee283b60c0af199cc127314368fe0313a28ec0a257ab4e96c931c6bca5f30d1e9f994556dc817faf1b464ea6c3267d6138760548f67e21fb32088d35739ec32451fde2bfb1e274e4877b33567dfd31f6bcdb12c4a74b23484ba56a484a48509ba2dfafc6d1dd6cbd4f9209c853f5f66a89bdca33d434e419c5558b4aeb1783004c945e60bf4e17e1beedc3374c7a84590059b4adeece01744fedbc1a4174796463c74c2abff3b84fe9e310b97459a3ec7e7da48ab54b91c980d4fb946a56fdd5459d967ea4d720c335bec4c710b0d855cfeeef3e95fe1af6e45c74abc3806847504dc597ea79c88db57832668c12f9810c43e5e163f4653b48b8a29bfb0878292a568d2dbccc208c693b51a97f1c9abee255fd4aa5ea4bf946b5e53d2fdd52ed1fd6b346570de18dcfb9d47bfa08fb228300c23122afc223dfa7141a92397f2d34363e5c7e6045549963f6d13a03b8848cf67ed0ab24b4f4d5d8db84e88fada1a40e5ef85041a8f40a63620fc445b81923c4c8a09cea240254b40134416d1a8b1df8082136acd85e49f5ec371075e7f6e5620f0509ab7f77eec65dc9573e5a5ce0f4dec234b602c72d8a4a5b5a6c7dba621fd0c31a972200c7c4972eaf72cf78180b11768741ccda2442ac4c3249949bf2849edb818ab85483e1051734e1236b87b14228841dd90ee8d2876e76f89d037a889c4ff9c5b782a4e62dbf8a2042afb26344f954eaf12a3934d99809716143fa4aa54b375a458428dbf8c704c94b386347a3385ade1148efbe8370e94e96ca5b02960183f89ee8bb1eb3363d78344c3ea726165662eab03238bf12de43e6e94d34bd0c4b5474cbbd42fa98797f98f6ba668327a7b7143e213cfc1b6fd1ee1191bcc722cb15fad32845ff8d8eae50d165ed0f1aecac3f4416450e2d8e96e701188283105d3fcbdb4bca831c3d00c73f5ab01713d386ab82a63c5ac931792a50585c22b7e4ffefef894793fe4d453796a01c8432181cbe0d01fb2bc49fca80cc9d92d4d0fb8fffd2128adbfbac5105058d18a35f0ab505adff06c6570b431b2019045c718870af2c7c9f6a28d4317ffafe529520bea5e0dad6020d6e08ac51ae137fda75d7e91a735f640881e8d1863a38372756b5907b90f5e7070d5e11a621ac93c151dd63b35b6bd774df5cddbe346b32689f6582abf15abb2c9ff5752835e0a87e4ea2aee1d172d0972ea4904c40e6d05176ddc3ba32e1c862de222fcaa79316e753ebc7539001605d6c354e9f5b46ba6854001b54e64288eabc5abc83838afec7b201302ad9cdfcc5a73bbbfb62753c88ba3cfa3625f57adbf1699850011f5a62bd9a7330d5676cc43d33bdaca4bf45ad60e93dd3e6dced8e372b719192d9c54343f2e98c994587ac4ba6e0851c5ae0788db6b1af14dfd1c8342690ad30ba5db7ad8ac8c82f770ae2ad89c5e7a2588d3d8eae51514acba6c7313c0768911813ad222d4485d93521d9732fbc7bed0820f0f7f80dbc675f66bd81e2c67e38d148551c777182c502b1b877015edfc6a431c798a7987fd95c48706d14e05ae77fb049112f15fe649486a583f481742646663f322aee7ae77c40cba1e55dd6591b88080438","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
