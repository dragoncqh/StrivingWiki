<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"959ec3cbd1eaea7fa3840f2468d6d5b5026cb3e231fe472840592eba5a11645f720d7062649e53da52d5e4038225563ce607bcd397a2fa86b37c7986a9515af70622eca28a15e7abe94f91e6068b19281a45a340c08ecf223b8d2d14c43d7fb52b4dbfc2dc1e3f28aaa247386ab86d676a71b19790f83a733e00cd6d6e8e3d484730dcd9886ab8376edc6681c3e15b9c496c233690ddf2f29b2cc9d97c0781facb315b32007a9ad127aaf6f88a92ae01eb798d6d5e0382ac7f92aea00a20d28a8d45f729e375ee02b714511c62fa4428720a93ab870df932064ba3b7f65739c5c1e9f59c6d0ba8c3a9723766dbd10290e99876ed973875ad8096c2988145ef03ca62d5b61014ca18e2d8b8d3f07819e69f46d78e4dc10770a406abb6cfce94c0aeaac47571db67a0f04bd79b357bd254494f4aefa963af9362989ab8c127ff89d95d00173e6aed485988605bbe777c84837e070fbadf0455d464554d6af03897ce86f0206aad42c96298a55986a85627d267a5a6ada49ac75532872db0182d57ec4189436147f306a11fe7d8c7dc820acc9ce686940f22f8cfe0e056c60bcf8d7bd7f115a53bfe64d538f1c540e5291151c9af03def3da7b58591e8ba3412356754138603f5ff20e2c198fdf4367b77ec3f26d4f36fe01190ddb8e4befe5b486e09fc9bef04066ac9d46f54681e92ef69cb2701656ca03703c5c9a7395a7baae9c0bb0341c10ad983c6879c7f5d79db7d8d22b14eb999f58cd5e31cfbe45e409f7a4bd48b21a92b2fd5e4c407e72b80f00668f625bb9e7c9fc5b2afd79a8a18f12103fe883a9cfc505aa7825a92483bb798a6e4311e59467bf622c1f501dade7a48abbfd8ff322a98fd3a408ac9688682d311e0914107625ebec319b77ffa9c903ee518782431904bc4a4cd14dd98c24934b249ce44b44677705bd0047d025f8a0200c427d14207251285c474d428f365d62f6beda826d91819a3654696f01d659ac579e974c99cdfee3d289b9d191e868d003997f2058217e4eb59a88d01046f3415c9fa4ba36660a260b3bda5a09910a17b1b57597f1b2577fcab3ada612da2a67f9a2343c74fe10fdb4d54079fef7ba124955d2482fecccca7b7a587b59121b5f3e0da6708b9f44c601b2ba874acbb38484f9bf3cc946f3a84ef6c6a920a64f6653ee22bbba9623740117a749cf34f1e0488a9c0298389a668089a64b5d3ecae9ddbba240e3b95fc5d3e53a0045c73177300e753910c3f6b077fa025074126da0bc8ff325f9be5c2b1539ec2041b00b7ab250931128c00a63cc1c303a3793325a42f9d8199fe5732c00b54c4d12522f85f14ddda77cf06aa27622318918b2ebd1e21b582ee54ea8a80927575472e3d3a2907cdf4d43141ec1f22776925d63a6ef80f98c4f424749b8b753e594e8e5958e24c475265e18616d3aed30b7f40c8306506c24d52062478f0b90bb5076542342faf9a61cc04e04bb85236ab4dd2de69657e2200f80bb0ce17d92d5b9a8376665cf8decfbcfcc8f951e899c979a1bf847bec3856f4053770da3125451cab543045499fe15565b0187a5da968cb2257803ca55d50a25064869407583944e0688d67b07b90ecf16d4c53a1c22943b70bc2617fd99fa4b4df0b81b5bac3340efbdebd8fc9fa063fb5d87d727b0f4283033e9f39e5b511cd9915c2f900e9480defe45ad0dce198aa80d8557121e6b8d0ce2ae1435cc2f90270f364200b2a41c18ea2c4e58f187b4587f905742e5391b74084dbd40518bbf68632afe76fa76ede51f1976d51aeac2c97a6ae51f9bcb45fea42016c015837e385116395509b2980722d7526dbd2c796e264ccb73e00b114c595bf4c05ac92b36e84d88605ccb8ffb1fb7f31cd5e28ac2749ec57598c94eeaa381731d25fedafd79eb51a4b5bf82950268004a14492b33202c8d588733dc12d029f58626f270a4436d669a1423024eb345826f5ccb9628a6d8cb471dc0e2b0fbc00022c75e7964afc43046e0ec7f0f064e8ecc9610b22c0f525a2e22eec9f0bd3805e5d08fce7c254712a068fd174dba794b637e30eeafe2def32795eb593b11c29343d3824c9108b77c9dec85fdd90f3b358410f0a21db3f6f2ceec9db37f1f59a25de9dd45e718ad9079c4e0f4ef93650f0fe9c1aeb47a0ae398b7d58fd33fc0a825f3dcc583e19ee4af3e6b0cdaef847adaddb4693ec5f31109e93107779b5912625f2a918eab4a26a2cb9d2d2b50e213b0ff5f9738cae9f1f89a0d19867240f952abc829f22c991865cd39ebb403abfe8c6b0d7baa96b08065caa8026e2467d1245db8c93325ec537450374e9fb6011f0aa545db5d3356658b1638df7c7eaedc7e9eb3d2bd7f26f9a4fd554eef8af986772b522cd19a185576a08823692da4e87273833fd96ebecd20f29892b5710e0c72207f0d02ac27a0be30803b6409fa18eb81644d976a56a5609431390b4b00c9b2e2ff6f2a406ee07e1a301c9b5767d5fefa8259b4df1abddd378e6360ef3cdc78d4a3470acfd0c1f9b5b77d38fd5ef4a3680d5e5924efdde50aafdd245a3dff25adb4867a4966ec680cf01bcd9639cd44d82b832bf1406ee246378e5ca5330bd729be40273060d3cf0b9bec009e2dd4cc1858c7b8db1f4e481d2693f6c949f988549513d976874d5bd0b3fceb2592a7293d600dba283a93f22b802fe17468bdfb67dc6b19953a29c6e2b9f8f7431a1126e8ca3c13d87b9d8b5422fa69e078646b8c03997b36e650f2dd8c2e3a9e11cc143a9e55301d32351fbbda396853e688be1887256e8676249d5ebb35e1cd3ad4e9566d66aa0cee761777a1d2cf969378ec01baa4460382b91f1a6517b7e5293e649bcec53775ad06b817042f5ac6b9f9ddf47944eb8d25a16ea17f16a0254f7030d97adb887279d38d23b7d11a88d0c1b607a17fa8ccaa09785f851b3cde73682a26a2886bb926e823b60c023975cadff22b80377fbede33867b6a145561d639aa669e6956bff9b6cefc5af271f3ddfaed6888e61500e8cd1e936dd24c628a59cfa294feffa4842934bf51971fe3c9099a61846bb16157e1ae721dbec106fc6d2f57799957406a4343b0c272734d724deca774dac5ff20ddfec2fa43f433728db6baf3109b35ad09a76b1ed3b7e83346a96b7d7da83d255b9d5f68b5f6681c96b346567ac97a2230cb082e597ba8ea7ddc7bb4c9332433f40d7d33bb3e86ea964ccb6bddb97b6c1d1e0aaa8bb4726a4436ce966f25dba32f6f6e4e05fa1e0415c8d7157a981a4526084acc08258a49c6d22170bbe6ff19f0ff456f1419c0a957c39b3447429bd482f74fee44b043d22b9421c99933b8952f0e7d1ed4f2cf6a6f3998e99281ca529420ea6dea3b8ec2d467f8a160fd202855beb38525e72ef496aa8aa9e3c1aa84b64072c350ee4430697f45cff9f4d0523b1f1e4b97ab26568d4b6e8e3896c33e1a9948a12733c432ee7cd7f63be7f6335dabdf9a24ec039bc3ea2af1706e97f81591ba5869636fb2481227ffa93fb13443e58450e9f46f838e6e9a8a494a38df64ce756c05901ca4899bb5321f309cc445b2e6a2dfdd9fe07200433d9cd230d58267950c9d0c1bd95dd93eb83e64d064d5f3ed65e7fa0bcc01ae9558d33c0ca696acd9389de520aba2477fc9e24d1b13a41e4c78aaa82c88db462a0131df126c1760d19bd969cb1f12d15226a92f3648b3a0a188039a3ab8a6fbbd2c4690a7975858715dd9003219f24719713639ef9fb115322dce3f5ccc66fb139533a773f70bf230669f37815411a8129a492a20e1f74bcae3d683d643279d0f1498cc22959bbc4fb51c2d8d6b055d223ec22a87aef5125f71dbed923a75dea9fa0bd182176eb3dbb4e138b8292dae86cffb373ccd3d64372ce8cb8490183963c0c0b0fff0a0141e7fbaa33a6d8da5ca7d938692252e1d9643661abb02d1b89917ffa63331c58c7f89d6c8761b722da4aefd86794d708694bb34d67624d89fe2f1695a0128c57d40d29f5d046ed3d70fcb991413dcd1cec23a3a259da4a19401f20cbb8e62955ebdaf8508ab9836ffae75242e08058cd5073edce56b9f30e79551c572a1e4c4cc40331783dc7e16640887198183d543d075fe69f1f994c924379e4b7a77c024b7f05ab726ad4a521f0e00b053d8f0b32c233911877c737ee8b4a30491d3abe3a197c55b1a490ca03a69ca34de8f24e543ec1f47136c93deeba737d79fc9098aebef9d7c1d1913f61ddc1841064d2bfa9343f8ebe2c3acfbcc6c7e23ce0b7ef848fe06ea4a42ce5a9af93ae6c89214191cce36316deb7fe278a6943475c3a77a99e5140b7e647ac8e659682e91b9ba26be6a678bb496954b08690aaa230b547190ac47f1966ca19d17aba9496f6e311aa61bef6010245967ca784e6a92e70a1f889571781eb5e32d9af4b5866122d0659f15da53f76c310ed45a7fb9ac7e16629f0e18877bc74bf01455cc2edc4b16a95fc2b440872adf6f6f2c948094f3fd5440b0507ac1d439fd98954a7bc158221d19bba5557ebdd2fc40842dc488e2f28792b31fd694f95196020d8f6cec642a52f1b870ed1bd855f45dea8c3a68e4ca8457591f73424b94e63a654712590f7d729665f82d9ea1feecc7b16ec9871c55e760c05b70f829f58c195273907627294a515f480d8888ccd752b3b204023ce70db00ba88cc5281fd954978e6f101bfdf2654b21de59e64ab2cfdbb016339345fbe3d17b61007a7908b8eb1e0be46524447e6b1d28d6b8cc9bc38771fec2f6795d76fd4face23950320bb1959cafd8d4fc8c3319ae181370a94acce8382dade4ac7adaaa4817c4b523d168d2ac2515b941d283d118e20d8ad5021852904b8b655b614e6c9301defac6b5204609009c724fb41e9083333c891462cac6836efbc4d2f2812363a7dcea714fb573dc3288959114fad2308d12aef35844950df0499eee9651aa8f9bcddee68788b742a80cc8344193cd7c223b8bba48d29a7b1c8a9c651adc9a97a65ca3f1a1f25a231bc8cc78addb474d91b8159a94821140d20afab87526fc2665e6f5bb5d4f9c2323bae448b448e55f14508b04ed0aa6f0ddac9c325ec4ca6ebf293eed3f1a4a132826ccd1c126314c1c22687579f1370a81658dbd06e41350671f5e6f50631e3ba241a8c855e58a7452fc28ce4a5a2fc6573f4afe4d3482d116e251735b25c7bc70f402bdc22957393337de303006e753c5a67755cdf1ae63236f330a4d16f0419823f9a352ba11410ec7057042a905c1072b885431c423b916f7eb32c36d01cde0bf0a3028c69f8065c37c19337752efe3d5229cfb5bdd076f39bdf400ecbc6e3018bbd2517f0b46a57f2654ac678ad5fd8640a1cedf1866828429b5912e43deb22a26de1cfdb557fa40f868d5a7ca0f80dfe14dfd0bbbd80cd87e3ae785dde736f29862806054479013c98f50d8e31deda1b1907bdae648fdffd9fa59e4e693aa8310651809da289fc69b2e01e0b2faf73f025da3073628f748c9aa4ed5a24968c77276e13709c15465619917d8345d96e644c6eb71e597fa126d90190f60594b760fff647188654266dae0147b1dbaef32bed94a387f256639cddb1c2cf8323d83de5b144fcf400970bbe4a045f79653e3e948e91a5f37360b8b70a4573f49e0c38f8713844ba4237ad97d174cbc92f8df239bd95746956b432fe81a97c0059bfafbb187b4d140ca9785b53dbd200535adef79ab9c7db75e8e6b7ba4c35f973dbfc95711abf885988262adf05855d6e631c1b004ddef8123648ccff51cfe4a85b8229c987b3f18518dd70a6e2c465f2e129fffcca6d4a62ff65996725958befe8bbd741b35d97bec3cf1b4d67ca19da49a9a8357ce54eda5b3d0551cebbd9ced0315b4d7bb695e3c1c047dfb7a45f94dab51b6f73af066c83eaebcd3a382b04504693bf12b794d48924cbb01d5d6210d5b00b0785d2a07c29d517907926f44e5a85eedafb717a5c45cb0381ea0c7ff52def21500d052e9a5cce86e1603395fa99ae0f7faac08edf2b3a3f5ce98f534b9ac5cc70418828d90501de2bf7bd8bc5667539f80484a076745d812b04e86b402aef9d724a6fa5636c16c5139ce6a85d77078c5595b3907616ea705f9f186a6223c9d5af7cc11c8c86eff12a9996aecf963b40e6bc01251e7532768a970c51cb868224e605eeb5dcaf87e8a72ce1ba2151f7cfde745c546641141f9cdc19f74f336394ef5c1be6fc0f7cb5b49c99127954244b79118328350149896885023a1e1da0438e43f5018c172088643c8290aeba881a6f2b75532ddc3c59536a102c8283a45ccb1c8b2817e380733bc3d19d42b8f47162cccbaeee00ac5c28d23e1ef13709447368b51b8987fc90ca41350fdd3ee53ffcd17624be5fbc4ba2593b012cb40573df922354cc34187b927d435d04a467ad689bd8449ea5774cc135e98cdb2147ac99922bdb26e90d6d57c003877047a3ab5a0a96ae99da1a78826298b7eb8f93e3af96dd05afc80ebf68ae36bd696a8e0fa6ad92e3e896def28020c36e612d6441e2a90341e3f589d9ba6eb98248a4533a5edf941004cc8889148c2c910f03bd04e34c13b5c83650b99402dde1941faac31825af3a22a1f306852f6e9228b66b640e02738769e39facbeb386ffa9422abc952d2df2006cb0cf0dbafdf3aa2675133c1170c4c04fbc24a9ba415d15054c8b51aab33428cb90eed20a4c5dee055efcec00e3f1753bd3514c885a6e17aa474c6a27fcff0395af7b95720f8d3d5dea7d9b265d249e9bf31730e3e7467ab83150c27cd6718110c901d5c6a3d8566afb366c7d01d3b33cd83ba423cc97b62d6b72cee4694fc3f589383c770c86177e03e04a60af80287a856b986e31c98fe08ffc9924ff12aeff836eb5822479cb5f637c2d3ff60aab0bfc57f99fe68c8fb474e8b835a14468b9baca34f7f9bd965bd4beae5fcada52cd57cfb18bdfc6fc9c7248b7320145c0d08e57cfe7f69cae826c5bfac5f98318c004c31c358a2eb0cb339fd73a221c7b12632128f031fcea1b8e9a774043bf2e5508c545caeaac53cc922579b90ecff7323cbcfd1957985f614bed3f5584b026ab94a785b0514d778134eef060098f3293c02f7ca73c58a4c611418212590f3680da4d187fb800f10db7cafe25be1ccd62dc2e09ab3a347a1dbd1bf80c6fa3f8925f89ec9cb7dc7863885630798ef23944b539ef250faeb8100ffc126cb43be6116a04ca3167ff1ca332fc349428ddf97a5c118507eb03c6240899b4900ed7a0b44508bf8dbe4f3992bf176f1f5e2a68d1ba711187b9fa01b30635d674fa870f71314835f918aca28191d84809501ab24a53f13d109d5747d745581b0effd76eceebf4bab2f40027f52a3f61c7facd145dbbb7fabf1741c77d57ef0dd60a76525800aa148bfca2858c36cd1dc3691393e6d7cae96df1a19d5925517564e26d720efd600fde650c712cd798fa8b728dee7e0f485488d9ee3ef1a03c05342de28ac8875b9ce6889069bc45c22df6df1e92503cd20f6cf2df3aed6d95ab1ab0af729baa0b483c3662b25efac2b3cb830400b71c7c928d0bafbbbc9c23f324b20a7e94e86945d037df8382b550ee870692be6a56ad7b0d10711fba70371e00829c7d16630dad43e59b579fbe152a962ecfbbc9210c1e0240662d2ac3a3abf7cf486d290c7dfccaf1cb0564a2b760f370be79b9774f92c76bbee865003a107ad0ea01ab84a37e86a203837e8130d0e7f1a4f49a0706a389db32a39685ac45696584880626cd0a1d08435c8bb20cdbb6b9c501ed695aa98cc0b8947e95536475da864ef7066ab05b6efe4674420c5e825116f4d6386b4af7ad2a178eafd79aba8a9b28a01739d495244d101509ddceaedb3a06fd64293d27e67947638ca72f07e0a330121e659f5c8b08b4882d0062e364d8cbe60453f74d3a29e7888f172d30a2f7577b2f4e8b080510c4fa7596f0ba66c205625228301b3ce86262370fcd1895e4dbf34a72d66b98105ac1ee0020804e252df4664b7a2f2e90c6cf13c67ac7b22d06d535d51065a6c29ac538d3d4fb5679c41c90530dfd2dfc604c71352aa2655bf710785d06a27b2322846a0542e11ec6c19ce30c358e5322e60ad75160859f9c56d1c7042177a46b762a1053a0109bc0cd5b51a455a9b6c390cac4d0be2572ba6039c00a175322a8ca3b5ab83d3a1488260eefc23cba1a84fbe69cbd05193f5a057ef6eaf427345ca5c82ae5504269193a6a07160de4119977f5c619c66fe10e6415ec36ebab187787baab310790e86b6aa86392427beb16305a003876075baf17f32aa7aeacc1b12a74ea7715daea952c062129fa2ed3edae62a78f3cbbd1535c0d6b9692a209e273170a9bdb6f9efbeb014e96c6e965577fd45f07253f8e480e3ca1f67c1e869be6c8e345d48235bc107310061933f4863f6dc531d47fec9414b7756e5967391ba7546eb05980ebdc0fb50ad8bdaf9cc5cf4ddaaa8023be03113eb42717e22527e2fcf1a4b1e2092a8984fb029ab9a4114ed3785fde859da1d22971f72d38ba364016dca16bc8df8c441c22e5615df793884b8cea41e5ad6a5f657a3a5050f5caaef80f8a1b39689c3773a8dff17ee1a0401c69fa35e28923625a4a4e12851a72f604c2b279daa35cb68c69e25fe8a72260d8f26f077750181dd854422dafc7d373512593b95a1b3ab40437096fcd2fa69afdbab5cf567a1587704986c7580cf208fe45b8d75e9e9b2bca75a70dadad157b4300549e9b6d4e657155d4b0fc508c81c9a759d9882afbd39576d7359bd3efb563c4e76b3c60a7b98954a8cb0d3e95f3af848d8e9b3cd894e57a8191d103525e694d3558322f5f449757ccc8b9026c9b43d728ef5b0c3808814ebbfe8eb67fd4194e1b920659c6d85dc6b04aa5a3462e40eaa553208e637275634f5f8492739e039145fcfc5e7f71e7ef414505f327c0ee0e1a476f63d8ec72bc265185b04956ca86557b7e75645d64da9b03435e9e5da52c933eaacdb8e4e7c27f36e2255107bc7daacf9edbe25756220aa469f281c6dbf04e79005a75638e3171e119695492fa40799b3a26ba8b9d2ab4ad56f54473996b79bb86e52deef19534477379512b7b6578cd9f6f97eb868b2b9a2045ec21ba362614cafd79d657b85712f906dce4c172452471cde5bd0b1dd168de42e9efde81cb228be4ab3a869f75e0b175c63e3d9557531519d2b4d7cc82c3ca2e60e978a2bfb562d20d165eae04f839c81028d90fdc490ce73bcbc3d7a6217b88b11d57caeed763c37ff35ba7af462ae43d324a78322acf11bf9d9de285b690eefb9c1654bff51743756065177fcaca1cebe1ba342e435ab542b9360f2391b4d199a2a69958b7ca8fa34880b1a12d4bea2ff38e55ffef73f18ed937fb944c63d975f722fcd600ff008d3962646d0b40f688491eff45c904f122dcc7159238292aa0598692b98db708a0216e3b3264581cbff110c6bd1ba6a17531fd76dd3e9eb2ab3360e2e5aee770ddfc452db3cbe04c82c4c01df215b8adabda0f47f1d7015cea9ae2d593294114ba9efe51dfd3d6b70ae418a105704369ded3bcaea4ed872f25d777c604ec8218f6ae42386cf67dc0a592712ca0a14d882fbe245c22a7a9683263859494d101e66e55bfafaf0d9f368386b509420ee4b97c4b8c11974c51cdda7f673f08241546126a1430517a0e19fd8dbf5d38b74089e6a5a7881cdbc4ae86f2d78c3e5df7d735e4ca052a34b503a390fb3ca8a18bc5078577d2a7dd753321bd424b0db1edde0991182f2e62b8d83af69b9976ecad8f2bb2f5f7a1bd492c97b2b4d9ccd20f638dc4bceda97bd072775f911ff05604e806c7f48ed856662e64ba228cb9a1dde0edadb85d84c5a2067d90c30afa595be5624e4e4e16b367bf2ae56eedc1205a715c7b2b3fcc9663a1fa03b45a91028859bb88145fa4028a396e2e86b4bba9aa925af693bb37a98f82b756acb4cc3c657e236c046173140e42be5eed377211ac882be007c6e988ad7023c6e52c944aec5d3018dd3df7ee485c01875afe7016476c15557c7c67cbe4b8e0fd2da84054c33086392d61b51c691bed6d5d26f59bd9bc2e7731d128867c9fc73eba4950c7b006cfe3f8cf2ad325906b65c73d8d788824c9e7a34bbb425c4bc1f0866498fc106a2fa3f4499a19162eee3053e5a7193d9f38d3d4f9a0ca364a9d62dd5b03bbccca83440e9adac2b364935467e45cad9d8fdf839124e585196e4eb7f751095f39ec3cc6db01f0d205f5d4d02769255478cca69791db3eacda778acfb987b56be79c10cdbe803cb2a5cee1bc3e9d68017196983e17f772d9ccd976fbbbe9bd51d42251b563d0ec2da9d7143fab4ea000f2c6e141b5463b2c228b0d911b64297b8d30250bd74a4e6b7dabe5f8f1e6b6f53f1f56ba2553fdf0afac67df89662f54860bf68d5c7fe9d2e0c19d25dc45445160925e4380a2a37be136b363ef3c76c6ca4bee3278391353bb3082f22d128f66c73562568186d3998cbc042d754e899e20bd9e6809988a04a405aeeaa9c2399799e0691dbf841a08f918fc86d2d95cfe456a8dec757ce7f7a8ecdfdd33f325e1d16340f6b64565af24007be4d99e1dc081331d48038f603b0db8fca53ac0060ac12b34a6996c6ac373e83848ab4c477b7dd81cb91b711add59e82a2044bb7a323a99bb52d71ac3e573600e94ae74a899d7381e1cdee251e41ebfc009815d7d16fd72d07fac4ee65ac44bd0a6b9527ebad1e9f56efcf479f0781139ff1c4b0b207de98f3e3a6a2b4fb7465c78e4da28c1988e4b05f5d1b8c4356c9860e2d1ca7004f4bd486686eda99a857f1e45b124e90b9a9ba679ee57e36d200dcbcc72c94bf112a8db2598c1cdf32e9e51e8f539a475204381f407a542eb14c1273695a437cc997c56fbdb51f6531383d5099aa5eb26831b7f350c16c54e11c057fd069b06e5de3d4900ba2656002276103dc60c364efffe718793dad5aedcb6676e3b7f998442629d8e37a652cd6b967460ee9912b3751d5b97796685218a7f0d9ae8f8084eef6a95b109a8084fc2f2cb19390963e9a4996ead579043226ddccd01f8d7c96f07061aa1a62e4f77782cdcb4d6d6c89ae5bc05f5ded264565c67623cca8a2c1929716966ad9986a280d16142fc5e6f19d82af31be7e8fb0ab9e2f734357ad4b764fbd9cd7a70a06b5e727c8a5a2cfc3f6355f58221fa509920e06a059eb77e7ca291cad937fb4ef4ca127ecfd55fd7790f858aa4763adc25dff3049069a265944005b44ebeb7b937042568f8e226a1f9cdc32be46c29a63ae45a0f1a5e1e174772048ddd531cfd4454ebc980886c2b00b3f6987961967698a191d7aa01e19afe14a1a4afede19140c61f2d2fceac7463118551d7423c8628b60f2caa492561a25c2f87a242f15debde9c6831876a600456d51067d5cf5a163b351f87c786b49c24d5e76b3e9a389d6a39869fff7c5c1d950c64e4fd94155f266a20e46044d443586d8a655f9ef6df6249298b3a601358fc0ec4209e479be4bf4925746db9ba407f9fe945f0b3524e8e6b09bf9b57a45f2038431431149e9ba36e146b8b2e175f6ed49d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
