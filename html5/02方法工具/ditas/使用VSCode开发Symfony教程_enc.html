<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"988cd9d74c085dc064b5873f6f41a1855f1b35497a2b326c2b6d04357136ac10cc38cf312925e2c573e7f092a4c2180e3e2e595c9663c6a6039b57ed8cb4bfa9c93acb17b3a70937e46ba01b2c0e9b122f356c9481de8a51b318f6020e1827c189eae06d1ed6a50b74287d2070bb0af945d635f6f7afc879ab164921aea8a4e39626511c3d4966289bd72f144eaaaed8bbc9ce9d5d0949916f6ecef18a1e312cecad24009f8f578807a5e53a5cc885ed635b23f155f575cf30f18d7bf35421284e9c7932e2ce92b89df1f4134adda2cdf92e9dafda2257af842cffef7507c29dedb3d5c0f123e049107fbb0af4e53924123759bd8b8b72792cc2155d5dc38ed05d921af7f7d248fcb28002bd7132bb526dc854d09b119711ce17abf98eaf6c441c0c05a1babce67fb88955af5a5885d97e59ed8b03071c097df726f19e34502a46c79f7a4e58333813abd9b2c86a72880af7d34803273aef23dd41e109717cb77bc1665ac8b8d8f34202eb3b70f6a5a5ee9c9ecc4dbf5ce36e97e696f2b5cb4e237b073fe0b0a70b5d42d40538fbb2067742b9ad048a34a963692e99ab5891d85f6c1aeb24cfe8f71c102fd949d18f94b43bc9ed1b7230c07840cdc272834debe6c03ee7bde8d1b1589bce76886992b20359e5259dd13813570a37a16d74aa7a9af24029dce57a37b1444e55e4820c3e5f73ac4cdcdfe811aeaf2d0251b1e5864b93e6d2fc12c601727ea92157b2d7e24c9229204a683f82dd8788fb12fb8a29205d18ad5aafa76c854bbefab2e6ee4c9044029552bdf5e52df3064fd94a38bd602baea75874cb6a4a0be27db4b6f980f63f38047fa7f27beed07fc281e5e215d5650c7695b580d8bd4b89999e7115788b37477e27742f5d06ad1dcab42bc8e0c991f3918c719daebc7891671181db5383e76ba8600df697375a0d303c94e0422d6b07e9bce2d0f552797d21cc065768e6b4f40db5d146bf435de72475006292e40151e68086dab8f36ab992492453bc3ef66e3ae4834c37ecf210ecb2cd307124fac3e1dbeb5a4720c2409c15764e85f7989387030c8778f5149aeef86ecbf52304e1be7f570b9adf3584181fd9eb8a7598f7ed53c4efab0b320ece59eca09f4742502fed33438874406fbd053dcc97f964f8d23cf935f613fc61d74c3ffbbfdb51d0beed59e1dd77c06feecf380bf2008313a76b6915bd1f7e0b8c9d425918fe8c6dcdf7acfbad5dd640e94a9485ae48ae8b6f4e00c30fa22017ab337c39ce1e65c9b9268b192490112026827c45b546bcdcbc5d2f9a82589367586219109918f8e3e8dc2210c66ae80c7d805a7990ae65593b8a3bb73f8973dc4b4c21cfd6509c283f1bf03324c7548068e252d876a8ba5d5a450934b2b767834392df850c59f0005a17afdd43ecc87c9484768e52f00bfae064113f4ff22ca42d6c19955f95d2ce7a0aec68d00aef18b8bb144032737f58b38d6400bdffb80b471d54fadd0ddeca00bd5652de0613979b0e3db18fbc928b0f66b4baf8a4ee10a49a83f6817aadd5f0d79b6e7a762fde3c59088ccb926e650496c4ca0784374a4e0b4b2d40947cbc67df0dfac20f3219a18ec4d2aaba27ccc57c385e6bc4e871dd074d6a5abbc4d435b845d9cfc1324f86a98632428aca915d001a38fbbc4fd7ed8fc4b20931398f98c7f54a2ed924fd56b12babdf5701ce4da2885ec3820469502862e4904135adf0d59b64188cb85fb669d5b02b1d699f85b4fe5528d55dfa3515cc58b0f2fc3b9645ea03d7fca26692d88cef14e735da913a0772af2a3dbbf122fd9c7c59128819483b5209cf7c4c9458dc888c4fa983a1f3b8ac3293252e8f0e603a813aeccdc60ac96234a836267b4cc1795c52e0e25d1cc619177ff8c142a0e4d5d7994d0f48de6c6633f1920eb5e5dbfc29ff47cba7761878573e6b61441cfc25b913015af8def591a2bd6d17f9133d83e28a66c2c1e740f47cf6cf9ba80fde55b8c23f929c2090790d508d1b134795eaed3cfdde3f1309dbae56563ff3d4b396cb1666335162c8b9e5e736f3b1c2616582724a48d9c76e7b6a33cc4f2ddec804c83aeeeff024d99c6bd828313d604d501e114cdc5e929d673f38ca775406bc917065961824c5072f51aa28eb310c9c5c80cd77ec6537e40daf7ec2df707074d2874d5f8c5f98e7830c41938fee39c329411f5474cc579ef3dbeaf108dbf7e6daf5ae6d962354a11d5153daf31175dfb6cb87f5c7f74b0886dbfef97046a19d6363b60a6d5eff7acd392ba2a2ba2cfc20e322daf25e097d71e5b0474482f39c0776146ad385117b0991023f81926b973ab09ff6c5fadfc852083926dde4031e4dcab8b316fc0deda6270437e18739b1d025cb32160b755268b2e7937ddcfd7127fbcff5546e1bb42ca6818462b96badf353d6a92a008ed8309e09aeb2436255028a359449584a4a48e36d1810d1c82fa021e843d7022b9183985979c0839ed03fa1675d4c67a49d25b09dce9614f9ed893a1165ad879a54237127328a91dc4411da16c3fffa452b78f8e39a47ba8af807fc29a5eca18e697fa2ac7e36d19c7f4bed27b8fa4333f1219a61a346e3892ebbd67c29148ff6ec0d9af197c147b950c978cf6402dab75e67d82e62bfcf975b77c4c9c3417e6bdc9d8e2e324410b9bf40428dacfef09c7b465f219cdfaa490dedffeeb91e363b72001fff8ab61cca53f377737e1438889fc737e8b707a6f56f3d52d070104b69dfb2d67b54bc279c9503165bb10d1ad715e225cbae0a75253e5eb641f075ba359d490535196c9e48f64dfd230ff85775baeff008c7785c3932c1ff4e42ba87487f95cff6ed404e93ab81bb669b593a05ca69215cfa5e5e62cd5004403a34e6a09d67340309e90a43cfc42c544fa4666e486673ab532d0d5274ba17a3e6a522a41d29c24f0c00fa48587f5f9f499ef00aaaae8c4f32c7e2cdbcd3c89d13b13b52f7d6e852bc627dea165d1b9e8b35b302b5e8f4d6e82ae635290ab51c5139996b10882ef8e4a3e74cd87727d2399f010a0c78726c06afc71b84e56b7c5efb853085173f7dfb87bbb1f55aba0ad86ba0eeb88747f0e3c2c53803eca4ee93bae56522636c730a8b80fdc0cbdfa85988055a60fac7817aa84af9c3fdc939e8abbf6b688f1e2c7530ecd8b2524a9b431605f2cfdd2640329745606993e6e7e405a00a5851a71367af034b92d80060630ccce2118cf478737076cf9207a3392025d7031125c644679baafe979204ed2b0ef8bd6e80737b3b6a750b37a43ede33834812e13b21cc765adefdc3d1c7ce533a90cc881ce4e8008649d2e810853b9181f6701b5bd56c01681df6f3b132f3c0cb7358b3708ce2bb272cbc698437c70bddd9d1865a6bd8e98ef8ac71193c71b860347f599a5ac7ad98a6d0d0a9965dae23a0721dc0831180bc01a07cbbb3366699f8548e4b9e6713542c6b0a93466521013bd17726fcd3f8730a7a420a91bad9bd33f6e5a5db59dceb07957f59fc348f0393226e880da9acf0c0f34d17a81989cc43ee70918602eeaf972ad24244c4790e7f9d256f1a513ad3ce6b667270247858363fdc9904ba0ad06af4dea45f9f795ea54a5375cc418b7d97e8eba711cade1b24c8553c99409344f4afb3459e52c9f7e5ed385bb46b21210f83e90836d12309cfe80e6bdc4f579cc9558fc3855ccca12259c6bf99df73d121ee11a001b329d0c7f955d991d4da1dac85dde0bafc5f89685ab128e285ea429cb49403a32445f5f7cd7ca0c4889dc95cf92ec8886bab636ab0dcb3aff83e6559422b4a1c48e42ef4f96a69c5b3bc1d6196f1e7344555039ed7bcf42423328d8d4e9d9ceb0849848d124fab0dd3d9f5dc36650c52c40d9160eaaf98f11a048335f2d112f88d032e8ef55f2aa8c55677264edb37cd46856a0aaaf912d628eb8822263f7e942b02415696ae6ace68e2539e034fd777ad4b34aa529ac385b8e0a3e9eac6990d7a713671d696e0eabce8a96b8653e476792084c92d7c41c81c2d61d93304c8fcabce53615adbc4f113d17dbe7a2030f1be4e8b37025a3a16c116dec8a71637eb6d7a866741475c8921f69c54d496307acd1c47e86f714981c73fb90f3b83731707629e5c7e7cfe744d23d952296f33d72b38601d11e8a76de5945f85162561fde0dcbf53902931d5598416faa61c1871eef216d213a94b826165657beaecde3b7a7720733ec7df30ab7c3d958d4ffbaf8d51e0f8c7931665cc2304dd60a02c8d5497a6d4355d7a2b77831ba6f4b3d67d018b36454714be7ca55fa6c5ea123c31484eaefab3c21f685db906b1241992f3e7125b61286d5e3cdb9ea238d127505a2724689d493a6d9ea3bfb4efff8381a1798aa6bd94cf106ddbae74b4ee77121cd548b0ae6f1515c26f9ea039b8b76171d426ea0639f803c92beab9ab6968fe8e976f90a5516db8e45284835343efdb3839c597ea59afe887dddf6cf312901e3e0630207d144a596c4edd706e827cae54fce1631da37fce63558661b86ef904b97557c903869471d5a79662bd827cec2b91f38e13950a7064d90387348097c8235e70fb0e075857180c81a49fc82564aab5775fed3be5cb4ae525ce293b22a7da3e266e85b7925fe439d7c7a0e186fe74899d7ad8aa5a26b7e2b0bbed5a721e515fbcc7828dc13ddcf0e4b26f9ab92b8921e267fac97e25672ecb196ac191f1b2762d591fabd34a02a6eac98d174f2b287b0eef5481fb47d508b017f54a7b3c9760c670410423a5175663dd941d48f0a6f63321f5a8c63c007e5e71f1456b2cc0ce6b8772e0664e3976d17049376ba925d423fa479098486e13b11f25b1a237aa9531a301af586460baf134b27f859b0a4461435fb0907795ee4e17a346a0a969725801944aa803a72e5d10ba33af3e2fa917352eec1922de2f86bfef68db6c7537e60d314280b3aa9b353a9a0be849243cc618f2d8c10638f0768ef15f578c34312d6ed6bb9e179a39dbab3adff7fddec9919b15384d841be516dd1a4a23e34ebff4ae26b95059416a79f84873c383b9f060b5f6f7db9085ea0874858f1394edc0d6be07fa32647f0d5aa131d642d739dd23b03e4b19bed6c715affa49fd90a3f4e99a8d05aecf2fe5fed4c387d30137a7d12b18ae54213348a71ce95a943ee5555062ee6c7f8dc03a7a9035b1661f820f57592a719f81fc5282574f55158628089556e68715241610507beee2bc90b07f8a44dc1e70ae9b258b452b9ae32d51a70e605e12bc37efce5f9d5e4d7ec7b9847c3f18c387dc3524b85e873e536efbd10fe126dc61108e87cec44b396e910412c95d2ba5700b2c347b8586662ea5bd287703159d47a6e83dc2fcbdcf2e54c7933723198cc8a8f6d1c2075c004777fc205770127563f3eb4d88b5d34f61fb48fa45aa84d99d77491d045e899d01ce715928bdfc2aa3fcf70b8ee4b300a1a2af304e1aef8c190b30d3dcceb67e913673dd78c61ae117a468cf91384b4a2829d462347df5c78aa424d4090de9636f1fa0ccdfbd235d012a1e3977a93737eaa2bce4ee1a0e9e575d233dffd621d7cfa652292bc6c92fb8a9fad74d155780bc5bde336cca7951f148f33c80cb84120deb4ad72feb680af67b7f163bfcee426747f7f2369406d7b9da1c116d2caf2baa35eede7bbd774d9263ec53018606407d15735141d9fc87f97713a6f411093c221f553279e6f28ca185f66c4bfdaba9cbb79ecacff002f6e64a841ddb98f977d67663b876b0f7528ea2087690231a463e330810c049a199c74542fccdb5c6e429eabc4aa2bbecc7344ba1bacd0b86a5ba166229f6ea0c226882ccc8e315f8b07ba2d0d273409cd5be1a1632b3b9cdec5224ae4f64ed08c957121f7ad803939b9db8f055a385989a73bbb3a99ff495be070342f109d99a83570fba322c411523145cc3919a871a28b5d18d30811f693ecf52c3fc957d253c880ade23953df1ec616757844b86edb5abc5061640d9b6ed164ec67d4b3c4bcdc2a8db0ac476ddb01bb70917dabcd216862097f077c0481c057dad9c1b2ce34c4ea8dadbb6cb381a0872b2005ef58a3a3848e6d7ccf9c37d8222f7e8fdf5a4e17d1b4ef50e4a291370e63dd9f6fa3ce13120bb6b86fb33b05d125e179911f7a3ee51a3dc391a2d0d62e856088c9760bc658137fb1656f2f40f4f1a7eb4c7a75d9b0b93a74c61a53700f03dd9e15b82fbfeb595c18068648b09ac16ef1d9e477b22b61847058ca43dfc6b68a22860736f980e0580447aed0d47a26123a99811520b82acc9a900ec25be0301c66cb73dc168851ca994a039c297157b8ca3726403b67e1ca9bf54bf8274e6e902204d0067406e1d248a36495ca70634c58836094e0440c73f57b46d41172b1635334da15b4379a132312c8e4994b16d308ea1531823d419d21627c5b9055e10af45eafcad34f75da8f3cfcd2db8ec3996fa645239056f14d631f1cb9644a6adde82831a20755be784cf3e578432026b43115800d6cb7e4f50c3dcb946918479477143a6d48509a825dc8a6b64c5d73f96e8dbd1520df606db9a3d244ef77cc9183ec9ee0ed9d70f0121898812b49c293802f6e3f834024421472be9adf811f319100c8c26588970e2688bbb512f7c14b612aa81b8c6438c917c3e99adac2b211fbfaec5160cdf1e54d82b510d41ed7af4eebd011d6798d1b8eb9937c854c574c926d3891e032f183d1d1ab77a878bb6f5726c12ecb599547fc46db00111cc40695e64b885f13feae0678339e75aed34c29313c3006d7038598de96eb8cc56d9f95b0ad20e32bf4b81f577ca02bb5f6785514bd74ed98902de0e28c72a7c769b500cfea862a2f233d1bfca0dc15388c65b4617a6e2435b2739155e6148e761cf81a5bc48fcd60573efcd1616151f18078aba00b229e7b01baf9cc661c367c3264b13d6795238f9c3ea43b4dd6b46bf752365975f2d4e50ab23437d829f927899c0df03cdb9a3e3f2f0075d1ad03fef9aaf963b08e739b0ef36683fb76d3a8870bb569981cde40f6e059d7e6ebe3241916ffb751ace85f207f346b3873a6ecd5f73dc9f0448e6f6d8c6927ce2ddd537c532f5b62d22475608b34b8b1497765cbbe4a67e680e17e62ccfa02f13cf0747663f976f6a597fac6195832bbd349cda06b07eb396c95d913c1e82a30558b6b82a60b538168f55a8543e2ceb839a745b0b70979a772deb0fb2f86235e9d33e9a7f0df9aee9a9d0bb13610a4b9e33bffc3d943d19863b2807cf34c76258de98c51402863ec491945f453671b1eb7f391140c0e0afbe4ce38c42f259d909b7d035913634dee4a9165cbdce044b398c162f0e2f9f85b99f8b452fa83471168b7f23118d5993680915558f6a375234a03d27e8030c1e581465f05a96aeb9d83541ebd2217599aba3da0db21223e067564401a1fc7abd0201652f7e47f3f6c79977b142b5045113312d295c5d84d9364bd25a3a0dc583db22f08a7283ab8c7079e0a50eae4be1d0b65814d02d46f4531383078c007a1baf0870c65115dae82e7512301c502de2bbd7377c99d951e9a400d026526a77d823ef01242a443116e3509b3064a0c82226dd083875303e20b4a16e5941d9473f522bf49385d375bec7e2c845ad967252ee25b1c1685d0d9959977ecd92ad21cabcb4bef0112120914e89a0311e77a5ee7dee73704a6b6dac3021ad68dfe5ede6b73fc7d6571a8d75a2e713709e38bb0ecc17b072dbac49d27d7336440985bc6aaf19f833c427845af885567e87d46e6207970e49e1e36953f8df96939fbfc768f621f9563e04e9a09c25aba92054b5e5c2b061b9c378f589e6ccbe6c3213347f9f942fcaa43620f1d7f4256b194b28395bee9535eb74c57be7041d053ab106b2b857e8f3a63f39eecc65f042d6e7b22c57324d7c9fd2e4e18b8e5f15f9343a8b55035556757c3208ddb93cc505c0dbf1dfdaf3d6e45c0272d765163ce2dcc62c50901446f71f527274fa9034bb9e824d0949404fa6b42326737ad2ff300cde33a66700b534b72435166f4a8aa131887e5bb95c271aa466a4a442049f8549e12e552f3f142bc34fd07bf8c88d83c29b7d3175c1c1437dfef428377a1127226752e8b481d6f12e75972797587f46ab94cd6c316fdd2a2481a9f20829202c31fde1373409c2feaf89af94057e7027a302a6cd30a1e43883e5c1f6c866787fb7d195c021bb617c6d7d28551b61e61e840285e278d57cb7bcc4a72dd7ab3b548cad742c8a7b22374800c224832df38c8467750194f234750593da8d44d00cbf882ac1e2f6834c6e450570a4032e80bb5985e61d66fb9ccb9281da9eb5c0a11c016081cab2e390a8a373c7eb52916ae1b06d7e7f111b271b30ad2c8312fff3743f640cfbff81c2579baffb9f0d963a4fbbf81a93e382f979ee795d5b268e799ad588ea0e6ec092a5f7278677005654502643d650c49fd217994efd782c65f1f8231d4f68b6475297ca14f12aa6acaec3506642b7efae1836557fab49bc2e0efd6de1766994bafcb776f574742573a59e3eef94c9551d0d7008c80a1763238784da403f3565a5c575755a6349044fd11bb6c774415360d1af82ae2155dd747b469391a1a83c07b6d569aa7f2cce69b6fc0889250f51a4c0731aeb1cc2a3642615193a58accc9dd521aa91e46ee1eabfdac74003b3442d4d00adc41cd53eda87f2d2d387d530157c6b559008fc21a608382c0d9f335c605cc5c227f3143ca2382dd2e580d9801bceb8f34689f30ff3c2c5c663801d62c56e9581a859a5dfc3665b10d5cb6a3c77c24b1bb66b70f091cb6aed46ad38440e06526a4d744f3a51adc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
