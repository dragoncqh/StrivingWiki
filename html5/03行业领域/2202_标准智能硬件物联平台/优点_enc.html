<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ebc3086a1b875d29cb29f48d7d9a0d81a28d2087c7f998e50878d7347fed4494c5711410c059b5aa103a0095d8795b1bb49895bd19bf24b3d9f55f1a034ee21e2478b3e1ef43963de700f77542825319e65cf3302df02a2eda4fdf7600956900488365856e8a6b7cb28251afe2f2151e5efffaf9478732f9f42d4b7deb58892b02b64960011e48c00f35ee37a2591a021051315413b929927125ba503a53f0f6079ff3f855f1d9b44eaf86de2d414b3899352b934fd28b46312c0eab5f921cf02749ae34dd25a7b3a2b0ee978c36f4d6aaa4f1997a18fe0f5e9d3c72641e15173b59dc8c13a87094286dd9d4531c42fb7b6284f204d2e674354d2c6fcaf56334ae0ddfb5cecfe03c817b73efa41ed716f95fe738cf9884e9288f516f931553de3f6c3ae42d82d7dc10be6ccce8aa6759cff3d2600fa2b98b4906d2aa0931bead04c7847a69ac8010898650007ef481c392b1be8b1dabe19c1c2b05b76f2860d1b2134c84d1ba62a3f6a5b6ac048bbf8bbba4991ca7274fe3a242a2327e674b8658a70bbe3614aaae76e2d9430ed248a53967c312b8a2eaa1e81d61fa970824e367b8bf7b2350c9030434d02bc4adfc4b17904050ba89296c6e6ce876c7a637d280b2cc84635846da92d210ac362d08d285b221a7501355308abbbb675aa1b5b7c60ffc20ef8644b20e92c56185396a3cda9429a890ba878de6e974930b92d68f5e4a8014888cc3deccc1beff16a6096ab7fcc77e561ade252bae3164f49e4e60728191133ae6997ace78dcdcefc6461911a925796d397f00b1bcb9e73cb9f5f3020b9f0c069b717175eaf567bd7409a674b7b9bd9322cfab3320ea4c3fd7aff8a1c984469ec43761b4a4bb534869c006409575cfcff97f38f1c8e2485ad961247e7ea23bfd5724f1a2fe7ea77c6eba8ef5b1924cbb2ff5a8d94ba93d3c2ff6925e72949adcb44c02e2a8d2856636712090a907ad692731dffce5de61737fd50c839bfef5a0e8f276d6caa3f75e4bf3ee1e2b943ba1422ae0c486ccd75843ad13860937438740853aeb40055c5111e4fef1598882dcc7647d5cc5883109f4aa6a4a63a7352b93e72736f87b6ecb72758f6642146bccc1a7550f0284e94b4bd3c99931949195206aaa094427b04ae4eb8d3233f9963d25275b6641cb23a56fd79bba7a522eee7e8931550e59b7376963703e830184533e3d149470c41d2273f85aaeb4d564daf39b933b020df6cec9ed82b2f5d4eba26b787eef878fdf0f14971502826662c55f886112a56924612871a0f8c3291803130ce321480b6e1faf29d1d7a12d04d24806724eb9e7dcabb2fd432d4193f496baf5296a0e12d40280af109815e47339afc4bf0e008b322cc86c3f2f709e9e98a921a34e81f284f3bb172241125da38d8384348d64d31760e5134374759412ccfb6bb66c3047043fe908815ba38706077eb772d1a2af0458f1104eb8fb93f8a17e722f1ccadf3f42966d9788391f277c9f3b3f715d0f2b51aa4d0f7aab4e2254c4f99e7ec65ae07c2aa757df228f1be03bdee25dc1b1c555181abb4d78858a4942e9de242521313dd19c14a2cf5af12f4e0547d859ed9724c49391561425695e412344f31c0c7ff266d580af68baeafa02e726a15f8b219fdb0c1fe992606cb7630ba6bffc10bb940a795b68e9bcefa8e3c9e82dedcf719aad7446b8a28254bc708ea3e275561e217bba07884ce9c2d299f542735fc26110a296c147b2c5d33635a442930e7a9c19130198a0ba06729d0c88a921bf0847563dc37dc0e7da39cc80978900fee9965fdf4aacb43b980c4cf09c9d3340c4e8b98a09eb34d283b2fcd242f9c892b622f26cda15305bd3b54c0013c9cfb4cf85d753f0891ea68d547b928443e976164d449130670d197e38fd139e87839b47cb2353cc078aa49f40f38dee300bd56e3fcb95d3673e27edfb13766952b21afab710c1781bef5ccbbc0fab13ef6f9c0bdadb2dfc9a34d868a0dbed1f021e280979ef71fd3a96b1e8a444d9bc7ef6b93336d210aa22c1825dbd8645af20cf76149b798293901fc63bd6d5a2ebaea80e234c56887e1ffa91a9323efd5ccf4fdf5e532bdcbd153ea4c40aab7e836c3be301682180793520233ccad916948ba2c0c80672290b1c3408d466095417a92f48280b988427361d09ed2a928b80fd1286c232043efc3622cc974724cd110051706250595ba42a09a1608c19722941b88c90d111b0e7046414c61edda31b0ac830159fa071ce69e5f13345bc369bb98fc8084266df9dd1ff5caec6f8b627fd015dc35a161824c9e448356c5502b20e72c5ea100dec6a7b40f7b7130012baf539924682c1511fc36493189aa3a911063da3d8de5f8ca19a8e3f9f483ca75d42fdd7513a6b47b55556ed11433f549ada3f2cc634c883f2a502a72be87b875afb7c74087a9e36d760a46eb68047c1318bee4ec91c8ce0532c7e7d2bb442760039a84e7f9dd3677f46878cf4b4b1c3158461429aea8b94cd17f3a452a2bd374e62db14f18c5806888f5ef3c169d8c8ddf31b5589ce3677547c61b3d3344462d40fb324e851c261d9de2dd3d96d588fcd6458d95e5bf17f6f9521305e0c6ea17dfe7e3a91390b9d5731700d013d39b2233b5e489cb12c201abd4d601f8729456d32ab7895d9a5f7dc0b75a6d271f63c7d2fc1d2346fd36b53ef74aaf94ba83e8e6e47ba350d05f495c5c89f33cb986282907a591a7fe1fc3dbe66bcb618972d0a2eed8f4ead09a4fd9d58088a4c2fb131001b95499fdf3dde7822c12192df0159aa2f418c2282f2a32bb3280cd8e9375855d5b44b2b5df8f6e7512bac1815d26aede62a53e318fe44bb8170e0c765f93b6c510100a260e0676b476ef0629cc4e4761c654b0c3fadbc60ee0403d1c0b591e4818c6779f81495bb1317d47f95841eda571337edd30dc51eeed83b6429a2f4829a6eb076aeb8a8623dba11112b22514d38a0d03efd467ac571999b43aea9743dcaa3ec39fc497494a0ac90b992c52c13238a27031581bcd6266dc45c1997684ea175443a6c391787a05d5a5de9929507fce4f62c1dd83d70f176a6cdc353bb5bdb6d3d64ab789d654ffd4948855e5015d887c51b6f07f435858f6a386ed83eda515002b6bcd5ea28825bb472f0c1eee893140db61594c8d780c3fe13b24b9e07dc855e12c14fe8231440f24f6684649bdb9d9d118c12a5d472130b0e3c2e07e11ab428cb99671ef7e9faa7ab35b1017a4afce4e07f694d7e35061b69e381338bc9b412f6c02170720444201f36ab628dcbeff13568424c043efb83fe9761ad070d1a22387184170615d7283603f97b4bed557d45d0183458a38d7009fc3e046302d96d050c3c83c3315211233d6a84a92bee22d27db76b4313c8884af0f51f227fb9bc792a2bc9a8364210b9b3ce24eee05fb5be636d81c9092609c4c0f6dc7d145ffb7fc6ab47c323e6d0c4fa12d4bd712a87da0dd6fdd50baa5c71880437357fe89256fb76528b37cc63c63f834507a29ae806307bcf791410dc63b37cd126e36585168dec225b69e12de4c784f5c96907da7d3789589889efe8e781d80e6e3ed047ed24b7b70ceeae07b8a5007e124d26b0c707a8b4a498b4a9857b7e915112ccd43351e704bfe6cb7fdfc25cff1b0ef1ca1e010a8918776bd86b9d6593828824338e821d13e6bca39c8ca2493c5b0ef0ac972ddebe07a3d9f2b1d5a58b5980860b5b3a032d97b3b040ef8f8a26c1686957fc7706202c2e2ba68ff5818806516486af36d3efc058451b0b46c7308b5422778a6e52f11bb2e3fe36e8283615e2d4b21c821f8b8ec1a6a186aea003bf537304972e2e24186b9c7f71a51e0751cb556d2912a548a517b6de5eea00311beba40c00d5ae98526f25b9e24fae5775081c447a9e891517857134d3b11ce5ab4e5ab87c8995abd76ad93a3ccc84364d17d7d348cf0926fdbd5414a5ba318bde6a347b220e807a69a6590200ac593f8ecf3ae12007a9091b24b20f3ec33175ccda1ec4c2407549976cc01e64ca7b627db2736fb9e11a0d59c0e62d85e26285e0d9b3911ff015ad954052eb10b445497eb6dda5f2dcbec13cfdf51a825e0c4a2092275530eb58ec7fa40d14e8c4a627ef9a5a2684f9ed874bbcbdb98b7eb910b5d83f2339329f87b84adf033d2c2f197c630af63eaebce36b142b3915f86b3e4bdba4cc3749993123e27ab9e56c40cc14494e253cd35861f986dbd8d9b29ceb5eab6ea4b757d7ab5ab0cc5b81cce2dc0ae11a96e8a2ea587c52b286dda73e3eb524efd8a935e4cecaf7bfccff755b7296513e9245a06408468d424855414d305b26ea98deb2d63497cccdf98da4cb4e3d21208d86e4e4985f21da0bfbba2e13b9d2d424d75c72c85f7c42f0889dd97af6f570dec1823a470714d0a2fd9c2a776c0670a3cc3ca406446d2684866e045b4bdb31932cb7afbf0434e08df1a3fb2d00969e554864939c2f03010b1c03b7ac4b76edc7dd65ca4c084e829a9c361a7667f92dfe293efaff098439ee604be3e5076f485e923451afed0d04e9bc474d5da09cd0f618b5eb46ea224d8345e85b75900a68e132f09e81ca27b73f1ce769712eb8cd44ec771e9832219356595db31ff646930133f9fd9c505eeb9d5e231e962a8ceeb3cb96f42f01cbe03f5fabe4be375f82a42c6231dda3d4b8d21019b80e068b2abb607adb59177b5e37d73459915eb2bc747831f61289f78a416a2563b7bbe6ccce26ab00e5394a68200dd071f305152d425a7dfd292c3110334f6955da448ef16562706dbf0a2f87a6ab2a4aaa377dec1af02d16be9c90bb8fce1441663f4b87587734884676d1f55036c6a82015208bc284b5d40ad219465b544e9d66979bc1c63e34729fad1e918dd190231514ee150e5a65bb5e6a287d3c16e0c728c93a0a428d0b878d5a39e5416e8ab1712aa0d1ca1f8b7953f52f1648867821c962aeefc65dc00724bcea4b28481c19a2a3bc3730df408658647584aa6d2af697baa8d25bbd3a3bfbf72a59b1f398c798308f7f438b52222c9f9ef419f39002250b273d395ec61a896bbf55310e7dd7b1ace6d327e61b99f8fe0fcc4f2da7ee38cb2e88cb002702363217b6c9ba1e110a373fa20097837a17c7fe329680649389ff82515b931e347f63e28b264436dab5b0725d59c5e3257bbd1f6943dfeb1aebceb6fca5ecd558c962507fb1a718d1cfd9f778d62d674d554839f6a86cd48826fa0be6a27e24078533d700a418c54811bc6cb6ba8a31acd40e11ee85f5d1f1b7c70735f9fc5dcb5033c80ce5ba4048a60413c4899ba09c1c9c0c12bfbf7bdde19e24c8aa3a8faed3de5ec1cb55127a42aee29b3cb8148b9109610f696313f90a673247de88c42098107f7a46407c5d5dbb1ded7e4e4f3c89a5b82aa97861ea25a2f5342c476b8417dd83f36dce53e03152d4be72fd232110e555297962a7c9ab5f39379d688d883ca9ddae3baee8df2446b915a5830574d1a8f22d5dc77877f4e8fd4aa12d67708b05ad0a068f1f5d3e7713f19e2852e78a4ea73dc5f9ca37b3974685dd5713deeb37421ae3491eee634dcad445264f76b2cac2691aa6c3de97bf642a077b51896b93d316e8fdbb872bef69e6d5a7457aa5550ba80432692f3ab2c4c7012550df2e74fbc2abb8730750d3c518a770cae4fee4a3ad3b07ae44ee296ecfcbb6d3d5c4da2c9afaaaf565a98fed0d4bcd923a9761a7aa3b6acb6b6032538cce20b86315bad043b2d1e120233c1597eef5f5875e393ff3526f0f3be2616ef630f7e49c4b3ec670c883bce7c06ba57b1d0bc7ceeffa847cb5ddc54ee94ccca32a44f7eba6df267feaeb51e0328acca5e0b12b98d131ad0de060bebf7d5fbe77a5a86a628094847c963054a25626c0270c8cb6dc113fb95b4426a8fe0296fc291ddc45b904c74d7ef0c19b21308b26e2ddd50f8caee6932641a09444c29fb796a8a667d4d7bd174d2ee6c62f17e14b220765b4bae7932ce0d36b87ce3c22ffcab3346da67350076289d77b67b798f0e7b25021e471b783f64595a60bd518363592c6df2de925b33f497be857aa6fd276468a07d3ea6765e9e6c399c2e94ed276fdc144091e6e9e8536be898b8f4f87768ecbbfb4ef4c2983d0feed2e828ffc429079216438714cffa991cfc0d326b75497778c6e279768d1bc6deac588a429f9c565b1cc147082f092ab115ac09de617800ea94661083212cc8ca178905bf7995c4e6314c85fff71613eb5878200d4dd0619a2fa1837ce5af1bdb03849731e192e06f96025c2aa5e6708196b84978cb9dc86d610c667981f5185983dbd2838c8c10826422935fe79e38fd771baf802cde9ddb2eb34220633e6650ead620c5e00484e0bdf525a27d7175bafde8371cd061b1bb9eb0899e98f320a57aa16464255125bf90c490639a92a5c071e803e8debb3d0c1e3c1dcc9114a2bb44704721f7c6d02884b3b074ca02bacb51e08a48c53e8e7731fec346e9266a100d6ca46e9d7a3506e026f1893e6f0e53bf87d167694e8ca4e2092cbfb37ad3460121c811009436e49995a220c07ec9101f4dacf731156141e828733e8a91ca525c3127384034c305075b35944e43c7e8796e8c554b011bb0285ffafc6a494162599bda5b27411b676904781ff889c6c9b81a676f347e723f88831500e7b32bb2726bb1a7ee945a51bef7c72e0cee372a9fbc57d97cf0fba933723b1883ce8f48c5c8fd81f3951e84678738fa3e3e7df976c19227e78dbe3a90e89bf0d83b03a619b1eb9291a458f577cf24c8180f74f60c3de0be846355e8b0d8d716d6e3ba6d4270d41828ddab41cecf963834f6e85a6f38e5bc716a3b337714e5b325361425fb27dc1d03b0c547abe264d61bbd2d658ea2c199ad56a84f3de8bf7ea80c1eb27edcb0e0838dc3cee05c833a230b4e7b7719d385c5d67c32f3354976e041add2546425ca073a2181ad4b78b22234d2a0ab10e8cc478beac60c6f47a3d1b6561c1437a2d5f11efa788b009466abbb96a3377b8930b2e82861e1359fe66f56a75fd4bfcae8e1b07e78aaf1243ba4bca33ec40507e225c9a219c8951e3209b764fc50bf1c28142fd1dad02d434ee7c4bd7272a4154447fe7a1f72adf0792e270d970267d7dfec393edc32c038482ddc14baee4fd906979b0fe72adf594564b7eac8c51989382f46adecfd9e1c751885f27491c1ad7f342f1bbdbe8b270763a3d4814c118275a614f03160fa02e7c2d669ff4c87887301a8d8aec56c406df407977f2234b1d43cd40fdc05c51c3071ec3ce62e3e40a7152395533461146daefd111e2c1f876599faac9262ba3f60d358e9c9a3eef42b6103cb8c2d29ec4b691233305316832761a9fcc8b9f8f2055309f4c23665d5883f6002050e7794c6c6631550a9bc12bc9e7283759e3536acb06d8503c1c2008e8ddf060f03db82fa412229410e87c8fc89ff0531887e7626c53bee4df1494187d297f882af15eca907a4f2fcd1d714edbb8c04ae3bb94f7db95788651408e7364d0fc1c734ee56c2bbd476f3ae4171009b5957f3ac29815c3a767aa8db8bb93e47c4700e8f6f5e2fe6e86e20b3a0bd36835f35d0011537bff1081a3ee940a9c1b6eca3d7beeefb8db3630f5c0a000be92aed81939730b00a15144c19fbc8ad3d10088b6b3ddba0cca123df9df3380a46f12595ec3b3e1f564e005396d49119b6a28be065883fc5e47b1356726bddd3f096e57ed538cb498310d60629296c0c431f918a452643227466e90034c24011d860eb97b4a70d7db99e302b0cca35505e8d6616637e23409baf8e828cb78fa751156b09346b78214e4a45be4cd8fea8c54a7ca8cb602c47cdf16f10f0a566dc4c949dc6c3bee07207cf2efc4f63a48c4c8246227f69965c446f9f87164f5e7fd27691a7ca2d7d7b44141f9b9e7faf0eda2d9b3d314c50731a143d8b6d30974bae8b732a54e0f999a91e9a3f081fd5985e638c624a3ddd16efe93fb2f2dafa3a193755181a94c2fea07fdaf5cb2edb817f7100b8bce4813a46b17334b7c2169585a85a522acb4ec2967883f7d18c606e22cd144e6eec10e443a8f11316ca5f2155fe82065f49bea0b5095a35216ed2265f9f6c98d0d91b9435ca3bc8d8840374f4c98fc7a80b37d954ffa664a4c142f43cbe3e5d7b4609cf93e4d806ac92dbdabb50a96211aa43e53e952d36a83f3ca95a10b2d11cee697aabf1418287f7406488b588b6c5f906ba11cb535a6a36a51e952f0c0e8923e417c1e7b7d20f20c6b24c2a9211f3374de48c3e7ec24db878f7e0e939056504cb9d39dd5f52a27cdb75ad20293bdc6ffaaad2c6152a57eb0a75fb15626b50880b5c19efc3e5aef6ce90f2cd34557a1c71c2725fc831dc95dfded044d41d7d57f9cf934a34e650f45f07938f206df831ffafd1f8ded6a9abd9e13e98947bbe15a11819bbac142e4d989239fad01f1af29dee8fe3b01fbf0a26a29ebce8277a11c98f2d0756b7e989c9f4bbdf15a4d9bb60b07b77686bd59ce9755e46d9c8910bc53b8a19e6ee17e5fd730231839e5f82513bd74d59fdd2e2c8b64578933cfeecd3f369f67738697f19ed16c6322c394d027ae00f8b156651a0299c8f5d38372f6a08d9167eb00ed8eec39d2848d02c24bd15c7b8bfe7aff6499d7c5421e1783016e6e0bc7b4cd7b6620e7fc051d116d4690666dbc3d1c8a5a4a3885dbbe5ae9b6e5dcbe7c5b3bbbf93ddc7318dd6e50f06e0f3d3cb952dd3febe5fea13b49959eb40f80b9648f14a534f6fb6971db95efce8492579988941fdce544d266e262abe1cfc30adc4c2d0ccf1a6aef241422bf18b68977a8e44bd98e38fd8385a68d741a9fb951359d937a727a3ad82b373e1341a87128e44cf5624e1c01abd81747c3442611f469b2554b22f510b91f15050e2bcc192dba91c79ecdc3e1973383abe5b7bdb2ae8dec85e6da1b17ae359375e2526291184cf52ec81d9537637213e5709ad6a2ae7d01a93a8115bb4d72f54e6ac47e87a071e7a8ad80a1a0a654df1fac8f75d52b4807380778f3afdb18a03c0c497dce127ab75743a1eaed3a33cc76389aab021307566c6ad07f34e5a39ba497fcecb70d63154bb06cb273fdc91c9dfe6f41412d88271441922092ced38730ac64988a5726259bd7fe1c46906496c210364bc035a33bc1de1875536dd613f35b238f611e6fbd3e1cdbae17b0de9e20f3de440347019523d2b135f754ae99edf013b0b730c6e7ded222220cbef9c6389dc1f110f7cfcbce790c986f5270aa339fe805e15fd0bf4790243e1e5451ae8a7a72a48744e8f58261bdb6b8e373195777ff85ad024af1165e52290d6067dbf935b0537ef4552ca77cd8ca69dfeae4bbb4aee1539081e8647fb96d84c25ce9e4e600c146972151afd7e070354702fb1f791190dcc787b5b1743571b0253531d46b4a1be3c0f9b27466dc8c1f934904e01a64623985c3377c3a15a914fb45d03ac3d31ad86fe2c1f532cc16728f1ec8248c93af779b4b70825b4f2a2f16b14c7a4ccc1f4c60807883f41acdeedf9404f9ce875441938798246c2e93fb3c4523663c2e38cfcbc1aa2ab6320747bd4d235fdcbeb61b2c83d6b8afe7d9f774b736cfd750c324c90f8d3af46ad187c8a666ab80737d7a0e6d5d45e5fe99a4210727a1630a4054aaf8d73222f71a71cb41ba4abed47dbe3ad05c718a84f39aa07cd342419ecfbffcf2bf66efcf2da6ca6c58193bbe85ee07e2d1036ecc1018527b7f86ae7844d70ed67b757bae2fdb401cbb7ecd84fd76d7c79a078f5eb7a25109cde18a0ab3352635ef024006f2770aaa2d64f2317eb8a75fc7fd150606542e887d3222211d9588773432bb15b26af4e944b4dad9d141ac8f6c3ac1578b7596d192fd9b00ca113a855ecaa1fc931c042353f0f60862dc515a24738fad497683cc0df7a63d0d68e8d5f10ead4aa4c4da00d7a70b46a5609d20332bcdae812a780c2fb83a69658cee845cfd1e5e7e76591c28acf89858ceac9364904346d6b2c85f585f69faf997265c414a1676941b31a7cbd73da398aedad31ac4085b6383a7ea3619f282d1c0425fb0a84226f301ab081971faae1b25bbe0f891ae77aea587ac442be286cd0ca95619ae25f5b8e9d466804b979e4f4096b63dda0a4af7fb9b7c077931147a79c9bf4b3f7f8e6e9711a249d4e8c67e311819a1eec0ad86a7f890d38c2b40675fca1fa8cfc9991b1a3a5ed1eca8fc76190850cc49d6ee63438ace93d91aa03a073ff751f67e81f6224d09f1760213ac2402d018663957b4ba624fba8a76ae438e34a6ce32fd50365d3bfd82a52c4d29894cb19e319bb6fa26a6efdc582a54e29bf5aa1941f0cede09e66e497d6dea469b45cb385e3f367daae7d90d5619386bc6a45dd869154ae99e5074dbfa324221c607eefb3c38de18b2b12f8e53a35d56c9034a15d79d48bb4537c61b667ce26f89942f5daf13ee49c591d75de4ff20657213637c1b6d2b56356560415229e7eb9a0d6822bea0b13efb513aca464413aae8fdeb515bd09c615a3d4d3bd102f72d40f7ce826b087f619c46fdc5111262c40d06307052ea0e9591f4263715e25ac7d9d06e7fa2bdd068381e63a2090c7f56358dae4944048a69fc425b6cef2b4874bde792e00053f33ca50c8636493861e9d6ed83ee8f7cf9f1f30b5d91eeeb4d763c03ea9b6c3d20612da655d7c5740fab26246dbd49bb3c4521945eea28f066fd1e73a34b4f8df3cb616fcbc326618d4a50d28cf8439456f8948f76ae3b013f37161528f43f960bded256763a9d5ecdd1bf8de9ca10f922b6b97a368eb4ff54f39a234d74c7016a6db61354b1c800471d8b4ab6c11800208384c3245db24c4595d10630e56f419c0bd011b48583a61664974610988d91bb55a8ba6585bcb1704ef1bd0dd09559676d7a5cbe2aa49cae7bec65aa404954c04e2f3aabfc76c5a5489edc7da30c78c0b38dff552652a3e5b0e03434270d69db316929babc1d4ee925295d6777caa09ffcf4cc62568bc5a104cfb86eeba065d8efad28d9a86ad215a9ab23cb7a445a2cdf2d34cb32178b9447a5e76b161976a64899f6940bd94ed740304d72aa60aada866e4c9f9f3e5a010758d50dceb7600a924da89421552cb3c53c3dd78648734b26defbd9ca75126b264c8b14ddd81953d83cbe37c63140fb6ffe75cdf1c712c33800c2c16919fe3fde44c7cc2e1a6b8f0ab0d961e505645df0ba361f95c71f8d877d1b04cf70a322f6f9009833d67da035a9bb95735a348426731870baefc0cba3d1ed18009534d0e88aa906e8ba8567335b3afe8b9309db4e8a3843dc4160d8f03f7d01db582972393b2b6f1d0fe03ab80a978d74b800edc89c6fef6a2bac68c932f8c0ab80687bc91594742a0c8c2c8e76745444c59827c8d5fb219cf14350710105199a22658f945e23b568debc340a0bb9ad96a3304195f3eb38ae816dbfc124829506fbcc3d8c60939244879ea04b454dcc4534281ecc814e1c42a917db4761bb3de0b0919ab3372fa13381851f299a417fdd7fdc2bb0f313c48753a0cf48e914ae5046e5429bdb40bdf239c93ad99f5b9963430216c61d461422e8d3b366f7519f1c2eb4ce95b9cfe9f991d535d8d6eddb7817aee8975a981abd9c2f0732c305300985123c62a3a2c76bf60b234c60fecb6e7eae1eebaf12e2f9673dc59b8b4c2d5d702e1e84af32717736b6431ad038b9e4ce2a1144db55a1b984bd16c10a207367fd1a3e038434b94547fd6efe68d5d46fcd4364a8610b7813c3bdfa5bda13fec28be6295451ab4020cd1a2399ae96e027e87432fe4f2117c406a7e571ec26fdedecc23736bfbdbea1ad7af997418d9abb1558e95de6736e0faf5f567b8aba9e331d34120bc113440caaa35c698fb526e418cafcf5c1028d879085a2eb2bbc3d498b427658a8199af70899537303323c8e5c789552b6124be7e40d3e86e01fbbf30f8207f7e71da07c41c40a5f6dbf21c574556d217d534ec2955be85619dd44478c3c77e4f6fc50b41aeb816af0ca9111b540030cf18c1be38270aea813496bfe9c608c1930c9aaeac37f121f2b15ae10c97cc140a87a5064105514c9cca06e4e1fd1bece6053d82d95d7f0fdb417f896281c820597a74d524c8cbd7526d7dd1f675571991f1d70ce81832f62c95a19c240a622a662c778b3638de333602f3d95979de03c9e01ab9ea477e5f36ae13229c7ca0856884aa47bfcfeb946c2be1a5ed1d503db9435d9fc9b6d7c0bf8b9d141e97a7cb403489dc62ca97a839aec3a9131ae4adb7c5481ca563d58490c1e3b618cb156a76b077d19a00770df1ea8073ed72de466469ccdefdf00f5a4b59a7e5b269c328f810a27965e08747ca7e58ecb7ebe3853cedf887b18f011f5ec8698a6f207a0de6ba9a805b1cb0a59e16750b55ec4a7506839cabdc84d78d251b9e48061dbc93713097758749814aaa0866c28dd0dab3a46af8df764d149f2f646e0958b2ca6438e77606973b0c789d9ce8496432a2f5524f76622a14acf5e853da1100c378069081bb82f7338e8a339faea221e72d6bd00e148484c41b7e508ce8578df9a2e8dbb07101be5ec23c98f542968b535abd8899fdf46629a9c2fc898a017cbe1d08d54339ca05a29a61069692d24140f783954ff1db4fce50136915de246be85f5e0d42c6ed16c290a187aa4573a91ce2b9df5ccaa88feaeee4b88ebd55a09c3537e8dd040ba0ee5ee8511a87ea9549f96cfd92f3af4bfa42e9f80994d337b1954b5377108cfe652f0b6b18132741f62e69402c6bb902fce22b922a643e2a0f9ff787a9e6e22d6bd7e16bfcea7b3c1d6f68b2a7511e890395004e2a72476dec55fb5727f124078d6ba097d389e81131b7d34c48d6c84f16685bae5e1a92cc8164683b39f00f1414a49d3a8238b77713476092dc042fd6a87d55784357780ca793822eacf35a12412b800a74aad749b3572de4a8727433633f3b496b1d4ba192fc9c9a2894efbfe20c06b54675b22c950e096e7092d5a39001ebf1a9ae3ef2678ef58946ada45bfb2467baa5bba91cd7082b255219adef2ab39613d0e6e870db50df879e95ce606f2517c530ea68a1e002b4b23117fce43c399bdcc79d4765b92c3b1eed1f83c423f2a20d7bf16c918ade53df4d8792b36a337b62ae96a11748e8d8abf1b5c0da8ee665f0078647eb78b3150247a26c524e0c041524a76bf41973c428a8a6834c15dd42469957ea140e33b51dfc2a244d385ce52b9533256bcfefa5ab12508fd533de2964710c9ee562ec4a92c8e36e55b2c344d0a4a979d82e138c1b0a477f0d092d7eedabad5fb6c47ca560a0b07f7d49b5cde8a4413e0b8dbbbb1f06ee71ae6c05bb02a0764683a2f7c71896f3e61cc9e20e429bcb53f87b9b9efacf9d279d2506db963de07f754dc5b36faa76ca34b968c894c816aff49f008c58c50fe02cc2cd62d42f291899635a6a4d51db4b21d443f7fd6534da25522c66cc9c7bde92bf89cf4fae85e689383c124743d07dd8dd3dfe01706a4bce8d370a4d0a0f2fa8b51e6e36bb7ee5c7db8d8ece956bc96c53392b79b90eeb2a5f199963f69d202cc1e7eed37d71dc823619d8c459f4935f801034e46c802364ea7b3b9134139cf4f35fade9b238cf57f5ad382dc653874b855bc568941baeac9461010dbe66135dd3c588a177bc87beaca02305cf159041bda2bc2ca2082f4fdfb7ee0ba5aea78e704d620e17f0513355fc5909893e18e7be3b81c394c259a87b3f262b4f1e4e187071ecdaf2d323cdd32fcdf1a0e216ca729aa6b81b6f2c0c7a85382bd47bdf8bbc0b5d71e5b917002107177102c3d72a5b708b1c93418208d412f8624fa8f2bbabc896696c338bcaeecd4da8a66fcd1f12fc47f006791dc84f313d1e0b9aaf5806461520b6b8141655efeb9bb2f9f437161d27bb89b14daf615095f76ac3a5b04a28fa0d05c3294d08de125f3289b96c27f508b05cbe5f833eaaa6591a7d39ee4ac92b0dfac40a38b8fdcdd4a1ea5a9a17e03c96ae54802afe4688b986a9b0135581196fecdd9f4de12bd7f85422a50384b589eefc77effd2cffbdd1ce9551cf96c3a84f2a2227b3ab0b6c5b6a4551ca26c9acfbef707012c53e3133e2b8cf6e7f94b68c9675e743259a4a305f05beac50c9ae6942587fb0542701cc29418feee14dc08bbb4a8751ba044568798153211e5df3ccea02d56dce23e295527893ec5fe086ef9d99ef801ed066d774947a6602f00d7816a0ad5438fa8edf274f37ae5d0fb15638f86012805b19cd48a67afe27656ce42add4250b68ce6575fd84f6f4fe7783bb4bfbb26c1c7956155285b808b220dda0e789991976c25ff01c852864a57a7ab2b7865e58e3142defa68c732c98e503f12ee05d18f679277e2621ed72fb847c711088fa6c7805896cb19117acca06a18585b853d0b08a7b836c13e06fd6ffe7410a45480736865afb48d222f4b5d4f5c0b321f0e709b5bee1a1a33d324c557e5953d4ebc677c642792075030fd44287bf766873b8a6f633aab6a16b24eb64badeeb61279709e848e89a7ce1b7b3870128cfe64ebeb262f46fc04756f3cd5c374488eed8e6e3c3f1196715984bd687c8253fbfdeb07cd261fda2475f6f2813d7fcaec55a18c3b6c959b351d88485d151debb9bdae71fc9698509a1e8bd1456461b348b41a45c1591fbe5179c87ab955c4fa42233dc84560c64bf2674c91442bc6c5d2ddb87c42173641646125bc163b2e9286f624d598bf87ef4b7613e998ac90ae7e86b73155226be3f86e15fad93036d267ccd3fa911088074ad62034a0ba07b55a3a97506b5258e8a413de35d7e362d342b9a3993e7e32375cd58db8cac7d7d6931fab298793cbdc6eec595e2dc24065d852c60a1fea03c9d84cffd1e37bdee72482ca59b6b9a67ba03bcf3fef08ab6f4054b8c08198fc52ea1fd4e65924a3ddc61f6773310a0aee7cb177f71da41af261498a12be464c9279e1c425ffde9e7791540caa7f40c867f8069bd4aab06dad9527cd131e7d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
