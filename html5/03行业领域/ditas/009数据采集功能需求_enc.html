<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1581ecb0eec15456d1dea23df402513b8962de1f4ca0a7d9ac82729babb0e46049c31a0cfa368955e8335a4fe58e6db4be93e3c48dc4082f6b47cd3266d6d7d14401776ea0add6e099b159c6ce30930a2040f2fb57d69629f78b06ff49c6b5967003a3fc87db0de35a890d90fa9784383bbe17a0701dbf1c3a4a84950c0ec203510758b5261abdaa188f6854d3070b46e5e46de3739976d0f644bd570ded64b0deeef6988d2b58dffe83993d68484def50ff4992e802d57f4f5e323f6bce109b1fef1f3ab1a03822be7492c612f941744fcf268553368abaa016874cb98cba5db80f95cb7591f6309f7001b362f363fcc9d7f62666492a5db5e76865fcc7ba5586724fa3439e903166157a3df62c5fa2b2e40c7567b5362d3caa4a91c7d693a0e5e916f8634237114e7b15aa40e1194e0cb203f5fea793b89f1b2cff1685c060b198f2c6ae782fa8f1fd6f562e9312e6af4a1d1ad70a817f459c8ee20f49e840aaad4d6feddabea2cd621a219cd065656813ccf84ceb9addcc012ac76e9df7383f39d9816a6f492035f844a1b4c4ef2f47eef7f9f9173deb8d971a9e9da4f035408fc50b51b8da7480f8aba3d9304ad2eef75144c36b6a2536b55c3f59e354b617a7fbc2ead20e5b983826c6f3daeeb638c94738db15834e2103e54023ab28750f5447d931c0150037fd94f745e55c027b60b117f3cd05433b9fc9b17fb420e68af54a0d50246cd9e588d9dbdb683e0f2b003d0e867b4ff9b5f22193f1cee7ec2995f2d4c29240504a2277aef4b789437d2c2d9a16e9f5611b0ec123b301e60001e1f988d01ec1c5809c0ef986364781c4e33f6f94bc86d53aeb9fc701dc03a8e1be78bf9102fd21633aaf639b83918cc20dc3b8b22d045a1306b53cb96468f796c7b74efd468aaf75d367fcc86f1f3d01966741ff768b70cef4d9a5e9eae47e7f2839fa347ad7387a4fc24d1d1a77837c6816d645c48237f4acb32227228ea5829af82de129d2090ad5459d58ec09f533b4b2d20c28d2caf3c95941c5f232c5390fae4740f4711ace510f9da414e8d04391600f02d033de887c6fbdde1f289d7be0e288d49abf260a4b73564a40a23557c2f633698e1f7b20323a5913764b6b17756a432a9ebf0f62a1f03ebc5796760817f395557a9b2e801b5a417dd9cdbaa85436f0425ec42c7a6b09c7daa9214edb637943d00e02060c1495b27728350dddd3195424db67ae3a904cab6e0e162d10cb1d9864164be1f1f5614037cc1cf4cf12131b307ae5c2fa7faeb04479ea4b2e079dfe6f423d2855e0e5c5ab70901c961d10bae4b4540f1c4de47b6dff7bc241195d785a59ac41f36503bff20f38787def63b3d02a1100532d49627212564004ed564b5de0b125eec817244ae17cf22d0c413a88b778befe217a0205f58d4caf61588b66f5b775d30d586b4a1cf8ec5f333d674a996d81969620932a4c16dd3d6b5a56153e92c7afa1ffa89a02bbc23cfce5244515e3ae572148d079f0ba888ff505814fa50dd21b410defc54608954ee751e0ec7935111a513d6d57f76b10f5b8911f5764149cc972842b820f8cfcc2bb02c14e7aacf73225a7b6ce3145149a602084dcff5b35ec29159b41fd8a1ea7a974277c72446d761f7cb81b3514f21c2d8052e382d0bc084834565088290739f990e699c8005cccde0b7ddf20f40efe4ffdbfec1512e0dfbbbe943f7201ecef680f11991eb03ba94824cb15b79cff22b6b5dbf9c59ccc5435c48beff2fe598f6bbaab7e4c703baa3e4c66499c84de6e6a4eb65ffb0b7233a591cb4d64283ccdcde88c88ddde634a733966fde007756f74343d6d9ce677858f01b10641de021e20c79794644ba9afffa24c3904b742cebf0757c907cc344a07a8c1bdeaae06a088153832dba205255ae26963ce5764e755b2c9bc466a5bbc3782aef1741a0399e7a793db82780f999940a63385007a5830bd952b470a81d25d766358ba31be669ecf4e385c7bfd47e11146e246d722424ab79a09087154da7ec7b7191063d7fd53ed2bf7fb9fad084ece75798abebbd9c3ecbe1f690e9e4c4b6014d24e816f8bfe230ed8b06d87db3a17926057c7d1b0bd624568d38ef698f544ec5c1ea265a4517945e43d0e1d8e4f732abf969fd272e5fa759496dd3828f701b3cdb37cea4bc522cc1bd38b6b1f39303d4613549988fa9500a6e53533c7b79e678d507b159c46d1b4a9e0a41f87ba2acf19c4eed52a47ffc4e9199af61d47202ecf0eed7767ad995c2d9f355fc66882867b86d63a02740d02cfe561b194c8c400404dd758ad25790bdb4bfc4257b196dbe4d6f667efa63cf0265fdf49abbb8ae13feec5d892c7c6da1335e44eebfbc25ead9702c74f8f4902a0bd2818291212aff486be6b728477d42bb2e329792c2b47e1f4ae5908e3c62f308d979964cb87acf78c3dec87cc01056fefa1cc59f1334cf79926592697b2655d01a01a31e4ef7e41db959debec69f6eeb783ea5d34c352107cfaeeab5261004fa20a466d96e067189a9c63872ae6b38a0bd1eeceba4cb2f36358a869f55d669b4ca337db776ec78a91e0b0b15a8631ff18fbfe32accbf69626d079ed97a36b2a6a756dbe50049443ebea87338cd27cc5d363b2f07b4c5c537582e2854040f4b39562ef87b2a001ddece7d2a53d4fe19fec12f20872ceedfb113c0fb98fe7792fb81f15132871e05dc67ed4f51a7a084cb10bc5b0a3c2c0aa35ba1e606c53d5883fc0ac3aa25ecac816b233cbafb965edd7bd98c4a6e25db8c69ef945f326ae01af1bd86d3a4b84ecda75476ccef6aee2d8c99c6b28f1baa37ff5feb94afd6a5f259a308ccabe50498fe188351fd1c2ac36ccc6926224ecf2561697af87e56eca09122f2c0c55b78bf310f42d0f0db373cd3036af1d2523e34e6aa8ae581dac4b0aa54387c257bb6f7730f83680879a82d62df672730fb299bd5f3aa9374d74ea94939a70e29f3427f21bf024e7cd530eea6a448746d0050f66035d14f8c15f1270bbdce9984efe8c1a821a5e247e64af155e091ccd7222cc52010852b8a06d06ee12a25b2f7c15a7ca6aee8b9f8246702b925bbc4ee718168f6dc46d971ddea37fd90607dd629cfc13e363adaf121f64f88d358cfa45485695885e884b408ab0e93bd7691bb14e2d7b58647d47911bc470b602c9bb6e0537cef6d4e7fe42230cbe74274f52cba65e4202e67c85eda04f8cc6cc432bd853c25b191ac1202a8e1c58a560fb98631f4b4bd420d1b7132c4b3951fdc24e883634d3169373fc5f5241713c1d834fa0e1aea7130523b1bba49cf032e6ae3baa99ec648f6e953e8bc6d3c9885e56e756d056315f467293202988d0e830f57541fffaa22d71e3ecdc537bbae2deccb892d868eca9b4e5adfc0a2e34b7e92b662d5da2046930825497845df62f38ca2019b243663959d88334080039d20d7bf359bbc2a78a4fd62014a0aae80af32c49cebc99a35e84f82e6f4aac2efd52b60bdc931c3b5cf9d971659f91ae32b3ac264ca9746b718147522e536b3f21034d0af3a6e0b03fa2d860adb402a42464c51ecd572541c55d2ef8ceaf9e105916969e0f8e87a427671fd028eae54fffe889b04d557dd082ef9397af6b04c1cc26f63b7c162faf65276c79d8be2396f9ced1d0a2941da0299b381b46d9a0b3f27f77d56161dc64bb2b0f610431cf263fe74511928411221b33cb92f519b189e05346e6605bde15a474f41d514be9ef0a98436b15229a909416b24ee9c522e265ba55c673675897c76d29aa05473a9d16eb52d1a18d1df8d7bd27c2f389f6047bdab253a1cf7ac8be2bc9f179759825a98a9e84f1839770098da9e193bdd5b02dcaf67a21426f8a4047cf6c9458ac69c51f29173116b58fc0e5b90c6df27ee5ec6eae40254dd2fc3cbf74a9ae7efef40529ec2183088f5ea1876f94ba1eecc63417dd85d8f2904d968a2976d1ea7bc16b87e59b641596fc84d89346481f60c0049df49ed435fcae9092a9ae7ccb324e3a928800c07eeb2f58eede14d5e5a5b9dd5f485b4e2157485d654ada9fab6681e3f6fc0941461148cd1e1ede33f1a83e33cd3e0b7a245853587dea8a464b92a8bfbb11d8dee15b7df635facdc2496bd2509c42b6440b93d9f33a7f2ad2b0171350cdb270fd324b85afcace03ba0d24c47c5acbe68041128d24ce74e795a4991dfe57c9c095797d6f8996a1c535342cd6e35395e4c9f7eb2d297ef0b25468186a145efedbc616cca73f00f9cd308f7e44aeb8f8ff25c3f0ce344aff75f8127091aae4af58734156293f1d6e2d5805a82912ef16fdd959c97e963c80b70ab58b85ee87c8df04dcb6d0cfd16ef0a7377172f25a6ba3bc68d8350ff44505508513009d4437134e273db1be7e11c0d4ae9bdc1c77c74440b920db44e18f18fd72e1f977c36a79769c065c19dae82211fe4fb3c1c6bbc0a6a11593e4bd01d484feee0ccbe8c7884eaf9b458276c24caa944a03fa2539c8213e426d65d44229e255aaf5ccc0e9307569825edbf3e91833d2e16f87c8dcfc6da29298890ed05916cc3ff67008a246deeaffcc75240a803f9628df923973801fb49b887bd54d3044cc77ff425d62862ff2916807e695e4b0fa535a20e779eda853f7eaec93b87aaeb2d02455a71c9c58c4c7f04c3aedc2a0cb191c108ff74aadfaa323981f2b2ecbd280d4051ca5d9cc4d767288eb53af3cc07ef1aa4348a298feb853539200283e577c48ffb32870eb65bd639223477afb22b8c2efa8a5cd6e0503f7575f65486558aec0432807037d4c686b6c6fb0c0e664c07ac2812bbe90755147fa614fb6b5b1d95f46e0637d235df5281ef38a34c980bbc02426b8a61ddd73524ca871340e02e5e9e90949760a15bce5be2eb2efbb1a8f28c86ceb46b597c4318536e54122d298b8ce722d50480fce4fb714018b7e878bb148327eb5e1a8e2636a35e7462d9a3faa69a04ff6efd5f8dcabb14ce6005f73d079ba5694e8c9c44748a5c51f30217629fe66aeaa662cb2cbb4c0fc426505bd79e7d8127cf923e4a1dcb45bdaa0591d8ae4681371632ab55a62fe1d7053f1978ccc34be9d699531d2f4881773028aa642486ed6651385844348963f508ea86bfc3a8784361cdfb6d4a3ac61f8aaa1c9e1a945333df38b8a0302fb524f645852db4a2ad771daf6adc69fb33fa39191ec82139fb9813d3d31dce1137a0dc1b122ab1877d638d11de5ca0f12a28f8b09c148990d18c6247f332ba29d13980337222f6abfdec1e74642a1cb38e284ca01241735ef83ee0c2867d8b11273d80a07b489e30f726b390bff11e146251c79ffe7eb9727dba6cf5ae17ee908dd18f8724cc214ec30bc8d1abf8cc712b3331d0018c3804138a632b7f3cb01ddd1a84c0147491bf483d837ccfefefd016f871db3a242e8153dee1bb72f8ba39ce0b22d77d00a0b1907e6727e4fb67b279f4062059ff23e2e700016a99d2243316b56eef732fa66975b63d28fbae6c2db1afe8994b0055255ffa8c3cf07f055613f92ea255ff23cd7fefa88ccf75094d7867d0919bf5a40adc579f4324cf9b394defde2027656f16508dfabdc6e9e0112899876184956fb63a515cd37599aec18afaa49f793911aebea8400230445f8af7280cc363bb190d1287783b7fd20b4a5cdba26f305dade8787fca4ad2da491e1b7292e251486e691d6afe8cd27e83379dfc95f239a16978010aa21ceb760a76b1738bd4e87028762f2bc13f154cc978394527d9152d382cc879a40fa43f7d9225e3bf990528cb6603aef059d591e9233f8d20d93723f092e59a6d32220c30cf37be2289d23b67b8f722835c22b24b0e2092936430bf4a226f0c2eba741eeea3c117804825c6cbfd4bdcc3bfdf5b2903c9869a520c9acc0ccb8fe78c0cc7b4537bda9489d90e96c70bfec0951dc2cc4a031aaac364e0f368979a2fdbf57d78f2cc2151768b1cba2b9ee8543374a9a45f8f6e1f46fae9a620bc17b67fef2167f95b7ff320544a5dc82f176fbe5c6b8ce8d72f040f5ea3a35a255d244c2a187b5239abc343ee810862d819c86bc9170df904aa6036b4214575d92eaacde365a93e69e750ce9c7c8e770bb28e15a566a29aefc41c64b8c142ae80d8d57372dfc744f66e092ef722a5ee163e87467cd70392a7c7737dbf4a3858eda8bfe2b275689be69bfadaf5701d9a929ed3c3413706f43a7393e581b527e638183be497e0877577b91d4be2e8f35a18c8aba7769a25166c60f01107efe8bdb686d8edb77502d6f9af9b849dc7599befe67ef56df9f84ebf8da09411beb7ccfbfa5dda820f5c53a2203ad4f8629480023d5caeb34600857ded81acf9677610feeff04def5099e4e969dec3bd94552365d04638052622e095279657a9fbef7877a7323d379179bea8c9f279627753bed2b544acee03d2c0f9abfa22f1898c6fc2fe83bede2a331e30c2561c60e36095d82d6bd2203cfd207dd203dbeae98c1be8e0327cd930ad596f79f3e8e20de2625e8fb10c16b01535473ee5ef2ca61a07b5aebe9decda20dbcc1b5d64f7bc5eb54d59cdba74dff828bf2c0bdc897b42c895fbfc1431e6f6e5282fa02286d876b27074bcee82c0d1dab37aa204fd92d6064c169d785a882619e38a90c30d5d51f7e76169d213f9a8e135530c01f1930707e530a07ef33767e012520064434bee7dbcfb607e1da18ae017292d22afa7affb6d0a97cd7d8032dfd130b780483330fb5d5333fbed961c49b4b9cccb6ebaf06629a57a6e9e7518b940d44eb6a90ab158947e9bb6fa40c6d2b7da0313720a8aa457a63813a477aec5f242540e37ca2542664bc5d1a41ad4a25b07fd2ee92b0c34f882bbe95cc54bf7725cd27c25fa9aa21c04e83494dd1f527a7e5c7fb9cdb8da1fe4c35eef316695c411dce107792dd7970407e8dd8f2355152d8148fbfeb5889b039b8a068073d316d4f7f17ad8761c5649b72c14f254c9f4cb8f82034c6dece6f1a6215af0bbb64cf0711e4895522d57fd2d5ec9e9917a6c3791848b476dae8785915b1a53285fc2a59667b75de1932d848a2791b6d75be48fcafae972729c686065ba70fe674ca645fb6763b6157da45667b6a1cb306b8381126442a55bc7ec8ac3c271d49e74e2a8c4ad5ce594f675a9eb835a2cb5132ede49e9ea9a450d0f01a1721a186691d2f587038b81b52c9b2744cedeb3d712beff0decb041560148985ef84a50899266c16ea61602116d485c98526500a1c9eb7796ccb20dcf022c8ddccc9d98b75104941e68adc3c78da7d0f143e38f91a84711c88196b7f3f63cdab0fd3100bffa22783d66da15ba0ec661c5b8b508202bb501a18b1ed8ee86f93fbdad011bd30d86b043ccb08e4c6e269dfb6a0699885ae73feaf502af5dab083988765e114710fd842d34d929901e3ba3d05b1744b1bdc60e59d04bc1a26155a415fd483a161ed8898649cce389927a60cc9d94e270d9c1d9c22983c7829adb9d16a040fa6b70ddfb4dcea5792e0cc8fc56ff06042364ba110acde2c435ed91819129d5b6583b594962cb8c2f39993ab20191d74f55b005d54a694a047f9839df5e0075e688ce4abcb439944a6e6c3093c2b6701d7cd9c577027adf7a48f79909477be46703b9aef761e45496b58eed0d957ec88939e5d2406c211911a4958cca8d1bb69f37e4474efe5fbd78240e7fcbdc8a8080b60340cf63f1c8131e0cc4f3b1cbdbc68f23f08b3568116cf9d31a353e4453daf344b197641b29ee4e71045607df491e45bfa97451c0772c71d96a45bb6924f4a40992114ce99e036a9d88b298e42fd2cc3212aa82db9a08077d084711a559aa67016ec413eac388b6efd285a8b7ec5f422b0555b2a717c0830215c603ecf4aca39fe2c66b426d6b5215bc66b150b6bd79c6d90004bf16699850a9fc717f56072fd6807ef44f75908f36a25c663b7d6c53abfdb8846f1bb17662c1a68c355644f549ec0313b99afeaf06d16b67fcded0f382e15eaae25c4f78e4f6f549030e77eebac135bcaaf03507dcf486e47f48920f130f8ba29c25869d26b2b68efd132f75a781011250cac562471919cbefd5aaf66b04a583c288ed1af909dea61723793f5284ab4934fb737dff18adf1eade8bc2c9961b1fa712c12e987eb5cae02d14a2d978805a5606d7a3b17d89653c8ca54d164b5491808cd31b890686191fc746559cbd1ad78de55a630ca66068e5ccd386c9a646a0e4fd83032f5c1d9121e16685feb08a95e10560a936ab47504fb504a123a4ada1be6c47c29d4b330b9f7824f4b7e38ccd6ac3c1865a6e87518898366d9c1cafb3fbb63486acb76bd8155dae90f933eda4595179740b14bf3cbc600549ca28a276049d7fd74cc12dd9da8e594c371726c21a052de250e16e2668fb304559642a8dd08a56bb88723ff15344921cfd0415c3032c338df4b00805920e412bf450e7938a8d64ec35d12eac08ae6ea7981224136e0e3f6c0267e8566249d6f7948f950fb3da5266f6e9f80440dfdfdc78f18b7321e52a3230c2aa4979188bf8cf345f0ccf2e8e37b611657edfa23441e5d8b585f233f0946669efef4b710e7537b9d96729d34e51ca41d4a5d7ea379feb0880c6f94ce166b395472fedcfb25171034813648902ec6065db13c8889fe0c28dcc384062210d4392026c5d9c5b827e9228300b0aa99d6358df879767c5abd53ccca08a568fe8697bbf46d6e3d25521bf1125b38fd107b0354ab5c18a7bce3a962feb2ea88ba021406d1f0e04487c8eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
