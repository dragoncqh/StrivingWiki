<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d32056f4768b35c601ad3eb4d6a71f7b180330ec39424a00118fef3dd62f8b6c741c93b6b1c7267c5e0a715dd421ae408ab036878eff699ee250bd8237d0ff09ce8c59e32708e643b92d8f12d7774cbe8abe5db4e1430f96124984cc7dbddfc1498ac7ff5a9486bdb4d2910a026a7b780e09b1e5e9eab40738989ab23126f7bd8b86232e1efab542663cd35e7b2310bb766fab543bd48dea717feb9d4c2c76b5bb72a070b1574ebb050673fc8c08877ebe990fa38c6bce627eb0a56ea0254258388c05faaaa6b782b07e88c3efbe8032b4dfacd9a20febaee27ae7a9cdfbd50c284119cd8e65ee2b076f3bb64bf43bd1353f3a07362f2e7f14817f1f086ecc3939f398d51ec4de81f523c69ceec69a77c77ceedc13d70448bef56cedd9186b190720cad53dab6855a5261ae9a9f8f0c8813a24c6a2489569399c30bff426853a0dab2721ceb800622954c9d67a2bcb58b5930592fd3a3cb450bda01cc8b5075a3b114b5eff920f0ef68c1211efa0ca1ee0453b879c5dd2c237c8485931c641e56fb0b47943a06625301bea384ba1191de61ad49476cf82310302f8b7aa01b81b55c2fc82847c320aa5a61d6023b1e4ba9f4cd8c2730b64b543134fad70055e659c179b015033a728616ef472c7a2796b708384eaec4c27af47ad9f66d235a7b40ec921040e0c2e27614bfea74476e21ba722da532eb511d299748e74a8d24240974e9da91532d489106fb61cd4c7b8cf024dca08e0489e56c026daab14d90d4457432f49ec0235c0a4f71980ba5387b6a73e128853e56c5547240e7c08d0e79db5246b96d6ce3cf2d33bfd67551191ee732cd999a0f0db98a17cedacaed5a91a708168e3914d177e587a8c32977d48cb77165588a6141324d12be89c398390fc0e7751211d42095aea5fddf64dcbea109a3734539507192727667b7a1ca37dadae2938a382d3b12604567ade645eafcfd87a5fbc959a481323fac3c050a6b135195022beed01b8b6e55e40c6c7fb805a811d772ccd1aac6a16e46f0db131bae3d610fb63a7ae2ff7fd00a5c69c6e38eae7c299864e185552cccbc16ffcdb85ab64758518dd84662ae7d25b68aae528a1b671fc1cdfffa3766424b605ed2a65d0f0aee83316240deef8fe51f5fb54e02c94f171169ee95674b6dfdf57ad239f7f6cccc07fbe87fb0724e27b5ad03727c194bde68b09fbbf3f34065c09904696f020b140a88689b46a108ab8ca50c979ee5332d7b91090ea21edfdc713a236b1cf6401d7062faef91f64a28cd8e9cc5bb87158936758e0cf21dc7c01b759e194951bdbf588d8c931d87ebf71a19f8071296ece9f885138eda537f3f8a0b2413459175f6c34dc7259727063f9e84d6fc9bc94c89001f1d2e7e6435053f68ef033e51dc869c56cf7e1bb59cdd7b50c5b911331f71dca878426b89cecceb333d9289c4824e114165043c114e628917960daf6a7f1c022dd85a634ee8276ef25a2cdf794d924a7087e13322aa9d57253caf1e79eb08c96450cda7fea3802fc32fdae0d807ef32c1d264ef09dd4c983e11ff5fa541a897c1c513914b1ea1ec76542bf800633ed8aee75ea45d45af24a576b5dd4f156dd43717516781eea0489bd11d64a5c9c012b76835f10550662b2d659ff1762c3ec1347b7a4e1cff18bf09a10f8b5965b183102d592128fae51c9bc8c9086b1f3cdb59d785508af2d836461672c0cc0211b5fb5791a1fc4bdeb3db75567193feddeb5521857b35964014220c3b46440319d8dd88277bc61d89e1a7c7e8e707005ba086ed72a0f125928c3b25e9a7c7aea06ff4f6b9d28aea02bcb1d125df242c995c04e9fefd9aa577aa584e6bc29ec2fe41d64b32108eaf25e9993f668df90c213f944b3b0c6e0093882a65f57a30edc79d4307523adfce10cb1c4ab00f539cad4beba78957934f7e272037d8fd13dd8377879f2baba405dc81f73335792e468fe35d730a5bad94e9dae0b225151b76f9449dc71551c5819425230d928eaa93be8f0d5e920c9d28458afaf7d0d54efad773e104e6bfabe5010135756ff4553afd4b599cf362c71f8e742d9c1ae178e27551e1f48d22b1d14fc8bd837a3bb82c2f91ed8d50d7b949ff203c6ac785215cae467dd43cc3f364adf85ac2de27790397c7cec7a8820ea55e6b057c8c75c6f7bd4c0f2ea1a3857a994bb72febb9285f2317417f8633c0bf1a8c6035fff312bf7a9b92ad32cf5345c4ae4fbd6c115d6b0433198f9abbf0a71021b0fd6b4bf0bdab0cb19cbb08d11e16eae3ddac5a0ea9562ffafa1a44bf63cec962702c3d462564039ec7712e8d96b1059e5f753d7f433af9618244bc75c8875c874d3bff9b543ecd57754b2266d0dad5ac18159235c0b7a1a553c2c05f1226aac07b7adb121ad50e12cfdb72665fb913ae3171224bca8a941e24104a1c9c1d70579466a27a10347c356a20acf7faa0c64616fd6656b6ce39119be4723362baa760202612ae8f8a0751b74f0bc4dd3d170771f45523e124dce3ec1b03b29e35f9beed4b0c1cca06a5784bcd7631c244bf3829e951ed158a40953a30f734b499cde6854bb484973ed7fdf406146c0167441f3295c994b823993d259b21b91eaab570356893f2679f16b9f3ccc99bd2a25fe003b3fccb0586fc8f434477aca95aeb8e615c3aa6b0acb9176f36f87bc7534ce227a6f7ffe74b06557d0612fbdd6e114d8ad8b1d0d84659a16f8a098594bf0af0487535c2b4267e471618b83e7ebc2f8fcd31212bfffb720b9b563727d6ab5f4ba27629de33d9936d6582930be0fd581f885e07b69182a5b0c513dbbbb43ba1602fdc7452de7392639c16c56b1c585a402b4d9700e2b0ad5790b44d4d710a818485265e9e99e9a2b9cba7736d8bc8aba95468362332c118779b14ec8089b1bd17074a9475ff04b831203b7e764a14b7cb89bbfb9aa1ee9b9e7c83c3e14737d29783b888ea4ef7ce53ae4c87fc631abd181dcb6e64fb0cf14c40cf5096961cdf2a67ca9b35ad09401f6c0dd65b1ffd2795f374b33aa76a7a8c17c15d1cebb667c20a816ae8ee187bcf3bc3160d9f22b8c48b81be3293a5b862c4365f15f976cd3bcb31472cee1653395942d60ce95fbbf98e8d111f7b16d2b896f4593ebc3a9de32148da01244894157ad9c783ed7199aa63b3569c0938c95a2cacb73d08b68814dfc9ab24c19dfc8f0e95ae6deb123b0098cc0c9e74304144a3fce9cce44eb0a1c1de77f65dd2ba5fcde030cb325594c92405f39388c500cca801df3d6ba46bb976317d49e9ff78fb460541baade07d6bcc17769395d4d33e16fbb2d35b69ac938bee9490f949b0ed102a9ab8a352d90accc32b132ff609289fd9b4375660e32969cddc00f3719ac3243690203d9eba2cad6fd0c07e5bff0533ee30a0a41696782e83d01f762907d71fc6fa2ebafac712165179f4b18476bb408747b6207b9fe9d627887819374828b88ae2ad5bc5a706965c3755ebc205964792d2569c80f03b3dc2215a57c280beb880ab18d9086dd0be0c874a5a1c26fcf65975097725ef2e9fe847320e8a5d8ad9bcc9cbac7b64c7cbd987be3e7d2d177384921d2abbec6f6939311a63462f93a1ecea4cb7ab0e50d1165f2e9cbea1eb8bd1e63226c5cc71b5913bde5fa46b0ff0b0a5ea3c5e9b4966a187930e6b6eebf623954f33315556023e495e52e7e3df070fab2c060accc0fd798bbc9c28b75a2c82fe6de2dd9f5c1c3c60ba99deb568a1e495316d2d89da91285a6b34a1744ca717648ed94ea6345f97d73ef348a34a0a1ba5abc9c49026c5d258cd1f793f5027519fb5c95bbe744c071a21c860811f4032b77d05815cc2c4aa5152e9deb017cf1ce0ebcf63bf9735efe86e23347f4854b612c3a2a382ab6a9fbdd5ba484ed46275020381708afddca4492357cced549090c2f42e360da150c4766b403a4ae6db5e90ab3543b5114048d09f35cf666bb023a0fbf6de198e93115733eb8aca132c10b486151733f47054ba05eb2bfa4f3bcb59df6606a335f98c0609e6908ed5ad386636cf0683c291384f2259a7f641c95fb591238853e2cbbe380854ba6e5394f3026af6d27acb486e778dfedb5fe9a48cdd637511715be2a5603ad857cf257b18e091e12db718f7271e64b02f37f6c799c3b7625da8a8d21081a2efc7b2411d4800c72f52af41a952bc116d648fb5615a9ef94dea4cb48ea7f7cddbbe48bf6710ffddcc0b47df87197d1254079ea0f54f11015b1b79d326b178131ac362baeaa4f72b023bc6b31a032a7d1409b8660f18715c1799bef8e76c62ec44fb2489b7def02dfe0d8a54dc8bd363d576ff7d18c32c90d64c9fd608fd9ad2fc6b6ca9a87a245a152152625467fe6654d2cd1b3ddea9ffa197f2a334aea8d4840e9b990332ed2bc03f2efb7223c0f032841dc518fbea0d7c536c5e52e215e6a5207c848c34aa4603595cfa9b94d5dc180331209b90865f85e42496a682e576e3a8212d386de52075c3283d1c91f67e367db1378048cdcabf2a2f966215e9ee28c4b23937abcf9071c9f4804b8bd0a98d91d4e3a795e9bbf68acc91567458512b6b7c8a61e8c41d0012546e14c7fea0143eb751bcb6af0d5ee433904d1196537ca8f9ef8351a732f72a318c8258302d4bdbf514fbc230f1464f3dc5954643d3ef9c7ef098742764d8667b39f47ae41120b6cb59208e58b7de5730bed106c87b81553e80a9b2d01cccc81599cda8a453b7b876dcb733c7b2f6a2810f286aa257211056fb3c95909e9f0b908027a6ce3d76775b61b3ba574d9ed711ea0ca94f841828e6b6d682c3b74bfdd62271191987e4208904e0240476040761b9a5dbaf43168ad1133d24166a35ad6aa38941acca21714f5214863db457e0197cf34c7b0f046bd47054d2c4899eb9db9f2765167015e8d68f938a790ea5142f569d051fd946351947693ee989d23d61a632e60f4f818489acb533eee971367a93e62d34bf2ef62f22f93b25379194223238c097c1313e6cea8d9f1b1333e3a5276dd9fb3c88176659e64bc0f9a498cbf563e76602be32cbfa969dbc9fbd726cded693b47b20a83109358b75991ab6fb3f7806b62eb4868ee3b7f87b640bb16ed4efb673d3f7745a877a7b4b8b51a196fbad03e782f7de11df330773c187aaaf1635d15f7a0920020e286b806b1a23c2d6fc6b463c9466d65f35222a5a263e47a60ec3e43093773f448d7118cf1248b3a61abb6f0de58205c17a5509e73faa6a7fe76241107dbce75cd89d59ac725c8a7ef498fb3b77bd5e00eca499b09492692dcd78d99004e4642244068c207db4502e5f8b698014581564382406e168e31b5112abaeb62a7e137eb8aea351c5db8d65ef65474e56c43c9d812e554a98bb54c26ce15e4d2a0d78f74975087de652b09d7d36d569a43ed37149f875eeb61f21582f07879efbdcd606d41200217595f137e4aea5169a9c530c50dcbfb1c87e32da5b61cf0ada890133a42dbbad4bd180c94ab133f8fc9e75a46d333b095cc438b9a9e6131fdb3114922930893bd66abe788ea87ad43222a558b1c86f59e18bfec2174e5acc25e54deb3410b7349409016cea13d6264f9e0a3ca41c8a50ea607023797e822bf3671d5385d88388954e44b2ac88f5581760d2971e88dd8750b4e4888bb38a4bde9938713948946f46a6d9334557c4d122e786c404215c78b6928718263aac022c1b26ba39698c5304158f3cda394d5c395f6af7c6a84a435f6f5a07f3a07341492621ea5b63e577aba22b373640e90af8212c79560bd8c4f334922d6ff8a675cab0c6652a6f1d06bbec17a6d9c081b3884081d43301b34d9da0a03e37dd6341b592a5bbd29f291659ffe962ab4252424d5eea63b010fd78fd5869088766ea7e9d31b0a658fce22793e62f4d41c3193200f70cd6a89b9702c04d3729f41523492b83ce38cf103b15d199db2ddcda78fc8d95091f25749c5f6762f0874bad3c061605629042b7a01d2e43abede5e68a8d243d1a578784a6ecc5bd2548bb7298cc9f781b1b13c304250633567e436f665940be8ee97a70b4f4d55e631c33f032769220f5d224ce0623c4ed54c7ed0bd1caf6394fe612f8a45664f0382c1413c9bef3e6e1f6ef3a82b51b3fbcc932a0be2bd431b602fcc7abc0e3d9d1c1eee84cbe21a3c4cfbe040b0ab89a134dd140e77662944b7788591f17bebd678c7017b62f2dedcb91148b64b916019e4affab50d6535cea0104edbf495996b6a9161fe74fca001f36d599a47c5a9a514c1ba7107bd9b6c1e5d76a7927c99baca52b4fa6addbf8b9d399f69ceb2d4ebe1157fa9b6df52c16a02532de01143d5a2b894037cc218d87561a80516cd4d95251fb748263aeb33442019aced712bf4292f28ee3dc7e23cd7c2ba55699c4379262773c2d55e0b2f1b698e8f7c1162e5e8646a7e38d8d763edf7a85fc7a092ef2cbec9680a6468f0524b660ea8e6f97b1d316552475f5f037f3744714fa9063919f2f39c704a3d19de9ef6a28c5a39165a0a1e2db6af411366362f54b30277ccf824c8adc856280e1871255a2d1aae49f22d2d9ce0228de6a39f9678dd871d6ca8688f28e589182365f870973e795d82e1bcd92cd56d9626a6052071c3771b398c0bbde5c0eee7c2a9d502f066236eb3841d875efa5469a1754553b774c4e545d8807276c177eb70d879c749e7680cb72a33d3dc54b8bb7ee9653758c2eb2788b528844e0efc50f80b0afebcd72cafafe61f93764270cb2e26a55965cb15edbc9fbc892ea2e8b21406c20c14140541a7aef1dfdbf7d97080586ec3f65a98565a0331b489c82d65399c8bd907f1b95b89733543f012a318c37e545308d93837dd20d6f7e798e24194baa541133f278b1f9143bdd6ddaab8a9752bdb8b8fee4bb8844148665f78bf68c7eddbfb0996fd97fdb2f6ddb98b7cb29735b5bd797176577e5d90863be81964950b876fd3fed8b6470cbcf6c697c648605bcaa60a8b94570aa432ac251e0ce9334caa995f925b19b472c18d33ec8d5c4c5be6a14724f69ef5fd2b1a95a99084bc3cca2debbeef93ae896e00bc5ca42a4b2a8c6c6d003c69a52e581ef4a610de62cb140d591c8b55350f1c6779026790e7c18b37ae4dbee11854491d58bd6dee8ca83a2bb48b77ef852f0cf92fa4cc29e120af3493063a71649cc8406dd4f1e917d7ff4d6342d96f52adb5440c2a39c8ea1ed5fe2c099751f3e94c722c4569c003a2ad5e9e82c7e5064b6e7860b7d90d5833e073bacaac7876c782c51820575ddbfdac9ab47c343bfbe5065d6d5e490305ec737ee9d1b95323ebdfb1f5b0bf67df92b2dd8151c7fe4518d5bcdae1dab469efc60f502c882d7552204323ae1814b643a05ad0ceab1c1926c65a9b48d10e16d264847ffe6acaa6eca6be0742c06fce2b99a341f36dc8ec563c3c7b89255de7d84e106a2839cdbff7645aff0d4d0b9a673e63b444c307c1fd43d10abe79deb123b278eb4db833d242f282f98651ee2db1fd1f3ef76b8669dda364914b2420b6979021291d6622ab76325eb9b1922cbdac22878c1071aed4f31a1bd2825adfffd47acca13d6242a95e8b9449ebdd198aa35855c62e4510a5ee16864202acfaae8d966206a26118dc4e696e099a7824bbc220417adf572183a3597a67061d33eee3114c95cbfd921787d8f1a56ac388bd878173b748cf2bde75cc0db1e2005d2d9b57728eb4281fb58be8dee444ec7cd23b5c6964d091a505a3a594e35537b7bd9bec1fe80532009e42192b35f7779abc747da74910f2b842812e508eb5eb491cd7561c5ce7f15b17f746704b9bad0510b6fa797ffb76b761fe3cb0c99e2661aa50aa70768b840b15792b72d4eb24f54c696775e9758c3165b3e3c88a4b4960d169fb2c3827354664283382fb13d24b9b2368110cf547094c00808121a114c7fa49d63fe2c99dfd4878ad099848b2aea9d00569ef9c9c6a0e0b73b44073c28940e55139bb007f91df09683d2fa4b5fbf80695985703561040687212a5f04f4ccdb6610ed055983dfc823e3a87a33c1420e214ab1a8efd200cf564e759a6c158810e34e43b0009766112fdaf92d4fcbcb8ac8cdf66836817b9270b9a0ac6671739f898423ac0416c67ce8e9bf3744702ee7af1dafed55badd3505972963373b89953f698bea5a8a775778ee1970e57e1dd00d57289fcf750fc42978d6e24532120ab11bc6ac557e079218af70551d44da03062f942449a1d1585848b8388e76aa5e4ff92089fdf494338dd3b152f3b0e3f91197bcb65406a2c86687ef8c6a826ff07344842fb1b1544d1c7f05794dd3e15f0f740db57a2f288b86502d5957f678b5d6b42647bf6dd36bdaed2dbee31c9356691fc3fc1f8ddd4e7b6f438e312e11a49337d941597ead5f093e8bb8338976c671efa726b47a02f9bff23e32ae8e3bb210b3285a8516c0f25ea64d942235e3a759b295a51d9e325a0b95cae2e3e0e98af98807315795d1aa4548662084f6daa741567534e88107f95ab3fd4957b896f6bfd67b11159f5cfd23509078192528247d2c72870e7cea8afad9e0f20371ccdbef74105c85fb294960887ca5ea8da2ef5bda64447adc531bd84b4b02148c7efddaa0cc9fa559e6d752d66e7306925333e8f05e8e21337abf7841991dea0ad88b9a036dc634d1137817eea2ee719c98a10bee42a2e98acc8571a4504d167d8d506c2afae81e0cfb41a80585963a1b917117ecdbbfe1f778f7ca168002190812b2f49126ee952496210ff4df9e3afc416903a4c29db869bc6f3106aa03e7e2231547919b1b10c90ed101c0a19dbc49e06be7ded77b7cc9627c18dfc4a39570ddd5da8236f2621c8497979bec420965c4cac55ed587d694bff940f4fe33d7fefbf4d6c97f01073c1bc8a9fdb624701eba5db3fa742c326fb35a90953cc0d2c9761bab457a134324d9103626be33a53e729741a5178fd29b75c95a45c723fc1ae80d571741cd4e231861c22d2d22df5ec95ecb6842058276ef6b65e92be895277107156187a27044bbff252507d77052ae18c00fbe3fce681310aa7ea66cff35ff78321c33c1379fbcb72d42c2d2c85fa1e9e653c00f8b0141bbc454ee35f705e7f1d3a58ec3a7a95ca7545c0c82f4160eb3672cbe07388e6eeae7737d19c8747b0c6e1ed9179d76e6e4cc9e2c4a666050e73a166165af6ed86f55c2689341a7cc9060c60487df6017323dc4c63145954139b51814d5e15afafb4a299ebc751ad68ce913d23a361d2dac9d7238c506f758a096b964c972ff1126414a3b6ce69384ae531c580e60be2d6d2791ad124991184121ceea44481c258470e23c7532ceed885a63b51f1ddc3ba5b5958d3eb7fe7157ea6e23ddbd8f1dc90b06902715ea091f3fe86c91a77cbcce669dc92d51b8fa30e6d18af2f6366e31a070463b7d927faa66945811a28b9575e01586c137ddbc175a1e094ad4d12bbd66b1503abd1dd1301fc5c32e93bd2b9ff975754741507eeb6ef1a527a01b7a1bde3ce577c1006b8d39adb5fd15eee36c7a2590ae618254bee5b0f6b528246f769601ce79c7bff51ac4a2788119ad5900a80fb5313c255a571c15b24612927df55ba5f5158815b32d300f0bcab965ed35872d01d06cf3e1c8120781156c03b064aeb81581fd21dfd755b97ae7c4164b74cdefce7b43bc5c57ff8e9e163cbcc97c99b033d9e440243b9dc1bc01b549824270294ea49561628885e16437cb843a276cb35a28c81d3f91049731d5e6298db0c72e5df677d0611c84b9dcb1f1aadc8aa162a60216a25ad793e859d0785150522e20cefeff455107ea7c7bc8689f353e51fcb3dabbb4bfbf518c8a2d24f3e6db177cf6c69d8ca467bc3de77eb8d5f650a06436b80b1cf6a9febec56b0c9bcf81039b9a37945a8e67c4f115ac24c6bd093181f174bc7ba3150d415b4a3ea60c758bd10fa31e2f07e371500cde85409f1b97be9edb1bb5a2fe37e1e585d73fd7721756ee42f133294a4524c92008f1252c050e86be3c277d92640f42990013732f3294449ec724ce95d8009bbb666c47008a384b9adcdf77e6a9964d6067de7697600effc9ae32f26e60b94f921ced73804dbf7188f29b14d1f46cc8e901f4c4bf2e0e40ac82f49b4fb78c8fad69816bd53cb4572c85e38a648d8ae155007c6416909f459a70315e9e6b2d8c710ec1ebb4210f6f368adca9cc9dce261a10e468b3922ca7f9bf8410262092d46c8a76cb7cb8249a92ecf9677c05b2991fe5f21842b56fbbcac2c880afdabed5fdb29521b62676b213b239636758d6c1a1b82770071aa078befe4cc59c0e152a3755797c911fee59385ad7980471ed8dffd9fc05e85a9ff5e9999b2c863b68691dbdc5fa51a56801802e01a93302009e782bce067e12947ef4c5c4052965f8521f5de092408e028d65be995bf57a152b97e9dfc2fa7b2c5b5919b4fa79ff38fd438cf5ef870e4f2ca70e84204c91333126faeaf06afee473a37ee0dee53b949299d710b95afe9999335b1d1e0a0e4100faef640ae9aca74182d03bad308dbb775637ee23924eeb0a1ad5f63c81f425d3213e7150521c85de190c30d3fbedc0a3dc846ba458dde5dc41d9b2e812d826d247a80975054153a00c2e49b5e9d73c16e790ba93f07a65c0158967690439f2f553e724eaea5dff19687091e7cfba8eb646d73cb22245b281b02231b800a01f7c2a6a552259087275c9ab985b2db6e7a34b5487625c6f9843164a7c293f7c486d498f50a4f9e67eb41b527e8cc04e547c1c90cc17bb10a0698629223f85a99342fbb1f1ec3ffe98f35e9da41c4da62e9716bfd9b7e799b41fe5ea842e7009811afb5e17ac7e30485d646c91936272387548707dc9fa1c4d358445a7dce58f37b61530b263295bb7a0d406ae035d27773ebb72f84d2143be7d2ed885e233ad7c62914b52a356e036944d31cf94d1117e7c7d35136feb9aa97c53b2342111efe204e0d83a9819212495729cc629f2aa72e95200c410e5f1c3c4a2de2678fe6f2bc9a2d946b677172fa690399f088eb79087de7961a4ae40eee1057a0661b3b510d0a06c68e06424fe1ff6d4c7e725d5e53609b5f07f277debc85d7b51b567c389306ec8fdfb3680e09cbea2e2c40e14269543b585c6586300fea51057efaa37f0fc5f94a5f5d1b605eb74abb4687b976413c13880255569a3408214d93e86fb26aa031044eac89e6dba93ceb808f30e9993a62a8c83a10d02a0ab9f4a17f944df61399a67e33366510deee5e983cd4b1984811280d7dc51994a688073e752968693ac5ea70a79ea80e3435e7cfd3abbc4473da577af39ce6798deba0e03d1e941aa384cc1f0b260b7c8e40746ba8031680d29186653b35f61c03fb9e2dc28987966852de6ac96761a71b1acfcf7af527e746f3c0bc4a8cf1570adf45b05db4b4e86b709ea29de6b6aa9fbb1725869adcc71d20c33c1819811faf72dec40da0fb0bcf1a895d3dd45c91a3e4eac7c2a23aeafb3d95922de1e5ac28d6b5bfee5178edb0d48798a4aa27e00416e5994e48aaa89ce2eca407ff9ae4ab0c13f1659371561832afb23427bf86698a8b0de35c82a23136413e572687321d88de27369737c54908f82aec75666add856bd998e43632e667017c8ba6c54142fc5a4902681b0cf175d7506e9dd027e0ff7b1f306e644b69171de386e19b21fc3c7649d687ac688de33861ee11c42449a33db722bb4c738e67f40a16c0302646da00105e4f741b99c2b9738cc035af1235d93284ee572cd14e5a776c9c653a629834293f32969f6e500062bd70586cfc4a7eb323b2d12f751a0386046746e4f4e7385f017bf979b114f93bdc66165b616a5c0482c7063b6d6fe5cd4b5a5cfcfceeb21881e50505e0d460a5cac467fa140fba334ce41af192daa5d786bfc673919e081ca7e08a78ecbeec594323f2a975fef03558b62aac4fd4e218cc0f8443de12ec3c9a50cd7a17f955db8c8a8543535bf21c4a874141e18e3c13fc41a7a67223ca856ef55e3a4874adfa6125ae52fa15e5d8c1d7de4726457d153769076b1d9473c407119b9390c52ef8e4242258baa8ec1b6b27a224ec00b83e55bfd55191d474fa54767353b76d5d2e1b0302943ec841061859b31c6fbd9f89dac76705a59c1270b8159b4a66893ccf237988c65ae1b62f49aa1cc7c77ac7b3a5e44410e54efb19b0a1cd58979ee2da9e04e6bfe16afa198846172ca77ec99077324fbb34e5b68d4119265a0d456c2fac7b19bfd6e2c852c396c87093138863a5950fded522d1290a4b4c183b009cee3a9d4ab737fccf0432556ec263d0eed1952075561d21a05c0e1722cafac4061cafade097f04efc3eea9f7a7bc0bd4a99091f5493e23221bf520465c8970900468572dd9088863a34769b3220ef43e7619dcf551b4d5eb26d00cb46ceefcf248b992be9ec4eb8542eb178689f515d659088c6f259754726b643d4d196d722380b096805f9d5dd61b2ee82d41350891e442e1366d8c4702603cd3a82e62ca40438ff498a7fdcbea360d891eb95bb6ce4ee58b8db13f4c993adc6086c3875012be87d92b91461519eed744121521dcc5eb9effd5b396da1393ba3a10623c5339ef6f9a405b480bcb71645d5f6ff1adf72972adcc9c2b10a0246a9e5027896ea876c177d2697424929698fea7f5ba3a197266bdd89057826bd79a08a39af7487444acc73b269c2a2f2c499e6b494551b9138a64a307d087f5e35d933b7061a5d2999b97bac1a288b5ee35474d5bf0c56df1735d3415f2047484229e17a43097287589a655109e42cfccc11a4dd6dd094b6bef0c8091ea0c779aaeaad9f9d61eda732a9bef536c006cfad8df73a5d62648aea1cd0ea19add9d5846580970c5aeb9ca6fe2ca788ee54178f1d83f2ee2ea1c7af3e8981669d97e805a18c14e20a6579cc06ba7c0a644704c260d9b9ee37ae62b5229b9f0abf4e0e0ee5e8a2b22aebba2fdefddf5aa9ebb92cde8d8005190713283e0634d21b78df00588d5433f34291fa8e96a0aebb50b18498b48ddcb5ca0cdd8e660968918c74803f05c41b6530052e9b044b658e739a72a71193ce77f31f0bb7fc6c4fabb1fbc1984aadb3dba721fbed2be0eddb49e4944aaeb185a16151ba68249e1cb3c0c8d59c8734af738e61dcafce5f41eb156531d19fac41d2d0d57af8c0ec876062586dec8335b5d575d901c6851d8f4f968f7a0253a31cd8a2c6ce13a3ecedabaaf66e6aaee1fd17065c626719493fc0c16c26d15c60996c057ec875271a3245420e427747a52d45c2fd1d7a10de5fe4468956fcd5e7d95cd461648cc99930a3fb84563a3618d44fb9ed323abcd6a4fbe2c56fccb2c2baaff7df3ad84d3e855995df6aadc6259292f4bd665cbece9ddcfef7ae6a6a1fe8d8c22495e532a6847af74c166e4b7f25ac018bb8550d835da499467a00f9959eef91c9637f4849129ac07c22b093a14c4136ab6b900b1648a9358b056b03034f469bf5bcebeff4a25d1a4cd3d228cb378ac95ffd1467b79db660237ea7ffa28af739d0d379113a366c50a1d5fd884b5b70585db8c947b079c688e8571f7fd5f03b59c865573029dbaf0e4e01e56d90b324d392cfe1de5dc7cbb5da016e4888098195806ef5ad3008cc0cb1efda51331cb51d6bd2c09b06cdc2d30cc44bc82b88028ec93874f2011a72ba5e33e4cbecbedace286a63c0a7fce30d1dbdc06de2fe4eb30c88ba08085a8f03d4754246a8da3197b089ffef45369bb08d649f5cb5bf008082325a05a82b6e612593bfc5742aa510e391f310ec67a3832aebf0bb6b9c769d3b080d5c858958f496eae62849c64577bd2757a66f132034845befe6aea741e8799dbf44ba93674cc54a9e11d7eabea251c34c011f348e8f2b64adf0cd0e9f638263f299d286e794e1b0a9d56a5d371875d64341b4f8ba692cba4d124b11802e143d1dbda49e6ff73c7f56715b939ac3ed13d8c81e4907ac027f2f430c73ce1ed9fedfd5dccb218f3904de089496da790ec737bf3814e4a816d57b09d2084233282e04d899f414a508c5b7f62cb86a1ad6eca090d2b259ad621d2c02bec52af7dfbf528917147b3f776326a724cb0d3e7fc995016c8bad6ef6b0f7a15ca1865e320939ea505f904996b8853baf052f24e2cc7b011535311a6b185c5b0811debdb4edd9bb410fe2a282a1fc5a7e463f750968eb3f838356d457d2a94c22418a61cf8b87242830c8a18989d336b47db294cc2db8dda4c34f3d07f5366ee4440ab2cf214b4c8a8f7044907aa07033b94a9d80814b35768e5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
