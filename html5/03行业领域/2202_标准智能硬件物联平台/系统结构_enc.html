<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2384015b0b868f57a2343e2982347933e7fd8662b5c8c660178ed28aae20d5dad8e968a03ad3d0ed866f6bcc939cb20135b57a4adbf3363cde21b583f3f7884f96bd32cd7dc373b1d0488a62ca76cd562aace9729c6163085e9efad8131691ce6555a392a242ff7251a066e65afe22b7297d51ccf8a2e8bdd5333a83aece3e0ec58c93c093d7951da48382c2312e46ddb7855b266b5aad078cdd5f01e8e8a6b1d8268d80a6479f268d101c0e8ffeb4149bca24cf31e5c9aded0e057deaad9785bab009290f124ab420e07403d87075b6960978986685433fba28e5d2a90ac3b5430d26e4f1dfd143fae8c2e4b54bd141a31344a46cc3af8e381db115b1ea64a79150c2f2256c5fc2fe201a9157fc39f2f1a8465a8683fa929c1316ac3e15d6ba819390ea8fc724d14e1221d7c5b19b4e8ba0b96e1bd1ec385c6f28ac82328ccb3b4643cb449350a3e515478d24ede495334eb2ca1cb50e4bba2230cac4a31ff44af8765b389bd89766dae2df3ee2ed2b35cf1579bc0766c7bb6b1e1f24b23e3cc25fda92697db041ebaa13ff4e1685c7d907de0d5e31188cdb6a76f48e0e3b0fa09962b998cbb081d7df83288f28cb966026e91b9199263c671d17610a3930da14da9c5043ae95db1ba70e1f16c2ab3029cabed4fccb91f4a3347b6fc14e9534d686c38382bc73a716d563a61fe60325233efbd1dfaa6f7a4d8d5d8333099e5c88774fcd5c5bf9866ed14fa5af701d573de8b97469b031d1821890e99f2f9dc35f40fda3862d4cb3c75d8ea14f014301003616b3d30ce9a0829e4abc5950e29f4fad951e0b0808fa3cdf59c054a51d2222a6970dd45d4a9a06ed04e4ce215705d915124801940a1b81ce3e53b268b82800ff826321ebc29584b895e3df1a9a80a10d08ec3c8ad74a7e7084f5207deab6174e9c935673d605cea7055f503a2fdbb1d94bcc2362c9a9042c781c1f19315ebac55cbe04a11317e237907a30caf9003cb563eb94ca0bcad70eb8f6462c373713d3167d59df2fcbceeab5962de75fefa09506c4f9bffa594408b57d555c5a0b3df4d390edb7c6382e56ced59d36f737cdeadba99023526096d821c0ef93efe3b81b68e3a40758db5e6baca0f578cb84fb267f4460cf7b84f44cd6d1432d70e1bc37314b4ae50b5938ba697cd164d44fa897746c0de58f24bdcf45ec52797aba12bb9438870ebdd5dba5768262ecccdbdc55514611ca7e0040a18f6f03ff919a9fd703295620dd1459ed3803e0f17fd718fa559e61d40852fd998b9258f310b64c48d686278b6861fc0f2568e8f2958e791b003ffdc1731d78faa9506ec40d068196f15d17a9fb9140747b52c2c75e4ca9201145b5cf64d907aa5ff9740b98cfd346924552251c3c814851fbb0333a0b86f63766838a233cff9477aa2ee5ac277ad580deea4f78f4f3255b824bf7d0af382ed4240e1d67b5056dd6dec4d41eefae4cfdb64271078601fdb5719e98b80f86cd1b3c04930274517d39175f959136f263995fbee4c8689a991ac63f1dc0c2c7c686dd93c7f2cee25cc4810d46ca14bfae8676510e22433d0f8ee8a5d3042b30354364d11185bfe0cf20c49ff30ccd9446ea50972266dee7bb1987bb574e20063a246206477c2aa12dcab99f7b352bc60322ecc95d75b187c1153891ef7b2298a94ca4fa4f935f88576a9ae99e311cc5139e887f31df096acc2830d6f5a2ed8130e56245c22157b61b96aaaab7ecd915dfa821f7c17443ddd0d12eb6b2ebc489b1dcb515939c7132de0ff56ea39a5af55e347a112ecc637a8c9fbf1a5640e162fcaaf3dcdf8e2103707be6db3d3159f74181d9a973c9e685caa23c66784635a96c99527ab7dde0887614b0f5acabf61bebdfc376624dbad86114b9261a5218e97c3d2e92256cff78a557dbec4d32bb69f33b353b1315c1bdab0e8984cc2a6f7456915a711aedbd81f75dd0bff3db40782953d28eb54bbf6105e605078372446698eb8ed1cf083eb541d2f64d435e33d1a50848d56bde104015af353e2be49179af64247e24e2ac2d9096d552c6b3d481e2987900751708bf4e8e2295c8af5e205b024cd5de41002f506ac2464f162e0e5c55b79d03b2a5d43047bab93962b1183c79b16618f1ebaca7c97aedde753bc6082f29e1b8a3a3662f6243fc4d74dd9e2ae3bee276fc025a8e601ecc524725fbb114b56b240801943e786a829e93cce491347f7c691c7fcb26a9bedb30d4394cfd3b819aed1919be66c49e01bc3717191b8f0ca0422a06175e45a639101e3509bdbef9b9845c6f11e91b50abc06a79891b0025b5dcc60a667dabbe6f2b9e61c4865fa2bcbaab410be2b430442f9e6876e937c6108c090144051442dfc431e9579eee5f7cfd542b6fd2b2ac9a87c2b957802878dbe0412e365994835c5fb292e695b8e40846be15e7fb9a09501333b4f7d9325086a2701d43a28bd7885db7c8bf687ea755fef217a40029d9a0216e90d54265aad9881605e894a5bc8c3894f6fa6da857ab18859933a39ca05c0b7f69bd2d6baba2ae8e91f331edb09613ab84900d6c9527ca426fe8aa7b1a4f5e21e076f18352530e0262fe505588e876e82808bd6ae0ffadbc46abbafaaeda104c792c408726ad9a5eb934f6bee45e2f6a0ed97638c0c9434fcc5b9eb3cd51c33d836edc37ec0cca027a34ddfc40463187396d10ec1f307207162cb1b4e66befc7386af8b5c74e8d51ffb087c3c2c1144e3112d318c012ab046253456bde03d4460ae687284f37de39bfc6448063135894f7c0dad66fe798b9089bbf8807d6285124b3b5080b4271922fc51d4497cc37de053e5b8153db2eeabc703728d7f8f6880069676fe8e08f87144bab4c753fa37e889b2058027125d335683dbc4b0b53c597ac0aca63649332c47a1d6671ae744cf239c7dd2025fe3acfb5f649527a8c7c7e07e0c5ebd2c04c465d15bcfcfcc354d58a001f2734642c8fe950179c52485ed7d7cd8fc895a4c1de6c821da383934f8c1606bffa4a2569068af7868550119cc3f2a4e6a6a19926a331841aaadd92d4a027b2813c1f7166be696efe8810f6441d5b40b4e0432ab7a82629d6c2c02be9d3f0cf5f3839370175a56c693a3223488c6a192e109e0c68dc27679bed1b9da31915d4c83b408d791bac305ad44d8a0e378c10aae91a34bf9b9f8c55dacce2d887096ac6f3e9e3e43efe5b72861db93dc697166745f3711c85c1d195d3a2c958840a8b6b8d9c2f1ff22661f81d8b41dfbed00e38738ccfbac6350d366d99b7d3633d26bc00c6910dae6a77f6e4551460cc38606693787897555c75598adba56f3a6e63c18b6a052d3ec626f1df49caa128141869e1561b7e930c91db50dde8cfbc19ac8c9d50e99384e6a9609ac6e7b164ce8c70a8570e1eef21e597db82d9d321f393cfc23b7c50ba94815356dca35e180243beb31bb1cb4f751c3d066c7b1ad68f7f3377ae14a8b33bcba3204e0f3147cc5b5d102a92241b1730a9101629c08f3a8211449467ae20e4bab9564247f88ec637a9a5d96cd48aa33b99e490691f1404e1cb1c49ae8ab26b9bf3b29a8335ab7cb0b2f505b1f767ccd395260d00db3374267f2cd2fdecf38c492c3d9ee4b1214edaaabde8bbf6b9512d1c43899eeb175a68b7085c556ae2d169aed78ca5435b71bceb627e029cd969a7d2af20e4e313640efff1ce92f7588ae96cd2f12ccce8113dd625f11c3d3943e8e09c1ead5eed106bf78b389b74757b843b6354e684d1d17e57a3e9f8b6f7caa94c3b9c331e8931db2ca3df12678d5ad7fc050f6617720aa8903c4c4311a0a83121f2f2945baa167fa612b4fe1b40eb49163aac6d5b62dc90e2eb324743a37a2a566fd3e740b60b24be7eefe1e89a052ad2ec646d9124bf3b90cd6a006a3872bac7dadbab9f08c3e24f3fa7d7c968f5024e1214d6a76ec70f4fa5824255b84350cf4809678c150d77938bae81f3e195097561b1dfa1c0f9df9425cc40701e49a690b83b856f1eeea4d57fff94f5f85b5088a9858dadabb8b8dabdc24710395457ad76e72a67e3ad6fe51949a8ac8f91ff682eebb900021d9e383a927a540069d1be99d1f56f676cfdb7dcf2d8adad196b6f8caef1d18ee54bbdc1c03375e553fd6c0d11c3db1333220b95d291474e9ce0c74937bf9027f007c1168a3a5f14e02ac36e30919d3803a8d0414b004e11365346cdf475799bd71ed7c46e3630205499e4b8b40ad82dcbad9befa2fc8175e200f81275649e91d13444bc2c3980c14e7d6d1a5c89908fd1a119feccfa115b90160dac9ed4c3023c8543cb61ef3e0c27b05ea05e0f2f05731bb7d8324f75e4dc561263ea0e655127e70886145066d79996469e3fd56d89203e1ad6bae807cdc0d58ad80f1d287337f261270b49ee6ea3226ca9fbda689b33a3faea63f549dcba539be783e05399c5d08bc5031656fb330a859ea580e2843c14c60555a59f110bd1e528cd83858b719d78e231f476e3e0acaa6c775482fe039c293f2cf944a4a8790bb42eb9c91255f3a6f2444e038953798a6bc6f79b39f61c7f0a8da0157639199c5e55a5270d6573d55696973823811647168ae1aa394a5d9d3cb336921f8ab272c40c70057effc3ca4776b51f4920984fe14ef78f77ba02b6a289915389d958902214fe297be612a0e503363279fd4a77d2fb801b67a0842ec19611ea29cba20b1c1b4deb46f1cd3983f6e9314423411e4302e1fbeb8d170fa3a0d1286ad5551adbd6c433ff7aa69875e36b2c43e595b7c885af9b250ace6aa2b92a15ce159feae6aa672b57b6f322042d1b1aabba420a3a6515c2fd610f3ec29163713416208acf995313da674fabe180c7e90f081c7c953c1048984112f87eb8945025f6b4a627d7bb46abefebcc2f88faf153898af98888213db63597914699668e1ddc2986c970ccd9399c9b8f3d76ddaadebed4f411fe7d286d31659388cc74ae17b382a8a8d3513d0fd705db5b9c280a2877394acae4bce64ce08e8b5c2d9673965e327d09f99649c248d47f477bb8fc3a83d7ffc6d7ee3144b218e1a33737dd062a429b80a5767f15a0f21ec2f8cfa83e3e8b6c33fd621cea205f6b6dc8853dcd1a124e90a88aeba49a1777dcfd5cc0f7c27db6d5ae698aaa1a2b134a08b2ebdd3d8efeb71f27d7f4b9eb3da3235092b291b9844c497a38c61cf7fbd350a22bc2e08e2faec93a68a03ddd8e8ae6da30bb1233725887fc39353e4349f2eb61e52047d4f15f9c9c2ee58879181a673d8f19dc42ed5504d68841cf8986c37ed663e47e1de47c43e87d296701afd0ccd17977e3f718e049c889edfebe173501f0f1541d506be90518305b2d903ecb5de70a986708921bde406b612280612bed1d0d3ebca85bad72782a08d16edcd0c820adcab26c73cb8e1f44a6ea2819ea380ae176b3959240f417daa3536184318fc081879f3949b1c66449fd9a3e579f76d457b5867707a4bec60a063c9ec3ee3a5926f414f8ff5841b7d8c3c89ebcf249dd1d2e59900d79b84a6c78aab08dc52d18145b9dc43a4fd2feeee893b01b5395973b785a6875bce7eaa515bb46341dac2f6ebef6e53d8042b4074ea53c0670a7f3d865c7ac923da8a15b6240276afecea4b6f737962806adf1b05dbbdf79e7352196f261cd0054bcc6bc5669185df90158b1d263e75ba243d42842fb63488ac0983e7add571623357d5705c115ce4ee893ace0d3089251c90b1ef85b43fce89a49a36e20d61b86a19279a86642dc3844e80ceb6d4ae57fa479eb0469a7323be9b5357684c097067b30319748f3ccb91ad880261671f8bc6c2254ad100bc1b1ae9eca088bc15a91d4ca41851cbda3ef491c4977c4657d7a70e30a2a73b937247e8ad3479976dd520c5d320af8fb1b68190b44ff2c018febea1d388e1ba7639f5fd915d3e2f3af255031867d2172e4387982d347aa6f5aa2eee11a034c4c1ee4d6bc6169fd3dff68c438d287db201b52149d92f1a673daa2e24bd975a5a5edce3e57bae213aefd144306b89712a3a50bcf64c731f77a540696f6ce23e0fae6f9e6c0033fd0d8396b3c3c726a42f72dd0c117a7e8840ab4060a5fd5ccd300cdf96119bb8a3f34738607031088cc136a82bd6be46147bd170b75904dcc7da6190f5ebd1e58d40c18444738174cf45d82feb96e0c99d8f9769ce78ec642ad061efb61405340def3ba435d69f7ce9820ec753c939f5ac9945b12c37532e361e6b3ab340fbf5a99337c014a9fa67cb31b6313e3a35e3728200a6da3b4d00bbd3518c4658032fad65aad70b19e1e36e01e7e4989224395a36b60e2e68381450bb5d58d06a789b66719398c61144f788a501cdd8d96446a470f7ccd131d664f8719287297a8d1d9d1c7c2cd1ac481dc52d27a9ff67fc8463b0fa3e21531b38ba77954ea83a42619a0ebedd5ea403c24339ba84109a9ff90fba19836299156b21202f11cd0a7a00a04520f2de0f3243c6409400e9dfc17786805017af19df4142d7ebfde2590f6628fa86717d49138199432a0883e5add8ca31647519139444a86ad3e99c2f08f84c3f22da7ed52909175fb0904d875b0613c8816a071049e45ea6cedb1ba4751b71b6918859556219d8b673cd3d5a2ac82e9bd4e12eaa0cce90234869ce0e18f0d50de5113d75db004044dafec74ac7f5bdd2136bddff9b9b36c80987c240d66965676310da15fd83fbcbc45fc1cc1ff209f3ce5e9ca76be1b95d0252ee8b7d824870d5eb38e386632917a8971db556b33aca17524acc0855e422ac810a6f57f316a3418aba94bdb5f5d40a9bd1586eaf99b2ebff49ea7d7b97909994913d890ce2c66ed83c973fec9c02b75673c0a5b189b092a52851123b53ca80bed70585cb4beb11214e2e798d24b9b5e460d5f43a72415915b14f7253a77ca667bb23104051ada479f0749871b82d5e1a7e0215899a860dd1c975e8c4b9c0c9121f32bb332bd386ab1e38a648f89856793c04d50a3b1c7107ccd6cc87dc4f65bec14d0bf23f7de05c04472c9ffa53f0d89568d873b773cebb3523303d2f8d1f26f81c1604d66a6b5588375189cea90e6f0533d8af631e336760a1ce2de7ad1491aec3ba2267eeb9a8397e593a8831f1e24b272c342d4d82c0f95a14e7fdd3c76864b83d01d054fb0174ebaad89589bfcf4822f377bf9f36ad388e2f16e1a234f2d314a17beb41b2ce40b5e12edf382c403e269285b627ff6eaa8f1ec81a0cb0120b4a077a057f33f66803929ea647899e94e120d96bdea6dd1470f384aedf7ec536462f7f2fb37afb2b7d89c4b7d49c873fbf128fe3e6db50810d531045ba31480714b8e8182ca46fe97fc67c38ee666a6bcc1fa681198c5ad972889a2aa6c546aa0edd28cfed6c092e99bc9d92e58c1ee31e3b3ba604a4bebdbeac9cbc92e67c57bf0c07ea4cd9a17f277bb7f44213f7f0e1beae1ae54055fd9320a5fc4e3d63d7444ebbc46f8266e574f5bfc888fc874c9db3be9dee339b8afc004cadbcc53d39febcf2439d22b4e1f736c82b7b150beee1cf8d115e97cbb5e82d36f91fa0c57f3d0b27eb1a496fb7078b3c2da54f23c307a3d81b8c9c58421473e203e4db139f938d2583073b11dc009a170b61f39fce21da68bccd0e0c2c64e9e7a6f3891d7d95cfe1b5b3fd204eeee715a7aed408218d6f128735bae6c605c8e06e3886bb32106e418a9a7fb92fcb7ce65dfe091b6d7a6c6f1c2b99089dd9e3f34c2096add7c9f948b0f80dae2498b0d6c6f02bc5b951ebe02d35781dddc4a1de9ad1d3e3f50a850de16dad67da4b91c3aac919962cf06325b30e4b6993665243b0bd5dac01a3106329f07c01b1dd52f5afaecf67ca003c3a2a524cc35d6fff03d2745f3e79bb9bbd733ec9f45d3784e770402da7b35d5b6302c9cc6e23d782084ff8737141b5c1761b37ef4cd5746c18e724b2e08907d080e1a0edb0e9a659d14ecd772ad3ebce56b3a11149175310620a72dab3c837c473258e2ec689f8f682b74483f956d3ed2d630df3b96a0c34001601527dad3b30b8eb675e3f2081401b12e3cd1512013f8847f98a791d03361784e153159c87fe94da0e3355890fe3df0325600c85845c6ce805c44b34399025863e1efae371d6a05a28d601f7a3352fe4628081196fd3ed20eabc3006888d26cabfc14977ff54ecef248ca5e745d58d1faaa9ff79a44c42db23fef117c8fdffe776056bc8b3f3e6f7a5bb7ef5f3b7c8b315e7baf9ce9bd60d30af4ce610383f9e66ba282bbfde1e08fe8598ea3f9d13de6f44fa8a86ae555fb0110da7b83d28f9467ac9138c5c67ae715ce2fc35b89a0722b38771c95a9f0178c3b0ed1c5e5986b04247a5eb512b24307c7b230d1e59edfba1c683bd829320e9b29baf026ae1b30ac0402bdc24045a12f3cd2a76193720226f79b94f5849b950ce455a9437ddedd3791ca9bdf979b2903cf82721ed66b8cb34c405be4f33cf75d87346b6d667c3d1228bc120bf8c66a55c9e189a1ed3a18d7a75dbfb102c1e54ab9e7d470565d26fb265f7ea8ac58a5ad0d810e1fc5b52aec0f478d8b1fba0901910aade0621229740e6e890b7b33a2bd324942f932f024eb7c956333eaf4f5313e01783a2c1a6cf45710c14b4122bf6af5179258689dbb66251b8e07bad088654f263d8d47ce2c32c4ec70d094976198d9fe850460763c645c9d3cbfa9d1f26cde858c53c32c394005c20c4a86117b99644ff130656d6fc9c4377a95aa70810889cca7334585e1f9c23b39fc89daae2bdb5352e57b61d62565e07ebd5fed99417ad40448c3c107697d3768139ac22e534127b2ba8b1998a1203f45861178eb9b0010e41d2d604ee1ab79b6153df8cee149fc4e1a36a018ebdabb00feaa1f7d50d4a46ca55fb4d13af3484889f59df23ac64b1176b909aacf136c3411575a1ef979b1eed3c25ac864578436b84083e00140311c92c5a117ffd5870a2d4293b7ee3b26c883125efba410cd3074517f593766c2514fcd95f6b7e34b0639a6f7f2e30a3707594e7cc17b9a700c1fef4220daf554f70045a2d254a5edea3a8ec32ed581cc2735de190dc834f494f4af92915f64dd50c799244d537ad033f5e9068f86311f3ce6c267775dbf296c798eff1863044a460a854690ad0bd943381c623af99a5c31b8d5ada94bf975ddd946327eed099339ff9b2ceac488a187f01b1d455d253a1e138dbb0f0dab2dec181953a7b24b7fdc4e76a09b7f964fbabbb37083b773aaad8e6ee3398df680522198d46ba6966a05f0a7c71dc3f6bf98d383416327990440327551e7a35e504dcde3b9682af843dde57310932f6ddcdb8c59bf600d6923d13f8c9b8292a27580c2278e35590b39c0725748a115f5cfb4bdc46ee57edf64eb91ec0c164e185917f0c06e333f0c4abc03aaf1a1555bac6ba3b9f04a8e1933a18bf158dbfa88a25a1ce019532cb002f3269344f0871a7deaac50a84efcbca8cd3f95097ee1292a189a50c4b46881177061703d572c72cd9dd9e63a17ce394195ac5bc80a91754d1299fdac3a60deed060715b348af465f43d5175fa7fd50379f89bc5754365c202e67f5c9bbfaf018f5627efff551d835f9a9c2ca3c299626c071327f4ef10c0fb037169b67e30c293efd02379513fb69dc679d8847dda3f639b1801fafe17ba4e00a1f98dba6f5d8d0024d7efa575804f39b0906178e7cd73b1b8d8a98f89e18f257d1d5904ad86c9a9a52f64e784643d2e09bef35c3eff200b3c1dd8d4de95b2bf3693782bbc3dc0c97321d55165e7e557c42d319184f690d4bb91578b4a99ce581fe9fd3b103004356ca0a51ec72257ddf3c4172645a22c13d7553e53b53bab4a554abda7686d106a45a8ab9a9fa761047ff44f6408934e92487cac38bc37ebeb38bb4d4f31c69b2ac4af15e68a1268668f4b0791c381478e59eda9a75991cef2cb484177e350d985592db3e6b9c8f2771df3632cac6d9b2646858150ada642b3b02df083eabaf298ae9424a8758569140a652e19e320d7babbcdd061adf7cf8672c0804dd145f486e58bcc3b88dba8a127c3afe89dfc295082283733aedfeed58dcfb4dc149d57b48c09c07b2909727dfb2c09da9a33bb0bb17cfc30e6339651a51e2a81485d0a4edcc7409591ef8cef1bc86c4494a39f7361cfc47bd0c2f563108e3f02c12a87a43dee80820eaeb38b91c2f7036c61238d789f0d2acfba689e3a6c310573df8f999d8ac1ee2b3221c0aefec11214c098f98321131d7522a24be6ecbcaa87de0696437338dbc44b1ea07fd4982bd676287ccc34a7a178149e28fb53c0a42607f8721d16d5f80cb9e58d405c30419d68fed896c585876c87492e827bc00c2da6f88953797a2b9cbb6e390878e4481d3ac94c29f46e3fd47156b948ff21cf52c40dbb65620fb9aff4c29547eb440cf01f4e0a47dd4f8e4c12f819dc517b38658dcc4e4e1e791e17d168fab98d10e40f26821a3bcddbb72d6bc30277553255a853aca3cd2ec91f0983a35cbe807b821e2ab96f5313f67ae2a82523300ad990307f9adccab11879caf98b00e034200255e459f7467a855000605c9ee31ae45dcafb7a3a9dc7be4d055fd2e7833237db02e56fcab2b7c086b4a439a54cbd3f3ad40d0188ec0cbcab311745bb6390e5da4c830364102f7973d6d168543b90c08fc4897195fba7843317072ede38a0cecfbf3bf5a50159353deb53d9837c0f2b40fc5be7dc0fb2e37861c54a2bbd72a901597c6b4183a5b9388a155ec8fffadc51bb0a288456e985df5f05d5fe7ffe0415954d6ef90be5e226843dfb160f35db6c8d462e778ea23887993f821fbe2ecb396b4e1b66898ecd3b51b366d93d4d3591e8480c440a8fca7cf3e2fbee67192ad6f22d90e9d01971c22be327a9c11fc7918088fd442b2aa2700f93a5cc01f0044a666bfd85f7b759aac978b4978b276dc6d57aa1a6ebab2f996be78369c298f15bb03a9de578470c94f285898aa46396cea18547c9aedb31f5e746e963088d3280c2c52fbb3791e9d41b306bbce7602fe31051363f536d4d914291fa8bcd5ec999634926013d7759fd1d97f8ab07cb2cf7ed9ae39590bc5310db67cabf0106763759299cc376fa6beb850d81652cfe6fb641b6bbbf05b9a4ff32c5742d0e6e86bafd49eaebd9bd725d8b0ed83cc984fbbd8964ee8276ce3d9e2a85ddba74e174b26bed88a6a53139c49526379cd5b4cb5593fe566d4b23dc658b3420069c265ddb5bfec43c19a62d2b64685e4f8dae9d4d1e81864692a3ec1167fb206231ea93f240c30007eee78dd1e1ba650cbbd4dd74f6e3cf8fb7392c6e99702ad24975ca8e9ce62c08b05ce339503b31af06a2428105dfeb05ece02ae30ba1a106c863d01493a14ecefd0b50fdbdd75817000290098bc2eee458991382fdb8a7b66e0e5814ed3e524cbb7ac7af097e560fb534a8bd8310c0740961df78e8dbcbbcca64a23aa91e1ee4aaad3c10a88f4b1a5f115e0036d485d97094b329ead2c6798ee8f4ffdd684a8cd815b1d4196968603e966ba487cbb4fdb7cd7d22dcbb6e3f398094c7f755868946c998a7f78945972d52d6b0e91898ccec5b79d09e018896e7408238a0f754e4e099d323b5dda6d018e8635a7c2a4c0c10305558525979eb5c8219e90e2c098bd7a330938b7505ece417001d9eac8c2f4aeec8bcfffdcc1466ef19c27acb66dfd24c1fc2c0ed3da8e17a9aace7ee3511b590528119931817513f4b6d59b3efe0ae63949984fb3f0b180416b1a92110f8e63272d5196f9c94907bcc8a9efac28154672dd56f3202f67ec895357e8ddd807ee51aee0954be21f72ecc6df9882eb8305a659b0a1eea16809e3184ba8abac95ed01159c0eeced26aa26aa8355269848645b7b46ceeb7d9dbc5296254cc8642c49754e8a7056bb6c4b3fdc4fcfcbec3a902a996abe564d858cbcbeee91ee75979eb1745aff6bdb2c30322c87819259b5e96a321c0e0736cc47a02e72662114a69d3f330fef5bef0bd5bf5e2d32a8281c3d0242f807335c42640fe79b7d9b9891c758b0babb381275bb726e16cd10ae5e20867b342f57a00a6635fddba54ba4650d023abdd5080ad002f5179cf51424a05c19a21681fc9013953a3dc6903a011e85c7439cdb22d9d2ee983b8391df8b022620e4e87de369179d6b1d642ebe81af0eebfe3a9f54d2c046669903e0230bd4a782e80334cbcd5880f708dc307357724cb234af213b034ea91f5e29ae919eb2c42b58ed5608db12a979cbe0504b830ae18af19e4a4874433c3886b58b33b09f66565ff6552530896f9e7772f86b1586de94f0619b488849d4024436d5eb26e0860008a5a458347f9953e7a7ec4727cd38c15cb91f6c63b255792e21a4f261818fa9153ac0bf7554a5917fb78cc22ca529d55d774af6d61016d688e86c4aee7f3ecbe0a344cd532fd43bb849bb624a0b1511f1326ca38bf0c13589d53e499e58c8441b85ed60b16e6ab922e86bc42d514947bcad7dc2d8dcad858f80e5e296658b62b0a0294244d4dcee98d9d6e3baf8f3d56beaebadca0155e7b0d540980a3345f58e5b4b987fd301762f4c7b98563da60de31847eb111d9237fa2c1d30d56882f9820c963e50c086c1282bd756d807ec4f325d4e0a151805570edc4e727fd6ec2717cc7ae9b9cb096183f92b38077179b34a5e4fc92bc9daee99782b93a3c04331cddbc8394559e4363abad8676e1c6e7b0236534e90ed83782653578073eb6532154b46f4e70ab8f35b3bc9be6bd0179bea02e04962a1a9c206c6cf0cda8ed1b96072a033e9d251cda82eb9b4ab3f0418afc167885a938f8d38d49cbc449730bfd094d471c4d6e4adeabc22adc7d96bac1be9ccae19d7bd0625c30dcc1bf02a2b6190778f0cd6a8be240336e465a0df8d192f8d499f5e4c71ac6496c824d3c4e0ac5a2563eb6b10b000a1ad50f908ef54f5e9f30bacd8ce594a99a7afd1af4332eb9643ec2e90da7d0cceff9762d92e1887e491b8b2a00af3847e2ea84cf71d503b84d227a9d78704de824adec9613617d1464c341c52e554f5b2740031c3378a1084d56f011f3f7a29200ba6d9dbde408853909bc2035b765ff3d0f6cf1736266297875c7ba0a37ca9504cdf88d3137ed7a649aab18806ea61c879c1f1c474f175513311e8d67f5da43352b80be37f38310c0072e105e8aa2639891d2769b4b46aa7d5cae6354bd7af66aa6a4f53daa81ac6440024f8381cc990dceb800043adefd2e0ab7ea68c438959cc7d75945cf9df00f40ced4bdd302af2be31662042b2684cd8ebd5486acb80d192d3a384def0d3c859a658c43c57877b788425503f2a4e4b3eaff02a153d5c2b168f1edf8ba80c372b244d09a1d04ab331697e44489b8c9f048dc7822768a177c127ffa394b47eb5b43a5cbe9a9c80f0f34a6219d002de09de3f9dc4d4eb896cc5fd3543508ab8b213eee534826624017f922cdb434203319d1b3e42ae6c9faa59d7d2f27b4ddd460035585162fc35449200fe6f49c0df37d8cd53bd753bb6338190abf07dbece11c19eddd8d8c49d8a38a1c71d4abbccd13764f423ce0c54bfe8b72d6b1fab34b86b43d3b2ce4fd87e111b5f55585f368b005bd52be46a69dfbd537e211cec51c66cbe593cf023618742fe4f603d8cc80370a8ad2cfa81cd92f813b75b5005f68075afe13535ce049967cedcf69294ad3e0e7346cdc23cb319a4b198f7a5ec1d680bed974f95a448065b83621927d936927b118e3ec88b6b28bf5878073aa9e5eca6375bc1a2d840c60877877a26512990c6694c5afcf9cbb0829543b7e303c103e7e80fbcf7a473f47017456e8380ce1109b974e5d355bb8ba35b931a2123f2f5ddbc08985b39c02510229979d2f36c5d2d0ececeb57a2c3540b0c5068712ff2ec5dd3dbaf654f5eca2d4d83fb1c45c372be45e70cdc53ef486e9b421a21e57b13e294ca4d9ad71c5b31465cddd0552b1404adf8c22f9f2e1ad79c6c2258ac9babd2b931defa6102f647a8d8cc3b30720dfb361146316211e0c9e87e1c04e742c11cf3a77f26700794d96afcdc597aefea1faeff77f55bb66a8e2baa9c2a48acd8a23615e7036d486793c2680c4fe9a1d777091789fdb0fb800d65d1fc3fc228c33955cefa586710f104c60bcfcaf7223e0fb7e286f941c68f44796ddae213abebbe6e054924f76d3dfc3d9eb315e2365f97a1bb5b22df79f81fcd280c101987d59764f50c0e0bbe585b10239246d6fc30c6892cb897d3acd4dba1b5ab0e7de0551dfd7d5bb8547cdb144eddaab42e44b136d2c41cfc842828ea6c797412dbc4922e2a461ba04f83c35f3909ba867581a74b658a111f00ea4ff4acd650aaa2d37906d8264af30c5a0e39aac493c288eecdd7429dfce4e89b58ba533caec6ab3967ab18cbfb0d88db77c5d09c011f98638398f643a1a419d22691b5bc8f46ffb3e0f0de7a503bae3b09a64c810ef76d3b67b43f593a2800367336a9ea57b2dd564c9f05dd820658551e651886184dcfba1e7024106575dd345e34aa39affc359e55db5655dcd02b9abd5f9724b149a3caaa8125aafa1a3e17adb93ad27e682359f223fa1e0f9aab7efda621b81d630fbd7cd5d80bba8bbd287efae8c66b1ca795f7eb57c5e28790c8f153337f34757383c87ce0d7e227c9dee7a4eeade291f7e54a642e3b0229bef886e7786e76570bb4703105f2cad6ceceadae8ada397fabe52f9b83c3bf7b464fd2a3d9408be9a380eb691e38cbff11b04a5608cacafc5aa425c23420c32057540938aefa2585f406b8845168a659fb72ed5592836d4ad3c0d6c1214a9c040f09dab6d6073e8a18914a5d627f3b7bf839f9a342d3287f8b253fa1b35785808b8fc9fe06492a7b34b62a74560b2dc872207d044daffa3b2cd7d4ca18cfb1f8342ca21eaaf5c083e27e983ab79d514bf6685179c163e28d047b67435f375b93332d68d89e06136f49e41f79e08e371c02c24402f8ee92ffa827a86566f194ca135c2d22f4b7d2cf66597293b9a692369dba59da4306334bfa5f3b46c2b626b14c4cbe29adb1a41b75e00d7abfe4724da1c084baf392f8e6e354405028a0b8426315c9840baf9fb3dd678b1b45b5ae3e74fda0ad894beee11e32bab614c350289ee7ee348dd46c2e9337bf2e66f4efb3c087e174d3210a667bfc9ddd43eefaa12a6659962a63983f7728cd8ff98b65665e51d57fb3f9dd0fa8e8115512ac70689b00b2cc230d7dd4586f874f08f1816ef6d94a2074f160788ccbcbaf77879b50ea79bb0ba1d6739e2ab7585eb3baa1b5654cd9f833dfea675ce3bb25f0249c67a2aac640dd97441fc1057ff720c8ae2a25fc604866c50cc64e6c2d9fdc36dd484a561df6fd947471e3fbd437407c161daf0d54b3248a65615494c18933cdfdb757337366d0e47bdf02dcfd50e81873d2b0223892bdd428046c0315137c0266e9eff05601e4823e8ac0977b7f609b6895b0990d64bbf76abce78b621918cc652aaa3a2b3732df17dec4215e356e41e2af641da11251a1aa9036c3c20668e85e990cc25036e9808083a9f451e41f47690a826d92a3b7c1e4b2976ee28f399d7957353d5c8d40eabba89b5f1571de72487fcdf32e3264a0b87b9dcbd2c013f0c8e47594329de34a9d72c521fca827c562c0e08ea34245aef443b66a3103837b8a00bd5fa661780459d047d0c4bfc2b1f3b0bda4beb51bbfc180051fb0bdbc49e79bfa7138ab22b83729f1fd7a1701e1657279a1850c4f59fc46a68c481daaecc14776be410ca95d48adba8cf0441600772565d1d8bd1ff5782b9efeb945f0e8d3a2557713ab74e91bd0ca612e1c0c1247a741cf22b095420841cf652d332ee6d81d07c0b2fe6623d00ab64adcf85158ccbd0c39690eedca61ddcd1bcd010b567adbd2aafb62fe38946e520b7de5a82cf0089b1b3e3b4f1155ccf0f73891f5efb3b1a8c26dfe872978cb49bf06982f62b227b7470b61d26d607f995eb3766dc1df7c074b5102cce2afe74779c57128d44d1920b3d1c310c8e7b68c33c3ba6f7085b1bb3bcf8dd5c1b95cb6e893b97b01178d52812d9094d4b3b0d9be84dd07605a0ffbb2e7c6b937f67d6d6d396ab4025f8b6759da44879eb58459f7266eff0de979cec7424a376dbb4357fd14bd0329baa917209979f42bac25dc1365ed97cd30db476016a7116f77f83e1df98e33b780fc72276a022af3dbc5543449aa730abdcd50e54cfbf82e2871bb7d416165c44acb94449a4d29ea581a0e413c671de52869d28de660279f31234b0bc470dfaa0b497d6ee7701d239ff8ae73245a05bd5b8f5fbb99b93109858b18561ed9a1f7ea3e09f39266ad9db833516a52440b1ce11cbfe034bb957fdbd7de5d6cc5e1970cab66e95ea568ee9ecb32399f7b218376a366f940de0743a1b99d5d053b06cd85b097f2e3abd1d9c1cb6e14d682ae049265b7bb27b3335031f753bb7e9e1a767640cf7e48c1058e6725b9ba9192db9365330890552f379ed81c8527f03d69fda471dacf99a1ec85034c0d1b21e0d8539827b8673b7e4bc3f35f054cb8941cd052c40010014cba5d0873b50ca258e8effd4ba6d722ca584e8df36721a850048eb647c1c467b81e074218d8d70fccdd1f6a1e437160f0487f74f577a253e89210531ac18f3337189c55ff2afc7519886359fe4eb02b4c852465ed70626184c3b02e6b1af090393f3e5ee14acb01ecc011cfe936513624bf9ad77f51e7669e306f91803c97fe59b34adba7c13dc556cdc5c069a402a1fd9c0ae0a7cb69a9a25ee10819205db4bdf0318e1bd7430a69651fce8c9980a5fb7a1399a75522af4e2086eaf13e4259c799d813a89a0d89c9420fc1e8e3ec679d59d79a527db14d496026e4f74ecd7144aef87e6e0b5f452308744ae01aa8dc87d2b67374d8d4d55860de232176020e17bea47bb786692a1ed9eee854839ed320e7a33c5ad1261021cd9abbfb83cf2287d5c9543cd87436c25b325927a85d48408d6819c69c6629e526e74ee4ec96df1fd32fd90442496f92eda817a416a82175f05eda26bc2aa25c2cede634a89584c3c9925353cbf3c991f3f791025802c0d69628ee3989e754566f97003a3be25e212f1a7267730c08a00a2dd38b1a2aa72eb46cd227170b54289e00f94e7b3f9bb6e589b9ef51e78474107a1b585c6bf6557c411d7adfe7a82c52cbcc347b6dff4369db0089289ac42dfcf303a344a67a3de8fdb2d3f91065d27dca8ec2a73f045fa7ee57581b2dba2bd267322d98f0fca913ca0615fa42360b28fe0e5e66ed40dd494d15e29602204b1fdf6419d54edab7228437fc5f2fbb6c9090cb676c51b9067e64fcb145e45d0809b370c4f18a094fcb2ff87af051de834a96538c8b539c2a36b6baf9c0d3a1e01294bfb18f11d7bbac706329c8829f3a759f6ef0b2d7cd59e4b7490c3f4d93c434fc34fb4ecd4f433ad4bdf154d9dcfd5197e65d8e3aeab33baf99b631372283ebb10f4b4d8cbc27643df34f95ab125ce968a8c96caa9698b8c978a7437ce6cae46897de5fbda2a7c75f34c96b378f6efd23e0580968662ccf38dd4af9164d826d893f80e76a4d79a00d29698d280685081ddcb60c14fa57d9eb6660a97245945ea6282aade1a7499b0588855051abe5e32657fe98ed128ada43a977745e2f1aaae997aafe308124d61cc1a0859431b7576563e093b85df787223e18775c190e56ba2986d942ba456beb8de64f80f6a3f7d9eb88924b004433f9ba81ee082015edb080336b9de76b388302913fbb2f37ebee5fea8027586ffa32e8815eeaf7bcde136120703ff9c35e9ffc505e04f7735851e10c40a4b5d568f757ea1a673be76fb338a2d54f27215975a064575df64ac293afe926bec9d68a34cf39cc2c0239685e8580684f90b302e9476bc479deb9257ab5db550effc832ae465813cffc373126decd38eef04e5976fb43ce548e0df4d53c7d66ad52c7dbe8f0f30d71b431e54733ef58315513bc64420e13a14f8f82c5ad028d95873dc2b652c4eee2bfe51d5786027300c31fb8fdff3056cff765997858532bf9e56036b8193582cc4a9438ac90e8607fc2554f9c45a7df610f30bd726262bc0fa1fd89eba21e86e3354ba89b1ed6e768fbe41d0b264316f68b687aa05f634292b31f9d45154aafdc7dd3ceadb945d8488fd9e4e18e0375305d36f5ee0c776c44cb01aab720c36636b553bf1d6ca368d611068c6f4bbf2084cb2a91b31a3320490c02b7b76786f6f1107c70b8471360758d10b86bc36a1807f94f0dbc6184a4beeef92cfd87dcc621ea0e4cdcdc8adddf97a2be72d899a1798f4a530887c6b1e6910b10619743bb4d0e2195b80d64f98ca9a51113091a287a652ba4578f1d9096a344087243aa66f368c1f4a9d79daefc2d28225a5001bb9878a5687e3cce78fa2730836059373ef080166ada74148cfc64b895669f678f5acd73daed727ac1e94533813e5b44dd3a4261bcd9cc2677082c18ad42c1885789a83992c419714d630f4c2d9e89b91028285ab5542a44d316b3728aaf8f16e6070ee56ad3894d6a30ed547f17055508b99ccb067298d07fb2abef38c3925fda07d5f19c3faf4c95ec4ded96a9540d7a8d16783d43df464837fa0b414810192babc3b8ca853cd8e008344dde28b3c195ecbd3c5ed133df0490a5a45563375bae35d972e5a6137cc80fb7da48b5c1e75cdab9d88d27ab7ada883400fd8786763499f72df42e6b7b007c4084b6d41f9bb07dfd758e1d05b4fd0400b5f1fd455813a3c2a8defdf4b70ecd7ac95e7d6b4ecebe249c391a5d11c9799364837a27d831c8215048422c2fa3d03a8b0b458da0fbd73be43a3b0ee3daab399f0554c6d90f1b371cf39d574ec126034b1588e684dad96a88a2c2efd524c25af94668391461a134abed59a695852dc51a7f18f8356ff53cad89e569d591f28ca4aab0a2b908cefbc0539461861f1ba4016e5ac4da04ecea83e2a313f0cedca6143450428bc2b74fd55e3f41ccd34cc7e23acefccc275a26bc9b42a789591724c7fdd37d93b969a6daaab09b5beb728656d54cc6aaf82c323cc7aa2b9a5ef094ab5a12ec1f6269feb733cb063c42e09aaeb30b7dd22d3fbc95720eb9c26a313a7d28c1a7f62f194b4741a9560d6d93951476048131102e7154d8dd7d69712511702e5e1c43f6e558d4ffa0381fb3ffa4e4cc8f517a40294155f139f1be7b6979e3787ba83b95ec0747d50014e0fe910d9996230922f69e5aa7a404cff0fefb59e3fded382dc43d84c669ca3c4169d15af23029b2333dbde9244311337a126586b44c5ae81cca3792b88f67f7e31774fc2dc861ea4569e28bb970bc2abb220c53cacbc0627dfbbd12b757cd5aa1d77d448c1be56293f32eca55bed1fb68bd49741ea8ba71209f9b533a1dace20fb4d17b08e28fa111b41cdb82243c1b28249808c3ef8a082281570f11a9edaa4a7c199f045a29443042f3ac2f070d56741a15cd3cb77cb18e45f50422394fcaba3eaca5c9d8b3ff1b4e52075555a01c030d1bcec259bbf3829857709ddfcd13680bf3871d2e11cd869165bcfdd98d16d4f2c35cd9dbf657e7660ab85b03c2cc12acebf8191bf9ab594135a90b81b5d537c72e3641570afae391ea1961f80f718e4874b53c408e2e0dc194b808f52ea8d1f8fcb0609db11f841f2b7b033ec1b8be870e313a8c3b4491a654255dd72c110ed4b20c69a54c8d04c8fdca20d608715ab5af734b5584d9dfa8be4b57283682aaae300659178aff57d4781bc23501aa5bd0c143ee7de995a0edc55b77836db42a10cd30e6d8fed3c751ca1b0d35b779ae6fcfc6e476f5b86390009f3f2a2f8bb90ea4174685416ed0809dcf4e7ee7656042bde36978399b53ef0e544365bc877c572c513c8ec894d692aabbe275c429816625cdef345e8e90f729c150e411e59257facdd997a17997b314d3a3dd9be1ab69d90671b1727e2c7d45c7c8ed68f86876ece24fda598712fb043c0b12392fca1b2726159e5b55fb60c4ae03045fcd5ee198e5986dbcb2f86f784216477a6e9cc57646aea851f37b508975142d143493e38a7637e08d5fc37a993215259de45c9f0ab5f1ce0e5ed4a6c6acc6786657edace90546bd930b2bdf0f8285ce38ee4dbb151cacb8d6d0972bb5d619dc034b2d31dabbeaacea3a0e4cdc20550ca4c8e9acfafcc3fc7f5d46e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
