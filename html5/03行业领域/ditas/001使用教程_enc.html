<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e001f1d79b03d518a8585a9c4da380e776c2dbf25fa61112a7e39c4a5884ef8c260ab2885a12fe45365f85f4fd6c002e873ed64e273d1551d486af0a1f93ea0373021d13cd28fac589d31eb5d2896381c9b99b6caba75cbe1a445814779b1e326ce69ed14c4263b098a5589136e110497d9e202eef35d73ea1114e91d5e14721b7f218d7e64db5f8c90b3c2b8adfd9e0e3549210bf0aa0a5facbad117302c357e005233f89602a10e5277e5b05d1fa0503574a3a14f487806895becd2b12ac5f47fde682cb0233cef182894abb16f635a4969c69760bcd56dcab2f80b357df5028b273aa528cd1a8bca2620644af792210565f61f9a730ef4bf1b80a8ce692e4f0f2cb3af789610e8df8cc32e65c6e2a0e44633190a2667eb4d2fd33093c46af6ded625cd7cb4d9b32cae677e73a46bef1e3aac5ee8a4de65ad3491d4ef5436006eb7f98130fc31bfb1ec25c6869987f0efc5c7f1d6a078ab4bb19fd0ccbcfdb0ed39041e8fc43d19696e7ad5f63c4b423096ad54b504a7ee34a1589d975823c1323e282dd9c8c3196715487c84cad0df26fef9f1c776bc571335f54abd223cb8ee70de536e14a7e20dd6d0df0092e8199ea8cad0a32403447ac00698f1dfc6a3f1c360601ad84f17d36442382077eb52a8c82647409860c87cce3188d555784ce96246dbec622c9870540ff841af91898cf1f27135dcfcc1a0aa2fca0b0902886aa6ff24f285ec74fc78e569e95e23efe13bf4f6b7ad0d7991c5cfc6aece01e0af87c9d372ae3f99f8fbca337517c02938b7bfd3e8fa8776c86a68b3ffccc402297f94f3f38f6b4dfa0c12fc2d1e22f3610a6a0e2861bfd2f14dc6b9ef5bbdbc7f9126924b2f0211f0c63a2aba097577f3eb1daebb71ddf1eb778d4232feb6671d2601c2e3970aae6eec56fb3d0c65d649f49f4ab2eeba83b0d0e008d4d985faf3c618c9688e2d4872d476d979b2dfd842c8413613cae02e3adbeae62d6a9ebb1521055e8d9bd0d9c25660ec0a755d5592ba594b6a4d8151590c9f96fd31eda3ba4046aefe38dfc707c5588e108a6fe3c9d87e063856bec584d2782e9ebc53433476a6443396cf00a4ad633b32e92fd7c5a46083ea56d7921e1ed54be00a120c438a42c43549aec86836f62c0251fdc916ee0bbda7d93c8b616b963b9f4973027f31930793433e054ad412e30ca5bd935f30125d9ea5f53716b7b2848d37273dbcd0988c4a2359659d8e903a6ab1e8820fa80d208622fa56d6ee59c7f7f34bbec67febc5f2ff913347ee541d169b2e9efda1bb8ee4666a6c3f0798f86dd2c029297e331f8111e4a02b3ae0b17bacee2a10f3b43e6f5e08ace34817f316835afd83c3cfb2e2ad5eb2af5a4d9191181022ec24bc569892faf84f47f7a6f112299c94437fca5e6782decf23f8d57f8086ae7f7c731fcd1878cc0731be4cd56f91fec2c7bf932f86817fc8f799d33a4117983fac84d28e4b6d25f5887b236394fd5ac5398af5903faca852668a6db5c94a142ae6d2c5a3746e0e83a4bcda37a86dcc615023e033163a0254aa8c854855144bc056a6cc8016f2108f49860552450c8a7612354d8926aee139f2d691876dcf04759e6fd06d00431b0bc16afebfa67505512ea7c377fa66afa4bf762063f8a0dd5531d7bfb1629b6705b0a52570d76a08ffa53b6e54715bbcc51d3126e0c2cde90210c005fde11a12d8ccd558f4b7adced958d361ddab3b473cc8d4a3ce1d887e44cefdec9cd09b756f460a350a92593c9d0ac7836bee7110a1ce1809e3ebb91ec1a32bb65e515fe10f7e412e05d4a2fc3695943d2056faa35587896cad47055ed650ed77c8d26e85c0f8e7262f62af107051656b686822a0927bd2e43ff78b531fb6778915682bf70d04fb281d688454d3cdee74402e47f1c68d262fa3d026a99159ded26ef00b91116688c7a55ffd06733c7745962db3c4c7d66c186c9a9ff91fe2781e837f3ee92ff4049fd76d71b9808c3e43a192ca2c901189aad9a8bb9dd6d48a639515ff19a4aeb45632ff4524b66f39eb9b8517c4017b794992a86c95c9cf1544b7ae1794c0549667e6b3a0d07389816b78bd70f9df5e7b70122f20200478f9f96850efb4a125e1d9dc2f9db99a51f6d39fd92584cba61b761ad34ae68835ee8edb451c68171485c5f726fb53a282b1c6918d933a7d0fd7fcab8aa045f74a1a84fb9362dc04cd2043821ed471ec2e61ae1171dc347153da61d698ec6023222e456aecace23fae1c740424b91033dce4e218d6db8095a1d2a1f3c02159fd8216280060efc24d3af1ccb93cb483ac0513058c885fd6c9abf3719f85dfd2d6c72b95cbfeb1b73c3f25528bea310ec792fdb1f8290bf48c96b514927a917a1c97e3f67886d4f7c59492734115ca3c9f21c300262d6783b2f06debee92d218b66713663c4d675698a686075201a1b71c017fb510d6306dbfaa868299090fba75d8fb39a394b375707a8c64bded3a86d40e08ab801778ebf6ea32d713df1595b07532f5e5477bfb61b1bc6c72ed682727615da8ebbfb3c4fbebf2a73073adbafcc1acd1805cdf6d498d660ab676601f564dd7b89d64ed8e002a47afcc0540e1ea5a58776cc61c74fc2993894d73f86934705178b6597c340da85e3d0727b62aa2254cbdf3b2ac0465eda03c056228b98d9fa78ad60098ee16c87a11334c176e5c89701e409d17c19aac256f4246b4a9551ff7d78a748a281e9a6b4e414238ddb707d9cc7d18b92ee4a5b9061b91b62a516280fe893212835fb07a39de19675fcaf10279dd54c2295c6f977b1e8188b7aef9fa3728b64d8810567f46d27e7da293279619a2122f6eed875548dc2b64b146076bf057f78bf83e5e0d632a3bd38206b1d88e0d9fcbbbf9bcc42b29e5d71fccaaf158c19edd26185695105fc63422d341f6bd4cb11d38367a4ba8e49407f60b83c25a11509987c80cd979b9d247b5d93a5d19887f687df726cafd436c281cc048c4a5aca10f3cc24cdff506ff5b68c82bdba9310fa3cc6c14a50a09ff3d30640aa5a9bfa18cffa9b4d912c92a98b2e96c2c5b28111516e2d2f5da720b46c0c9b8f31302ec89e2bc8b94d4a10e6de380e4450e195dd36ba66ecc04e662d1a56631d2652d8d71f2a4d4049484f2ae6de0430c00c6f89a8aeacbd2231565d80e6de582d74c1b6c47b8021eccc88907be79046652321652fb412687839c20b27e822d8fa942b4a4fa8bc7081b2570cce47ebb62214cbfcd63e3f7fa92acce68bdb306a2585a9380b91aab6ab74d51c163efb203ae57ec3e20063ea5bd60f5d81cc87c408b7903d5441d50f59e2ae2d583fd672a28a9a109c15837e6a1c728b2926234ad99ee0454d4487eebbc2b94193bf23c470172aff7757d99194d80e3034e598451a9621b99fd7b41d9c2db4d9342b34634929c13dec19747ce9237e4fb81b20ca9edb97b37c66593a5f84be0c76e0fb1f561ebfed80c9a04ae59cad5b07524254ed5ee3b02ccdc7ace0deffda15f84a3a061d7db9f5e346f79c8749aaae6a1c3532618157c8a78f7727b691d1dade4d2c7bd4f977b7d29bb4b4002ce6e81d2c859da2e103c08ffb40b76c5f4f17e37e8673c24303be644a3f3018661c095eb823e0ecb86024e40aecddd2e20a2856465aaa54dbbadabdab8bc7ac62ae154771391bbb237107a80c71fdf6826df894b00a3b9c473aa376cd11912ae369576bec26f066cdc4e74e35362f6425c9f90bc740e31a99281c18bf5a1f2c1d48d430f5898821d3652176c20f036c237e0a38fd1f9b40a03afea41c03682dff257effd9a0e69527da8a314cc8e075061e0fb5570f496f4e028dae9fca94b8f73e752ceed582b138bad67e2925bb115b9a84e7692b2409a6938dcf1665c27b956d7125a403d64f2c5de4c17435a4bf86b64e92986063cad3376c164ba036d086fc447c298b58e29f3ad58046c1fe6a1db5687972c3934d82129a7812351e376c96adbb65a4bd869d91d3ea9430b27011c7a4327f7d48a2c67d981d57e677523b8dcc8f194bc827b6fc795989acf8d58ef2c311b06a9f40904f95f60418e45fe31a429aad46c87587de016c20b0ef9c205dc95c1332ac74a151825a2110aeed3760d0445802c1a1c24d55687fa22edf6ccf4c37e5a107e2c261f461de13dcb594e62f32d54c6f8213609ddfaff7db5cbaf638ae03e18d8d9f0101120e39638b56bd05d827b1b02277085eb931d04ad9bf5cc57dd92fee07ae865f1d6c8af5c9ad77143b92bcddb7d8c2785f435e08fbe8235e5a3acc0ac8b2286719cac4cef664314b6cc0cd45ca57f0371b6a31302ba5b63144990180b8b22ab54b689ae1c3f67364b580f0ebc30a827526d9c57689e0894d8b7166fb13bbb60ebb66b8568e39d9656ecaa757498465851265cfc0a795580ea13503c74a0033521f58e40a9c7bc760acdf6bed7f923cfef8e806552581563163768bc50280f93e73cb9ea0a1d4d8d187b2e4f885551d258a7fc0282f6436f0cbd89dd96bcda00588c78ce86915953f634c9712851ab21e20ed724bc539aad0eb43042f4e40df60ca7e07d872fa62d49ada0a2156e09ca8efb93fca38c8ca14f30cc92239c07aa3bc4399cc0b174753c9d1f125a6845084e8eace21ea8b11fd3b1f121681b33300b2c06b93a20c94a3f08997797b633cd75905724cd64eaf5a99b64c08291b0c685d23d6b09a4720de71ec82eff66643ba0aafdf20fb83f9e5e3ec1b2b2abf652dae338db74411923727d00947386e29516973505f90c5feb9d2afa7c7ee1ea5c424fe47b4aefd897f4673249b4425f85b053bf3dde49a9f96bef6f2cb4a4df3f73ab05688918ce18ba085606881fe671393a0964c6acf92c3ff5103db39667cdd15ef2063d37d73797018df0424206318ceea90ef6c0b49996d27001387b279181e341399ab6d179ba104514f262bc2c5919b1feabc66c12569a7d7c258cbfba82569179e6ed45c146f2475be32e918fe884fd23260f6125a4bbf14ab467f0e8678dbf899ac43536955d6ea7ff0461658eb5b477c6fa5a623d622a5ee74532a679ab81e06860c84e5acc5c3cd3fe8c8b8242cd8524457dd767a93afa2defb0f610ff43ac064740740932f8f59ca95d277999577c24a9aa69f7e80717c073fa8d9b3325e1d5957e292c27f308936508e88135cbb1ecc5dffa68f50fd26db1dfc85749543bf261bdd01179a17f0baeb75a1b8b4a2f41fc8c129a454663dd0f779306fba1a18d1388226ec4898fcec003150abbdd4285edf02e4020777414eb4daff5a39f7ce97dd2ee4350618f83e91a90a07252c6816f0253b29b571795be016b2a3aa36d1370881079b970c083c62ced26fa108aa3b45db2d5c67f655b8fb48ed88c2adde7c5e692e068af5626aefb9a41e74c48b4db41c018bd1217368bb49160b14d24c7c641f4509d8577eb1f9b815c899e95f07ab2e3227524647b8c441a0d79ed4482fd5d1444cd8a327b9f51352596c774876e699f5ec903395b55a1ef99a78ed73ef6afb90100451ae7e9fe88bd836ad6cb351e404033ea687c07f6c397aabdfa68448db94fdd45eabee78b9f0447da2069018df9f917b6f32db16eb11d7bacee6e673128436c4bcaed568da5b6dcece5f7a980f4c2542e32ef261b3d282cbb161ddcd463de350a02e715b6e2aab4bdac9956b7ce3e9899c7b1a6e6c44f0944cfb33dd8414130ab9a15a4445d9e938bbeafb78b7c096d55f70cd811c4bfa9f2b1275691c945cf1c81eb5975ee2e595135a0e911247f891eb9042bd2e5b02566b488dc1e24a297ea4e4401a54d8a73d2ed3ab913971a2fb6362fad541e2545480a4ff1645bccabf97fd8a649a91ef07bb175de455f603f8888ed5c2a5481aa3fdaf5a9c46cfe663f79a914aaad0539061b101b6c7702b8280c35b04a875270a2260c5d15fa8bfb3f5991596a28565e1c845358f8343302895bf6c0ec45067f4d9e3a8ec74c6aeb0fab833573c47fa2b1a84c2f29cb75e96fda35cbf793ffe16298762c11831b511c69fb20e118c8ca681ad3dbce87815fcee9d55a4ebbccbb6fb622e8630938fea6bdc348ad571a368302113364d6f8fac08a96d00cdf147083364104b0d8e43520c5c2b53eccba82c9e797d8438373642c01be57710601a5fc188f08c28d0f5a2a4959a649f30cca53cf356d7dbe731460e56b13f5490cbef8847cc94429ecd2b5092a1ae5147b9724d2cee360561403f38469618778f64a7770128cf09aa25e04a29d2543ebb8475eb6984a7a90a3d7fc99c6a47334ce0c85387a7bfe0de5067c216395d96fad7bdf05642987aea11ad976792db8a1dd29042e9fab32617a6e086e49f2d23d50048db90cb3229d80b15c19c2bb12bf001309ef8ab0e89cfbbe04581c02d558a8bc13b85ab8a7f730dc5ee7a9e1c6cb98c672dd12bb1245f6230d003142e459232f953c5803c073c01cc562e8689b05b228ec86b7e59c0d3acfc2a524b0b615b083ab618880ea45be82690c97b582df2677f166e59c9adee0a755b9b17e014a9316ae9ac7450ba8c1baf7ec76e368b2bef2e3059396992fd9d4b50616af84ae182f6681413e2baf80b403da64c59d3591710b2a00e6735d3cad53df36e8fa123ffbd052bb8def725b4aef90817e701ee3a79a3d5526a513232753a0939b9d7e662fd5fdf5c70e85b64cc6760135ce5fee2757e2b64524ce0d1fe0411d5f17ea22ee33e868ef4235362d8fdbd05ab1be77e2a5980c29e3a9260387463c837892f71c6315da96fee7e2afba1fbb1b010a52d060af9aef52a47b4d4f6438bca43e9fff8f939cb21d374b40ea1549114c19a606eeaf326abea442b20f3d7dc26e75458c923d78915ddb1ff0a1e03ec50feae00cb246ab1a995eaae02650e31299a08566b3eb1cfa05f2a9bdbeeca855c71b77104679e20a69d2003fab483ad9907990477367bb1c9f9b630361c844abc8bc2ac4470422a895c57eb120f4916b125001c99bac628dbf40a2345fa3f71312c9970cb0ba0216bb7488183b376ec019d6c6c632ac04798581535b316eee205a672a00827487d72fc99bdee7c21bc62ce29c578faf98a9dff6b2149da41a07ef4694a9dc3d2713fbf49942bcb6125c17924848ffa467d3f478ad76dc20b48fed8edee958c1202bde66d4fe71ffde68da702b06442b8a8f9aa2577d39c727d62b83da3283d97eb25845d78d2d9f631cc1d72c4f1fa0beb13154a19271f2fd4a8e945a27d1e79516bd662e78a84d0558b5fb50cc07ab8d19af960b6482b0c8be74d573ec0399c79959baad7530b587b3ab47e2d5b6c6bee2655debe3699b10544a058495cfa46cc3307c0c025e5641d19b29bafe0f1046a5a832be4694bbae24ed540b3e70c04cf672a76105894ae848afbf6b08e95d56233d9c5c22023e4d964df132de82203e2dba3294a95672fffb8625c5bb893cd013a4f21fa53c00cf919abd6ebb13c162bd4c960a1fccf08b7371671ed34cb301b93fa7997d8f75a10d2b30a6a1a5e84fb20a542d382d02bb6582baeaea66d0264efcb197941970d19359655090d778e2e652bb35da4cb6802a23d10ecb30ee08be24436dcfa8500e82ff9649da774b7b0847a6f2da842ce3e5ceb8e06294cf6c72d1296c7a8703c0c07680ccfe7113e13aa419677e0d84cffddd6ec083ff705fe217943c14f4c13e5b13b90d174b8265ece282eea064c2fc8ac46ee92bd97e569a45257bcc4ee02880cbc6a9a46366c726ec3b8c696edb99c919bef8d470160ef66de5102172458fa2537231ff4e67074b56318b01255bdbde110a8f5c46f40d968a9241865cb9a9a23cef6c7d0d4c8aa6e0c6d60662310de7d496d558ffa04b13c241c6eb6165389d395969334f54bebea0030e09d76cf77bc31e17b8f2c01a6f429532d5ac1f1b28f66edbb124de5deca920b4b30a0567c9954c37b969bae4af3cabe6ef7a89fdb5045eaa0ddd712ee55e0b9aff1252cb7a37680bb46b1e128fb329a07cc607847479a2dc46b843d9fcf99bd6f94027734b265d022810c0483f6743c8cd5197c845bd18e36e896965b7c10e8c3f3d27c727b6f0f34ec40767808dc42c6d8f658a4a137b3314bbc884d57686acfcb00b9475cb0fbbf3d4c9300cd130ebe84e9db838efee8c2763c0c90087f9c40fcefcb75f1dfc6efadf5ed95a77d22a9eec6c240335e461f0e61676085729fafe358104d44de9f0ee492c732611f2374927cdffb2b191dabf2fa5d9d4952615b8be86cfdf9ab8693ee572fd33c98d0b5fecf218919988c9d0a13fe223d77fecf71f9abd717018a51ab53f3498083454a495e61f32d323e09f432207142d8a1062cfae99ad9f5a44b5edd3307f5bb06649ad3d5f9408d848bd1e00e4f9cdc549c3886dd37717826dc8d510fb820b1002aa14bc2c28c0e341c366c2ca1971afdc5310aed6a872e1c67ff78a46d8e474cf72e474f3f99fa3552ad55d95a00e1333f8132d1297049d8c2088b181804883b73a595c52fd8e08b1c193ad0a7a803b5115d3dac8d0be8b8c2676648b600696359c0984d473bb200c593f53fca919b1034c1c0749fba36bc5e723312d601d90975e019947ed77e6a28cc298f475cb10322842afa0bcb915b2167c2ae091858de2ed28b4d867efbe7f443bca91493fd82c5fbee929341cd75472d99b09258e399a77edf30feb38a3cac78a18576e5f872a9352439d17270afe1f327a724a61c4083d0154a1a0d4d35bb2663728e97bd531567b5c8d0e6c64f5ffea1ec66f46638980bc3a3065b8313c8484f3a6696c96f9ad12aa2c0867ac67c51ab1fe7a49274c6f8045544dd8a5e99c00706e8bf01667f9a6ae6ecea02c746bf41ceabad507a1f103321a29dbe5dc6674bfb4c7f8f09355ee60f05b28175a875071aa90d66ff366ace5c730cd2585f1e409c8dffa1fe276247e2e5d6d0448c3865f9b68741094254961409ce318a56ef5c4a190fdb2f0934602bc5b9f1b47b968fecb4bafdba64fb589b87118d004b81292d0eeadc124b6c04ae96249a5208fc08f2cc4fa21fc294902bd33a3e614f3773edae01ab8e2cc8e829b864b3b1fd354990f0d1559344fac958710b55a78da9019081ac0d7436452ca2e99fffaab0de9245ebe96fb66e9c88da5825d903aa35c6cbd1af79ce710a703b95335adc378c2500f33fb1463168553896e552199193fff3bacbbbad69a853d3dc2fca92d03e240851a8144b04d7c19704c1a1e200f7b102a4c7476787b89d3bc5c3f8178ebc19636397cd94be4f45664cae2bdfbc314df2b87a79a0e85bddaeeb4a43b1d41b3d14d7aeaf38755ea4ea38715c34e0c3636c0114deea3a44d9a8fcb2c1ab3cd072731680f637b15dc86a74ed466375de3b68b8f95af8bc0c8984816bd438b4b15a09d30b25459d58bc9d301e2db014fbd0f221727697a39ce524d29e61359e74194b105d2169f53a5f8ded248f445eccd776895951b0afeb6f28d69c4e9ac9711ecef96d50357a295c2e3d560be83e13012dad7c34273abf529addae6191f39a61cc7f64cf1215407a439b352cd107228c1e65dfbc100524b2cdf04062aa7d63768f5de65d97d6f546aa21c37b83a4be364ae64be1e5ba1894b154fa50b4fc72ac686bb6fb9957fb18482c5c9bad149f5804c81356f4b7bbfe890dab8387990da53a3e1f26d8f191b7065257150557eda743fcd4ae89d1b39ec73dfdb2bf9f992e4c420b112abe86ce76e0f76778df806f2b98c1921333159d337ef1eaca640b765c91c561403d77d9936f29f4cdf08f925e4f7e87f56947401c73a55c883f5ad676de9190413ecd04cf3a98d16f31782e14832adae1f11419840dcfd7c6f6287dd6fa8e6a213d126848f0b72a8007ec1db3ff64db8559337aaf97bf15b0cf5f2c0487e2aaca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
