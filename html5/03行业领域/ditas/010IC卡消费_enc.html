<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f7d8e533208689a10d9f03479c70e04603965a0684964360b1d542f18d99529303bc0704988ccf9c2b7f8ca0e6caee9b3a53166fb3ed4384cabe11ae17ce863f98c5db436117f90d4e792ddc2bc12070326d137e1ccf8734f414508a34be0b6df0888f661b2854c178e6582e6dcf5fce57cbe75ca88814818cce2a04b6c7f8fb47d60a22cac2ac9e8263aeb1579852947785c8e4f1874b0bff8cf3c7b5f77ca051365e41f28ea42270ec0fb4c1899280361ec4e6bdb8b0462bd5abb5938676c7b65fa13f664114d7d227bf8ea823153e858322d19c38e5cebd329e0dd3f663a35bdb86f96b5f97f765e5badc243f9059182a8cb439a51c6a4785814c596cc8095566639e904ee9c1827064d59fb51eee1421d1b139f1b64af21d6360db5bba2c21e02a13a3f918ef525d8b566f3e8b9230c31135146a3003deddb1102cb8b921d7a337a3558bec36ab6d1d64b44bc9a1d61279d35c255b23a2d4aab84c0c4366ed458b9ba4661a02171436181450dc4e6ae560fd2dc9c258811f600049ff5607fda3ec8b5c3c530abe3c3ed1baeba23a87dd58ebeed675ec3f11ac0171cd6f531e57d6703bb528b36b9f23101f8fb6baeecf93f6b3d805ae3a3ea143953db76cda6ae1e85cdd03a8f6467dded218b8f49d9f81cff98bdbfbb6b0e3e472318ac1d31e9a9c685b066f0afceebea4dfbf921f4352450144ce0514ea42c10f71476012976e36cdf0e6e46a7a4a285ba17f0ad1d34227483d4e99beb9685de31e74faa1a67e3ad0fe00a0d4ce73b75e498aa5b79437152eb71fa7a76869dc825ba7298b82c167834f09f992b4c59814b64b4ca268f19d1585fbc4647d168a9a89fa564e96bccd330acba3d4f47b2adbf2e309b852e35bc468f7c4a969eb750f9315999440c1821c7a74145dfa1d6b869ed90f9428f6feee508a6b216810e39eb13beaf762f72a036da72f672e1d8d8250306c2c04f97c1976433dcac3ee37d677dc6aa5d484df4119730795b9e01bcff56ae791ee62e268986100bcc4accadb2bd8e97792d809fc0d39a1cca3a5fd5a7fa2e6cb6ba5b791941bac8619d7e2461d259935bf5d8c6eb246f3a7798c55a1817bdc3e54e901d27c6b1493cf0795fb6289f98f55ae56328102572aac27bd824af1930e757724d80a21f2e31b7a1810793a199e2fb1147e0cf2ef3ce144070e8c034c50b4fd1e7014db6c6b0ffebed63fd274a8f37b3e0a6ef8fbffbae38d0aa1a482fc1e0d817f18f79d17c61f8ef4a9f26666876922a8c4f4f5d1233b9cd20a2f36af6421d6d826ef1327c853f5f1b5d52bbe4d0b36f02867f6df12673170a1a3e08016ecf001c89b5b66e6cb91cb668c01bdc54fc5f73bd70eebc18c6dafcd7e88deb1fbb887905fe75ca80391f07a4b107453e48513fcc56c78029ae8301316831eb8779b540ff1146bca90fbbd24956a6f7acbfa69acee0ebaf15ea62fff806b250ede5a575210107b4ca6aa3349fb396c2ba8cfefe61627e5d1c014892539cdf519ff17a3adb7f11fa9f9216c0f9dd1ffcfe7aea0c12f23c07cd138ed756620c663690f0ebd6e00bc289d202af5373d6294cf4cc2c8612ae577354b6bfeb98622a33caedc95d89e59f64d94f591f21c5238adb9b94cdaad40f14bf6896f91a79877b75d89ab970fecaa28bf5dc7a833b57b3e73584556d6722702657fd02af33e095762bec5e1322e49298947460b19c305a33f02c32f7f5efd6d7adbbec2cbaa6ce6674e4f8bb6fc34f85556feef88ea4a9c7ccdaa7aac243978abdf24cee03467482c1e5ca27dad1d57d64f3ac636c2bf3f7d3df93e093586b627fbd68e38ea9ba3d546b3f7a910280a7eacf7138b00e560db243b06510274b6b5289d3998b06e41a45a327a459d2b9cd3093a6de964d068704792ce68fd050fd128a7e69f39721100b57ac8c789483ebb8c0dd301ccee63b2b7007876b3d534dbfb3e12dffde5c1de908c87d72f88b6832e74f0230dec6c4bcae48d5648c2deb844e068b788724f089f8ad36dc551f3d6924aa80e289392413c26370200f001587383225a26123332200f7c95a29a6982d7057afb11d9a79a514b3bde1b32b103e1a923a48b38cacbc6c52862545fd682a6973ff0a39e17d48160aa191366d8db79623409a126747218e08a2114b8688404a35095d367cfa6eb57d2751e982f099a39da36df3c1a5b55cfca036c1d188ff93e9e22fd10f68d4f47bc998707fa79b085c860931bd0b6dd7d5b0febe618fd0aed2f3a40df4ae67036b738f5ca67a84ef40c8ac06d5e6c1af324afd63966822fa41cae49eef1f41c4e909646a3f70fce0a5774d56034c314c42103c98c7c521fb8e7dd1f523940219c2ab167b3793b74829218fc336009f302ec5f12a34349d4300a2834d57973ab00be363e98199be948c4e2656b71d92756793a5c310d01eda4a204f053675c693c093d10202d05119ae3e0bbd917dd594eab9bf1b8596617319062f06027ec9cae1d2d5e5b1cff2f79138236e64044c1df7e3a1e9e0bcf88ab59a1eb2db9439ce2140ee6a5b3a51c258e0dd98cfe7f9d25890d508047827195906730ee536760bb17038da01d9a8f76f504c5beea31023ea3b92b23b3681e4af1208bc6f20187a8d4b77e5fcc331b07202ffaf59f96c421e0877312db817f7c6535cf0cb30ec817166b16d3c9e09165358a54eeb4e808efc64c748c5a28e1651492bae825f02b4ca2e2b93e9f2c539534f44e44c244eee9c502e08e3b315378cc3b53ca6144de8179b207bd5d9de06eece2405e42c00c95b147cb9480b4aa0533479e1c5428a60dda30ef247a5e21728b2346c3df0b34b8a8d51db0c90fc660a8edcee4ec627d78910a64c7e9accbb08eed896ed1dcfd927fb364379d45633ecf7f282036be9bbdd033f18cdce51ba79799fb47b916ca63782745766977dcd3177e42ee99def1a3976af3c7549c76651a8d5bff9b0023a37d865edc0f06385f392ccee022b155e3361a9421f1becf68c840bba208b2f61dd5404769e31f4cf2da9ac6a2babcf1354a9a8e3727630afb5a4f8822438ef6780944598fc53885aca49045c9c922d93ae01d5cb16a8dceb76bc51b7856b22a7f81acf18aa5de19dab4d33dd7c2f8381b07a8be67c17ce5ec7d48a26ec495770926fb960d60d9687368fc4916396c0c43d072eddd1e887148fa565dfc5f57647e441c60a0d59dccbc34244a57799ac51b310af55084f226538af3be87a61a3c6d97f6e2909281d4aa55ce2af977684ff6fa160608cfc966bdd41606a4218855afa32a54a9ee399d9534fd4940f57934f7a7c29425423bd84ffe506e6ed01b6493e0ee80b536abeccde69e2b2d51b08c1d94b54189e624c9f11ddc391f56e300683894a3766addc0359249a3cce4ba53a29feb3ab0eb12d041208d25936714ab8a9bcf69b3554e107171643d70471b95b15553d0a80bc7233ac845d7865cb874f47948b0b1e1058f536bd21a4ddf085fafbe788bebf73195aaaba9c4c2ec5a6850ee7051cc46c5ce52ef942c138383ec2c75da28dac12035e02dcf35595836873ee402a2a3d3fe10759c79f4b771e1ffaf98e275c98f0bbc5fd4895172e8e1b8a7bcab9d2cad172a0b7a7af2355318ca10eb3b9a990a4d1facda597ed30e02d077cf4cae63f53c51758a69d1a9598e14f841fd1668d3e958df0d21e43adff2fc5a287ceb058824ab88718f2ad9923e1c0e18a0f442a48941c8a8f2f4014be6e9000c2d5e4293191d8cfed9ab6f15ec7d710c9f532c2236a8acfa0f2846e0159141678b002dbd3225da119d33b3434bbadcdb73dcfd326b226deb7291b497d8d658d8bde222fe4d653423abae181daaf6f97be1aa773ac576b9866f012bd0e42215286973d87bf136bb566307d68c6c3b68ee0141379ed55114685f8f0d45fea089a316c1e6c0bf3f9a78cbd94400dce3a5cf3600e27c9333e3f61707b2132939b321af71357e248de94ead0c4d5eb91114d1dfd2015b7c11efa3bdc08c4d495451cf07522ee75a401e68ea40b07ef722d7fcdba394e7a3b109e934a5d6353de8e6e44cce7e4467899efa7c848df028c6db5a5158c85de8f9dc387ec7af460451ce06418bc4c18056de782ee988276b75825f9705f2daf762b1d12ee96d054629d7acc53c694d1069db367eeda79ba48a920013eb364b42e5502a001d3890153b158afd4d4428160f6e88968b7bab87a505d860de0a23ee84f66ea44cb66f031b2ef8ba9eca9f146f9dda5921ee2b635f0206d95d55e58ff0524f6182b4f54fb16116f5e4f4f8b4f1fa28becb3bde4e4d1f281b8985688aba9e7a0f17f474d07c1ef21757176ed7f046ba59c07ac6794b88aaee6a6e51c3665ac15465a57758d27c1f9975ab46b5ecc92a10468400d47b3e619cd8276a7a8839eb49dd2eea298369bc25eb54a4ceb16778b1bd828c6745123c3a469f68b5dda3842ae1a6bb7eb058a4ded3a01aef43325333bdfb96e5413c2a7ebe51c0f24344e3553a27292cf8a3c47f0c28c8f85e9af85bc3a0cb45ce529868d2c30f2fbf7b95f164b3f831da8975e9fa2b1508b74240e817dca8bc38e2b3b1fe3b75e1e33f05c764a3b6545f2cd4e94708f4bab6b8f0148876ea0cde486735dddb1074750a17b57c0359ac945fa08038f98081276c24bfc05f1cd5bc8bb13a8d1c0b22401be1c4b7eb39f99798d4a7a9085e13cde4ba031179754281fa7f168e71ff3f99626aa57b828423b5c0de2c3cdd54ca518d75fcc57e84f8caef5da1930c4131233a8a94d0bddb8db4c14df4d9d275a763210e97fa740e29c83f43398b4f2a8af6846a2f4dcce17bb898ed59ab752b72ed99657b6227c4fbcfbabba4c702ad2ea15acdb4577807fc7b5560f67dc0414d1a08934c257e8f46e849d60c19038f826338b7b3703b1655f52b4c2ec4e4e41bdaf88f3be4776fb0ee923d6fe01f7d1dba8f7459bf0efceb40b879be87250664b1270dd8cd4b918fee2dd46a235e56397cfc29ad7aab8b97b10b659f92f5301e29ed985b02075d0398ab3b2b817ba250390985a5ae715c2f3fb5efa42ae1da1436bcfbd26c2dc241ef581d088581b2e28195dec8e67e2728b3b52dcf0f3ab152250652d159fe25a713b60f1f8bd7c1120808cb6265a8cf1b8ffeda512e621cadfa4206a3094f44c7b2073afcfd9d5ce581a34011f4134237f48b9e41405f6ae83b24901af7443377d35b9e074f706c89138c1905c10ef0be358749d320b2ca387c5e5715b4414cd6b948eb2c0dae9765b4aaee53264aece5ce3a9881144ccb15aa18a654f7561004813cb6620504570d82acade315545b115c5f45036fa6abedb7ad0f87177a600593bffa784bcc94ed684fabba999bfa18a28a7a497d2646bedaac581bb4a5cad5c24b61ad2f6eba3b90e6afa1db269e4f5959196b1b4f4e09ba1240089eb8f9212f3fb36ca71de244832d3b847be062cd80f91888bad93136072351721ed087bc247769e0b838976d3421633151cdb255a7d1241617bfdb8164308688cc605438805011498e2103255ff53664372a18c064b14c040bcc60a736492c2cedfb21cba90df2e72943c1e75fdf42bf9ff54d9f90bf10f68efad8b774bde41a96432b008958bb0bb5e060bca7b5fd3e4f22912a8c1d61b97a4cf7bd41b5e5e38ae40ac8a1bea28034921804c0cf6754039e713614f7fe07de0fe258e2f247c667a14912a44c2d7f3ab0a34b0a06689a58756fe857b2567b987da9848d1c741a44ad542e939095c244dbc15a7c27127d51dd8ec1a5ce4ea896e69cb02565a37cc88f708c0a667eda5fceb4d1d6669cc777b7ea6868bf080a29ba6848fd1ff07561116c5fcc81f54525ea1c0e0c69a0296b86331149addcc9e8937dd3197032032e60cdb9305c8eed779a49a627a49e262e1e6683795fa7b77f6f27a10841a498568c9a5d3e767a0ee1bd394302d768609b410242fcaa150797d76e914cf34c3202e43f264cc01dd252795c8689deb0a4bcb124cd1a95e180be8bfc0e3e6bcc4775c72cf7bc506d3115936873b868df334c6f35e0b37757d5850a555e7b5577349ba0413a27e234e43ca33d2ddfe424f00356392572792dce4f7114ff2f814902cd8756510d6ff73d305220b9338b2c03d45000d0cce999cbcbf6ce995c740bf48c5ed6fb9d4f362fce2d6a975491c03d00b678682f0f0f364ba84e35297ff5b05c84e28bd9241a05d1f5916661f2339f0e8599db486322ad3981cb91c7346b46ddccf148c876147d115a779f35bd54f640df226f01c653386c4c397b6c26169885b8177cf9dc06d7ba6e99acf3ec9b3bd31150160a22bb11401034cf8eabd57c257312b930bb0ef06ad479897f9951191814e781646778c8b1f7bb02cd79531062a9786703a46ce6a7e92751377587b453606765a710fb7374121058b9a430d16625069ce0d0f7cf5199bd02f622c1607ef36aef7ddea488c68985a895f208913651ff3eaa6439241dedebd440d37489212eed30d4fa6ef16bf9917db9984e9b6695ab108a77b6744d5dbd8752361e11801da1011d457041f2b176efb92f007232949fd7a759fdc2d0962aa5c1497ed54518d8dc3962b9ddc966c45299d86848dca9caefcbe8316d95d24cd7c42a71dc8046b36382ace032e6f55d3de6a743add59ed038788b0267335dc6a9d4b91aa031664465cf1a41a152c3d667d8cf6b440da240838becf57a94a602019ff15c6ac49a5f3b0679155130d9561c0a8f27be5cffde14f6b11ce4733168eac7327ef600b1760460210b844b9c1dc6dd1bd129592aa9b5e61840d43b36588c6e72202b6e9cfd0335d6ba3fa1bc10808bf7bd2a71a9870d61d64ae522ec1c6f131fc912a88e784372faf1454eab05028f14813e42601ab93f26ec29f4332c19f45d97c6cb8cd863f4a77124201d47029bbae164fd88cc8e33326dbdb80cb1d968f461e74bb6d1df1467982060eecc54b32d3594af02002b5834808eddb61092970b10d38c28ae4fe6334a2dc7d6c32547e19ebbe554ce6f2abe07646c81702394cf486eec9f589f8d7c9a1508efda2902dce95fa57074fa352c012301801acb38d2c1027cf18e5084646928fc6182690132e22a8cb782c5875cd72e5146215bdf5292f90de22d7aef2fdc888843606e5b3f570e822d842517f82cd5ca24b4ed2fff86d4fda2d828dccb8ff947fdfce3d57543d6f6aa0a423bac41595f87784b7fa3a49b4f2372a0eeb4ebe497ab469c5d3cd95447b041894431681b542ba237fbe15b73765125a4baf20ba0f54ac6aa0a6e5e6231bbf09cb8a3718fd8028fcd25d91e08c00b107f3622365028b486b40acd33a37ed78dae04351f143a3894f6945bf102c15c0e5a302f26ff5b5440254b2bc7fc94192f107fd7504794836cdd34015d932df30437107611454a09686d50a1276e75f8adacb0426b3a01a2aedd48344b5d9322e947a13436443a7ffc899757759fc7972cc15b67a22008d775e9ee4d1cdbd38837923fc941f37e8c29364cb9ab20dbac6df4f6283da32507ee97100f9fb0d739eb0040bea853d61742b1256125b2256156017bea485b74b21bd8062a55eedf2f511a86450b444d5b952ef6a0c41b251d73138529a9968b58fa3679314331ecdc2f5efb222fd901805359ec1fab8faf45a5e9c29223acb65fe16e62f63229efb9400cd9cf420cb97173d1f0067371182f4001716112ddd8ea93e659ef206d493ee6c569810e8f993089b9ce5fb54a7071fe8c8db4bbfe766d8178863eafbe99d08b9e59339fbd1ce0325ae728e0e97758bab62bba4c6c83abaf3c4bf152897f07e67b6cba7ddf7f16a5afff594d9d979fadc60fdc4ea61e7dec734fa350b5d71f8103a7c1aa4d5fcd14c03c317f90a59f46003570d523a75ecb9b15fb1abad07e2fc3cb8fe817566f832a426c9eda23c6274b5701a02108abd44e0bb6697b5ea06559257a8950d5f04e9df9519a754f09843ce389092671bb7922c9ab6c7b128bb34232ee7a40fec9cd553850f7448b282cce50002b39f2be6951c51e19f92b5aa37142c3b2fbe0fe07c1641f70665ec0158b953b92bb7dd3da0ec8858d42bd949cb6ae32e605c5661608658c7fe30032d222c103730e4796bb1368b26e7cbfa0295f9ff4e45c0bbc6a67d974c3575987fefb05abf819ae1d89e2c3ba6bfce7ed04163bfbc93ea8cf296d8c0fa7837a965d8819634c3e3cdeba65266ce2e44067fded9ce31cc4782a890d452364f39d3566c31a2440dd7f6786c1b95ee4788ab300fdb694724863273bc300dac66609064360c0ae973fe4b790a2572f5e89e8942d8a9bc222f2c8461a84f2ddc57c47759730252a9fac67cb26ccee2179672c72353b49bbe1488904f1b9085e9f1e09a6163b7e442e34d2114dff8c696d9184952c3f1fba7c13fa3fb5dd62c9d1b57eb5ba5aa201ebf1e7c2125bb2fe2604bad3df21ff36ca1934bfe5733df1fb6b5f245783964efe07872c1f257382d701f89d8a7fd2624e0b6a46d7f5db9ed7e12f50444d40e0c12b651514e108f918fb5010f0c891048f14a48fa54b522e2b49e7e21660b68d8be0ac6c7e493ad016810e5be294a4c5b9ec5a678fbdfcc71c0d2a1aebfe614708cf8eb69524ff0cf93b07358c653bb1f61f709fead877d851543652eb4a21c6fcb88df62a5277962d545017bbd6e2af8d30974d956187af598bccfdf28598d5128abe96bd2e29bcf1c793cad1ba275075e749e4bf4d36141db028d5bcfe5894c11d0e1d37a2becbb5f601ca0b3fd29d5bd165bfb9747ebdb6bb9c4594edbfaf0f1bb775b32ff6436ce3342ff95ff21467b5b4aca26dce7c24ea7056f87f2a807f0ac9bcc5e46c50a886bd19979e509c20cd877947aaa19783de41f586ee70d69b6731295e3b2f0df71f21ef7ce3d8b949909c5f174ff5377e6c1e9873a23e8523aa6c3f9143a89a6e346b957dadf6e75489b9bdb9ae597bca88e0a5c4e9c524cf6d845bb391d55d17e3b872c38819ed730d9c91cbac30736f83885832fae3d76da13bd37d4eabd2693a0d44226841fa3fd709209083fc9ca32850ea2000c9a7b82ee7cb1c1bfe76561e4260a71ab64bee8ea5a353a8e9d0e11b8699bbc63458f14751a8d9e9c5fabea209734323a5131f65961c623fab480165ec7a2ef47d1a160b29afbe8e08949669733f20ff964d31b3880ac1af75821e7bdbee048140ace8b9c95c89d1aa79b0b3578f4c8cf72990cdb40bcd0765f767d9a9e6ce6d1a05b21633b770811750931d7a230df5e204a83706613399bca00a9920c61ddf8d50c58ad05dd547694eae12ca64128e97fd96181b6a5fa267210e04dfb5c19f735a0e25c12af1060ba279b03a5c081f808db188a1cf44b50ed898e7524827e6bae08f6f847f05673e836e97f7694292a50f89078596fa0b110ba6b58991a67fd76c711a0024e6a3f8cc085c566b6fe11dadc64414174c7645e2443b9b257b142ddb289714fdcd5af1cdd173970dcfff2e62be646a8be6b66ed8d38471c8888c67fec5fdf2fdb713043ae26b5a78f7594b9917bdcc111a761a2e9fcc43dc17ebeeab28ad675604311b3852e9542aff134598e0ab84b9ac700f2143718f02df7a07391973a4addcaf4161d42961f0097424becddd1eb1d8b961b8a06b6618ede96bc3f3fedc46be38e275dab3b2da7580325ce018aa2847c64f00654b5449d6448e2fcf8bb8b6ae3d44a8d4724380137d6cc48f373b440ebdb7b7bc3968388df6a82163bdf2f18a415d70260086a90bbc40015c427fcb5eacff283aef62dc80bddffb7728a61bb5e3a7a5c627ccc21a19f19399d7006925dd63a0bff214b31124fed5b0ad1c2bd97d682088438445e4380b30f423b0d6fff006830b671b794a60bfd2d97a8533e7652e678d510b71766eea005029320a2c5ad2cb63fdc1a635a71d5c3d14529fc2987a09e7a04759fc3b4e2a50b9fc214b5d3ddc321bc288a9a628717885cb091adeac6e5b12f2994e93fe45e428510b31e8c8234a977945df548c43821e014d882c818cfcbebef0d1df6d99cb70d1bde1b1b9d30111177dec582b306139a2e172d95ea95a85278a3ac7c5793c2cc6a288346284860a00bcc0872223bfc4f7c8b6cec2e91b60923ef7192fc928ea50b975c68d6fddce38c14f147ebacf8167ed41dc08611158df569c162cd7c339f1ff952f326c24fa4ade2961f976c285e3522bc0a25e19a6179eb9a079d24795ecead3e1df7329b0b77cfa7ebccc3d5dd87ab8676fcf9a6e0b6f3636d4d0f10c8ac61eee76961f0835f7dadaf48e9e2dd7095d7df409c6da5fb6561a74a18c795122645c5f09c39caae21c982e6a6aab96f9972e22c0673f7f9b8a10a1de63709ca2b2583c105b11579b0448d5b1bae51694349fbfda72d8656227091237ff8b8f9e20390f3e9813a99bc5074665741465ddc4937c0803968c7cb3eff7e410fe45895d80f0778cd5f58b2a21a6bf33ecbaa93d337be56989dace96f48f6459de47f5e8562618a17c02cbba50537abefb492b92ca002fce9c0a3aef64dc241d15c8b0b4837f19b200a652d9bf8682a838c1d3f4e574a8659d9be9d34893822513c045208cbf749b322bfa9ebe6cca80cdf1be2337e3625a623b22605fbb47910939da7975aef53852863408aa89b59740ebee194627b934cd7a2935e227604f1f9af1a6e85e0c331cb39c322de65638e3a80773f7f58171a07b003c9e4aa8e85c81d54b5a8f4e59b60f01ce765cf0416d44be28a230feb9e4b6c034152a7e8ce28f6989683fe42a1e41ba0e61eb095a0e73a57b3fcf05d32d389ad14213704da921c1bb5c9631def9b6286027b5b2ce2bf1687a61da1901493ed63c13a64a8ef36ea81fd4857ff4f2588160b318a4ce9e453809e8a055c4442c3af5ff90773824f1b0f4b6b0c6f05d6c364561c32f84efc2d79848f8ef74efb004933b25de28dd0006219a49023db61ee38fe5325c082fd86438e42065a5bd7695da8d3e74e7b1c97a1561464c578d8f7f2ebedb7f8761b31dff4bf262c7cbd2579634fdf42448b301b847624c7fba03dda4a213c792d78d1be02d12774946319982230f737edce2c91d4fb4db41ae6f1faee37770104c8d9ef6a9084556cce85ff9eb0a869eb77d6024f899ea1224b8fec0d1ded0e2b55e79695ccf83add14eee5459b2878eb1de31b24e3dfb9a5d161c2bbd002f523d54ab10623a788334e8ffb5b29b4ade663312ddbf3223d5f65a9bdf4932db1c3323e2c55289fd628ac486c9ae669ec2dfba3bd857cdc23d9429678a4dceafd4afd7b17c1636cc2a3aa783cd61ffb7bad99bd5037e31e4ec91ca91e1efce3a4806a967b8f8881d225f500fc4caa320b259a70be1ca22d1614cfdb7a766153b4f7c2df254f26b62b99d2f1094bedadad787835e9a1588fa75635aaf4f7cee4372267a21e442770449b920b8af5b799061559a41e603c73d8a7f65d74c1681d6fd13a3f3bed4d9ba068f4e13b945417f99c5a9e4793f258dd77405c6c98cf68dcb744e067bbacc6717f915110f99a6b8a6c0109c6defc100f17c55e1055de5b162af474ce2adf3641dea04153ba823ddd4c8152647c2bf55826eb0a90fc03c22c9f509927b6340584a7eeb5c949034edee1d2864beb914dfce15f48b50083a65c8eacaf67a093cbabee92dea0266bd476654d5a9a6311d23b4644f39e7cacc83f27e3cb693c371cd791fefe9a732a462dabc4bea374851f76e410793a6a87566b3b89be3c0545076655c4abf1cc0175ea05ee48e5ea49d168c88e2349092f95bc67f3d9c35b0588c6c05160a3a4e8aaf58844cb5f9e2b6154cf42ab7861293b46f7e491ee57a832e434fdc5eb0dbb75c293016cbf608b651b8bdddcf7153f09d50add84607145b4f321bdabdf0a0dcf6efabcf5baca5d3c6b8c22e2b5ec79c739b470332748b8a4e498fe5b67ab45e0232c83f0ca85b3de9e1048b15f720de29555918a350fe2a77eb019ac3cd8fd7e5f93ff2e404e56780e49a8f1827c748b560f5569b5a63fbe9640d2dda416b529a39e94e9b0449308081c8c54d6d208e2ec9dbf974bddf707898abc50a2a2e7ec15ad3fbc588d1e592d35a0c690cae9264c123d0df1ce8c9a0a8f4f80e8dea6fc40c7bbdda4d17a66e3f7efc8e81987281e38aaa42294ac804e24039b483a16544ac422073e83142ecebff0b723514551dcaad1317cf8e897f7eb1cfb655821e9016810df799fb737ed4b93347f25badea6a247edbdb410a1ba1ba7b9a0bae05aac3bcfc686ec62699de20426cc4d564489a239042b574b2d44349c0342f294f8e080e639cc20e79a0ddac5f6e36d7c1dbb9ca06d05fb160ff3b02f88df31a707329b4b4e28e6fe4b70b57d79612b43c12377e7faea088fa82a97bb5d4c5f39b30bed4eece37eb452530d5492ce937049a0b62b3026cbe20ffc785695e42cbda4dac7cbc6c12b18aaf2a2a5012d6698a74398cc3924c2e1989bdb3ea6351149f7f7d5d50a0171be3211f43895f72bb0a9e1f90aacd27ce91dbb32a9823d5d7b6321b8594474bea6003e3208ce54fc75f95176761e1398d40ce83f14f67c75a5f17a0f8949e3b1f7f1dbd2f2156ff06a7264cd2a46eec67e09402ba0e58a6985d8f4ec524ed1571507dbe5ed11d6164d3cc6aa14b03c2e2564a5815674a6e3b707dcc2511ebd7c604ca66d2709ac1bd5d73729be36ebfe00f527367641f1b15f683498f3571570f7aafdee7167b0db8d5ff5ca619d8a7a39e8d0e9da4afb5ce39c96de257b05801228f3f690d14c6d494d5c8c290a8f412d06adfda8a57ec4217202c67a18207d0fb765ab7136ee3a390606dacaa6366eb90665b98acdba4584faf37f722e41ddf5d3043f11e50de9d7c55a3ca29c9c404a51697fd7d25924817eb2c7d4230a263758dfae52e8899becf9cb98c44c3fda41ec240f944a28ab5efcf64d2c389c15d8fd245b637d95b0992c7f3f64d5f9cc1d3b98a144b5721041d77c5ef751c348160e040284a9ca3fb6c7e092b7fe62e29680278eef809052ebf041f8443f2cfe76a45d8dbacf9521048c1b81aaba983a094d4f819f8f486377ee7e5c27a3e4e6cc36e56bd1c5b3853be116fca53b6191a6d7f04044b25c0c10996d4d872152563ccb22e603a7c5ef50c4dead269d2786687b2b0c92e4a4497d317fcfa773be1c4f0198edeb3b4bb936a504f78dbbf0a1021e6a41fd06fc58e04ed073e6417c8150e4f153be82d2fe6fdc67957f403553a50a9a9e48b234d2d7ab65ee4885eef734779e6cf565a92cb31223e1642f22aef6faeb339449dcb4c78b7bde1859a776aac5b336072e51b1b879444653cbac48f6b11a53c38e05475eeae846b5d61c9501d8f5f66defad471c0abca6f0f8cd2f2fea65739e54562863c22cc83cb84fafc8b619b9321eb069f8385685ac143875f31d7b2c7d0503e691d9037c4e0dfcf20fabd6d912ea7cdfddb211a37eab217907c857d98ec9b3ce182d7d3e585ede363925801d9a19d06e5ca97558050f44b6d14d48b267086389e8ac7043646ef50eb2107411a9cfdfa2ee1262c8edd6aabe06c36cf720a081555815b08019b143a698e2537f2b8bd4e84c1c3fcacecba78e5e52bc4194caf300ac50992bc627a4c59a123a9bcde61db4bd85c5451c17621ddc511baca1c1772999e47cc8f71e9c6d876dbec10c48dbd3c9556c934605c292f276fe83e655d0420a7601537f29411ca81c659b0123c09624cff50076a545358950e4ea79e8d7b1f9e9b62d42eb3322fb258545b0361a7f60329cea0af0feae007bcc460789c64bdf498f442a3e6ad1ac8f5654271a963d7ec9b33a4d9396ce8bbc846cd669b746843382ace4af0265392ace7e4ebd6927d6a89d6813aceeaccd8d13dbf4405612e6c4b2adf0d057e880eab5486ea58214289ff7cb0ce43808e3c2a1e873bb415e84050e85a27d4b898c2cb9a28e7ca4be9c5d60de1f05b0fbf5a3349ca042945cd4666631c22b69dfa8e85b3d6198eb508cf5002e6191d053aefd958265d733e2381ff151a9d6de93582c4c55574050234f79aafccd9f2f8b51f956a87a22ca2f022c1a58d1ae471a0f6bb8e0a512a6117c899705c7d55b45ba25b15b7e419803c99f60ef21bf856d9421d9fa02762da26246c25ff571f01a691c009fb1f23ff94e5f4236bba32ad9aed1f520c48e1bf0a6c3bc93ed958eaa7727e0bfe74fab9480eae6eae44e591a65b5709695ffb5dbdd63a80e9b790e0f8c39edfe53104424d07220ce19e7e689384fc7263c7fdc52719417dabd61ae0e9773d63d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
