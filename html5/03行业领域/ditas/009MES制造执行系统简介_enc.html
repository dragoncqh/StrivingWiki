<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ca28af97a89aea9470b539f010decf7774dafa377bf35b6bbe34106f5328dc3afcca58e7b794d9f6269dde01f01ad289f665df30a47de2785a9111c10a4423c1e0a1750a455e1c16c796cc0fa9029071fa756aeb13ed46d9835b3e7dd4d14e883161872f5af24f4909e4318510f754f9f6755c2370938238bde62ddf6f1ce51a141b73c222944785c931fc86ace8dad2f26dec6f23816cb316bbec63c1a742460c5c5568804a0c4b785aaa23fbf63961815af3fcd5a24e7b938a7183c864e940b2bd812c0ba47ac34e43cfa53c0f55066f7e55b2b0c9adb1cee9d13d5a2aaa27ea8752f24f3ee34369bc74e2517073333a04e671b262803af8478c10754baa582c001b1ee9f2504fafa79a1fedb8fbaeae24103dd557f297024135af18368831d285a3dd7135750c89b739080ba08ef7fbf4f1764b050e8f3dedbfe6df209976e1c7bf9ecb452197e249acc734e4a1245c0544e1aedf83ea6e73b9bde7e7bf051af1715daeb89801e6eecdea6ea8c2ea9f2c437e8a2f195d06bb43f5e77261b49f3e1335fc9b0bd6284499de852014592a5d2df8125dbd43bec07862b551b8b99d7d2d35e69bd480e00e4d64b4c1d1383e8d52052bc7cee4f7c1b94d7d8b7cac5c88493a32768d0260921f86a3ddbcf43199eed236850f8343e49dce75799898e81f6dbd9dd05d390f5a0c8a13f284f7797e945d3b2fef5bcec133204736cf94a4bd37324d0716182715dd84fec97cd301c934759762882f72e77da41d9521b4547ebd151d6a7b1ab0fb01e9b842f7c25bb2f52c1b3dbeb3677081674380c9e75147cc05c4c4e7a0845fa8facccb4e67b687d32aa4596cdf60649695c2f200a36fe6c41ce5d95054050c0f0416bf21b8444182a9a0086677b87ff6b75b8ef2dfe3a931c11cac1479cf0059929a97d141393b020ba8d7ac5217cd16f0dcdac530bb8f8cd7e2c0a36714b42d023281274fb147e181de07d7093ce893d116ae8c8aa3bb58f38cc71a366b65ccb6589bcec1a08ae598e310d1d0ecfbcc5232aec3842297a9549606788f484530d756053ad6cdc1ac404f6fab40e02f08912698b826082afcb33632e396083871f8a373598238e518762d915eda7466c34c7a3d448762f6453b85d004aacc867d47ce738c1a779117aa625a9e7209419e815182a1e2249a436b26c4eb188c3069736f8ee137993fd57e043a18f022e69182cde1326cf51d2a21ae4a67992e47bdfc9cb3ad71220188d9f9a41bed2b7ee45f14875d995b9aa545780d14f77d759b35d77203d7036715b26cd04efc460124e8433b58f109ba715618f8e35ff23157c62c3072fed9783b12f5522014b6a96619a1279fff26e61cc47fe5a4550d2f4938cd6ba9418206485d27e919fc430072de3eafc4b759e0b409e10d016a3a37c736081b8dc75766c4af4e5149eae94ea527a46a3681e800a893fa7d60c74c684a21d83f0ce6c56e89ba3215101d69937816154ae799a554aa456bbf26900b9876f01095c7d6203afb1959aba948f2b832321ca15f1726493a4485816aaf32b83b006f14ed89ea668d0e5269d86bb6414dfd230d7a9a09f0dea6d2ab164ea550a4dc810353a7edc11f1d779bc4cd0872c0f94e99f01adf0c34fc31ec81de6126a1bd520d018f13befc7d1da6afcff61c5320db0ad3b394169af81df00d9f99c5bd0dc0e7d0ada0e9e6419af2ec2f1d3b590f62240935cb8f05835c6932193576014de93b9ebf93457c7bcbb86d311ea3c75b182f82d8eecf9e468b962b8af7fff167b524f0cd18474865ca814926b8981ee7351e240dc80418c9d6ac4c44c3f13bbc1b34e32bd7761b99c77445f94def7d2b11259f82e3f4dadb20dde595d9950faed82dcf1169d7de5a70b59f4e067950b982b4fd14d214708bf679bc1e9c4a0e8d497d81f79b27e4c25a1f26046be06e4ce567b22f3ddd8b3bb35f9f186fdc1c79ca5d3a4f2f4cfbdb48e4cf12a85aca1b2bdea196113c0ee5f8058dbdb8fb765f106e56fa215fe53daade0dc350c5795c49e6203df2a3b528b5cc88d9b41e2bd145f73749a37e05445dc54bab35d1585d731d6031e1a47776036a1d4674a40d43ed14a95f82e22716b2e56fc3a08c9ff765e5a0b568f7995bf4135520ceb595ccb3fd400859be7667459dd07080dae4d027c35c4d088d935abbe70578a580f167054a41c2af1ce18b7da2e7b68804ff1d394d226fd14bec1c8b22c48a21e6a7f41d0496548e8f0f5165f69e0314f8c266142e04f04f72b65a762e62d86aa44bcef55ce1303c7a8dbe637ba692a2a0a4c1263c9921bde153909ba4341a63d4b897d6766b16d75167a761f1f94bacac6c6af4c03e0d933aa1b255dbf0a2df16f7a67cb2ac9334217220d8499657bdca2eedba2978644602dcc999c1d6c4de89501b5800b06fd501df5495aa34da7488b29c6c036b7c0f5a7f71b4c891104f13ab4f34c9602536eb0e150aa566d11d425a622c46f9a4f8b4b415ab200677b310e2f6db9d2fd2257d23e065652176424de076321aec20825c3889042a36b0c0d9911bbab13abef6413cfc90c9ef53f946cdac04a0a8858dcacbe53e649b50bf32150c614581ce7d08d2992d403480cdd0fc31d5f7293e094c34b7c2f048ef452210c3ba8f7936411ba475abe760883b3c5b26087096fba86d18718d26c1fc635ef1a149968b66e72760800b00f4c3971ae34dc90092b10137c9eb938633b3c1069243e7c493359057f1ec59ed041979837887bcda5ac29625e31e97f673a84b4782516ca8f51a26c5f395535f79800c3f9180d6231e0483f8b8c396456c9f379e5210279fbc07bba2ff6755f0e5574d90850993ec722068d4db3fef38cc1efdc5e355ac8335a360c7c22f36e636dc2cbc0b729864f3bf7e21d94bfc355d9401ef0546cace36ca4157e4f219eb9e24cd548b75edf9806d1cedce129f6f718ff02f5243fae7c42fb1593d7649fea2d10aea29760c3da506f64145aefa1dfb3c7d7efd2f5aec97972077d4d936482eabb414bad17d6a525e460f67adba76ae27ce25d156dcf7c498f2708b5c7db6c4f56f1ffac7b247b55a29a1284850da020c92ea09dd2cd8adb415dd1bb7bd9f84adb034baedac35fb371dc6130e477bbacfa3b7498c796fe6d5432348a5e6df9dae542ef2f8b18d9986277fc673d0c6f7b31ea2d2da93ad314cca464bb6039c85d4091c18731b2d2b0cf99ffef38cdfa64722370c1aaeff8a1a4bbf830b6d7577366c0972aa1cccd8c465924d584f7580ee2449d91cdb48bcd23c60cbbf6d7543556bc9f66a1aa01a7f157eadb58481decda6cecadbf10bbac16635676872e49e393dd50103af87348e74ae5c4c390f32adf957b82cd148bd01f50f12c6ebf1208ca9c4919afb140604b7db57730e055dc0b8b46bf79cfdc33323a4be967645ae26d1dd1aac68ef516572b0381b285a630164c51e168b17cf94c0eebf9031550a81df4a67a28c1efe75a53684c2e108e578a7aa1c8daea59717450ae66b01fba873528f3621e533c9e0d98d3a28e4d2e45cb48a2a2c02e674c03c9fd4bd3b845cb968853c62273140328aed754a6948f36a02f4b0f1f29f925ce37010bbc9c739a501385f7225939b6f6604168166e1ef6e8502423425a74cf792e8805a5864372a07a280e4bd26f1b881bb155ad9b176147ce2f98e6582b1cdef169b8447d23793347675686c2cf8c1a472ddb1e5190dbe21c048e86fcac55d387a5f01df6ad9d95960a3f847106930d6a4658c1264abcf4cafcf8395cd03c7865bcb0d9d6e17a53f38493101a718dbb0f1913a9b6798f307e19644285ec0d7dcb779d1851d8620c0171ac8ef7d2c278f39140a8c9dcb2fae29160127c44117e8f3206ba714db60680e0e543c8ca117500a78c0843ef0ba16150af1c4c1f9889e4acc23ad0a6f0ae5e5e6e31fca0a4b480d479a6a7f70d35f93d30bc391cfa0eb2764093e1db9c78b23e08b16da663632c308d624b550ac33d92d5edf50e6caf6001ba4c9188557f6b2629a8129d4d337bf6854fb75f9181082020517b0db67e4e3a46631c6767ee0b2620ae695198bac1eeed2349e9746c628fcf8d414291080b2976dd660e0786d47c1fb1bbe33aee0fda88047ac3708e853f109d6e86479d1c19ab74708c74f9385b31bb9d962105355b7698fc57901c22c75b3b507922c9b510c5aaf1366b51276502fecbfbeba4c8c2a2c1b27aafb1e4d02957b5df229de6502cd6583c0fba4d72384e5b7454a764fd59fe4e7dae2994960855fbd22f45a3cc0a90105213607b9bcc32950442d876c1e228d9b5c6f3feaf135221f6dfa86b35c4609095ce65665c44c655e07d58d27d365c609ed21463da46fe7fc5521cdd11332ae690e3935e2f5275efa171134e49f61a004b50dd59983eef9a0824ba3014c77cff895fc75b14dc803e73a8620ea4c5bb2d5cd6e6db812691a5405f39d33138aa788d5bdbb66c200f324c49846a8833d0faa08332a5381f1b60bcb8b297395d855649801c69ecccdd1d335598fd7a44efc6444737dcc666c6670265f30715f65bc33e08c9af9a1475a2b3e1a019a035b4c3a2bca3152745a25047230ef631afe58ef025155e8fd2bdc35125e83aac004c78f9e822461eff46acadf7428ad0577e027037cbe6d79a9bdcf344f17829446cf10ee8921df4544de600b3191a02f8900f6b0b91d5c6b46864846cfb4870062c0105dafeda2f6b8f72768d9a5fabb7ceebdea2d08bd874dac0e17d9369ef927c448309b6ac53cf229f11682b26d282602316508d54d464425d7d425cde99aa789fe904c645a53d5555b9ac7a5e2c85795d55052fe89786fae7aa52e4fab810a2c37d2a4c964d945b233ab68eddf3a8d056bbef52b7a74c661b78d52fe58f2bd4488642114e3a61a20112d72e627b10659de9e62b920692a722aaee34243c20561fb157e77a8f02f4c9bed4e1885a7cce029775111c642c624802ff4c77d77f7f54d658d73a867324941eaacec82ff4f87607a6da59b3ff71d58d827175f59df17ff850f85784759bdb74bc818a4853a50563e6cc482c6f3da1837f2e2a05e89bab6de204e643c99db2cb3c0e4bb1d742bc639d1d80bc3122c7185fce39741541256f2f54cbb909890bb8ea9071d3365bdc16d131e3cc4741978628f1cd7604867f08cc0ee3fb4d1c3e1acb1164219c5ed50c33f10d9729e3e8c2ee5cec435d7d1660f2608b7fa0f040761deaefcc1da75205e27cb50baf04af740e6b6edb2ac05fb56e9d3a5207d6808867bc28d49964f889e4a6b9bf2c73925e0df0b1462705b2adbb89d90f40829c0c71b7eac39191a2c8c1f155a7ae3f8a96e3f575b568a1b8a8432d769182990a75f3a545ef6072b62703386db57973dc4a2d9362c6dcef6a428fce6987646d7203c49cbb4851fe7e7ad152f7d464456eebd887dacf2cb48c61caf309654b1077989a8a0bf5743eb6db85ed8f4ba4ade36b48bf032decf079f6f6b37076a1c6b09d76076bf5da741c7a984c04146b48f607b57547badeb77ba6f23be2d62712b91fdc7f31712d28bf9e8c37585065cc5f86a51fe6fa0ee496bb9f8dad69a62addbae35110c9e5a9c6dc5c66f2783980bd052bc5a9550f81c1744472a782c97d78b44a1059efdf5f08d5f7ccebb2a881a37fc1279645eca08dcbff16332c75f1b96190d09693aea98d13a22cefdcc4258ac73c36a514e58d8acf4ce0fcc99e5b2859cfba7b07f18d3558ed03e659eefcd7f9e9aea4280fda16bd45e04197de4af1336798e2697861b7436a520ed6cd19b93eba84fee71794d894b4016b45fc52d0196cdcca52a0fc7df5b18dc3e58c851717672dcd8b8257affe0c77dab346f42d4fec674dfa98f38030cd48f6952186263f63efe69b035d3fdd6ad8995c9b6ebe8030cc2423b695a484370323d425ea9f0c72e478b7b947b7e949d4feb09b1cac18545b144918e103c91ee1eaa1d4c8585420b9638a7f10eb66c40df839e250d9bd9e7c32cf5cb662e7505160cdc5ef7074d8663910273626314229f36a3aed6506900dd2e97df7083e2c72cb9a3de26d9e051d9514a21135468e89f8cc6f0998442bff0d801c047e8fca0d2443563386778a8f6180e5c230c833108ebb062ee54a513a3aaa5a306143725de329368d42ef09ce978aa7f72e68f112d57208993b2e6d46b876841f5ebb8bd5997259638d1190feef6ad0f6adddf2e030ac4136945a3e25e771e66f913cdb79e171403212d81a651a0cf74949a1f50acf4b636a73739cf869b177e6144b26cce0651a5ef31bc9b1db6e9071e84f1c3ca15b34a52d2c5df86b764f2cad845e7d5c8a94c44ed5c5ec7569e7dec482da3100f86b9c4fe42562ce88673d13acb173d3d202d8ae79a7600c7b437d50e9841848d4728ef9b0e6d249c6494e312dfacea6d5ef1794e89f038471323e9b6ddb8b0cfd72acf3f80b9b6bae714d23b0dbf0c05b36a6ce387db657ec2f7dd4edf5ff64353cda3b609dc716debc5178a70696e7b756568fe27c341a70829f96c7eafc384d67cf84a0ba174322e8a8f1144fcfb47d55670e351b7a7f7871bfef8eb04caac2a7f3738beb06915ac00a4465ad092cc3b37af4754ceec75fb7c5e730576d3445a0998b753b60ea42b9b6960827cb67bfdfb8516bd0022c3aba1f9bc20693d13a50da0a0e9d56c8c63e10121565e6bf59fdffab2761f1365c7fe190579efe22af7f9045eb38c98828894ba1b1af941dac3abe273b795c9c2e08a82b7c1f0ffad6b5c7e43cd301f0269d271547f0486375f48c8930734c15518befc64b23d03c30fffc41e68e222d9aa0dd879de6a307e351ec4c27d08f8abcf320a5e0331c1763fa64ad69d85fb3584d03c1631fe6d8f1deae844d3e8bf594fc7fc05616d5fb20d7a843be60ee5d8dcb177f7ad1b02902aff211b636dfc20eaa47bb22c08d74b9c5d4488064c1a4abe5b64907221e3fc5a217744d3b114121796e038d68d2cf19134dc0b36270d64ffffa6b8b3ad6a0385b082371d4cb36e06b062dc6b67b5274dba09562926334dbaae42091fac30940c8f83611e74938441761bd25d7890b9f67d58fe726d7211f3c8740b665ba286b662f6554f731a84a46cdb6e19c7d85dea104a1235dece9664b6c46a2fb634532bd2bc3e008c9cbfd0d1c1ca6c219ec8b5db51257b6b6b373a0410a1dd9f069a2d9ac9e531b9d2dec62ef519d65f0f78a69f192929f31653aa6065f0458920644043d3622c1908466c99161119841ad54e3d561f695d3044a2f0f044d21dca7e51984835b2303a6bde0290717d6a71184a98a16c20ba1dfa29ea55c7e35125805d12db9c1d17ed4a712962088febafc027d01489e096da09246f7ec1da25b0de3bced3a6b4d851a253addfa5dca5ca5d1a427a5fb8d954b5a8ef732b38fd72cb84c8979a6f5086b7d3b169d35f209367d5850c691e8f4a8bd6f5bbd315a30e4004ad5f419dde5dad4b2dc681f3f45d3e8398e1266a9fd0a00da2e1fd938ada67887f5d20cc2888a437be42f54d36fae68489c546c8edbd651d324b3c1c2fe115884689ae93c7f0293c856dbca333213b08f74905f3b153e92386ba7805586c5e021fdc9c8ec6119054793d9911f046f3fbb9e3a74f45f03fe1cc67d550c1deb21d571459e6b4e1e3633b959170c6edafd5fe801ad48a0f137642f181fd6e07559ae3087b6c590fc1202df750c45ee7fda03388fb387fcfc7c9e1098e2ddbd7b6cd30b5b800c309e5325689b51014b74bc3803be7a50f0efc37dddbc6d05b0014395d5aaabbe01c33ac50966b51e54d7cc657f9a9eea27a6024a80d1c3a2a7a0f3392a91a4a9a0c629032b7227f79bfb6611370266599dde636160b3b557d00346b46ce75dac573f39bcc2638bfc3a0c101ec91b2e70d861081e59155f5e901070b69d8681aa25a97b7cf8423a61c368e21b2c8dcdbf6175c2e94caa5dd717399992ebf1a92c14256334f8b2e1659cbf2c3cf941181a558895937df92c702f919d04460f3c2bddeefd338d5233c363ebd458dc83aa04b9a3f3b8f8d89a9a1945ab26e20d3e51b9a7f8cc14392f1577fcfda041fd12113de2f9df336155ba2aff8b46aba71d2ff6fcb3ca0160c9e91097b9f6f04108275ea3fe060f0d58461f7448546d712a92e7e63c3e9e8ab2399c66a54c5fbb0703ac411d9abca48e5b1e7fc852807b3288716e196f69e01f0999dcbadea35b62a0062f16e0e4becf16f81e8fb366a6df09235600867702a7ec9a122274ea3853bbe1a608fc810b4d8554a1f21b9ed548e07df439d06d6a279de586438f0bf3ef1d298f621c85b851a878694b182efcf1f5d1d1be08236e81423d33f1557ad4c40fbf7fce8e30d4d569314235db61cd09a7198a58321873a491e6e0a4d544867302d91e3931aaacb5f2aef4fbb50a6320835ac19dbfee07621a1155aa4e9aa1ea6bc4e08fa03bf3b62252bd95341475ec241fa39347a49dd1763038a3b338f0467e4c9629b99941d7a9f0a549d551698e03823e13645d2103b4d5d199f96b0c740098f2667fb05eea69b80b093efda6eaeb087a2656da22d4f3c609c2d4164006fb4f6dc3523a8556da8c6f89637d1d88435a3ba76689416e0e0084ec4ecdb869e5c2d34fb1e463efe3e62461f636e2351137654b4a7b9033a7fa3b1316734a813cb7fe6f084017de9dca36605d3f2f07a741667d59f73763aca545ba4a0c5187e81ec95a5bbb841f23434510ddd681fe7b404059d6ef3cac9d50a3ae9a1bfdf2719ee29ca64015e526f8bed649c38eb7a4d1459d1f11ff0aa553992ab8680b3e6980ecc5b47f3b1bc76ac750d1c7424a778ba41bf451bdf6e6969df97bad4075930fc6b70450e2e39235abe20b4b8d5febfe2bcbc35e0c5a1ac7529503a148f87b531c6c1d858bf304c97ed4d71bcd6d70a25abea018e27dbe68cbbc3d177cd31e818c92f5ad3adde2b0aa82a0746ab151f217aa6696e3970ff5307203e64aa037bb9576dfb934a2b617e64fb82fb714daf2b349c10d26a206f6ab9f511b60c0b2a44cc033a161318e752533d3ef109247f109b7fa40616b29b60dd5fad7326462b8636536299fff89b44bbcbabf5da2c74d9b1484f923f5dce2c7ce15e3e360cac7d0e67968f3924c0d9f70a36a92efefdceb18a5fddc2c33436918018b1b6b5c58a6ce54fdca23479f8df117604af9174a36ba93c1c6273bdc3ab4593c1e260bc1c3b6950d520c161b1d4922899d6ad1c75e7608e40df0106ac736b5e7aea2b4645187a9033299ec23b834c15554045a2ff205d0c2a8eda13acacb88609a4d1c82fc2029ceaac8cc1021bd41aac5e0beeba406466df4fdd2139e2ef52d585852d7af93f2eba8328ac6c20dbdd503c383912cfb760ef88e1a4f84342d455dee875f1ae2f3d2bd93ba7e00de397284227fb1499d930042b92a12d27a91265e1b636278c36cef5124bac11a04e10a1b0a607a5556c9377ed41dc7c7dafca6c38935096b8a8387578514d5dbeda28c1e58fd1320e2a86fc380810dad0859d0bd13136745a8e8700c00da4d86e5effdf2d3fa8300ccb0565a26c50fa95de934692f62880feca4c0782fbab0510023cf64ea51dd9d648ba73f8f73f18c8aa0525e62347154d3d289d05bfe1b05907b9b802647c5dfb3a5ecc6369d81e0df0e88534115481281067b9509f8f55e8196336602b7c00603f3a10f174f686c04de330970fbb14a65426f26686f6aa37bf5a34029093700453a6a8590a34ae288ead8a8299253ca7fe58a6d06f2566d81a8b2ec008166f20f7fba71664b81da6b122a47c218069e115ad217d5efb4209a8a58310cc963b5a9ecbdd438691cd91296a8fda60018c2706bc8d260ae8975f0f66fbfd02abb3ea42e4fce45d4974212fca0915146e81dbe1e70dac7a0e650b4b495a98ea796fbc8547fe898a032bb04efbdfbe0290e5c90d20985893173e301f31bfa85488c7b7819853d654cb61a121529e9cb68e2b2ec5474494384165290480fca2572efb0a5c118e2b625f9ada9394e457155b1f5b278c67e68da5c98d19312197d7bd2328899f26894f7bc8b6a91cdf7b825d7afdcb4830e7705b4c3aef751c754a15dd70abd13c180300a0163422d21528a806ca768d0064c5016a9595f350524a1ab95649bc8d8084cd77d96ddc153421d964287f63d9408530129789510389358999924c86ea5a4acd8a9270cd5e4ba81c2b4cf7daeb29270a27eaee9d7dc8c712a4ef88bb3e06e5aeb502316f850d4a845cd8f3e9d79a196283f91dff9925f2d23b53dc8d6b69a314de8dbd6786e88b77196b3b86c6eb378e84d49ad2350c0c38d59e017f49b2d6027f6f4fd9c81f1269f2a57e2ac2e3048cdfd3535f95ad961a9f8b397194f7cf99df5cdd0a52d8d4c237be24ff8d16cf649b71e3135a7852c1b14ff1c8a4b013682e46ef64e5837d1bb73da836e1b3c06571108e6c3a46e304c7054f64ce6aa1af748fbcf3ef99daa35b4c874b58ae6c3620340c92f26c59118511174aa5b13e1fcd041b8a9427b18a0eabc5e93df8d64edb128012b21c2e63dc3b211c2cfb07621cdb608c2be15409d58c4d4921caf763f0725deca5bcfb4ca3ebf1b58e33acc7240ca394dde514d4a9315ace9634b2c266381525f384c098baaefc27e198fccd299f61fa91ad3e74d6478aabc58d076cb87877efc285d86157ad06fc5b9022c315a80e34946bcefbb92a4060495abbe6407e94e92e76b4aa0e78401f9b1ef2d1bdd2463972c03a308a53efa63f72190f460657a612482a3f1d21ada7fad78537ef735b71b8734cedd7f1e5af2d171846fdcb84c1136e87baf1cf2ee71f163df896d9bd2f0d8627638084cebee62956a63d30d9f5118a7b0addca03581f028d185025d6542f476c015badfaed01e096c8136e6c2cb9342bf94b4a7b8aeb05aa2a049013c3c3d7cbf13cf50382eada76676f41cae8cad9881729be5cc3edf9d9e79113ff0d58018f93a8b3e586b220a04a2ad33486fe76baf2722384d54cd52daa2336460b41243c5e1d72303e9851c4a16b920f03d19d08c72b265a0c58a96600da10fa12012a6643be6348004437a355d97b99af6c73c18867f0913507a813f0b8fe3a5e7e8090cdefe7f4d23a413c18e5de4ff14e832b8e00ba2d1f651a73797af330a3e43a91460577c7c6386acc7a47cf4bf9541fa63f5043045c5b6f722eff3fa9f1c133225872ef44472e0b3f3aaad53c655e893c740c23aef6e6d2368134467763229c8d7a8caa86bdd3a00f0c6629815c2611343d473247435a872b1adab51bcfb6b2459b14ef38e122c6212d1541587553bc98a55800898cb89c67854f798a599e6bfe067a3991acff482dcc39224ddf3f416dfe3608b64751302c27df04ec02628ed7a8be0f87c881ecbd2b96ca46d9c0a09840a0a5f75dff240c7864889bc29d9818dd2506dcf93f0bd53719936c4160f6eba81ea3387e4262b620c8a85746ad5820a590ab0721cfe51099d7885ae0e6f452c57df5a04a954165032e327054bb81b469063ed0a6d3aa5e84305cee33077e7b4621a7b5717f5ec5266c2d2c3af4804518541ac6f6c86e3875d014413997aef3b1615a5b8ca53f128196aecc048deb259f442770f05a601af4cfd1d1d2d10cc2681bff8d61a808c59e64c8e8aea92a96f7150eb4323d7d563259e77fb712544a819f6e2e7371b122f5f93dc5739a77c972d3aeb650b092a642b699e86d65fd88c9af3d9e0c312f6d166ceba5aecd2b5955783f611fc191668591bd3244153892efd191c1aa2da0d19670d58212f35d3f290287a6494b0259fc5a93db1699aea9037ade1788eb4978e1998f65ca6c82fe45fcaa4bcc3479a5c8a5256447659c0f1c502c55604f8cbc960cb403d5534e99fa7d22ff6f68d8fe55c6f3fab8dd448b6ee041080f49596070cc8c3c5a12152903be24313a5cee48633a606cd22bdc2cf9fa1cf56bf1cd67e472751f2a1b1b56f5e3dd551a0dbcf6171f1ddc4af36c681e47d75bf7effabd7a553da09030d96e108cf03b6f2091af0411b8856ece91c2af20def622954332ac4c2204a78679fc940a5e8c2f0fc6e523844858f54785e23cc6579e1c559f7c1244edd3abc0de666b5ed7c6bef355027f5a17eff7851dc2575c42d3c836d0ebe17ba1931e6cc94db8f5cb277033978e6ffacec5251fdf410df87501d2c53e54e854fe597b5902f4b084618376c731a9a0a17c6f6eaff3254c03cff835dabcc7ffdb8bb242957117b76fc8c4f4a5543c5e4e319bbb83092f7fabc0d56ffef9d5a0b62fdb2e0f9e91e3af38c4d1fe2a97bdf514250ff5c6f9dd8f5639697369d7b9ea606cf86aa7e303cec1526c792471371249b64688bc0188c42830a68f54054ed51f6a8eef631112dbdb297ae17a351dbafa84daebaeddf0fd1dd7d398a80a4050879718b691ccced348751e7c9db6b70beaa518ab31b6d7f3b9564327b309a9b3d3b9426350c41d339f155a151b00db5be658c48f93234fa949b2d2f5965c469ba7d98a75bab3f99a55552c177c3aa49dd170be94d729865143f3ca9171ffcd9055534718abdbe3f07a1745cf69095212dfef203faed25543d8533acfd8c1415045830f959624c24e9db030560fd69e5541a50a9650f8aad320debd7d73313e282f392b64077a8020d1b7e8e952e5dfdf970e33d533f6090d30d242ba57e9cb9baf586126aabd54ba417045953541c9615ee22ff4efff4fa37d0a9348463ddf07294a8e796992fc789a19e1ede28d9c2272040fbe41f0d743f4129b8d164d73c3caa3cb503c71e290cd0206d03515bea6b9b2845d1ecc5ecf519471af7282b630d4077c4a572f1fb2bb8403507981fd967527fcfe9701c29000858cc895f917db68de94cfc1db4eff61200aba39345e5b1eed172549be4b77a9d1d3259997df701e7cf754a351a00c7e9fc565f554382373de862ff3da06f3e9c8da863acbe46668b710fc9da479ea7db58a0fb534a8a58af61c82832eaf67587e59667cd74e336b232cd08e90f57ba6c10ce39f5ba98930cfe0b2e6a0f33d269c4cfcdbc6eeb6cca727832f0e060b3322fcb75e84fcb2049f463206fb823cf14956df6c05be6ff11e6ad2d5339753df91dd9852dedc26f7869a2cccfb304d86f6b32761b178735b5766a6a3b4ffaf8b0496721ea84229f3afe3a41556424814d1b5e3231363772d5375e26f273d126564f449b4ba29b84f5cc9c3dbbdaf0211451148380739182517a6da0469e897648b1d17e69facca37a7f630ffe3294021da4230ee98a8b8759cbf11acea69e4841bf7fdabd3b83a53af742ad740ece71e4eee195416a47531eb66826ea1bbeb8bc49e1a50001374021fde1cf72c58180ba5508b5ed8dd5c6ad538f4e11a1996f6bd67487ec43d7b4f39b098f560cca1d0a492c824feeeb0f958090e6f26eb041e67d61a1b5f89b59c6671e700fe3078459ca6f936601a5e49d63cb909482323abf05adcde5340d738fd7c31291dc4eef65fae5346931041295be13701c07f0875c2b97c9a895d635264fbd400a4723cd5066f8f5ba38dbb4714f2236d914860403c0302b35f536a6618200a52007a82b69a95c977ef1c0ab773cc3050df0dc9826081beb90c99058a4c54e625580522ea771c6fb73e07e7e65cf42ff826aab043000227906d9d70610254d7af857647d4a19e44d12dbf04d00e883135af2a306060283d1692c631d6d5a407c3d91b8535a437d4b7c88fc3a0ff530d11911d25a6b82bbbf7e89eb3636b844ad9558914a2665740b37be0c04df519f1c0f6d76595175e0bed642b08a5e95eda522b13f1399310d3cd0ad25456a9e853f174107f36237b89185cb4a6093fb48b21bae5059d89003989e182b322c901c26c4ada630c8bf9808041ab2b624077bbcffdd07eefe331d5932f26fb5ebecd2bab92f3c5420813e7060d3b00f985ad33ad88b141a0adb00fab6a243a5242e521b865f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
