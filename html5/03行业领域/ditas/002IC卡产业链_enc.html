<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b70f33304600c49f58a937c3c829d9d43b0cd2796c1d184401c7bf232dd12d4bccf8fe61e152a3a04b08377b4320bffaf630be089950eda98bc6ca7ac0de9559c406ba822e489d99a7d086d6e34fca9c12d1a6e3f2db1bea3264b8e62c3339ac3dc6745e9faeab5a99e1de1c792113fa5daa83139b854e107bf7205d7447c32aa3e28e4c9a2d2927763626ac5b85b0c12fdff2b0168b3f5ff4d0ba85ede23a2c6c8864d9d36dec8e882c5e62904fbf64a85313789dfbd80a61d92f9d50ee4c6ab64c7dcd0f57760c594630ff5d271da4caf5257071391b3254e61c48d1f5af107284e1fcf848ebb705432cda448f319716c1ba64b8e223d72b55d5e9b7ef4db79bc68b2781741ecae2b415b3e0d288644a9e69f3050a5d900d581caee4be0ee3788759b55450e6bfeb4962846c75891331211998cab54592772f5fe483c7f2a11d3a74e604cd49a069dc84d6ee021e823fe6cf2b21c5c5992755551f0efc010607d59edda4703bad9d23515b9e2b7e4687e670200ba58438e618e062adac9a5b2dfc517d3da6b536283a230d0ab28ced0c776806817fd28e8af0e3c4271679ff89bc9b1ff95648e047726cdcba9053684d186e3b3a803ad99b59f533ae0412946193fb3144414045c23e9b3e294c61156edcc2a790ce0d307ea993712a49f9544f3bf793bad179addbc5db681752bf9fdcbba1236e725b395e0ccc6640d563a38e8bc6874cdb69ef4f564357a0d09057d0c7d270e0c0635c4629fa5ce843f054b14ef5c7860d18c4463434224672729a6c20ba3a41034f45fea4a4058b53f9f3e947bbe8e8bfeaf707c2c0f4efc78478af7e562aafd22f1c7d4d5ac99a846dc2fe066aa026cc23202b998b98c3da87abde4f14d651c66b74688b9df18a1f257d675404815d6bd5d8b617805a1584cc4678d7a3b62bb2de8d7841e2853c2ccc89a2a1082e629722de8a77cf840d6c679ac9499c164709f57fcd75e77b0a31f6bc0e729d721ae8dd7036ecd05d4d6fc421b4253ec738fd58e4fc6ac7358637883555c1d4a1376458b33718d604da6aa2fc14ebfa120d076f6f78b921c32cd9fdc8df37a072cd2e0e83bccc9f80236265d13ecf7c2fd92b7c04f4394886683f947157cac7ea1216a875b19165e3bbc32c5fba9423bb5049e506348c587815c1b08a7a58ddfdca670e60e70683090c245f69959d937fc6a65a1d36b8a3e1639a84b5cf3d238521edfcfc435548ed7b486d7e0f7e28f61b38691e79f3b7ab7c05b966836f129fa12ade823e97b48549fb58f842e5829c2c71aaf0765fec29c8bc3562af31bf7c0b0ea2fb933546c26bfae68719f645cfa3c807ded38aa6382fba3b77b40a16eb608b293c4d780de794a3c3ab2018913a2b0c943607308dc79c2e591a001990bc566dc662bbc9810ea58ae409cb3d89385815c61623275c07189a969d2d7d9a69e03500cf9180a7a889cc94efb1b24a7b863917e9c621c2823f64bf66031d4158d589957f582bd39fe253ff2a174379c500d41c3fdf0343680df2542d1fc002d8a579e6f76604ce1055c9dd3ba0266574b61309c35e3568d00aa4e4aed3b8e182ba371c3514c99290284d6710975409968a96f283672b3537410daeecb28451dc6c8752c41cc7071e97488229507ac236c33df4fe511d52ae43b25e3888d959f4c8119597ad91801f879a4def86c7c235bbba587ef645d2f706eff3dbaaee1269a35a29eda433614b971f43d2f94d5347100a23940e5ca3314c9c8b1a2e22fc4f64a3f2abe33c9ce2a05520b302b0047cfc484ca0eee4ac0d7f902142f55194a39a0fe4c0d4db1b90b2068e4c40f42b126c770aa275a25bc32c44f273e4146e1ce19b07674dac310503edaa885b6eb3bc97fbd3c6303bd6d5c34dd0450522075bc11da25f2ba9f2bbea8de56bab148db297eb54f801656bb029813dfb7053a3e6884a1fa4510f1bdb2b7233f2d9e649848c955645ac9a76a6e853bef386069dbe788848664127c08b1d68e0c12b182e56bf8cdde14c7b193507572d756ffae2b414df2e230170b4007c0f9f19fa027535157a8199db0239285d26331dda582c52d89f6fbfd84eb8e0e655b42197a7059f6a2c40fb3398eacbf71339e5bef7723f9406095d5c3ca75824171ad37cafa52e251a30673238c3f91c7019e1f8b6feaf0dab5b10101dbb2510f884688e73a3fa5386262147c74ec87033605cc945c69f955000619c40a08ebdf82ba4e2c30d318d0e698aec88a922d7428d4e141222af1655f5bdd4675b6ad5ee279829fbc4859a0711202fb7a9257126cc9be5d454f9b1e0881943f5747213ab34801f44cc82d3deeebe595d9b8c45d7ff26449b7b5b16a0e25f234f60d7bf96607a37b08073b45e4f66711645826ff28aee9e16f7250021532e35e802590755ec96627577f9acdf7865e3ca5f20c3edd854637d1eb84a0527a4eca7c95a34dd43801fc6a67a7bdaac291ae7203374ec76a420a8c25a00f6a185dab99e87f8ffa9c5914050f3af2548142af3107e4c311540537776a990a2cc0b8b549dfb6f69d5280a5f42f2e154632b5bb163fc8578643bcba3cbe31da1d3cc13e726c3ac5fdfcb2f8b1fb6af3c2f322669b982f7f3565d2305106ae854735a63331e5e398d8d5f88bf168583d22b3bcc0920c45d1895910321c030235fecdcc60687f83b81b8683fdead7afc25697ddce5e4173a02df7921d8686e851e1e7ba8c8a7944742d51176b201f5212182a109862200fd9fbc5bc3f322c6e14149f4843aca61edc8c5a33b4d7dd2a745306a8debfd029aeb07f210fd8f40258ca30fff038d46efc38b964cdfa4b901590ba509ed53e7d3c51833e06da27b7d8839a40b2641003462e5b970df1b90dbfbffabb42ca9d6a00402c1f2a9de42a807bb3da7e5f31fe0896b99093c9b568fa6454cfd887aeb402736c583c157ad82aa6b53e2563a3cc312a93813e12d08b84c7227b9fca40d194cec5ffcf4214462bd0ca4da0141ad2e105c204f9bfb581a33499429c4c8ec8c9d8d99ecb538b6419c261820b349e938d8f7cec336624460cbf6f8057e962a242242e25acf010984131c00c765adbe387c0f855e0b6c286cb15e4799deb313696fb4e24a141dc4547abd45f02b6d04f6ef4e5e404361f25ebaaf5c089f583a88a976af38e69798d10cae7f8661ca339c3168eb857096a2c8820f0ab9adff53d8bd236173f16af8182af71ab7853a3bba5472cfdb019b2170de1e748e229eb8d0a14886e22d0a1063ad66fec6ba459fcc66d2a24a2ab1e511d0bb210e555570bc2d1756cd666513130afebd2d4123e677073a4d68add57975d76613c8799853a5da6e672a9b194ce6c178accaa32723f0dd24b493a4b04d24e3cb1bf41f2d04bf90b07fb49860e70b76bfcbf8e61a37a0287702d2a87ad3e3df7ce5a4edd991d226e9fd2b332775a12a3c39513156af72e9fdc8e46892c21908899427cf847aca1f25641abf0bca789bf88204d894a1f0291e450b92cb6fd17b4a72219f7fa3d429e32caa6829dfbc9469a6c0a7ca587bbefd9f6b44a53d1b56534b824a187babb2206e1b2a63193482a90bf279cf6d4252ee77ec9211e4b005bce81e4a5b0916fc68b54ab7056a9c6102b47369571a6542c98aa9270786285d503184cb9a558c9371843697b4910a550d6a9ac7e8bedc35b15eeea3e31cd26461401f2104def05c2028042768c6e46266f467aa0c345c09173da175a69de9972fc202be30f52cc331bf6415076592567d1de9fefd7dac41e70ec14d573bfd21348850730444c60283f6488455000b9aebe2982d88fe7543d2c861e8c30d4966e2fc89498244689c31639617c9264b9c634b3f81d514942dc45d6d2eb15796ac2f91d0dff94c7a60307f8d151584a08e86f8ceb7ca6a83fda0a68acd2467ec515b66dd75c843026b0cd03e4bbf36b102ec45bb447322a7f07057295d78ee9ef54e8691fa3ef8ded816457734c57dd8108493392b6de08b52421daac9e0917ef4843e2a53291d9b9f758e63aa058c44a337344cef00230ad056acb3bbd4cbd05f7050b8f07956db724fdc4e7be6ab717a3d296e68f096fe08a6db761631ed6751ec923a2b8b15c779082d278df510043161626ef508c5f6170f74ad3fd0148c59f6a3787a06b158fec55fe2fb2f27b32fa7990fa357a1181528e1bd3fad9639a3a3397d04a60f412cce4fee4302a18e9d7011bd664729f2f52c1f013011d39541a8356e210d2153ca6fb55ad4af19ddf1b48667d28217de62fae571033c7f03dc46f243b9f4f010c81c9a4b68bfe5e3256dbaf26c61402c93b9d20925e19c310407ac0e83383ff9fb1aa35aaa4403ace9b9b6538b9b6b2cd19b5528dfadfaa32badfcde9f67438bf925bf1bbb4b468e3863744c6b87c6d7a358a9b520eb8a8017497dc6c6009c877a7c6e35edd97459da57a65dc4c229873cbed661d3ca55615f63875f6bfef670e315327faa9bc0250f278c65f6f9ddc34d63ce652ee12c41c6950ff10b50d67971d10ec637a5af1e70247443be71e846a361c6d2f0c19bd2198cb54ff8b6a0bfc35b26a1a79c82fe7b38b2ee008fc6ffed250f6105fb3c80c0f767efebf0e1b08d1c8dbba7ede6096f88af3406c85a2226c9d7e2fa9b38cffeaf1198b3775ca80bb7d831be9663fde23d9234f59500f141075dc95a3a8df6219819c516c8e621f60d740b6a30462c35cd27d6c01bfb8c0b9c97a86888c9a44ec0607cb1d58af5b0b97ce69d2065e136f4b666486d9d5500da6cb214bcfbf6539958290d585273997c119d214cd79f79feb7bda39ae707690b5cb2c68f15033a51b1ae98404f28712c9eae1e8dc72b2634e74587e26ef0b2a9dfba53ff4ccff225756db4a28a57f56cd173a69cf46d869ac57799c236f18299e6369f4ffdd8c3e238953e4cb0f48f4536875e85ca174c6815b5130e16625925017396620c408d59b02683485778c9896f5ae492d8f9ae6bcd5a399d37187fe8a2ab6066227320e936e9f2eca6aa7bd1edfad01ab75cd493314188e3490836a4a921ae0e7f12bbf6e1e234b67751618e9140f72f899a899c7280e89afbc2ff3f0e376b43b2540ee6ea12041e7c5b6de0608f2870441b3adfd9508330183a74627d4a86e442d6a4acacf239fc3dfafd50cae057cba00c239bf38fe25fbc3453ac2ae0cf04b2f82214a5abf15bd99ec3c11c491e05ba2dd50a153baedbd9a058a658b0e7a79914dd36fa939b91f710db2519cb6fe8acae90b88c1b3dd37baedd48d332d6073fbc704af1c635f129c09a13b36a5f71191eb3f07ea9e865dfd7d57fe1cd884cc5028dade5fd46a14f406f5ed8f38508d3ff04a0c9620dcabd4deb96406ee5a7066c384212e66b5f12d12410da13f5c25f15775aff028492d29cf58bf614fbde92b241e0eab08c21d1a46c789532238d79f929b8bb07b546fff4f012b67db610b5b1a79b677d914420a71a678af5139fb3d2cd055861235137fe4f3e0db3061a4f9918e4831759c27a51e51a81f2dea7798756b207b9a991ffdb7296ec5884d8727f26aa56c3402dd43e2bdafcf42032e8e269edd6f7be82c2e75f17f22c5f80b93c7d1bbf00b15a32101ff7fef2fdd172611eb7878122fa316b7e672d348bb7b337562fa8aa2f679f8a1a677663a455006c9182aaf52b4b10b56d779eea245ec2e980013eb5a9f7c1dfad5e304ba6c549482a29c229fb6db95e2fb3924e79c10cf58a15913c65363dfe2c813d00f040e66603be20154d275298e0e0a2fe400376132c552ce2f66d803e74875a38deae58a057666a2c22a7e2635a825cf417ffca069558e95571d86ce71db2a61d27c5c2800b35feb1e756932c1f3eed20528bc99433a663a728b469cf58cfa4fe3276c959a3ef94f7aa43f180a7b8e1877698a9dd55b0c22c89dff102cfb026e243de25fdc69f9889214f219cc34f6453fd92adf969676d278f27ff84d54f1a1b8a034a210e85c3b565ea72e0b59df0ca7bc2238c54e169686343473a3f19808a70f944ee80f200a12b9ff791c153d21ffb5d032acbac1846fa9bbdd79e7d3f009a0043aede992d1f025cc973bb56e52200ea4d7337f4f3c8c5ace9e825d89c4652a7fee3527df5e4705d87983bf5b945df1d52bd431aa84d6cf483ca9b57c6a62643bb306edeecb8b7c20a4fb72db0fb9a85ce2069d645dec437221af341784da05ae80bfcbf3a20c8c8192b09a103b3ce77490dd11423f60abce1416492cf22f1b4286a227244f6564e1f5628598dbd6295eb6c4e665a7b0ca32a77417d0760867c13f17e8720208c753f70e9e7c046a60f201c1bba205b6e593d4bea88ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
