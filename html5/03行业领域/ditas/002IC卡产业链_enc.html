<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf418cbc9c6165e7ec3c9a01c9b41bed696d2e7e63a8c58aab14685b9412d871eac69e6f3248c867b85db0b63959905adaa6a21bfb06f21c61a1ab6eef4415789dabd02fa38c7219ba1908afe9ef54b0a1a2e9b45432307aa0f4c8c8fcb999f5f721da2cfb31c76379df52d69a77a6319b353f2fc25b1d71089a3cc7e7f23b4c7f6d053b8d5ae426b122e70bec4ca8154a37c176129e994b506ad90652108917c1f9885e5a27ab78df9a853ee5f06e7e09b0d49fa2e3b776cf1b6528af48da70b9eeaeb783fa8869eb109cb08d1ff2d9500a63562689a9a0e7aa012fa11f8bdd19ac453604f090a91872e31469c114a974553908c1172033af47114a25682d2d0c381dbf78b30839f3ee6ecdb3302de122598e9dc3ed83d557602d2d008b78ca35a48e23608c6608ccc7a7545bdb520b9f8f7f7daf74887a7022d4701bf1cad7395454b485740ba617a7ede4721a23a53d684c7008ffcc1bc487e8dc87c5b53bc908df814aae894bfa34f680cf1becd51fcf07c72f014b51be20a72343687d98b9895848b7bec14d4dfe61c20e22993beb667196ff8f02740e70d2873ee2e2f2d0809416e70b6d54a946aa5ea5a6cc21314a4762581c19b2fccbe52cbf9f041e10e118ed49291707479a1fa9e6067fe54945ac2a2ce0fdba0284c6f0f967b4b2ae0e57da07bb5074da6558d1ef8d6c13965206d20ba9e401a317bc7c4d19551ac7a741adf8881c884e7c074b970b23f024752f198ae210400da1d5419e49aa95347c4423ab451854a6066599bdd3f89cc20a9cfcedaf43c9efa4293151fd1b1b6fdf2aa752b07d58a1dd144503caf34135695b9d25dd45dbc0c605a227c1a603221e4671da0367af8fd1ba125ed31c6e57ba8eaf4546f736924687b6d9e146fb423216344ad738e0a9a0841cd571785c394f981f8f2be45e2487f425b02110e05114b029899f6c0a1b046c0093c3280b99fa4b5d2207b70a36397d51566ea25cb8672baac07406d3f95d10d3c684c582dd635cfa0e50da21bc876d80fc3e0a3b67d6372c672b09f9d3bedb80aec87a52477423b8d56ec0a616d1e7f05b9fc0bf4727383fab3d93899d59675195a6bd2a15ad7fafdde91ed21b667d0d1b2be04b8406c9c9ab078e3f88fbe8500f7b153e72a2beabfd300417a5db391c20f2896e0222481ab09298ead3b40ec7af0283aaaedff17ccbe2046fbb940c79cd177640f06136c68ce0d7e50e566c70a5312bca191b447690b954e56f2aa9def506d4718c7f9b72796d39c93f069d39f2d1bf91fd666bf382f419c66eabe485a6755b2a312673bf8f0d6d801006a9d026104aebaa789f789a5eb716704dcf133eaddeac8a322a7cbc17e0025038e71e39b68d8f2b660616752ad6b7d45bf916435c39f1cdc4f7a277ebaf088fe6d70c13475ed483ed663968714286e6f6aece41469e9721c28330450dae43e4cb9d0dc82e36474d0e12252172e43969d50fa7e2f55f00552c84c2995f55a62d74865304f6b9fae704d5163217166e4631660c1696819352ede04ac3958a30f6ecf80d4b51bd46e7eda380281a2fc4a1ea6864ab5114362880a84ef7008d24dc16635d9daf05c8687371b7ce52b45d9702e9b8e19b086fea5d17973811720746756cd75cd0333a224e192bdef9c5b22cbad1fc7586c89185a25469e853e5589d78dc9f49cf736a8f1832fe7cb40840a0083ae1154fdcd5bddc7810bf6eba881c238c2a77e38e68ec548e774fc46ad877a442fc717cecb6fb072b021bd48cc0c3dfedf17b33565ad3549fe76a7c3f878078397d4137b6c7167e9f4342cd3b558e8cdd32518ded6e236cad0786e09f681e3c0c5e7b10c1632b0d15f2ff66837717302c5dfeb9541ea278518657d468e04d99e7b35deb8be5f7647fc2a3a87fce8158d65e626dea60489a1073fd5caaccfe44a11907e58d908b3178114cc8fb72709d4dcb2399a5a7234ab9c3a4af7ae68d360c54aded91a911e89ec9a62ea9b688900b13fe8eb3551fcf9fb102743e4331e69b4dadb7da72ac2bff94b000ba6d72bc85ad88e5d9558e7b824911edd5d82db4175f3a7a82eb56779a071352dd950d7d33847874f2a8167f5bfa90177f596e6d15e29db2c4c1a5dbd60c910b3053691f9d1fb6d2ee198fe5ac29d5acdfd43d82962e90e06c94b0c0b9be981a5e1a56a1e9bb66232206835373e74135e06052b4c93d7c99d0277ec046069cc36ed1f26a163b869ae53df8c8bd84db09b966261de25470d2d4635c302595f9bde7d4be2843ae41f957b277465802bef76c8eca136d78be77a108d7bef092c98c2e980a587fa3d937512021f5c659520d2ade1e4a0d9d6af64fc27ae98b6c0fee8410b3dfc0dcca6549830955adf02a776babf1f412c31a8815b26b7a95ca728a2825b75846030f2eb0f1a35c26526a575bccd4afcdb043f46aca774fc9022910c7d507afa1da90a0dd90022d05ec263fdd44b46366c8ea6f4515bce604edae74b2ee97fac85a390467ed1edc57f22ec5ebf9a00c7e9f02df15f361445eee9558ca8a9772ac71929a3ab87385149f813c7d9a76075d54b64479fe4344221a6e41d52f49956540dc80703b2c9300e5125895054f22dfa7bc239a677533974c916ee80fdce909b0003cb79e57a05debc43f278a36228bf10c9aaee1ee71238db2c0503516e9fcff0a7ee89f090fb399dfb540600da98ac5ad0ba5983876ae881bd7227eb3f48d46016ff429f06b1f8e7456a3376fc99306d61ec7ef795c2140e5bd64da1c90397d98302be6c2acb7bb97000309888953c5769a36aed2ed33429ed944e8728d904d55529cc45cb4d5050e5e9e905b578f69733f08d746d20b08cf9b46e1bbeef55716f86b95400bd52765eb4aca6a42e803ae084d6a1cb646ea3e6034e51868edbb131f73fbce1e3410c3439d7ed99fcf9cd48003592bc04d78eb08b8ad04d90e9e2d85a0d8cd12b70036ed9c861b5222f9ebd865ea0617d5d22f2de2fe0def27ca9fa2a7e5cb8a1dd23a6c1e7827ed968c34688b407f6d0a710b6cd3aa4fd42fd8fa24cfee8dc6cd3874b89f1b69cb5e90c45831a1627cbf2c5eb2786aa2392af6acdebab48a9b57aecb823a27888c400779234149cb2cf8d4dd8f8f51ca27dbf77c112445b8db99cc185b2820c0445f90209160246ba99c4ab964f739a7e96287cbabe54bf151c83e2d7e4e29ba40be61f480a692db72c1b09cf6f4608cd387a4386eb76357a354149126160ea4040bdef5876816b6edb4e060fa3877f5b888738143bec0768d66e70f929080196f3d0aa7df6a9574e828501f60ce77ac015903593be855a719d7468d82f344e0d1bd367e69e3b20dee2f1c6b9f699ad6e437f5fa22ee75948740854637b3365cfb8b10e85c05625a7a22626d7be96ef7768a7f3663abece99b29aa8a3261725e10dca2a7e8ee2b99c65cea01195133dad5d94a050ef12296e47dbbb4ac7889fe66b153db2e68d3abd9172877b11a302799e05b63f74950159348fb499876db5669cd329b6f1e1fa77590b142e7e2d070dc38858a6d40c0f52a818c61592f0c703c246560388e53183a8e668b632af4e944ef3ab4196d2b226ff1f29a36c5b8a360b0be4dc29c2538f8938e6845481e42937b79e070aec650291e6e3368a28ded4dec655f38efbad21140d1875b966092ba156273806ccc9409077e3511487beebe3e63f7f9e625e76579482d67795ee28e0b70b7977172c44e0f6bae3ad7c6eda37adbe65ddaa9962823a1b6b8fdad1fed2f513d21c04fa068fd50a87e5c1e20adb8247efa53bb0b2c992d0cf8d3bf60b36170376fc29c53e46929de0f4f6a1e5464375be8ac229e934024177e866b259741741db0b1c60db637ff687c411a6097f0a09106bb827a233e615b5c004b3122b31918f55962c560be6d1d4c1288558707ae2e5daa47ebc08532e2f67794bb86d44ec26d6d9f9ae95cc77f82ba3d0e4f010b0d6685d08d51c3eec1d52ed73b082be6e48eeacc4ca61d54c54bd35b851275e57ce2c8a0d239dce1dab1c240846ea42db8a239d82d65204b282b78b10fe029b385ec751a4f0969527c19e027365a6b0ce88da80581b9721b8c42d6c2320909efaf95091cf439b6cfefbdb0edfd60a366a9bb68ecfcae1b3fbbe9db64485b20fb1ecabab00af35040d29eece067c54736fed65470c0889f5fd3bcf7ba5cd260d16d99e73de22ddcda379672d11c13fe2d9283f5afdebc55f6713b84a1dd43bddc0efa0d53f2c8d2fe8f7f9e0c3b9381d63ece054db8c3b1d1293c98ce7d6e4ec65c2bf28a8b111199510f37fae7df4c15dc31fdfc8636bc3792baeefb6b66bd8df11a455272abfc552f8b3b2baa94795f7096afb7546d5c8c3648d6ab3847bed6c95538cf7b1021913d03619eea37f770cad701b795971c6d4ebd3b2dafbbbf4da5e3a90c69d83c7024b5b42126e7a8e493061a800dc0f9415c1a99fc2f5a804d75f78f9339ea6189bf266a87b6c5576e760dce2e8d1eefda417ce4e775c1d6c8922536f820e0200203b5a1b0c6d627f25e72246a7ea039a78b82117cbdf45042c92da4621cd2dac8d5e582be9517dfefc6c2078e60a4adf0f867cc1858e14c01f1abaa641ea4d8069bb4ea9d1e57fabf397487b4c2061c9f9203fc4bb164b69f7ae6e445b0b69f1420c853a6b0e5561f7f0aac5fcbe0d49c1aacd40b168495ba64ba70f9d1b361b73ce63a2dfa58522d1cb315dbed9bc6da804825d2da79673d78840f338585cebd985680af64c8f05c66283448d228916f68386932dbd827106eeba4cc079df41790c30d534092577c100f26d3a300fd0871dd7339ff83cd311ad9dd88a98fabb16a92c21032aaa7a62bc5f634f86417b0e54c392adeb87def77689778c9eeb62cfae5f806a6e54d7b1df0b5fca1297683568d04f0c67fd1b3f6ae1c1b7af2480fc79dfa1d5ea54216c8b192c822532cc2eeb3f2b9c44ac9fe38ad1110a09272f3b9a29398cf1855a35fdf50211d56f1056e0a711a62f2f710fadbe8ae5508380d95455ba8e9e43d226e71453dec3757ffe1941d6a92a9472ca895458a897f810b38fdcec0a2d916bd6e3f659ad38965cf624935c9e6e11fd7c74bc98718ef0dd6f9afe4eda8f30bcad29bd94105695dc9b8d465ae51254a21fcaca1379992f883fefc8d98dce5badb5a69e46298df2988c634fb8140596b077c373400450791f687d29dafa32f0b56912636ea22b11cdda82c7ba191a81fef992203ac05688a363f8f3b9d1cb988a82bb1b46591da0896a1dbb601f21eb55dbf8a85faec4b1d83be8c17b18bab475a2cfe9e03496bdbf7c6d5a7e5a4993ef3525f800b2f9580b346004b3c505065125c9bd746f8426da0913e7e642b0b98c2637d5745f719e5b53043f4ded61e003669764f066eb33701ff70073725ebcd772f844e4439b3c2e9a21cc3a8d238160f00e0e1a95c896a9b77cd6cd8853aa0d3130f803c1d1baded8a844bed6b2a8fa2916218fdb4454eb6d826c59a59ccfdef796caf2a71cb339b0dd48ecf16b10d4f5b516c8854724894a3e91329cffde06221751ce4c00b2fe281ee8a7fe5d397869f8a70aad8bc60689fa081b55492ee405a89cdfa78c913dc0c46e8f5c9160cb0a0bef3ee60f7876bbdecba2afcddc25fda3baacefdaa35d2e9c34ee0393d22fc6bcc4d4afacf408697ce8dcd7aec173a90faf97751b59496afcf5f7b7896b4a996ff284f5be2aae29dfed2e28e95d66e283a97dc00404a9f701f7b268de5a355041ab8c2712c079c5a10103c896d15f9b9d897730682c8b5b991635791f4df0871af62e187af70eab58d6db400744d290d817445a804e36135d4225cb964e05eac0c78a84787dce879ef529dc6c16c628facfd19f232b3afad075cba0f1183920ef47ca69a3c84b47a9fcec29f936e6f48cdf4c1e47c5a4fe087746fa2067ee468185fd9618492361d73df2e8518439410c28b43be705b6fb4a4be7f92c960c5df3c001b652a540b11aa26da62b6686dc2c6be254c5f07f71bcb1f617efacab075a97481398a19c4709425d02753819a08f48b872443c1f3553ec38b38eba580f792e2c44249bc24c2a2b177ea3ecdbe17be8b7b580371d09bf46164cb98fe76cf0044cdb1f91944f14164be5cec3c8eb29dac5f5e4ee8908fcd501f7b7e3fb27b6d7827541f992c608c24e947cd232b373ed665a95fcb67cb93a495bd32a59da7cc256e714aece2a4cd1d52aa423e1aae170bc6b973689bdf95b9fd5e91bd2d7172342db48f0ec31e69600baf8fa7e1a59e39157dc325b194a6cad56ab4c86500f0f6845329b8ea040eb944059269e748b2940f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
