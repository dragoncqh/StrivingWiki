<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e1b2596009a59a5fdc8d470979b4a07789ffb1c11969605f2f68378ab84dfa43e84d2b61de1688f49381a140d6c64d97f00e5093139d5cc3d764e8957e1c46bc0130c6a0191f4b00e826f1c74ca5b8c8b7170852bfe7056100c8b44bb9d35dbc48210bf7f8d037febdaf2f444ceacc0ec06d0932d1a59b878160552164bd01e9b0ddb8d43c3408f9ee89dc4f5b538fcfc3faf7f81d96a4d6f8d65269e3b045c5bca07a8a204dc9d81f6f2d4bfa5bf9d20940e8d91cfee0d6eabda58d6c17f2506f464fda0d1d92a63db5b77a2415648d38b737b66e462d3df6ea874961b5c81c18af7268355fe5b7d02dd6f3d71f321d937154707eed472c4a2fc7cff1d33a3f451422341846ff0fd9c8a84e9ee9b431f654807164640fd3acb880c982263af30bbdd36cd8ae346279e0aac75fc0e61c7294d9dfdc98620bdf305f409351f8ff189bc5c37520582aa538a79a460ca9ccc4f752991c0a11e47779c18ecb753fa70b04036db4068181f0ed2e1c86a6b5da2abe8e1702eaccc484ec8d5a6fa7b04553ade7f1962286190ab44f93d8f188b4796ab9e2efb2d505e0a6477f73841f5b39a707d6e79a030c8759173cc016c70e15cfb8cc33c80f5c991c9c9a95190969aad3c3c3b1134d26597026ad17f097a34bd234dde04ad6f865b006265bbf74ad2521f119dd7021441e18fe6feeed18ad8c3dc8ae9ce7855c2dc2cfbed0dddb1b97412c836e2311e278799652b28962b73ea8c1e8648f8e69916f56c02687315157bd2a09891b5a523b589488a737b313c2f9b4d52ba8051cc6d6e4f5716ff3bb48cdd17c78d0c2706ad2bba41a0e3ddbf4c2cf8137d19623058236520e18b3b5aaf9ef14dd90db4b414c1dd5128d307e8c287afda5dd7561e8e7bf59b6c80ae736caed6f809330374336b2d4337854b21175a9870370fb95504e48a14555855ec5ab1bd3de196b736b76eda22572087f3fec1e79e09722ed93b594bc6909eca072db5e6d6f782ccacdef2d7a2655456878ea24ef9a29f9bdc318f03da31a7da61dd97ecc089fed498847394d642763095ca8f877f4734307dfcac7dbd0b51c51f92261dca15cd3d30496a8d9dc000d66a7f9504a722e49d661bf9117d087feeae59df0ae80af2e039d59572f36baa9f8e7a35c70045b9263962e27561576e54dd4f67596e62b98b89ef202640c9d524a15b07c3be232ef1ad0f53e74711d988419d784c33fe40aad2abf62f1e9e49015833448d010a4b093cf7f1bd77bcc3ea1287c95c04e67f82aff3b97772a990b0afc218a907a52aea8ea5a0a98956a85249016b8443f8abfa27a422f5c29057b93ec4d7ecfb6f9b96da01c82cd861bd74c2240c5af74babfb81a9c2898c302bceec7a29f6b48d05b3e0d078534d38a6ff4b693016420ec106f299f78ff04a20069edd9d91636878d05335979b5161c7297df1973e308e7a2e6b063da10f923964df330548bee58f85a2029d2be83f232b45d8c7ffb82a434059dc7467981db4663c37bd68a9a4a5791351988e44da62b215f37542f5575e667960077778f4ca359313f373dfbfebe1596313ad8ba8ecba931c7e286bf9dde770398b5bcc01e8bff36c96d3fe26d46d66bc824fd995797e27ec475c9b9ce4265e717a20cdc405189dde52d6b8963fe78fb102f58f2a1f2096f64d17393a6dcd5266f8a249cfc5a7ef723ccef8b5dd997b4591ae6efb02ca6e47552d172cc413789b7ec3627ef7113af5e765807f2e76891c9dfc873389eca06e6271bcce31ea5349234e9052003607d6b0cb0fd36fdb9f12a1cbaee2f3712641d9b688049e592c6db85b16983ef15be71dc62b978c2e07734c18bb9d23332e3e1f634dc88bebd5a5c068f479d2796ea73296bf7b7d1cf3f16f9d6a17b6b2dd03c4dae865c497c15fd839db56b5c3f17707a577f39a21daa8fc5711dc36e5f699448d2f6acfe82b361ccf8a051d2d27557cfcb0b262d5648d6b8cbfb2e6180e7ae4c4dbb9bb7cf1b446d7707ccad4e52af1377cc568fc9c497c16634255eb82a1f4a1db472b9d5b5963174834659e793aed39a6b990c29ecf5aefe9bc896defd0fb5a760213b374db96b8680bdd2363d10565c3f68b1788198595f36deaad608a2468651251e9b7bc258404c63268ce4ffaa318cd9f56aeccad3199c3616e57670137b90c74e1c1253f87f08ad0c9836f27c0b8498723d97fbbda8960df990ca72ebfb0b580a75c374e7b2617c0d4f4b9a19311a51a7f5a31fa265baa87bae25ab2021339bedeeccdded78e33bc94f10da3f5bbd8f76c30cc5330576031dad064db25ee8f3a9ed2a1b644c9381b20f17beac484852498d1021c8f96ce5fddbc59b97a94f804c5b0f5558d095bc2050dddf0f3985d3619dd5d503bc0f2d997eb6de7bd98deab05399304bfb3790e4aa8663949c7353134c773a33c208288c266a092ae24f85293ddd4b65c64617ed01aa25a560ae850727ffa1a909058b1def985daa3207594d52ec02efa0f7981e0be1e4400cea9c88d8f042a7dcc9aa66d5ff644c88cbbb94bb4eefa9db5ef868c8232f21f08f6f404bb54aec8dff5778e93f450c625b7fc0f802d3b436785022fdc75612f440c1b6990f8acfc6968ad341aa89698068040d96a7ea6cea9328f4d0b076b119b0a66ce375b8063463cbdc9e570048f0c08e7923573ab6a3b41cd9946019bdceb7d6287805f0e4aa58a8b48e41702621ab1f1e92c99305529d23b2e4ee8070d0820e8463b48803241952c457729005a30756942e2b039bb4a42e7a65123f7fd32e0a25575467d62f4d5fa93d2a476e885ffe93259d576f33e337be983777037aa32ca67b63af9ac7493ef29783f4c9faf1b927e660e48733176f9003161aa1ee195613b92906d4f1aa556e6865759ed8fd78e1a15169fdb94dbd60315193ffa047e357d096e63853a97ba958465034f3d1e092efe30910bbe278ca6037d1b8a3110501d2404deae883c17bc2eaa7c30c988e832bd835de8026ec1b5a83edf54af1232eee10408c0b7b3a5a88519f5bb8b1887482f024f71775063b190e7d00c792bdd083e31f86e07ceba37802c1aa8e77c7226e476dead1eefef693e7e065ff31ce865e7b43e9018224f6f1749a00ade11c4d87b8d2e3c7d5dde7b6d9627b83938cdd3fceca7d48fb5913aa72b15b60ac04c48cec060cd11561e9b09c2dc43f98030145b23263a7fcb87d3e7123579e4580a2dded0498d9d346f1b8e1da2359a8e84fca8227bbf3d351343ec42dc67ae6270636e401a6934b979e02a18eaf085d5d070cf0dadc07099d6f7fdf84ac0309dd2fa261e029f1ab2304f4eff2c3bf45f4a890ef1d1caf0e2a01df85c85db828e2e284eeb63898d9bc1315b4b706de5e0cb5e506de96b5ee6a3b5f17d41cecb77586e22a3814fd09e7032009dfe32a4cf9b5864f8c8a5fed34ba98dc1f28c854c6a8033779e4a0089b32c6048bf28007456cbde849bc005ee72c74e5e47596d701395f68366922d62e6e9b55e7076d145a401986c325e3877ab029d568c15d0b2f0421e5d7c7c7fa79c7c5f134db0b1dc6c655ae4bab9f17239398a48502a244dbb34b5321eb8f462f5e2ea4c9a75b1c2cf0a3f91fce07eec936d69821a05f0d2e6920891e9949c53a95592c540e135cb129594d9ea765364f35a92fef70539dcd1083256fe06acfa2d8adb10149e7c9e44361c2a7f6666a97a7401addc0a40b0e822bd3e88f53411b53f97dcd89684c1b3bd1a86f260a4543407a5f5c25225ed02f797e6485116e83c08e64a64cb613a973ae7be0ababe1bb9fa4e932b4fa6c7625021de9c6065e00de57a64c1a034bb7265454babcf6cac58b36c2877bdd99aee98394baec4ba9d9cf6a91149f756315b96877a623c036d5b7072c42f9a687db58f08922c18cb8f0b0a1f93c8c5b5c0402757ced1201a7fc8d5544d5e58c0184a55d981eca12bf3e982566c4970059ddc2bf681a91d009e1166e5a27548de520540cb56ab1e991d68ac848148898afc5cf21a3a928a428443512eea309bfe291d7c663e628c7e12b06afe3af3d1df6dd1e623ed9cd1cd12408faf013f5783c4a6919e572e8f239f19c4fdbec1d5ea8f61bbab89de1806e357ba78e7bc9f2637985dc5e7e6f12006cd2b357b23dfcf756c80cd1a200fb922e7c808d02d5a0e7d637dbd0d802d5d8894eb1fc073dd318d5d6ea80e8d3c29a451b27830237c2709e85f9d4d508ea32e627c472a4a68b63e8f8c2d69b94afafa3b9957498830e026c638f6d6ace8e830a8d68b07a96fd8cbc3ffdd84fcac7bd32a0ea926f0788b1f72354abcc6e40668e09f7d2a8c68a4305d5b549bf258a0f28ed8b59df9e2e9676f73ef88334604ef4dc8032ecb96d7ae5958a104a403e933b5eb171209852051a1d16646e6227e0efc905f804ca0b101946b25963c8f3a3a10c20841791421e4e8153ed9f2007f74d3920daa54e85d0cad7278259334f6a316a6c3a1a6ec40a4c6bcd9cb61c9cefb75f4eedbcc01f2400e5a077d920e66f86d3ff8c5918fcad29a5a817477a116ec2866375057c57bb4facd159d009052c142ecb9203b9394084e78f26264e69acee02cf8b527147e148807241fe3fe6685e84cb5f366d7c8a0e01535cabded10974829aaa093c4262ba5c4a63873709d7b818ee21a8144d04f6a80c7e08b9bdea6875fb405501432e0ee4acd4d3144dd39b55d43d2fab8fafffc085f14c7eb76dc702735b2f83c8f1015602c44a627df94ad1e4b2a538dac1d5f9197b80341c9209b444606dc71a170457af957116cd3643141e8cc29979acc6b4b5d9386d6769df29b056da1827cae6bb2cef956d963b0658dbd8afe1ac25c88ab801c237b829c5225586166a6b5e1a0a1c2009eba5a1a63028f695161a6bf5c7828cd3cfb572f986e39a72e22cbf649153a1c7fe96dfc9adefef47d894c2d26ef98b9db4ec5d760a490e82721f9cf2f893de59e60f95fc76933f230a4b07cd2f798ed7bae93419b0c6a19194e7dcba8ddbdb26441eeb1bd58b78c55881ebc9da8a07c957622d99568628d1816e74db0b92e089cb183b0bc6630bc61e7bf5f9a79f1cbd1e0fe84cc1b98246c243a16a297d2d9c85232758602f3157611916c6a051e0c588d611a758420b92a6cba1c28d59fa50c343a897d22405511ff677638c49d8743d98eb3d76c55a9598b02f2b3acfd14951e7a7240118a9786b17f3d5fb21990927129fb3633bd7022eaf606d26f470d403dd086ce59d7ad68e23b98e9efc23ac49d2460fcad419833f16493a623e1e9ac5be18db09e399ceff37961b612f649c16b55e2090b734b05013e5d213389b371cd985a12163643e37d5a0c2019f1e53070146eccbe4a209a646ddbf5661e8849fae6263b547096769b300d8f955c5b6ba557b8629fea958eb748f25df9a337b8a5a8e14d58097df7a10aa0b5a3662acb42fdc8e2284379a881271cb6aaa2ec26c825847c90d50134a4e11bf6f01bdbe55e805212594506fceaf1ab23d5073510ae1d7950e7d9a83b461974b9e0fdfad13658a854b6ca19d61db3daadcd63db155b7c82abb907f76cb6b4896ab6a123b9e5c4a2c390955008405a063e7dcf21b2b3ba6f207222fd1e10133dc431b69fd77215fea2cdb8e9f861c008d0b6c2f67055e8902badd07e76e830070f636457fdb09727cfb197564502ae456b0a65cfa225656e65304c77e3dfe6d311e4784fdc2d5938c9cd7cb5ce03d2e192fec5d5ac642bcefc1088b01d9c995a5055b541773266348ae3817dd4a63864d71ab3b21a0493d610eb7eba62b438330be444f0beaa7416faed94e3bd4ca70027d98ab17f7fe23b78c7c3ff23526b75b0e0ba47556e4140ee338845aea44874e76043c3bf2bf366e3fa70ced6d8c7ef90650b80d52b03a1e92c7c4eef832cb6608e58a47868c5f0ffaf03ad90e8a0c03fdcb9f022321e3b7e00b4dfa27b052291e0c64442a87a5818b9e06c61ea63ca489874859f8611e77ae1a34c1f87cabb100c845f4598bd3e4b86e2c544f21a91ad37d7babfef4fd529043c23cc747847042d7758db7f2d8fa8b6d1f16e2469cc169b6c9d8b2b2f2888bdc64d9200fb1cd6ea33d7311ec73d908274fff5d4bb28e9527a9e26541eb17efefcec4d0d43d45cf4bee130bebf8fd1a16d5319c3ee84b47128bbfbb38e1feb7e92d62ff86d302ad88a27874b0e23cd1260d2b20cea6fb0eebbe09a38b03be098d3ab63549386845e0a9c680675f8f0586eaca91b0831dfca093ec30dcc74688d5f5ad80c6c6c350068ac82cf09e9831ecae5c7a9d7cf2cec5a83615825c562ddbc7b796dda2e3876e6f6355cf026ee53a2fc201a38b94d7ea1e165cd58810b1ad18648a40d897db48d81e768dfa5cfe6dc427d5c5131e8420601aa34b103121b50fc5bea897bbc3759ff0e5f5d04f5609f9435a8000522e054c67b9f7bf478b8cf623e8e6ed300c0f4d164f403867d1a98ee793c84baa70f183f61e696518d5a4862d6c3a2c9e8e1ea841f6c8227629dc564fd76e67c239468836ca5cde7c0908396d9e8f85731e3ebe149ae611201ed4f584ab29ba6a85d0e371483ca931166b5397f1cf1f3a3ea48167250107d6a0c0123365f7a3334f03ffecfd57731ae44707bc8c2c1f40790d822e4836da29aa528e4a2319d54c72ab4ab7e3122b0749816e6e7a243b34d56457bd3769e57f18f68415d465a350c80d99c6b6a10275a488ccdcb57ef902364b4f961e3f900f0dd3b4bd12091b1a8a8c814f48ead6acd32a3723e8508de7d50741679fa49249127681afd288dd1c607463f99aab64e7d760f14cce47c1c1a265a845f3f50726a64bfaafcfa28755fac62408cd91729d9f2ad1e5e4c1a17a90287ca57f6fecc677d4f763cf420564fd1e21bd5e57796cd9cf9c09bb3ebc312def59a3a70de8cefbe189ff453ebbec3ba2ee9c5807ba6ee9e84e677a0cc7d1c9686b529e76737e1468c3cf1638e84ba32ddf4eed3d5b1cb858ab389080fb7bc9edf40920d97806a602385343a9666b7feffacf9b5edc0653bfa6a216050c18bee1544949c5105a193dac862b1378b6887d054ee5c612b88923ecec1174598f312d4747e5a86eb86df783261a7705f23d59c3958526c1c09b5deeaa5ea0c7177f98c146ff9b6e008dc7accc633548dddefd40784bb395d4d804e6d3d3158ce89565789879a1100b8c7562a50cfaf31f01291d043e27a36e24275ea349a95c1cb881a93766d24e0e26e7b94b37e277ee1b39455833b0b97a489ea81a09f64d219a8826841af8ac1c7ca71bce263760f7a2944eb82a9539ff2418ab56efb4f10ddcb935aae2b4bc3a8351f6e6678641a789866f22af03b3e4267ccca202cbcc5ccea71cd6b8b7336d2f98c249e8890ef0f9ec7f178a8122b52d888db9678ba2630a2c3bbb320623cd5985d185313678e3ed81f28fe755522d944394cc376e477b525b52a63f90052ab087d8ae897101e3c70fea2298c383dc50bdbbe4052454637e6a799ae26e14987483dfe90771fe8734203323c0f10f9f6e0e6120c33e47921632242617b8a96fbf66f93292365c7600e63147541b652de390862046a8667f659b29d44175a1cc66963fd8761bf8b2f0b46fc72403d264a09c8ce930f6771fd1391ef51e61edc5e83a994ad862aaa67c6d4552d4244a1dcafe0793e65498786b1049dfbde65f7f6f37081b88106ad975a6b5672a29335010caa5410af39e7483d620a736086f249532a33d5216dd0061eff370165ed2cddd203745494d520323cb246d93ebd8b6d8c938a999edfe7ac46681ea6848a5afb95d9ba1e8fa3782f382de58fa75fede37149fdcbb050d5552469fb1a43dfc66c69f56c714524876d36a160a9a09716348de9919c3e37f6764699f3152c2709af7d145cca715902aaf8b1beac2fb13853b2b7748326bd1147127baf1a431b6584e46a29a29e508792e5dc02b08c8672791a1e3ed1e6f6c42a908c0ae5673a421e336890f19ab8ab769dde55f10049a0e2a512eee2a54fd59cd1cec83edb6f3bc131898ca96e22e92e8302eb99bab89aab43bdc009afeb6b4c0ba50331f2178e0d5e26f692cf097b0f2ba39ade60420e149f58b76497f3e07c8f141c05b7331c2a7899d40d1c64cdfbcaeb3516d9e4083bedeab793b4047822499fe61ac3712ffeb3a7bad1a72274050145a81fc801e3c2bb2051d653e666a8216235955873e460d516c55a637ddc35cbbd966f54458aabe2b4e5cc9da94775d8dcfd66b7348d395a4cbc4ba2582ece3f3762d2fee4c219fa72580a9326f4c3a9fd6016406d516bed2072ecd4c6b45c6a27fff21adf0ec8697681668565fd84252c80bf38b5cc24788d3ab020153de5d05c6d2ad193493e3508a4beba892f1175b42d1cd1aacae34dd9eef2af12e3f41286080a49a26601a37c1eca0c1899ad738f6eea29a09264f22a4d43f0f16df508ca68f1acbfd72d846bc6238272a348bbfc33495f7756496b74f06480630c1465893ed4a7e90e508f77592533fca89e05f3261a34621cef3f14aecdd5791c5118874ddca59c425e7a2531657909f1fe96e85fa3e64b447f09b08c4f1c31f2ceff1079e4cfb0a64d8347e20c8badf8efa0589ef27d5a65c0a62cff809e11843e587872cd15032a33c2171e436f73455ca08518c13204299565eda1306c41d313c05fe17d941a72bd55064f06ed769d877a80f893487e46c76380408b1649af5f975d9ae3e7ba92265b068e14f9fca469178db6e2dd8d57a1181cbf241d7094a1ecd9029143d512e6dfdcb4d4e21fba0c6a092bb058a554b565061b05d2d3b568ad392e8b0d8fa0bf8eda513c11eef94186a1e0b7d5cb8d30c161693a0761ae93c555d2e20b83764d2a4c2d2c3a34c67e370077f397e38b23e817f0223b2973970020a73027369b27922e365d68ae93a537137ae607c612f7f19484bc462414e288f35e5cc7e421781cbf0e1a5a27e7b614b177e7b15ca804d22ed8fb79dcd035ca80bfbd36fa34b5c1fc01013de90f78af53328441e7a0ecc558a25c4fdbba8492e8e90dd486f8865ac5e9c46492d24ad38e2b3383e947da9fabf88194daf528e2d1dacd42a157cd2909e925cd19730d512fcb342cfe2677d7c98df596a59a2ac40c97c40508fb2111187f2bd43733385eabd730bb978474e137bd1b6a213c366bd98ae85dad7d94203f94771c9f7994cb3732a64fa7d2992a26eb6cf6f2ecf51f694fe37252c5561c7e66bf4eeea4420e1da50473b21b7c141042af0190ac0160087b1a6b681ebd43a19a9d2fa5a71bb57c7a23f8f742cedab9a6dedc5eac8ce8bd5782eefc477c1c52e93181ced16a5d4dac856369b9e4e12b0211992d1f7d402101b01b464d22b144e6a0c05fb0a9bda034faa0cab9676f29e0a0f2d34566cb8e3376c86c74a94e90b47bdb77dcdbd1680728d1f62dc3e812afbb4d96c04d01e75808333e3cfd87169f4205738ce972f1fe77177739c9c2fd58c1467fd5d8d9b10433f38cf0b450cb71eb2ef16f340505c16abe0d868cd84b3a26b3225f209e296906729a53dde3133172fe7c8337f8648288722941d3937d2af8deddf07596e073566f7390bb735e12dffa83f050b9f345d0a7b8e6d95f8199e48a1dfd3c74505393a5d3998d5375ecb0f24e83c5fe2085e73c6490372d921574dcce91a0a2ef597ea8dc83416dcea272f28a552b2484093aca58372b70397db25a8e14e1bcc6a4f7bc6d9346c886f7986fa68783e2331a881a2d9219dec00d36ab9ea5e07160b166efd088325bb92ccecb2c88339e5c4f4853b4ef2972f4b8d321cdc0d189b5cf1e027931dcc09e87afa7a500bf2bf5062144973ba75b375595c9238ceee091b6c556345f4276d68a9cf9c0ebe43d87025ad373fac7f914b47080e33434fdce64a61e0db83bfaeb21635b520106f552ea7f4a23727ae06b0804c9c136e38e2802cd82bd793d564a2f8fb4b660f61e1990ce44fae5198eb76004b52349d26359f99df8aed11ccda0e0969444de2dfc695214482f4861b3dcdc74e411eb34e36e05190b0e9ea29b4df49e818276a2f44f0069a030d68f0656cbb00ed2db6d6b8e26a0518ac7c7d3dff221975596b759e44596409c930dc02c99f75486b1e6c8ea0127d5d255ff5ea3f048b287bf446727e38fd2d36e487d6afd0ec9aa345bcdad9e654adcd106c8e1533df47cb4f0debc50ea8f63f19eb112503fb01af2f8dc8a64a0fed53ebbc074c39e95fbf88f0cdacdb27fcd0cf8c712c5688ab91d0b3aad68ec52c966ec452be39f06561b0a13d0895dd0cde52c5c48f0c06dcc36bd484bebd0a7f27b759ea4960ca5549201f856842a0b4fa6da6aeb86dbcb0587ee073e7ae4bbe0a74fd55af35f975ac2b1b57c937fdd38d9bdf1259788fabb213ef1402f11f7c3bbb8f625e67ce3bdec4f9054a25b478284f147db9fc29e2b52a273952ce9ee0441eb30a618f9c674f9702b3b09e5b3b6c20dac5325cc39e48a81793052db8787d16a2b15354634d43186597e1cf243ff1ac75e2ac62393982d986e863633017b4c8c4ef08af9e40c8c28f35b7eae9537fb3b5351809c0c903cfc524bb3c4bd8cbea2448ec742db8d3a2474cf4fab2073cf7bd24c00ba53e9edf010641c666308af0033bbe474ba05681beac566c675418242f654bf2c50e0cad603e31cb47f7919f083ce3613a16335cc9357c3ef53a41a19c35960c01da768cb77b62297e5a49b9641eca2b630bacd8399b62030f1cde1739c73be20d442413ab8c38b5eb3367302b922722229c65e2a47e9c9711bcd07853fa9af82dbfdd4a2ed1837dbc4062e02bd53733eecd553471c61e98a60bf3de1eacb1a2fce5b61ee15e101a95dd3d5e27d374065dbb8c1adec5d6d654dbcf71e8daa7746acecffc3a75e8d3a26067e1ab965b478a5844a2bbdda622a87e7bfad047b2c97562a1277200a635944d685f171c2aa4e407ceff83bb5e62d4451b6d80a173c6ba36ecdf4e5cbaf132ed440d7dd8ab2a8a84a2434060ed7e7a1119f8474fca4579e21265e7bf7f7827293d2512b3371a027b5e0180ed357ede2c5cedd377f6f56129fe16476d27ffbe5d1493c9e4801bae0811afc939573081d12608c904ad7d5b7a75291d1dd15c519116ae6b0d38a37bcaea2549be75a1363b3846bd4136257b7008d9d66e67382588c70f5c1dd51dcf3de218fa0b55fc4d78f5d260ccdde42a44dba4af9e2f0c42391fcad96de38e3aec8c2bdb3f9fd5af18689eebba30e6919e88c3f16957fd46c3bf5de83b2ca72b5a305ee282627fa053415c30ce83051945cf38b83a8343d6e3aeee4a7ef65ddcf5d22774bf67bbcd318eef3f5673e6b7ef9e8b286a829176b2457a9f7e4c8d5634310460013a358237918f23522101cdd68c8b9383830e86bbd835b41b0b0475e965489ac3fc9f4b4513ea24d6de57c9b18a8bbe8b08d9f857dca112060aa9a9e86e58fe12f31b59c7e5321b0e7e7cdf765680512363207328bbab1e875c61a77ed98748faa0dbc6ec4c579bda718f7556911c5cdb0d6e63adbcf82c5119899e2555b049f0df736ca16992936cbd1948fe0c0abd1441995eb85bd3e18f05424a1a637aff306e4345d518553a929c6c027a6878cfe95e802648f03e06974694c529cd553b6f12fe41a71bf293c6f6b37f56fcbbaa41ccf8b0626f9966a9d7e8df1f30b7a6db00faef50ec2dbd7bb1bd75e62b9e52ea1ee289579c6cfa4645d74ed04326d6fbbae4a56c63141f238cd1017c4dabe615e59f9d2ede91f9b4d8211c5f52c9d774a2c0d0274bbd7b629dce6fcfaf192b5b3d7f5f39adbde9d0145d823cf83b476eeab099c8165240620f39800cda520fd10acdfa01379500582a6fafc5622ba9da83d2f4d4364e618b8a71eb3702760e35f26f9897575f37734e3c4aa22cae9308f0cad99d938bf8ddc607ee641267678c9c310c9f028f66052fc60a410051c5a4edbdb6bf6fdc7c07493381d061d0141f49986a3b81024e1a5cf0ce7329365805e550e8f9b30591283f41e0d039aa449d168e17bcc219d7d2e7a4cc516588145c9cf25a6cad4bca3fa889b94ea1707b546aa11652cca09e46f1bc27c4b4d891cb26d963c2d7988599038f0a267072d737559fca8806fae941c26b8046f638eb14b357bb2385ef0cacc01b7c4b4b038c084a24fc8eb9aef3fde6f17a2318c9a3c8e8f9b91d1413d943452e0df4e245aa21c082cd671652e36447e6796697138b094d72cee88d1743e729dc7b591367828c880f1cff0bfcf5e224f1a39ec09a1122bc555cdb587c2b970793159371c00e7d8a5790077774cee4daae4e8e87f56716f3ff628c90dc08e757f84c5f3ca220280d51c7159e4ed5702add0e7a94cd206808fe64cddc0c2914d2488448a215505a23a5412159624ecb5ce726fd5408a2d260eae0c4c946937d1c946b6dead1c225216ccad9726060974721f52bf1a425ec472251fbfb978b86b1351e1418200cf09df7b7bd685c7d870c8af8e383c18746042ce015e770e8ca6d4e6cc670abf4ef66b7acc8f0e390e14b16d5ff91667856b117adec1aa214f9fc6022960c78888f316920e276f4b4b87b7bc3f587d14c91a81812cfd4e7cbb1fe99d30c043f52b46fc52ec2818a27ee8d475dae0b8c08a712ddb928aa045291b4e0b5ddef0b3e2c05d88208bc18837758577609061d1dabf28612212ddc2bbe0949bcdb2e8761783e5890992e83f41c383e8822a69037fc03f445ed55f194bbfd3087f9a1c49ee85b49506d06fe872a52d115c6063228e67437c7791dd26ea8668eb0baf65fbefcb0fe8389b31e0fcc2b906e2a9a4b03ad184071ef842f052247019539b1ba5e0cdf2dc549523df8b3d424758307872fc9d41bd58cf2f6b5821742d5c17713dc82bfd927d692e193a99e8b54a7c5c0bf3e117ee8753d7b0dacf5096157044c22c35d6229016f494e5bbb81176835908fe35eaceb2d838f5989eb34ee264f6dc337e47db56829244b5785175f5a57e484363ebda1997865c55944125e66e269d7ea99b5765bd34e211039e7e15c781ba962c4e850417281bdb58698fe3cfbdb9161a08be8779f0dab23b32f1215c55257d874c8dea8bb6e69f3e0d926931fa63e9b25173248bc24c84b9e94b5c165373b6de4e6584190dd5c36f241574611fdb464aab5b4748a45f12c12692cdbc85be40b1145a6c85d11108a9775449543428745a72f404b92ea3e15426e37268ed9ec33fd37e9d0a3ee1ba97b1ee4551ff39dc1134fff8c858d29f88135211a25605fdbd9f8f8d5fae19fb24292a28069cfe080e6b01f2ae3cc928bb74c99d79b78ee4996115448819c895cc2c72a1cebc549b20ffe0f4ff3a46be85a6f84bb9c1ed8f6579a3ec9bab2e6f3067b9ff97fa83f1d976f4cfbd87f0c3347cb1b8500733f0ed8fa677ed371eae2698ce59ad2214950276f01882ca111893c5b631e2f819183938afdb94e9431ae417dd2a000f94f2e78ee14872315638e5af9dc8a2fae999508053a5394c748e6ba7cd2335115d5dca7dc437de0af6a347f5d5e1bfe3eeca2d10858c34f8a966010aef7e031d5cdb43ee01b710e12c91a45b3e258817c37c90f9c50e7182019ce4a4f0ad9e43165faedfcecba4a723d295a591d9633ff38a4aed45802a0f711863dd75b0097e3bf0f0e0bc7658b71513046670891fd57416b34e16b30a91b4ce7b08c487833b865e7a0fc178d9622d416d9db6152454170dd247f319b9ec74a99f0a6ab4b973890269e496ea9ec6357a220535f69ed7faf1ad63ad44c1c877831520b8b75a456de5614692548b1eca21a25def639208fb94b75ddbe949aac01871233965edb05df8ca869d3e35d8337beb88438f6e0dc0c5fa0f1d1a993d599a2864bbc40114532675a19bf492f7075a5aae3dfd6848102e5f6bd99d524fadcaf86fd687b74495000bad960c0512955767ae02393d1339fc8b4a98025ccfb5d2620bee805f6b1ed8609eddb546187a4963804f0e1cc148a6e149a6d22e61eafc82f5e2c24916309f6b8ab94f0cfe66000959842ddeef724f17b6e639b5541d7a847cbc94258aa4c7dadf4988c779128c8d1966159d2fee1e22f0803b95ac54553196d0e4889b96bb12319e4df35698a0dd8e23bab39586d9315ab46f0643b9e084e4298e3b55c2aea4577f64a97de6f2b4856aec5e1f7f90f63c06bd1f53098d9c2e8b426d67b6e33dbdd2f013cb5e7c1c33d6f78118505a2de60f9b253f1601bff7955910cdbefe88f8eafe1e76705468b3a7f8ec6201f4d45699d0c4c0054a4d1b48c047fbd2ee6cfd8f6400853f685401d6e02ae609179acae6750fe13d601cd0e5f438fbf92e1767c0c3a715f1ba0348b93be8789defe0ef5cf82b09cea9bbe1f89f4289a045fb3e70caba4e642d50e951abe72148b18128c9d2611ff8185ae48a3ace35f7f3ffe96e2420116d97e78603be6973a48dbecf9ab3289b5485c594b7fbfd54e353b31c65d4bb2d033673c78d18d644078d0f34a164facf03dfbe6d8b1f28676cb2ec709b28cef2e00f932683a9fda17c5e82efa1b685ff5660de4ab2e1311b21fb611fbd9b37cc0f7eb01478cabdcbacd0be9d4d0f933a0dadc4c9df5f0907cba28d68b246d9794a6d91fa886db07236b21f6f42287c22c9c03e7677f10967de9494d6610b536f4939e6b37cf8880d30e932e243553d86f1e80c089ec54d7989c515a5be3dc40d94e6b1706644a21a9cdf187e05c37ced71b48e2aa6d9d63c5aacf826150a33110ee06bf465e965ef4e0943186c94de2ecb70b45e606d26ff12b80247dc0855f67d2b6d6a3616cb9607ec14fb28bc0050c0ea9527bde2a460611f3a6444ae58a1fc730975cd3563e92dce25a2db67931a9c748e579d6db3c55ef7fe4a78837ad8a9de75e4d7e588d75f237f0f8b00e1dd95f59348984b4594f58d160c205f54aecb65292a945f2d99c56a1fe8f33d9b0a55bb62943c6958b1e4c81a42952c6565ea7c5b52ea45b1f9f664c839c7aef151281db650fe40dac83c70736206a48385b1c31fb67fe7680cdfb5c83304294c00c1c2367f1517ebe92341239f9f02162562de8973eee3298245162f8644588dcf3597340a3efccf3cb6eaa98aefd9ee39f430f0ac05803b952888f1d25dac8e91c848292cae3fb5077674c43005ebb73ab59240649b0a885a7703cdd19e1e22d165f746a9192ea44da1be4c26d96296e621aa11f161553cd30c2099806a59baec0369f4dbe091fa7d3c586c32f8493a048e2d8962b76263c3dc1e182b4a8752b8a9be2ed262b11975752b8cc504684d82748d2f46e1b065e9928949f4ed49cce2bf75d227381baab09e38082fee044861903da51b9318c37dcda90acb967dfa0a0ba916b4f3495afb5ba00fb4f0479947f025ce2c324fedcf5f0005923e5ff3565cc72b26f39322eb1ba070e7ebd0e0f1fbcda2e54679f044b37c19a99f6cc4f09bbfc589d4c5d4f566b7ce1ac181bec6fa458329e5eebd3605e44302647beb4c36defa0ee0280385b08b795313851dfe7ffb0bc74ef698702419d1f7ab65b0a10b3c2553477b61e1a1132ff1ed91d7dccf724670384460a80c6fafe87cfb0bba152e32dbb3768ee51b622051dffcb3db34fde75a4c1b1926bf02f56acfa56ddd843d9dc80d5132fc4d02e0394780e1e784fd85248d3b2bd98427dd82979822c5a46632e8ad543ccac77628d1c1b4e29274089b4cb113eea2527034e4c37394c46c64f76c1a46ecc78640337e5e5ce6c2975243fc75053578def236a21798ce221fbebc2dc91a5c68716159a44aa300b708a407538e0c0c6f2941035770d0344f1f1d714d007b3f9d11dc97f3b45518c66a5bb09968f6416bcfffe5ee1929c3dec647ad4e9b9926385571594a884a89c1eab55a9182e62e5926e41774190c7f93f1c6360aed7205c69c0dd7b65d6beb91f09b70a105e5d8050094efbf40d39d17c3e918cf42d54f568d2a8ba687226b85121c9e7a5e797183b0bd267624a7606d59c490ba21fd8e3627635eb14ecd692548b79ad061d1dde261b7f5027df43e2d0c0b40fd6325b3af0c39a8d6067cfec166fb0371f85ef18c0342a8e8bb1d14d448f3e0c9edd9356a3fc5b380476dbfba6b363412f315b400ce9a5e42b847bc4dcca5ff8b2ea43c3d255f5bb4f5abd8edff7db12deda8a1d2bd3b7e43c0ffe411421258c4b88798b6b7e156e9eca448e3d25796ad4620f2b767f842838eb1b02712d4206c5d5853e75e5d04c5a376d833fbba8a8bcc0065fb36c25a36c45a022d8aa1a84069679db05eb146549a6ccfb2a47fad31ecab51b9ad2646124154dfad662964aef42e6e98cbfab03d53f5571828e727f84c6e02aa0236989e5e772e9035dd713041eb2e84ed5ee7c6fff3f396e7979a091bb572a068db8a8b4d04f4f75cc71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
