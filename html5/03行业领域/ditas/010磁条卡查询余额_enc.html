<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"070d3685054f602087af4a629e3937bddb17e565671f9caf5c8d428745085a9a1af8026b6b054a44754ecb75faa8b84599c975ac63949e442486d27926473693d30c956c94002b62ba4110e95d1d91736c8b21595918a3dbb88d8873573ca0483bb68d80f0c1a2ea3116b33dbb59567dba7d5ec07c4001a481afaa244ca4a09564398f860792ca50acefb1c4653bf478004c446da0cac442aad3d6e9fe02272b270305f93d43c061458a040494677f6fc2b5e221406646093c2303b9a8d1e7dae947be2f82996e2079950b5ab8953f730bef0c48145da2a1c77b62d0b0442aa334af49bc1ee1cd54f6c55c05fba7d542da6e07d8e5b2b5c2e2b99890dedd4f615e3bd5835fc678ded5ca972fa17c1ac44f5ba1063fd96eb3eae4c05184bf2baa4442ab92fbac4cdfc82f526e4ad551dfb68018fd1569f8e849f26834ca4bed285e17a657b5ef03df102b02e3fbf8d7fd85d3e7f6013423145d54ca890dba04c9c8ab8c5808b285a8377d29bb0eab6f861b98583de2062b8b0ecdb47ce03c0e66384eb6dbb80f366c42d45c965df08274308e3441eaa62035fda611c149a65f69cc136b6b7f35ecebcf29a9c3cc06e86dabc2033c83ce06867347d20c84310e4565a1243851e036fd588db5ec3c63ef0d3a8b8d39407ddf3aee28d072c713370c7670752d542d12348edbbf9f449336e2bf542d1589ab309fe07de49849e2b758d841b70b9d5b61aedd7f044a2d82b74a65c493a6c4bf35bb61ad14d015bd201408538d1eb9d37dc9c5288b4fc0e1c901df88c7dee2c679344e8f1fcffc7289dbab99be0cff6238070cfa3f3c1e73c330d492763ab7a01b23e0116f6f8e2403df3a4495ee32e9bbdc0e69acd2703188cd08532d3d5c8c13bdf876e7128acf0a949a49e0e3f33b6d3d8b8531c2ff01419267f816bed1f3af5140ee734a266cb291f841fcdcdd8a46801b83dd56b2d262ed36b33eefe5138b844827396b4a1bf743b18c59ee32cf4dacb08759f46300b3e0ee93be45d17c9ae2e88c19d4933a2a810326127f8ce402ba598a2a65f86fe6510296934f75c0241e2e83d464b2b2afdcd40dbd9896292f136898334da887e56b4a4b1542d09af812fa9c5f3750237328e7d988ca5c1ff02baf3217b1b55122188f1c19bba0c9a2776512f2ac479ad2e6922f8dfca0af989841b55357c9a2d5dfb6dc17d3019e0d950f0adc7aac0ca5709b84509a4368d45f6d22da3f52a019a610a877b70130a1b12e86e83e7c87713a3eaf1e9680ee30f4784eaaf3381163fda4b9994bc9fbcabf6a19266fec4776136d06300e98d04f985ad178a1083188d24dbe868f8dce1823f98b8f25ea85aff8c3973889462c86064efbbf3021edffb07bc2f12442a171b509e54c211c201dd6d4d7cbf858263008520e37025162262fb2139ade4eaca8febaadc5ae8698530dc4b33c71cceb5b5a9f0037405e8c2eda3bd68c2ff860b1a5225e21c67f04eb61895c0a4e3efbecba6a0f281cc73c6105e5e0f8a7fc2689c6446304fa5473d7238381883a2fc485140f5e7e44a8884850b2ee9f1808e927e6940d4c99dabb3d98a439dd493047f9dd87786233e3c6d411c9abe2560612deea1e19bd842b0cddb71604510e69e027168b6f543153c2ba18b1608503872f24f2bfa7848b291839661a99006e40f5445571147182d515f03307ddbb4eda52839297891b1de2afb9efc83a5d1e79af08035fa4f5ea27f088d348eb6dcf3c5cbd19c202bd9b1995c0d809b81e5d4510901e670b846bc537af65138fb3cbf9e0e30d5ba27bca733f3cfe0c4dd84000e14f24880440e7645358e6572e8d2d009772f23c1d575fcb1845f72e9ea3e716db0f751ba85c9ccdc0d7572ea709b1e2ed7ed6d96d19ce8c8d7323b8965c0cca19ae3bd2f89ebeadd030195db4258e7403c2802c1441dd6a468932b01f99acd282cd139f985b44b8de6a8c3fc060cb45d2a68bbcdfbb83519c39d64368b08bf912e3df68831c60ac8e7748743f90eac7f63ff974c92fe4eb2fe7591c5c7fcea7e0e403544e8ac487886b904abe7ff2f5c703e2740468624f1c67c55927fc3e4308aa126d83c5b7c28db753ef0b3818220fb6abb4df8cd4b379f2cb177177564e4a682ee3b5e8da6d1b02cfefa1f84b6f2d5dee08dbd1eddd75214a7943648baa64124c75648b2ebb17cb6c15eacdf3488fb571ef2cb1f55b7a32bfd38c4a0af381dafb12fe12cdddf803341b79a23f81091ae0019ae5789fc3f5a38c90f6558cd3cd964c185ebaee61eec413df5d6e6d957c6059f54257c602e0efec8e01fb1a2626361d2681535d1e551c6e1eee7c0d43a1a537871869a2bedddb8a7a48b76e39de571e3c37ef8d114e317e2e9fd209b32338ba40bfb547cac9feadf6b2f9b513f7a09eab05a2aa37fdf6b9c35727abd2d8d75f8c2234dc6a8f11f4857f3d2b810d8bfa5f067cf987be2d27e7cf790eec6b871d7e622fccb8b88f8ffdc4d6383252f64820e427f6cd0034886ebf7a7598df8d42891de2f6106ec22f5d94c9783b18263d5b0abaab3505398a0dcf959348ecd2a4c7e01f85ea64ed6e2adbac4294bb90d911fdf8111e8867ad4b04b8c46fefe52a858785e253cf645340e92fc9b09d9683154d677aa2bbae70b1152f54419a2a38e76915a8c0248013cd4b5e34f5ed1bd1b0b9c334ceb487fa30999e48fdc353d6a00db68ffb626644bd1d91cfd107b651c5c6db853cd33b414b65e329a6b4245182548299f3b01b923ea040414a55e2262abfa9dfa1d1cec3e543ded57b393a204d2f10380c73f2f8f090d1318228d3cdbf91dd556e200805e99277ceea19be844984a8f279ed9cb880ff876f5e79860dc36544c7ae6e299a436000a2181056940176027831bc97637ffc65bb67711a11c5a02f87cd2822ef03f27206194026e2e634115f0b074f7fbee0edee238f7c09c9802a0dc167910dcdedeabf70ae0be7b84d5fe4ba622ce375c21b0338ddf0e8b6bc5fb9cc6c932c082543bcf7cd04f4cbeb9b5cabbce5228dc2a846361cd700401a3948a22e7d6aa898c341d6072f25605b8a5bb7bc5eda7cf269a12d47e38aefb73208b343dc89526ab8cf455dd268009f003c521b1665270861645c8eea46efc22a2e085a236ee32490d201b6821df02b3f004acca96042faf0c13ad700458fc0aaab91510ff2d96755013917ddf4af3aae29a80fc935a0e27861500b070005e99b67ca0a57083352bd4c610b9d6ddb9035d67b392c79c4af518f1c6f622d38ce3444b76d4705679af2e9b067f7308ce185ebbaf266dc01e8ee7a49ac49de9297890e8b51cdd81f6dbb271d42417a6d2b2efc062478f2e76ea7979d0d99b0f947ac8f0776de12c53d808bccefe853f6f9a98a3ecefcbc25e5c423f033e6e44baf684a841b155eef35d83496414c569538ef4f844b3de4266c02ad19c15a30958435497741de8ffcde6ed97f3cb07c6062b963e269be6a7fa4f96079106a52401517ba4efe38f042b057d3b1f1ae83c16fed38db758f1958f359f0d86c79ca85ece7402016f35f983351e2c62a48a37e50b370866402c50df90432644367e889c7ce2d4c971b72a13807ff8919b7832ed4b034a8fa70befa04e94b3c13fae126d56de919c787eb30cd827d7011692d92f75bf5400f19e00150a8b46e77af091b2cadac658bd374fd76f444bc2da77d98494fabc2c945b98b7dba425a8595f38ea814c27b84ce1491133ae8e53139f9a23841660ea46221f42d416fbd321eeb31d745594890b87f37a3e281298b393fe2a885a55cbe87079ced4cb3231f08c6af7b047c7a67512217245482fef638e8db0cfb2d0221e370d01a24db0da8bd3760e45b7a4174528712fe152206a462837b03230c5af307091abb90aa1613d13c462b458d047c2a373041deabf6aeb7946de8ef09edb4c28c3c038c5de270a7209bd87e3e8a0649e523ac282f0ede75e723ca8c699ef790c5b4a0993c1b71e300712c7b34059208968040782fa22cc18faa020eb45ed9cbe6f80612a0d25f3651b6abdec5ec0dc2a96e699cc80d6a86db73ee730615369b3faf6f799106504dbe7b21fe366552a49e134359c48074a3aedacaa33b554d58183b4174a7f08fb81c7b89302a2af5c6ef2914c8637bfed70b439136c8d3f13fe4a9ef6a14d7f1c74c73bb7f3e3907d3b3ada491b75a0c1662add4b656d6c6326b8bd01d456c3fa8ce40418a39cf1ae54ec15eaac9efe9d9c61b5dfa7da1a9d140d8583186e902d11a79bf2bf08ca061ff0350f22f3a4f431a6129e6cbdf5c075efceb5556e7192dad4b131aa1591de113f2ddfda68e9f36bc9aaa0a8927157a5e09ac5063a46f361aee159c221343990ce2637e4493f93c5763f56ef2410251e7b3cfec31b60bc8e113d957520f8930cbba27b151043ae1685ece16c2525faaa7015c4754b8c55e439ccfb309d181088c7017667c6d5a847fe80b0601b41a6eb7900675057e13715e285a69010d0afb21a5b611621fe05665f59efee2c5a044948374deb18478f5844adc6d59866d3a92a0c838aeafa97a30e92eacb819c4dda39c7379375e795d02fb191277f5a2b59e281c4d59b58603c66eb20ccfc5373d5e897b257c926f3e7df338c827d5062f6b64f6d321b3de98bb20221dd1563c5c962b8007bf4d8976a4f2d18a0a466dfb4f68e4a9c5c53276f739529adea8e782c7f425fa42cc7d31cadcd4bddfab9b46e251c19ab2756b07e0e265ee621939fd9504ac4e3d40ac8c7ddd71719846789eb62c02d6025f551ceafc6ab392f83cd68df7cdfc86860da41f66daa1cd132f24c5fc2527a9278b80842cf552356f4de0ad3c9a34455df2d0c88474d9ad3e8b72c8ac0105a3957240a03d32f06ead2d8f3d4c0370886db4512be401c47920ac40a26f68fdfdd0c22424e6854b8c516ecdcbfa853f89a819f54079813c0c96654103fe48a95db53ebd6e8f6ba0d1ea6c1075be8eca095b8fbbc38c64bc73e8a21d4f4f6ba658696a18ac4465eb0f3f058096385d9b60bff9612eb2e798681cd42beb6ae7820c661826d3bbb31fa3e946f7fe9c89623b6fab19bb6067b05caf015e7a1be9a371029c30bda1eab1609128176d491a97f9ddd09ee36a2fcec1da29c761f8ec7255221ace66a61281934a9a6913d156850d0fdd98956614ceda989fcf21286f3cf2de4013f50f5e0093a50b26b2d98a05e6ebdd2aae8ba67854886bacad3d75d9e80060fbc68b8a111281d85b34b25a00b65d0651ece2d69fe1d04b60e340f7de85becf1ab1eba30a9b795f144d1b2430897a7676da3c563e22d062be9da6b81018b472a82540fee56114be02b3b0149b6f72a90007c8079e89b359ffbc005bb746e3d9cbd95aaee6b8c568ef441b75c7de3ea31f47ccb8a45dd5d4a0829cdb07a59a94a4e37ea46674cc29097c4a295d9f2ff76d95aeea5db598c8477d65cf29d12ee0150d8fdb0c8cd37c303ac91ea56464542a12480e14f22dac5219223c7a4dc8b2d531d8551ab18d123aed19daef13b95d5d969988a9fbe126b6f1cea8e3ecffffab085c1f11d2b79b1c8e69e28a23dccdd0b07963fc6fbf0e209f43d58a8cfab2e9ae57e83156dd63bba368ea48dd5572b416de2f3b5109d4648a7940a42b84b8f4ee4de3cea865ca0f0477321ce659cfd8638f844ee83a62d57e97ec0122634dea1228c10e575b3ca1e1fbb151b6f2497cfbe4efec681a6bb61ee8224746e350af525f3330fab9ea7e78a3cf716d07f1fbe5d16978c2f437c25391fb44bed1eca580dbfda892a58ab6a8f6d70eb87c7da173aec1bc76038295da528dc86c1d4d920a1c19d554e05ecfd5b94969082f8aa71590a73022257080e84d236f2c9738464eb085778230f5c4ddf7accf8352eb2e16e3db717d737d182ec71d5efaec62a3b622d6f60122b81331100a37f6b85796eaf60b52ef6ce3f45a1505d0db17ecb51f0ee1aa112c67b0fe35dedf2114bb052ab6b8212a94d8bc1422b85e7105de0baee3bfac5ade4ca0ec3967e1d3e46b823e7f8c9a62741fc5449674ed9d6be3cac008f0bc1eb2c87b7890afba5cfb7cfac6acecdc3d5459eeddcd581c3f35a14a775894192c0902fbdb6110d91c49db6bf5f0e36280f03f0db3b8f51fcd34ce02689193480eb8bea19a5ce5e94fda11046bbeade4c997138ed728714181558a1594faf46f48b5f51f5de003c75b8d14d8c3a7e18191836afdf2a6b8e421b1363bb82c2c0b8ea4560aafde7e0d1a39ed8f4b952891ca0223ebcea3c4099a53ced46e35680c27a24d485c53563549fe5045dd1248a01cd9b82c5a2832c31acdc8c49e9f9a6d4062c8990f5c836f02a174d68574b19959df028af065702b9c2897f8eda436117d82f1c120313e7fdaf76a37deb863fbbaa21281f3df53bdd6cccfa4852e1a1e7fe51ff54fb79dbfb72fedd4764fe9bf5b9f7a5426ad1c635f0c47c8bb15e0c5ba01ff42224e4a2d4072f9dd5844bd25e40403cfd0b3c5a3c37698a9d3688a1aa15d07ae3b6fc2615e224ab10bf099c94db0bbd38915093ad0728622c53e9d3e362689702281724d925169dcdb3673db3697333d2eccb7328823a4c5786e7455e99d39dcc1418a87f574fbcc4dc3d3aff4cdbac52344db8dad91e2537dbe5671e53b84a0e02d51165e6b621ec49a6d186941e217f16f5c9f4cb8baef316a2b28c3935e0f1d703cff71998d0267455ad80b9c57fa462c5567632c7a1405cc767b101c6165b5f2e1372e7c758636758f29e217b2085da92a6205cc041016bc5f107fe11a0f35328d955f32b6b3f272f1bad1dd05a814e7d1a2b4273ab7af87bba98303ae6916929a4fb566e38f401cb4965b7a832e0324dd390d49f4cb0cb513a9b903d62d396018e0aacf62da206952c9d61c074335cc9d6024175c8cb1d45fedcbbd774032a040aae4330ba892092b2ada681bebca3b99b7c466ec131e28b04cbc9609307fe10e0f708af5fbe49283099688b696d70ba0f769f94e07755897cb235a3bde7ea0d9d0928576c88fbd2565c85ef0d2641aebf68356677c02da3fb516fff8d23ceb0b581d21d8703a20e075f6fbecda6306969d1a8dd41f569c0d4a6d7750a1e843015f4f1efc54789d8ceba77f1bce56a1b54708b7d5c52d681d070a2abdcabe73d28795cf6961ff33ad75423d474f59c87791fa879dded8d6ded5a9e5775afa4ee2e5e26276ff1c5307e984882c324b122a76d4b20df29df5dd119f8ee2a5b9e0c5b1e8b57a5471e09f666e345f4c9337d55d6eec4851be46f183de0a8e804d583fcf110406ca7742fe7a85ece21c1580873969c99cf38f78df29f8f2c797cf9850489293e69301d855e18f3afaac5aa133db1d4144bfc72650985e2ed6789dd7d33f85ef7672410c0c003e27f23a4fac63fa72f9f4471a4b73b13d1bba0f1d6c47d8519c1f06b4522843f67b158548130fdba0f5f0a68769db824cf8f8a95e38c9b19fef57f0cbe790d57710707ec7bc13f50f620dd3f673b461824b11a89aa9195d32eba2efc37e2bd2de7f55b3188a5f79907c14c212e02b6be9d645b4103215a4bdb53d601bea2d2be3c56cee192df491a4cf365a06a12a1ca438e6b4d8414bbe6683ba2985547c2e1cef840385a32be294e7ed69e23d5d62681baa6adb901f2a60928e4e5bc9cca94aae54642c1507d7adab1bbfc78da0cb5e79ce04aab16976d08e24a09649f31b7df2953674f5885cc63c7ace27e28036c23d25b5ee28879af53f05a158ef4d5d5e5f2470a71d9fad0b6467aa2a6683d2ad1e6a6867b8bdf5a502a6e7c50c1dabc083fd64dd174708b8ef284b987f0804cd994a175961366079a0aba4fcc66a27754c054b48c0657030cef020d5aa63d5645c2f4b0fa36cc68ccf3c254775172d4c9c6aced9183d76a53d6cd98e4e8ca990a08cd6347690541d656f43be5902870f9016c62f7abf5d405976394632954044cefcba9556f5798beb3b2a7bb24f24eabede9c726e05b93ac9448de07d81a2b29c0a869444f4cc094f1536fd48fbb992c64e774f1500b15a6b3f1ebdef1f04f33b6f829924d7d559d2567a14b149c605dfe734e00a17f3a82082013dd5a3dad5e6758169235f9ccf5763799caaf85c850132df4a19724df721fb1aca0696833863017ba87fc6ff13c0f91ce526a162e38b6ee47a35ba4000f25ac86de7cf17eec96806159eeb234ca9d9e1ddde942a3c2cf0ad734ae40b497b6b934fda4a9667fe1ab07c97321c6f28b6e65e2c7e3424e8d08ecb39f14a7ee6ac883838bc61e26de0845e0096fc7f33ecb2eb7ef0e0268cdb0ff03350a5747a8b486d0344b213e3ef1aa3ce29fdb90b3cd9b52d9551f2218fc142d885707ec0929c2bc3063bafb8b85a9117c005ce182285eefa5d3be57387eee20a9cc76921eb0259346219a725d4038b3ba1646dc0ecb3d8f9b15436f381f941173b131c4c55e2a7f4ece7edf91ff275437b6d3de6cf535fcb55981767c6988e3ae207b1c2d52157bc09a17f2c35023096a82fccde36ef7e9b96927eaccbf3d4251bf41f83cd1f0bee3beb3f890cf34fd9fb3619ae04bde61ba98086b81008547af3c329f9d8a361b14fc5772f8e5977d4065f502783e24eeee1e5fd83fb8b4d3fdbacb98e14be81d3ee2114f0536c45ec10a6c05824bf04577e6a9312f074b7f1afb63f5e35799598302a77189c4eb9e5490f3a26fce0ea08da3d8c0215557908b60ebc85cb1b97fdc4e7b2573243f0de179aa22373c438c0eee164151fffe5eb8987592de60443a75e049e683c73be39ef5d7dbeeca84ba0fbc90fb8c9dc8c59634ad5da6a99494db4e6020786e1d6ea2d0d95d8b76075c755a9aa2387d24c558cefa9b1ec0d0643052e4430ede1731de710958fe691885b481333e2a07db2f2b5a3fd1ebc4867a3f026f8f61ae9131f75e26f0086cde999d0e3b7070322c1b1ae40a45c75151f8d3f744f5dd864becfc995a7853b745a4fd70ecc993998d66806dfa461b1c961d6c6fb5f094f386eb410d485a04cd7a377ae862aa7ec7600c84b7612dd6dc2e92017ad9138e51767a875cd01ab3436878b5a5b3eecade790dc1a304145f7db6a7fe4a82045f9775f1381bcfe4d906833aeb93297b88414938170a54ffc86d8aa8eac85bb82a6677d78631d895a230fe82e1560fa7b0025854fef4fe95a3ec1cec504570faada8b91803a47ee91ff074e8ddb1f8b177dc36ec12d7698b21399a9683b211b58c5444c9b79339af8d42101d89d1a9a25210d469823a0b6dec392b69f946ef6054298c93632ccdd0153158392be97a5b5735fa2a055083b69729b2d0e9175876142f18283c249a782204fde27efcb35fdd90fb39406df78879df48b8e4d90452b788721633387e300632f76e63c2090856c5da6fa7a4ccf0b67d3b6b8149d094e5a4341196eff6308d0a8c9e02304807a7b95ec85710293d63e9eeaacb9da04086ab82388e67cddc052cbc29a03617184ba46d7a5b3c36fc87e426e39d8193361d2f8103088338b800d8637cb9959afa04bca6eb7187cf0ba1288c77be15ecd200fb4cbc1209d8a1d5e5299a678dc5e0e45563c39e709bf1c8e89cb9f3bd09ffee49fb8bd761f86effdd46785929fb3e23bf3188ba67283079bdee8b3e4b4cfd5c954d1ffccff37c351d53066817e26a4c69b16f1b9a008b3d06054107de6b9eb25f4fa3bd488f4c5de67a6a8783651dd9b36687f8d8098e128935dd4b03a0ad3b30013908af5590c99b2c4a08642c222aa7707313b7d7f1855b05c76ab803aa044cd6e0a2c3159df17e59c446349e2fcff0b0c7a0bb6bed8f91b8d80a5dac463f95af276770c2f225f979db9b90b49885db719b2705423bf229321fb0ac0246445ab1bcf2a70a8d4dd5034b0a8c743d9784b51304a00ba52f1fcd2190f791c06bc47b5aadbedba48cadad2d4b316285fa243314b700ee17b373e577da3a2154e95e1e755582ff0d7759a8d5e817c9786716ed951b79e84da8e2b73cc6326204a381471deee20fd77ff6d88fc6332ab1036112ef53178d4f1f069140db9adc5e2cb8d5235d9baf92910ae6362afc304c611432815898a7945a488aa0f3ffbef813061d8875286bae2efce66ef51f9be341afe253525569b48280d09f13df7ddedf835db34afc862119a4b233c80309bb240a91bd6cd278365ddca39673ca0bd17c78e1343494ff685f9afacc6cdd2af68bc98581855834d84c07791bfbe67ca7144366b49accfc82a78ad7f323c90fcc5e5965835bd56184470b99a2c96b104b3ce7608aa17644e20f19ff8052ba60bafbcb84ca95ff76a88debb5ed67004dfc41acebff7691a38566915e1663d5dc35a25449181d4a3388031b238e4796d79ca2720deee2d23b6e31a19493c94493dd58614d812ae7d89506ccacd1f278f31205152081c7c50d8f6229407431463e4775ea81083e8cefec1053f5766f2da1819b0d43343c978fd9f5062f3cdb1015b790cdb6deab4b2748f1a6543abcb5ae782003bdd89a528ab09d37b43942c99ade12d995167d2bd6aa0ae97dae6e8e33f4da282316ae74ad9c046a566bdb985cd6718dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
