<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d44b338f693c03abcf45d4ff2a2ad8b39292b3aef5183db8abd3ed72d1767a31a7ba2aa4f0d984bc5159b91a2621137d5fc1d7a4f8d04f1ece2fff897936c70fdc904dc0ad2dfce43d9036ba9d966740fc43b5de17fee10dcede2a64465666a8544b00c341d5a8f290a2099dae2efc8255f6183dc7ef9caf851f3ddbcbd49dd181692297c41a144a965a18b9b321f23a57953852b1e9479e973154cf5c0949aff5e11dd71e1bc43ffffe5102963ccc8e9434195af8e6261ab6d8524a33da949e53ef0819db5e3c1bec0a768c5ee2d2f26d63497ff15b5a620cca2c1bac2ca28c9fc4fde5e56ffb50822269043dd480e678ef6344427bfc1d72838f617633dec73c7b299a7716b2703b1eeed1657decbb74386557fd38c31024dc0a069a500895a515e494d7938489ccc137878c10c565e0410beb1d14ae2cb16a97f015c401ff5dbea997481b082f19eb2a73f991db6f7ae64713483873bbc417f97a13b2abc439845899f12b1a8288fbfd5688b821cc449687f725e5095a902852ef6cc60ea83410f19d7ea8b2dce2c730a4ac7bc0ddc000503f3d32fe5b375dc4dfd0760df68f096f93ed92d1c4fd9bb754864b5934b34f4866a1297dc9a9d01e94ca1349bf5361b44547d8c9bf64fa499f7cf1751df548f80ff42674dc91e2ee2a1bf01899adc0214ff8e74ec826c60c351bebcdcaf76beb6ebea61bfc30461f7d3fae06f95bef0e985109bf1824dddd95a6f73ecb611a6e2228f2f600f5308e8a805604b19f0a1166771317eaa40dee7d66e6c5c049d6c321b925d5da48a40b8423afc4b9f90cd707cb4dbb217818a1fb029a50d42721295fa7b21f9501953205450ca63f105b6ea2c41ffaa578761f2f5f087b070af77085564eb86820066072e171fc524799264cbd119c417325086587d8b8cc620448b4404c279076415761590c55ad153ffd1b624febd5974bce536286468b7428a6e1366b46ccb66605008f89921885c57a21c4a44696927f9e6f962a4027973b2ca602e81f714be03b22ad55e832fa5ecb55a5001899022d7db20255a28fcc407aadddb3bc69c766703c0178e4d6a4f315ab34a2e4a924a96cfb0d4f739bca8ecc4dd4f822d183fc1ca7f04365671f676b4f373bc1573b6f66531e376fd29fb565866f0f67079f8557b1746b35e7462daa5b79419c0d41b97173ace090df68507e3ecfe8d8992dd9d489f1b885e99240f7ec763586ad2b2ea4f5c6e36a29eb42cae8baa11c6f7b5310f6cea118e2af67a5b20c1fc1954880b5e230abb842fabd4ec2e69dcdfaa675c60ad5220b6cbd6ddcd1ad9e2557f516295e46e832f9bdc6532487142b77bf2c0f8192bd1e28dab8aef376c5fc01cd2ab6ff87a485cef99bc1f53955b8ed9fff44f4fdc9d83b7905340f2e16b0ca7cfbeb18a42a6aa7ab7050bad976805e5288a990f388a9e49d120c7856092d2cf0b8e4a74cc52740d5e769bf5b789d1e1122e57cd78a6d0e4eefa4cdd2ec3412e512e3cd87e042dda8db8c947d814d7f739d8a4b4a3a75f39c749b827f42b0e29d3b48ef82fda679c58edb8859a9cbca9ca3bd1d5b5c581274944aba76e50d67b5d7ceba90260032d4221c535a0ac57d4dd39c6eb3630d2184aea7e7746bd866a5ad72dbfac03d58c764218dc245f4351117d0850f02028c360ee8b066f4e57d4c11cfcc0add88aeed7385d98119b8dcf5c36e2e93c0c9307e2be1ba978018f911845a2b960f7e76cd31be63b0894d6c44f8d7420c7efa85f142eeed0c48bc5680bffb550f041bae290cff53e8ba13617e3d783a30b4bdffa443d42f95604d6e181e4e29599cfef97de85e54d62a17e4f7fe2e49111bcb809b1ff22678dbd3a04956c0a6b826d129cb6ef0b1aa119edcc3e907c461609d48dbca2a3f70d3930b60b464be815979dd8b5a0732692ed4d0b049c084f125a8f869c18f73cf384f0faa54f10fc2ef41be13fed1cd6546ad1ee83945ebfe5b7ba94efcdced966425d0e742e52e17a24beef56c0967791c010381294cab4ec34a8ff17f4f7d43a5ff24835b7a248e6a66d3402067fa61131f4b1d4f527ebc1e669eb013b79e177fef2e92a360b31cc5c04a123bb7309ae582ae652434992eebfceb8bcd99d3f88d4a5d04a49d974f5d3f3934c131212584661047182699bdb14a5b5d1ed22b454ecb4af74eb6fd6c292cee21c44ad07e0ca300b9954b344366d4f4c30f75790b56c428434c61ddb615b4ec54f5c92cfbfc9da88e503bb98e83bbf4b64120b9398746bf5e9a50652695bfc70dd6102153c09975c36b0d3e46e006d01edec75a4a0351ddd811aa7fd6de4c10c03fd7ec0e4471651032a2c36aac899e138aedc7a9f82370fc0ead880b16e2c10c28fe5c3ea72b09afee9f23e45e515444fcf24498571a033a6ea4aba5ddcb5a3c43de838f982d5dfc16408ac403708f1ca26e510c9bcb5da350336ae9b4b277bafda6f7b1b09a9894c56259d5a631dcc1ae3ddc79564f89946e57e2f5365ef4bea2d14ea264c4930bbce3789553413d382e8bfa29be0825c746c609eb0835944820c1aef25a76a35125fbc22fc6a7f69d1706936f6faa09ebe81462c953b1b5fde3f032c8b895916511e2cd5048f2de865d0322657c9cfd152b70fd42a2f96f4d029fbd1aab2f3b851271b55c138bc8797be0b722944479465c503fa7d2efb70d5f330f3637132890e8aefbbd2724bbd60041c76c0b0df314717fc4ababdce052aeb43fb140090d1e4158818f26af1440c787cf011ffc5aa309a5d35b16f424a44c76f4c14e61039575f60d47cea08f7dfbb44006c46f94c80d75b4a1f6a07fff477f35da12247ca7c7279dd0de5d94945cd16b15f2071dbf258a2a6b8ff47d60038382b3b75cb1a36bbce35a10f8be3d5577491181be734bc14cee8afac53af176ed3fef90dfcd1ea3f7090c5b56fb168699dd29e25173e9dbc5e82a921ff2f2ddd2b3e2193d3c36c47a8cff839103b537f275da5e3d7e440af094bac06be52da5276d3c6e073287453b7074ed46a61f96ef00ee92c58c26f811c2802b22d568a649a3d88af88978fbedc778ff0500682ed990f7c81948c2d907e5bb290caca32b3b56e7c577d3bd4b8a5aee33d14e8230c68797eb09b35d915158366e964da9d97c16f34fc6f95f4fe9d32ace91278e943104f25408169852f6b93d62b7eacf7cacb272a1b944b41321edd4806109c62abadbe2f6b9ebab1ad6ea4a2eb49dda3887f97b3d115ff1b168828850ad86324e04b5cda9b3bf2da34a3c311cf85f27c909af73527466a7c27dbb007095a202058888929ab08e0d4c164cc77eca6a72bdf403128fb2bf4d8463e799e94f6a725f03ab55637444ad4c053a5007247e960d25782ae6459f7700ac6818132116684ddd557eb5740b05acdf38f1862a96e286212a327952efab4e0e055c9f686d9efb140c7a40dbb3e643e1920ad909d90402b0d852ec020d04f7e4222d4f251d756dc6c9cc6326e3ec29ae69538e7e5ac5828bf41d0c1cc21ede2d2bb18e64b46a36c89266f27acf90e88f2f95f061f2b4ad3ae66bfd46b9bbd6d1ea6f11dff40109465a6b432d3c4178748e49e9548f8251a1e0a3afdfd31e6181b2edc0344f90f44a4e045b06921c06dd2458ed1090aa4c6295da0f240880dd0975d037876f261a0a88108cfff3f9cf326a1fc67dc5ebc8a8f106dc42f7ddc88f6501d4ce0f7e24ea0aca7573452a8344b98b2f5a6370a1e6942f9925c513828698888a94a850c30fc1d02c06ec1b9522f2ef29f1c8fe353199fda3a181503266d10f5db0ad0966b42d3933e65e344d01ba1213adcabf211610c05cee709a186b4c812fdf053e03d3556ce0218d8a5880a76e65cfbc40f070b24846cd9a11f7f97a2fd25f5e436c042772211c410f53b348322cb3334861af3867e7254e703a72601ebddaac3418d0912b33d1b830b5edf6be05d8942d10ac0e3125b3066d6497fc5cbae402e5d697a26c7707ebaf2e787effb826c881d0e45c529466a5f058685ddd54215d1608589c6bce8bfef0834413a8b9b74b5f1e5e1e6bbd969a96f70ddee659ed18cca70bb44e84eb0b2fa23f21dae408ee9398b72d71eb4b1b9f0df6082777b3cb9d71563224062a8c2543f0b5d7a0c46ef8ca81e9e02afdbd7e505aa44793e177d379f2d8818c45d6ae90db108d47036554bb6760532a5057334be696c3ce123a3a122eb1e3afd438141b1b55e4e3db3252bfaa2eb5f7162d0b6f714b0be83c2e4513f05f1ffb24b687ff2d63a56e1cb7496773c5790339745aaec68fafb42e658020067e195f31efa8d3e272dc9e538df13b509e5b8779af210152091019bd32aad6e06ef314862f0ad2c0bdd3c778c6b1d59415c4676aab411ad9f7ce4700ad3b64511aec4f17403b9683ff898ad147f74e5d0bff7271a3306f1c584472a1259fe5aa5136039c2b5fb3860b328e0ddfb749261b2f5b584b7aada1b872c26429ee539f16ae18c642adc4fb30ed5916f6b9cab5ebbc457465606bd3f0e10e10fa4c02abef0b361425a47a37585ad10c5b826b8e0321d20f36010a79007bf7f02257a2138d28a8fdd770bbf9f15ea1da3eb25cc63754d7a6ce0e2259296ac19f7993dc19341d3a485f3723b1cd8cfe1157f5caa398968c64297290a06a672fa4c1da39eb50f9dde67ad81185fdfb28a51b6abec4ff7d726370d9323f07ebb965872c60745e18f568d6d4f1fd019b1e860919b090f8de999935055190bee65333350bf7f2f28a998a71612bc438e59719e343d6a7971581f778721a6fffec6ead08c7c85bc156eaee1d65a2b9e465c8bbe555166e8ff871994458157ecd79da022d1a17081ca2d7cbf12504ea264d047a8cfa19ec34982a109b80270026f5b5291680c4bfc966cb4ac26d789be3a94e4615d033587e52b26ac889b6d31e19cb52c61d9ec947e90dbaf72ad6378c326b67d49cdf20a91b8914a05f522e19d24a85a832b325e64f92364bd4fb76013750c4444a5ec82d2c4d2be40abdb2927e05feb9bb339b8f6311ef2f864ff35b614e39394817f3525d7ab83ff4e1442a26e8ed71b4bc3dffce298b5bd069930a2fb0a2be67deffdeadd09ea4302f50daf6441f09024a3761aef7f061ac0ae237c332f55605fd27c176f68533007c47368f4c628ab7baf737d8d0d377b71b374a2785aa64c4032d9448baa6211b789dea2bf657bec7d2bd0b2caa74e33350e75eb9f859cd594550722be19e2d693a0475a5a91072047bebd96ab37eebdfda9ba96f54ee3b651b9060151a525f4fc505a1cd161fe3abb4bf77a1731bfdb1b3ba98bd033c597083ee2814f0c68fd2b04efb289ea4849c2737f850bee331dfcc01b3b2269166fe8ec70f94d88db6a278c6d342a0560f3603fa789352e0c12408fc78a05dfe31af5d43749551fe53036a4adc2309c31fb84e61ff29e719fd5636d64b843248309a4d671112ae586157bea58e9df1182325ec95c1a465ad44c92d6e3b9378a2a4178bfe4ad852ee1b9faef2aa33a3590807f5aa38b50f4c19e5b90e306446f80f7753404614bfa1f80af65c581700987674335c39bde1dd46e16a6d7dabd61517ef40aa6631950a0e8bda8f7892d9fc0ec2acce7f2b25b15dba9c403b8bcde0a3dacede693f22e54cc132854320f5386e1813c9cbc24351d3121c9e3c74b6dbcc859d8a6db92cdff24cfb46b10aa97aa114ef3b0ff29aff547cb32ccf106cc2d6b9fe12cf6a9cf444e7da5cca2e09203a6278c0fe65287b85677d8b851c22aaeb53266b6521d0d02d828d06c74f5c6a3b514f8513029e3a68bfff9095a600e6ef5b88ccb729a5e4759a90be4717f7f4a4a3824e6bcc53b7be0cb7557448ee82a08b6b937f06e42c6308ea66588142a26c976225844c0e82400830fe6a0fc6616bfcd8a94f74b140f298a7334b04ae6a0519ab83913759ad943c4fa4b0950db411f4f1701414a23a01feccd0292ac7d6e68da51fa43d7329cba16ccfb7824eb50e83f23f7c2aee2de806f5d0496e16e8942c4c81ade718a8b29157c94cc610c0f3ba3617564211a1cff03fc615b2589d1c63caaa7517e1e36e6b9563ab7f06595165a0762770d71c101ac127758326a9c693c86a13a210a9b4839383776a45347e2fb1058f8d0472aef04cf6dc9ef05ed30ec0a401f379ec7eca994d73facc284676a9b817cbcd9a9487d7cf7f0a954ea3c74452561a1719bce2c96574a80ab8ff401011f1d09d4b1fd503578b07cdfe2041e453562e52e0dabc7bd61faa16bac3e3772c8d1ea8aba6b3152b4bd6bffc0c577604db37cd29281744d64bb9f04fff1f52c2a5b5bfce3a165668e0d98cc67f849783022533daf856f9b72661a5f8286739496f23b631f2e49934ebbb0726a81b281852be6969223e972440b3458301ebc64e4d8e4cf6f16a3ad277f39c7394c7808f0588517b4323eaaa4a049215b6e5467bb97d623db2d570f56e5399165354da629f4c638f718fcd0cc248efd2d5320c343bec17c9556559eb719a8638d94a2d6be41a0fb29fe892810698b06ea4f03a5e8306936ef22aa8512c37e0d4e0452fbf752e0e5f90b4cbcea83b563552eb3b5023c2627d737ead99ff0e0d8a3951aa22be78f5552ddc4e47928f63cee102c7688374928d2dbafa600f18df7e0d440d69dc721cefda869044040e3d2998622cdd061f677f791346d99316e5418884678e110d050166fae783d3473e87a3fc5f6e5fca2521867068f4a6c0d3a328f64736f7969c75e9aac44b773bb4ec3ae7ccdbb1e7b90b3755d0b5367031772af73279701776bf70281972173dcb2e9ba3ada4e149dbedaa65c7b3b8bf5c8f3b4470c72277de173bfb72d7c76be1a6db0db78fbe7cd92223921bf4475170dfe03beb1100f6522b493bb7d0a3a0d86e68908d9ed54d831c0c85964778479578c6cd184ce03dbf60d9a0a9cc48db517a873818a8fb885c580ccb4a657253ccf1a9f0fe281ba74da8334d91cb8516b201d83edd3e072561824cccd2350327c1205725dc0162a7d6de67b6e7f19dca726c05112ceac239de4f59961fb28f8fc37924757c69d8d565849748fa09acfb4d93ec2b64bca27f781aebedefd98869f4c8bfc16946a41840dc1cf52bc7cab285087c682133a5155022390f1a10e4d3304f5914588f140793dab42c053d0ffa0977423d7e9715a4de8c5107eae69024a6feada4b0050f775c1a1e90c8ac74abb3bf68b1a5a0a398198bc91d638ac0e9dd7541eafec1f674fd5eeaf69a43ece6357c2d1d2320ee3a56328156937d687a7e5425f26e4e021b305c4782b689c4a8d0a03b65f0785da9c49282a4cf055ddd56e300f0ee770110d788fb0de4022237b1a8f7ab592b0865aee3c7dbe0bf0c4bc8e85d87ff495992c8f847f94331a2c8636381dde2f22e806219d94166269f9d48dc299093a1ecb00d207669c20e7243ea1a05e8db60ac870a1d203df42a4819a834c5b1017362eb7d7118cc8c86bf4f9fe9811afb69c6fad57c7908261bc5fb76acc14785bea4d06c9cc926ac77fa5f80597577b08fce868dafe2c5792f0ad9f39c2c14ed9f0d8db934c4fc98b96c5cf823e627d021c647ffec83c69f4238e4d96e68dc8ffedad9b7a040b851f46c0ae61b38912ab6f5f46588bbabe73b75c685f1e3367f238bd31e1af6ff3a07f410c473e49be102a054c34b538a50da3d687fb758c65bd1b0372328cd288f25d5f1577b9744692ae4bc2871a8acb2eaedd740b4626416f29d4e8923ef5b5d42c65325743312474cfa5bca92678fada739284a223d95670460315627a72dd0ad97f1b38948427142377d7ffffd0b17fd8c91fa915678ad9aee679d79e42deb1a5d9a3c52351eacfd019f0d5bf1d337eea00ea5e66f6ee9984358ed08d1e2718e067ef305cd9a2b87b0720c82b042fa99b02dfdccfb4e65544671a10fb78eea93c88ee8bbef9509cd4a1362140048ef71471f6c6076b37bee3ee4576879d2ee9362c39d477553ef463cec9129dd22d4debb29dbfdffeca437c68d52c2733040c82b3ffa55ab99f6b9222f6a623becb1e85d2125cf453bad2dc0acfa81f1ca415ecc5334e0028590e14ad4cc4fec701486163c5631d3d16dc87ae92748a6627bc2e3e5338fc1ad1b4a6b1ff1a15da2f4d61940f0413f5ff776fb8834dbdaf125f67cab4d95eb847ab5d435ed949b45e2d76360219753cebc32d02ae1c5b6e248a9b9dc35512c7d21fddd2b0fbf8c59c158d39fa7c187304641b461114883f7cf04e843ed622d842c6400a0dfd62430bbf040b7f6ad113f437d300f41667d288c48571344e62a2662b6c58ccf4ad7cddd81f3b113e08fac62a5ced38268df291683d39d5cbfe902d652455a41f680d0f29dbd3e106c5a90b1a0617f05f4de5ed659f09b38089b787d40f6f34cf475e67ac14663e6b50932bee9c2facb764f6e7b620411d173d9fcea2e69521108236d14bef3e0a6268ef8411d0375ab7643b75c7c2e583acf647d72a524a47750ef013cb7fed1d0097cad6d98eda111ae4b08a4d965bee09d67d8b4e756bbfe5d9cd427f0a38d5b341faef97431173ad189fc55312a2c80d64ef8867c8af26b282cadcc74d5607f4468ca6d41d7373175da39a6e79bf150f0ca395f840fdc67f407a9871a99b775e803a2415e44d15962b502300283216c584244dda619873f7a295b51c7c7f3cbc5765c4ca03d8dd810a6337469e1d3df74b9c274d1d81932d05083e182781b96bf6566407771c0b721e5b00b79d330bf5209d14ddf89bd81e367d0d504429dfaec4e2f48ad4d8d95d45fd13cfccb8ed5fb85c089135127eb15d5d70fc3b90a16cba787f264db7c8cf1be508bd27b2ba50d6cf883906363652999cdd61cfdb863b95630f58ab15b50d4940507d134aa1ca70a08d994a1dbcb81393692627f5da43e48eab03208ebe98b5db1fcd63c5a75a9fd57718dbb025d2a65963f26626108cec2d70586d61a2c27620097b20ffc22333cdf3ba75cd18d2f6ca412a1ed1a15f456ae033284f8563a1c8140d0642fcf9a180fbea0f6e37c278cfdd715cba81cdaec443432666bf821de03a8ab7a1d0274fee1262e1c52ad2ebc161a8a633a02a51bd605af9b9c3b4bc29bb515f593bcdcc66815ab8a121c2b82729f421a2eaa5d4c2be735c0ba9773f82e77d74e4f40463cbd77afe4c8bfd63c9a835ff6803e94970a423a80349d8657fe97b289a94bd503bdb2cb0ee196411e7beb9280a45d1f51c2f947d9f993ad5a6d1fb8757f28f7333e5ef23312652999525e0df5f57f67b7da274ad1e52785c5be38237e9f3fe20b40b4a3203ade481e9d53d19174f6e1ef09f2747f4523562e28b3caa39daaf857728adab3e317e9673622cf9e945a20333ae86df04986a69fb8d4fab3235384d4188b1fd32f5c4a2958be1adbefefe280d393b7538013dcc1b7c878f313dd86d98fa0a7609686773f03d5c0348779d96341a680367d046d28d00b5c3c6e7bbc5899bae2685e3e97fe47bb4a9da59f9fd5c725d82365b5660ab7bdeda28a2c6ea04aa527a42e77f57d05217b303d24bbed299a72743b5d4d07375d0aaca7aceca528b1fe6dfab478f20c9996986a664265ac5cbffc50938a97f294125916f264e19e658faadc7901fc698cee11c4db0a39c950186c9e8dc18f11fe56da57fa05e0c30245fa058e5a020d7afaf2e7b48ba49d48190faa9d9731813ee83f404f2da0c3ec413dc961e121e922d9dc1fa94218d5120d4c71d9f2038d6af25cb24ebf069f5d26aed5b33f79021bdff64f1acc26c9361743a75a047fdccb2a49e9e75e85954c0e04a4769c82f114f26c815e85faf8772740a45c4f2df5cc228dc1f94a08687a2b2320e106fed5b63a8b3f8e4aa9d6cdc8faff2fec8a610063cf139d29b82fb434237e45553066aa262bf99dbff5c41e16b18dc73f44bb8401ef7485a30d262ecdd2b7b5c69024c93303081937ff5e04bc5550f3888555a5e613ae25bf5e81a40ae2f7f9c3d6af57bf01c4cdff6e3a634d6989c5d0922ecd233f9fb2a25e7408a4e1044778f1f0c92792f43416aad87c4fb1a63e18e17918b29c5485b5f8f8bdd1aec2345fbbed10966b59d9798c4374b98ba61cfdc2d1ab2373df77ce725138f0dcbe00a1c2222dfa144cf47574a74cbb645f5dac62acd10f1c2ca69e1b5df763479284f0fbfa33c4f8a2031503ee1d953cbba7c8ab28930cdbe54070c9e9b3267daf4a3be00c20982ddee316619b5f0d1fb87a8fb61b8bba874032ce76694b0141098e6cec3fdd8e5a587080c5f98a59578f5145f99dde37dfbb1b827cd4f596484e929f93626623f97f892da1cbfd15c44f1a6391e2fffdffe9ff96f60ffb13ed46e3c0b0147e0f69941e8ae91fed16b1c5717ef06d0e78750ccdfc0f24fc69e6f79a0e8d7d3ebe83a6e76698baa36a20b12306420b0cb336b86fa068c8f378c62ca475db2641e9ecc28c2843b0391841c031ef713600810b1b9ed62905842c82dc554bea55fe24393b64ba778685f6297eed9cddf494bfcfb8455eb04e32dd80e6d9ebd0437f384f32b1f8cd64d2cbcc1c891eb4963ef7a9faed5f3b76247f74eb5aff57ffa913ea9c94898315ade9894cda79ee03896fd3ee9b7f87f38dafdc5b389beb81fdf06168a0e8db177f22dfe6d60f441fbe4cb70665afb991bab848d0046ef83355a331bfefb6a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
