<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"293e33c460eb7b2245be5ff12147d6086cc6701f31b7158e47441fd71310c1590780785be85d47549f3041c9fae3e3ce9e8cbcbdb0138b403ae98a722927d753f42a210e10d5b9b92a6cd7f2e5a8e3175dba7898f4714dd824435f0bbaa7a01935375fb719abdd1b66a80ee7aec2d6a9c8c6f58736ab6a372d265ac395b6dd5d4c49fba76c70708b1bffef2f23f325846d12bb53285aeae305116c565d6c203dfb03e902aebd65d99a9c934d2f56d0fc31cc8b88feafd78b3cf49d39ca44b72a68a922883b06d8c4038d4973d3eccbdfcb683bb569c60298f48dadd554ca19415b45fb11e24d89772fdf48d3c2a19e15483cca05aac3f2d5ef7ef438cf4444b175adecdd168aac49b2d10bbecded7acc13084ac9dcbc8282ddfb27c8ad2b2fec9692394840facb110058ea2b3cc8294c18f63d8eae71e58b5aa096dd21e25c75068f0f499236a0e1dc7b42561a48beb9116ce47c841500b6ee5039aefc0be1ace852daeecc64aff22acac62f8303f8d46020268e730db9878f3c1118a0658c64eddba52f542cfa2fedcae14fa7db29e8b105bd33b8ca211b40ded9d0d62494d8c8cad903fdfcfc69135bd3bcc8ecb875c5f69206c1bb08afea7c47dbf9bf51af2634e4fd7d76a7eb0546130db06b25aec1ce7ac08e29f3fee71b2c5d897d10676ba85ebeb321c601282fb132357eea0643a4a9262a9fdcf26ceb9825df8a1b1f5cc85a6a852fb9d2ee303620d24c04b738a993753e33318b9823095dbc434d0d5389a00773f8486f4db24d3c084ba50085ea2a9662aa19e473e1286e5c64313a40ab89c673af5c459a0cdb49283e336798646fd541cfe6c570f8879b35742da852d3a558238897682d23ab192c2fe4654efb2cba649b848b260bb7bcd92e0629c99aa4bca1ddc983d51cf83d15d05f6f4d063c315a8b7a8c8280d1146b36990220256ac064bf27088fec717ebb381b0f507563f32796ccb5095d269d807c2f1260d850f22115492b138a7967ea156a8ae37fae53c12f081495acf5c8a1d9863b70c3b1c9c337ced57b077bbdbbf20042ad1b7fd5e095a84d86d17928f205780cca3aff5b281196155f0b73fef6207133831d4291fdc74f751af2fc86cc0d364e94348d220ebb15be83c2b106f826c9fbc7b7aa8f6738871b178750f7346af0ec434b9ec6a53058cc3bdf7648df2bd7f93571838fb1a3743951a065f7768bf9ca0012ce300d0233fefd2e341542d0b9f680ce7349aa29f656d0961043e3d3d090eaedd6968a41db7e9527a077257c97879c2a8c4d17f6786d524dcffa027cbbb10639e1445644450db54c5006575cccabcaf73599716126269bc4630979e0f268caa2a461c05e3aeb9e501880d1e5ca6ef36a9f995ecdb63c58249626733c1b786ef6787e2f39ea1a0b4a724ddf1f1ea0da77b519d3fd0015900ae017f9db64866994c85d7433ad363313e7b78eba70605ba3c5833a2326fc4e507f207e09efce7fb4af577623a0e150a9497443eae78747807160c7d97966dfa3cbcc602b1806657490775fbe7754454cc54811f54475a83d923ff7af2e5b52d1f60dfbdce3d1f3e8cffbedff909cf3e7160438d2bbd183299d7d6fb9f5c981b58230085d06d2843fb60ed4081adb0e6b4a40fa1206fc39942490f2502bd4044d8b0fc3f2c6a2a7f6aba8da4069c075a665f594cc83c7f6d4f005c646f4be75883ee1f15a6a73ba029de9760e243b7900e1896964bd125587d67c933506288622408d58c553fc963ef41065c3d4b6c68e7e935762dfa4f315658ee6094ac97f4c7f0fb822125e53ef6bf970479068d1e1afab9d2b698af98026369b50fc9bcaaa31ad8632bc994226d73f35059f3329a90b6701483fadb04b43af9b8f99854af7a04a439eb130b8867b1f7ad99db63ef0254e17a280c9945b9d084512a7b3bf4e48feac9e9fbd74408b56cecd3b699ef3bbe17a314318a288a41413575d5b43e31a8e7a019b0f375570e141e49b508f4c1fe572201e12f7f30fbcbf5db1e6210acbcf309a8624ed36a281f7843c58dcaa6e888fb45daf4a2bf14f2bbcd7a5636b2b912b3ce8c7db54331ce4bda950c2276d0e1b1a1231d0e7b7364585ff7a1543719b19aef718513267f6cafe688967735c30a00a3278927dd1d93f3730ca6b4f0015639f84b30a1b153fef951ad24462e68efdddf5353362d9a4226dad4193512a95d7d7954bb28ad3fbaa9e3c341ddf24024fe9a1d99d7494f701b83f10e97cbe833d9fd095bb73ab568c35af412e43bc5ac9059acfa9d07bb16d4081b28290248ef32da4b497d945b471a56e73e3088899a0cee830c23a5f9553d99406dbdcb2c5bc477081bd4e8b536b941c36ccbe0fc14a323ae15d693c7b3bbec26f9c96c030588cf6bbe06d9b63c2813b3537d26acf56afc697d195538bb0306991244ea3edd4b91c5f69e6f1d1c9a7929fef6f5b0ec0bcd9aad3e5415b12ee984ac721b24b8826e4da3923cca1ad9324289a570aae3ce0b1c5b424bae05f63c20c593b2e6d9f93db989be15a8ababce4f57289eeab3891df68b623da6e93c4b27bfe2254038429000146b52ff4c6d0d73ecb20432c77bf9918898a8e9e478464e8c8c72391fb9b63b364ca9e0dca981400e70ed5a2d692374ea72bf224357d12235e447283d6628a9467a90219dca6b5574d5fa0adf70ae601de9422ac1071ba865394bba5cfc9ddf2dc906e31f79765283623085d85e0972f12bfc1e86a5fbbf24c978013d78cb4f537f6cdee8c878350246173a0ed13438802bad601db71614b9a8fb89601eae535e8f6273d1c4d09fa69024508d9aa0355643efbe376a1939d55b1452a7261e9340716295f0553cc090000ef947b691d44fcef6d7533c0945460ea0b7f2f2d85e8763898e4185a4e7993607a7a1ca58055e0a9317633c03c228738eee9478de3a8330971f216574053af1b32c9ee4614de796f300a3cc7a0141e1b52a4296f284e54a41a5b014176b5a621e814c5bb2f76bb59072ac60e125d36b8e54eff6ca9af7cbbc2fec4e49fda3c8b0f45d5844472eb97d8ae5ae421ba86af30c9500945d9cb0cf3fe5bd5061189de3743c0fa793e4a5a358933812a5e222fb37eb0bbff3237db6705afda82c56e3faf766291fc6363868ce00a9a0dfd6f151c23bd9b648b1991caa89e1ac99d4a3cf05e85758f1bcbf8c180778a641cd1bf1d736b6566b6799d1e0fc061ef49d9c8174e0cbd58004cbc83fd1cca6f76d45e25cda5367da1b2ba92e25503de17693c005fd8d7d6f3375fa593c6b9447d4459f1e6a4b3ecc54f3afdbc2f2cb9b1e144765d48fd888c119bf56cc847d6f2bfcbaa2001758837dd2b5f0f6500d439f69a1a387a87aaa8ac566cbc8553cf09fb7342bf3ba71ac05b6a1eb2ff6a707338f11deea2336b74aa1acd29b7889511df210d80db17d64cf4a2f513e808610e78fbc815e583c65cacee1059de0fd221f524db21be03a8783b03603f65038f6df02f570727c638801d1215676adbc3a4ff442f13ae2e03c9a9b5caf0933e01e671eaa5f317df424f3559bd02d4b956e2300cf43906763d6e9015d58e7c22b090765d3b65244067fe30b7ab74dcd45c7018767e61b96ffa36e4282c876e4af2508d1796c4f7491e952ad8872e10cd17d1092fad795c2c7da897ba8cf7f4f7c72c1aff09957a882fa8358e4e37fd694b335da7e0270e1467f5eb3dc3af793f27fa1a428213a37f205db9c22a10b75755188398ce3c9d456a37ec25ac4b6b388a7cbab4c80d9a889affbd5458c50f9cb6d76c36f4f0915fcfbba915944bba9725328ec499b253df9e5751d01e697e46ee0104ff1a6581330fb18091922b7f9823cf54d91df124a326f19b697a637dfc6a4542dc36f9736f23dd37e90e0b4a25598e3dd88fa549dab96692a45c91cfec163e0aed44a67a6dfa3824f1137056dd22d3c8e6ba15ed240d52ab4d5b2388d90d1a2ac3baef752a01be05f3bca0b8e32fe5e80ca4beb64776a99e18f91c4d2f8c384d0a6c752cfe4442adfeeeac454c7fe8769cc2fb04be6c0f61f7b5473a26e36e3a5e034d0d033a5963f0fbe1d235c0bef64a13bcf1c64fa462d9ff6eab71fd182abc7800da75ce350dd5daa9f8858a1d925716535a06af3d531c7d8d965b91c5a9596067821c86266c7c6f59cd704e34067683b36f24e651a7cfab96c79f398ebe456fb9fbed68b9e6aec7785e9f62009c5052579ff09d8328cc33528e1e2f55bed7c5651b418c0128ca13945723f500124df152ca78d375efae02017c5d9e2c568cf7940f09d6f9d3df254210defb600393a3a051a873fd54e7f9fc7d4fa32761f867a585764e1f7cef930baa3e3313a8f1fe699ed46edbf6547e8be8fa30ea27a97a58fd9dac6fc7a59117efd3473efcab4dc26fe0f5ed90744dd35356ea023a0e71dfea50b3333e61dc91131f93395adc0a39f0d8970127cb66c0f1021e7887c7682a4371fdb58069b3bec53480273aa0512180adddaad90d3dc2920bc50a6bedc59c639bcec505e0ab53e47fbdb1c5093fa7d98434448a7170658f711699b4f2f4fef96f22b0f869c6492fbe1d6e1e3be2a69194abe0c5641da9f95107d87a1bded6ee63f7625df30bd4a1704c55caac321618b9cfece5aee6cdaaeff83e9dbd005deee22d9693122d7c8b808e6a25a52dc910afa778feb4072b474e440c019e7e7af34a13b5a9d0b5b715a056c4ff29ff016d69825aa117db59011da5f54649108e9cf2e06fcea058f450b056c4d9b3ff1e464f540f56e977fcbe61f18cfc5f18c08d0a470527dfa4e9e1a05c3be0b42ddde6cb7b9de91c62961ad1d9f94107218bb28284b25d571e3340d06bb46f94dc545cc0885e6038fda8d5bcb4b8dc6c3dd2dd2a0c26fa0d1a5923846eecc4dc0703ba16c23b097777bb22720f8b57726679c7267c20bf275f3fb1c7d24351327fa4d63b235150e1a781435181d0d65f479da5f177677cd6f4df08c4378df85be7c30a3ee94ddbd37e11eaba18d18cdff33208b87f12ecb4a78cc18426209b393ce227c21da5d44f7d96d29666d1b47a2d5eb8ce71b5656431e41b64097ba5c76ed35bdd381aea3bf962378c30399e077e5d7fef965db388612446e947a753d85db1074d38dced670fd5831c039d86869d3d570bcc7ced5486209062713cab50bffc170e97a1f406ba1918b00a205feaf06fd699236bbf9fe4b6903e6d7997de5db2aff0e139cb6d8c36274395cc3808b29a533707110902a3bd22b59e3d142ab78df20d2fb619e6e74db49b0ea0739fd6d35570865bcd44acceba3cc1e50528a44debe0ae4e7d55e037985bc15371032bbf4f90aed6cf0527ed80cf3bd56a086e0cb9e6f382900c345d2320a03096f2609a882169fe4f01666c29b2839638ceacb5e6fdc2eba95f05335eb18cbcbf6ee0577afc714e23277f7178527daf4e82d7b79ba774ca201709045d4d265a41a961eb49bd7636c2707337b41d0f6ba1622e96b9f935f11825d212b8af7979538324cf27d52467515620537c66ab68575799428e59769b4488351b8a781439d611fe59c1d6da83980e2ddc63208b0cbb5ba2614f5abefabf4a4d4a0596f88d6897badeafb34ed0490a92ae7c47a8545de17a3cbf2542b39a1308586f19d3c0ae93955b8ff62c9d35c0dda67c4c68349a74c0a8227252767e58aa23ee08ba031a40ab0792a0a03bd6719a6eba9f5bd7e1e313cbe860734d36cb24fa720aa88cba43bc8bfcd302e347b6a91ad97226282b4ce7b1addd90da73fd731bbe53a189846b731c12cad36dcc1f189ba10a6c9f71b7c97c275f76008abb81293ceab53f713219200673f27d8ebcc64ae783c5b554261526a1883629c89469a7f778fa28b0c4813758d4283494aead309565d5a3cbf51f963bb248141759fa2206387e8d88aa3915f2f4b6fdf5f52e63c7b8e795b9e723f4ee0e6df76e62122eb0ed4cedfeb54ee12938d7e75a31d2bd1a054119f796658440f16956281a5154486ec22846e280edeb2be2e20e0a81009c2223496bb444379c81b39c11ff2ba804f2833709b61f8b76e5f49c09773486f21257c7cca987ec06cd899c7503c289b687be3a4eabc7b49459a667509d5008dc29c0ab32793c027727bb688942da1643fd0b5c7fb3aec34f5d3338763ba319f58dfd994850ab2b51b5cf97ce161064b8a5864663138ae3e5770035a1627afa2b677ee895fd3783c64cfefc5e939e067881ac28fd2fb2cdad552e7c31f7497c7f8a6eda4cfc678975636841cf3b405c389c371884909d739b13489776bf533ab4650fe057610230a479229678087bfb939f65f2582d4e92854f20386b7332c8da7e591adf2f6b57f5a44ab86810867febca7a363b9a74ca6c0364bd295d1df9f3b6a3a7913847e458ae47c079a25e12d55e95194dd6100df09ab3ef656f761d90bfa517a0a53d6bcd0657aeffce1cf744395ff9a93a5400bc48fe356547fab28f84d37889ac6908ff6213948547538ae395e62479cb923c92274a21956434e05d6fa514d8651ae82f85a470d67a0f67b3e1894c8746c13a36a39bcbc7ba67c79e7490e3033f9114050b6899234681d6321a536639152691c35c32cad070e59f97daa1c3d71a811b0093bc8817fa9cc8ff36d05025af467863721459e9b2752f057f2ed8b4553eff972cc059420909b3228b4130546052bf07dc944868e3f12bceb1b923c560ff0388931f8d0a8678688530df7d59ea981fcb05d2020afa14c37acf56298039da96125acf7517d615ec69cb20cf013d8106c0cd588a778989de59a228467c2d69712ebdd0fd7d0b922c21dda2802deafcf90bbc6c850ce6816ce1a5600211e796f8800ddba59445d7bd12c1720c8fcc4b903b058499c4dc2fe7fd51d66ddd8a11f2c4f5e46d6d5d001cc6b928319b7332e8faeff28dc7f1db3f1d58190f5ce21ae87fb53a02b9016eecfdf52bd0bcf87c8894d77f668db825b891de7081903d0d2307f0cc17252ad3a4fc433ead6c1e6ec3023eef1cd890071e4f1437c0a486dcdc7c4343a7f1895bf62179f7156dee0f0284751feb58c2f8ee54b55a57fcbf638dd12a1bd5101e1fea3ce81e8778a03bf17e371890afa481d5c697c7fa56b0edbf15928458b5b858da5cf13a8d576de75e060f1ecb468ebe576c06cf83aeaf18c9a5d16672e5c8f598e0df94f0aec3b585ad31437862f14f8ac65ff3192102d39d939c1d3056213a6b24554405208b922b0503718a4d85600bfd98321914c852dcb27f6d53c49b03f46c02fd119a1ccf6589d8dd68ee827a81f1bc251e3bcbd3c605c6a93f13bf7f203e77913c483de324cd3f933350e9f936cffcc3b6b00c598cdaf005e2856caeba1839a4851eb27845397b2fb069e80a0e303ee8f1bf575bee71e9040e631e1eccad3b212d361e15396f271a03077125259965f81e324b37fe6ec213db2f87cb6b76c1273b983a70ee754ea9752effa302243cceac10a686a6dca666ce76b1e97d3e8158ccd403ca61aa7110000c395a48e3211c7d083014eb04bc38789cb63e0983536055ac421869166f993f04b8d0e77cbf929b92183ebe119b2d7106a2270163e79327ab439ba0b3b31dd71d5001965673d4f9d836e9795e9cae32b8379f7bd1304339537839250d5fe4def4da767718afe1de955fad185fb6af80ef2115f06fc64e5c4515fa741fc1084659a9c5e341add540cc63a3b6961a602e8793a05fadd126c57f96a44b74a5b268051a883bbbda106d9e0eea2055053ce27640419c2baf6ad57afabaae41355d322a9419779d7d69ff3024a31e2b17e7a8b42ba9ffab7d258285cd6ada6ce1581eb8c49aca72ee9ba858d9d4c2f0671434ef8d4c8aff27527ef99a2c4d237a66d33090e00742ca1ed6b42ad4e5b7b8abb0630eab236910519e0187dfa965118dc3c00e2d22ba420b43aed9eb971b03ea597bcf2c3b9cb1f26c1805657c7910be3435549739af7ca29a2783158f140e3411f6daa2e9ca43ad3af78444dd33bc64007dd633ecbff8457bfafffebbabf335895a758918fa500fad9f5020cd0f5216b00827bb90b5bfbac70f4bbddc01cfbdb4accbe93f8b0628d9e74ea6b00b512e3293cfdb260cf7a42c792a0019b8427f51d5899c6ed9e3f1afa50cb75a69478705a8868e8da761129480835cf18ae789f635211e8b81ff3f17dfca4301c3ec4da27832d9d05bfded5acd382382f6255051899aa9254ba7b534d50e6077160120bcc94ce9207e48bafc994f80f70abc8c41d0f8732823090625a7dd6d78337f9aca9cb4daec478ceca8b01ca60386798302e85905aabfeea6087356a002cf9a67f078f0d63ac88448901a62e2dd9fbd8ab813cc60f069a251b89259568df90e612bd1ca0dc68b5739322715d7dfff6889e143c99d442775192950d7ba7e38a27491b44c32f72e5a7da824bfdf93771e862e65571ff3c9ab4d952bd6c500c20dcf4f37126326fd50467bac60a2d6ba4d31c7fcd060575d97fe874be650573b282f925903d9a1874f047815109ac41057062fb5ae16d32cfdb5f8554ff079a3bd20b092d02d38c106332cc2e84b7e67d8bc6ca41d9d402424b71958d19bdbdd1eca26b198fd6454ae5f4cdafd2bbcda273a44090c2dcff4eb1006ad0b93bb89c5e84acefec48879d860b5e1dd4d1b90663e15fe975247bbc5abf489236d78c2374cf086794feb9c63eb2d0bfe98afc56a79d2f33e50f7e5205af5fde7d22661ae887df6fea9197ee01b133f5112d6b01d63a4fc0e30a045a7e17e435b7623d9b9922c81312e46ff4d83c4d7979dca92469c156e2daa14ab1103b0e228402ff3803f7c188e04b09a873501933d413feb17d1718daefc36422f8be98fc91c80ba7e5ffb620dfb1e6fab6df534b0cca9cccea2a02f79e1672573d06e5115ed697c7b78fa171ef7c55e518dd90b8794ff21bff4facfc30c493dedd97e1a2e9b36ec2f3c19370173a29fe6de98a1743746416a716dd171d452a288bc974db8d02ff2859c8c8ca2a1109b7ea789e8e7e2e011da0d7139f327d99397c8b7c618ebdb36a24764f53ee97350db4f1734b52bf0857831a720544d7a6b8bcac96164f0ef7fff2a80043907bb2e40b6491448143fa3555e7a629bf83234e8eb197e4340753e4699f11cabcde8c2c75a14953acb86f5ed8913ff3105688ff2ee72e92806562fe7388fcbf777e2c92175978cbc929d8ad853d5ed1e99bf8cd7a73b1d455d39b56472ab61544df7c7062651f2eeab73001b91d0e9250718ac6a0fbd09e66128cd23277bfce81d39f25c4873fea868eb73a549fbbbf55c9131446c976c1726d16451e6b91b8ec4a449916d38f1538c400cfedb6744258f92dac64771ce0c0b18bcd99537a25c66b37874c187e5e7ed4d2d6b375a26f467ca43384a9abad5ce5b72a0e9cf930523856d86094f72fc43f15099468c9a7d27a1871ca49212470a5528bf3e763d237ada25e061f54b333e2459f87795857e8ed762275043a2211aa69efc876e64260dc8a33fc353dc5cad71720553a4e43728ddd4b19537c5a2112ef56a16fb670b89ccc18b806e71b8bd32d12182ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
