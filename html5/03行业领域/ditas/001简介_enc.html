<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f2f564ef5ed0b8958d1e19aaccdc8f5296d96173ac2a17c2c7042f2cee89384f3832f57585d36b15f968623fb6bf95adedf92ead48be9a4523303110bceebab70ed666cab4261acca347450062fa477c126b3b230a9fa915c7f35f55fb7f675f11f60e162a98de9d9d73add3132a84b811866bb0558962280b39b32639bdde64a9e7b7693a436ff11edc127a021baef080ca2a9c6698ab45fbd3337f80905e5cec59d9032d6ff2fc8892355c4c1c2790a066570b58817ba6826238d38377e01b619837dbb7ebd51f190ecec98db7724004f3174baa475a5b00bfcca32811885bce075bb85871533d4e20d0ab07c130442ed9d3835d6b06a34345137799f0fc3715a9c42f6311b9a2af8bc1f6590d1b6f903f7e36dfc419cac25d0af5042197baadad7679e0030d51fd8852f01fd24e1e80955efb8a8871c7df533209f3e789eb81b98951b63e98e32de7b00c36bf3db2e332901a67dc7c3fd8d3320597be2cb4e25e893fce52b19fd6553ff5421c6c40440df324b397ecb5e0f6e99078675012ab105dd042087d125c1903b7dcaaca826de79938736ee38c8a3c0e85014efa8d0cbd7ae8602b32715a46d8ce078968335286f7b263c6d94a70995069524ca250181365d9dbee47c87229175bc212713a7e474d630dc167bcd66d9a828f2a9e065481e599f071daeefc1acaada693d84cba03bd4f08f6cce33e3514d4c4b6a77cdfb254e2822e9212f2154f1f898e6bd2a36d9ab67d2ee0f65902c111e5f60fd6862716be66d15a0be70d27c15dfa76c29fd9b32e557bb82b9e93c12c13ee0ce684952f318a58497ce120474199a87117a6c2350ff43007fdc318a5cefeae68c85a0fae2be8fe581ed3c64047f01e8138dece183012543047aa9971d7c75f1c2a14c0718c2e05b76a30d230de2b3cd18ccb18b9ca92fbfd8b95d5deb185d640748b29ec0992ced82b8eb92dae381ca749a87656c185fb6fd86b738b62baefe938b20c652a3fd08f657fb57779c01293d476a8074dfae18778559a62333ffee3e06fd4ef085781d0f5c2ff8f7bf1dbf0720f1a1aee56f2262315d01b1e96f962025a79a28e011afe699edf6cd7bb31d43a353c88c2d249d862207a6d1b768acde2ced4e96016b10b2338deebdd3cb537ad93fdce0c8313e66735342d88292c0e37c14959cc554f0187ec3f5a4a0508eef7f3ae9ce17efb2af65681a040c6ae393082b6d7a78fc599b1a7ab3b7ded0d187fca0af0b752e992a60e42efccefc7bfcfe807567593e6a42910213a6aadd4a7fd38ba83fb5d1250d55db5911df45559aaea924a927994a2e7b14e578fd7ae5344910f327cd90501d5dcc28e516a3b5b32b908813398a208858cb51895890592875cd25b8f09b01af5a93cd70698fc406a3dd20f46c304ec11a42b27bba7b30e6115fddd23c7f4ced187fa582982694141335f613be0d234da6837dc324b7e654b78321e8748327f047f0825808a1372ef00dc44287fd6be60da08205b319ddf389c5b351925b80c2f99b93292db2c5e9669ae6c3c7a81c0d68f40bc9b938b53517192f91ca3e0f2bc90ed2aaaa48270b1998a42c6b0804786b18a056d9e2eed517a1bad9e5cdb12cbb43d5715c6337fd8f19bdba954ff19c4191041a99885d61d8053b171df428d6f984e8b061e81bef3492fbabbc8f644bc1930f6fbad2fd1178169ccb96b086295e65033554ef5f33cbec4f5a3450dd20aa40c525d3eda7d305d3220e91faf4fa92917aeeecaed55f938d96d6102e2eefa3ef59ff0dc0a2b407d50170b82544d8f7a8f8ca9ed983ea0e4a459c52a912697c571ecda2ed42673a3456911295d96838ff3b3d968276ba041e74a9d571912024cf411dba844e7f3f485ca3bb53f65d21f23c8bda251677aa954487d6b027f51e7c07b160cf9e5a1b2325dd2e084198e34dc20ffb6bfce7de2425bc65047d4a160a09deca2ba4bccc7302699843ab61c013c2882cd0cc7458bc6fe5a67db7e23c1e8ab5364f0fe042d1d2f15c5ae4fd5e6e529b98143ca010cf6f5cba80261334c8d4c19cd7c8110d062ac5b63978690b8e95540388a123ff8bd0a183db2ecbf706ebc0fc44b09ed59a3d6b9069c29235c639e8142539b3b64f3389ba88322bb7b63dc47ed2324b598529176ee2f15d2465f95473209ca319744c00e9c0dc73a570b8bc5b0c88025aa6f0eb03250e65438fbb44c4eb4e941cedbf58b9cdfdf786643b2a821bad3c683e7dcd95f0526e6898b52ff69d5537bf4d306743b91bf29bef1d5b1fd1215ccda4802c6b1f511ef3a5a7a1ab60b161e67a7c0c6fc8fbe43882493888066d347b08ad86247e6711363ecdaf2a439055e5986af8a6d20ac6818309123cffc6ab40ff7adb66c456867ddb283d6038da61ae8c899aa5353e14471db9bac512fd69e34a321720587da3d0c4e8598e3533e34dca302b282205252afbe6ceea1f1712268cb85a11e83b203f9247aeccbe7e3de081a1b9c49196e42169210dab25a32f2f939611fd90db417d07f620d95f79a1ed277d48719b638eff03d6e0079ffc2a903ec958d1ae4a138b15a78431cb663e8541d8ddf2b94125a3d4152efa275d791a964e78f0088813da2d117716ab3f5b0602be69b104b5e7d3973be9aefeca2c6ab894983ab8ed110aa46886cbce716990eac6984e0e5702afa8f0ffb8e5b952b680b645326deb0e89b4eab03275ea89e106315a4e55fe0ac5c88ea329f347ba606b6f236ca8ddec06706eb40d2d5d910c3d33fbb2eb6a537262303d58047a1fe261c3c49fe1c8769c54c5336a3a32e8d137c6c71e369c8998dce689ebc18c70b9e93929083cfc5633404280e803cace00655200b74b88c0bd4c48bad08e29077849d53799ac636d3436dd710af0e633fb34169c13b7ebfb315ebf8f420b498a7324b62822482fb02264eece3f606263606ebe38b411e59964100a6ea782796d2f1d2644b63ffa2131f69fa7a6b3e124595eec89b09216b34be35cef318f9b02c6d1c315c183b364a897fc70c9e88ce12eaa324a07719fd304da0ef633be740c0702d325d24e74a90f4a4a2cec9cbb84c8b7284f295e94c4cfc7ddb5d0e5ed1e3378d0db08e8d0ed3a8b42dd8d3ce99ea98af0ab1147059de4c560b094ba3493de4c3550d23f86d0b43d4753c6f122c5ea5563f5872070dd153d155dc3dab53edbac7b2467964dce5260aef1ff88a43bb3f397723813ee9439d2a2d657b599164bdfd7deb02aaf1d7f14ccd015bd35c3e3facec544d15998f00733b7b7bc66fc1471603c95bb5e495b839dad79e59f38866b55c4c22ecaf9530d40aaff9936bab7f34b516e9c05a026ab9d65b71b35a77eeb26fde99fe6757035423e7b4ad07fbc1e8bfcdeaa768b36c1b153326ac6f63527baf3b7650650689df59f3e999f4e5a78cf5482f0ace710b1ee3d6791c934a3a9529d1a56ac517f45442f0d790ef1e372ee41141e821606bcfdd2a31233d65e5eb479c0f8ea64d3bdaa3548b1527f6f3ed3bb4b3713fd095d83cd8d0e2c9a61b6cb7084f67b2f10d2c279fd7bf94d881dda51fe7724869cf6cef4562a73136d4a55f52db7a02c86fab0aa947b9569ff078269b9297d849a836f62f3c4e80e8a35fc9b1f1708c77ccd6acead357fc44217987f53adedc460718dbe9653910e9a4e42fbbb9eed2cffda5f3020889cdf122972727deee4d38f21a71eac2004224137520eae6177c2148cee2f662cd56be2b030325d1ed4e47c1ae31ed683bc9b981d50c0b0314601b047dd3462c06fb911066a0c3159ee6095e74112613a6d8a58d7b198b455a304ac990705803c6959c7e8784164508417397625d748ac396438ce89f2543b2a78252fc7090ec404c8cada42764a779ae35edf16357742a5b201d33ae4526dacf6621f371b646cfec4f5dbb3166a29b02e418a6e18da811e1672c7fcf80bc7f3bcb018d528a04debc43c30ddae7f2907d69af5e407857f89452ca694f8bf9520de9e44fcddf00b6f0c22e3b23d926e1601d4d548b05543b4fc0919926646e8cce8f0731659877d38a62bc62725ea36005145b8bd668b9e7d92a78990f1b7d206234c384927d00922cbccaeab6c628580ade9a890f88322b5c74786439078bb56eb9edb59483ed65045434cd91de591bac0790b421cbba794f458f0630eb2a20eae8aaf981ce0865cb12d667dfa3531bb5289cb54e832dcad0fe9d07dd0b537b321503f506b99573bf90bc21f5b470ac0169528cb89795081f442a15c087b8d7f778964159264b49e33b643125d9fa12650f5be96863e65c1401028c58a228c7b68db979ee1ee6c4e0e989769db87475027b5a1032204130d97535e126e66641a398621cd87cb9df739c5d5280cfd004b1f8a2db039f7de2b97ff9f4a32fd3ca57468ed0660276285d06a6b168a10d868a8c8d37c21cdcc30fd3d5de52a419e25078a4f1fa8b7a82b274c5520e10a96db64082a5b62487614148851e8cb3b48c0d7c16e6ca2bc1989473835d3dc10df7e06b4cdb19cc52065a385cada7049c8a0bf058db1f2e8a269382a1b89fe13db4fd0aa62b2206b38b273151aa8afb7989ceaadbe1b242ffbd903250fbd3f759fdf1e3e27f7ee9b907fb764df357941759446573d75950369297ec04be0b65e612f3213dac73646af222eb34401ab6d24eb710d3322145222b3678e8290d82633d106687b71dbd5f20630873c97044e9d034ca1894610341768d14f2ddb3e26d9e51eb162b9bbb5b033918c49e923037a83bf2480135568093d21db7f7ee9a213d814f64c3504b32c4ab42e8a539f40b9d1d33dcafdcc2931327ca1c43a030da5a9b0b25a32ea7c77defed3e0cc36422cdd58b506d2d7fa0664672058fab128dce5e8a0d20cf124b458701763e2e20bf2117dda3a854d45e5bb96e38895279c9275131055735bdb10aebb1eb5e4803349b702cbf8c53c06e69ae4848a51af80ed12c3e688498d591e6adabded34f0b4d13b0864fc620b7e8ff28189c8eda1581be21eae1495ad307fae3f90395383b86421ff5ab3e80f9bfe41389a74ad32970ced780927fbe25ac6cfd1198897caa86c7907a59fd72311f5119a9f2ee84fcef9e24b0f5811eb7955cc472fa0f5ac5be9734692737a47cd80af57685d531fcc640cef8e4a1554511641195622c55aec1ebdc0d3c049815df495f2c479bdd6e41836a42094ba2e3569fad8cf6ce449a950b484928a62350888d4f0d8c72a7d3b819667d680d5bfc0e3b03a162079e3bf56f5fd579a5200c833c92106a1e796ec4f941faeae62d5be8b16ca0d045876243a69f63ca7c4c50f3c961aa3d734379cbcece2d7bbde091bf361f588862ee7306c3dd9f7c212d897858a586c68958e22f3708afcdb466b61f0721f2e7c01936292fde091759c03f3e3b2e24109171b418d526294bf3f632d7ad06b5bf18ddaac6f8cd8e1c5784f0cbe222425e2f756fc1e3f46be552826e0527597d90303bb6521d835620818be672c654ac576359793e85695edc220e8e18914156db05fb4d87375d774ebbeac35d98922e37cb5f914ae37ff2861529bc318824e7c7d31ea96b75f24f7dbc85a6b124026b559936346cdb920b9117898f9280fbf9f0355debe31a546a7acefc2f6205155a90fab350abe1ae5c13b5295573c873a62dd438d3c31c8ed3300a15d339c0c7da323bfc0ef4aefe8472611321abe3cdbe5d9337582a331ed6b69bca5b0b7f3f7f1f4438158fe73e1982c9ebf818ca716b75066b27d5e41e3fb12b903531b1581c201778c2481c34894ddaaf5cee0ab97613f633bb1f33b2b938924fb118241f0d08d2d1dedee8d5224b4d92157e37d98439228b9279850f608689d74d41724bf1520b22b27950979321713580369f285297f2f3e17daf9a2f28b4013e06f26909dc4a990abf9fe179992c181eb2eb143b494c1f9438ba4eb43c3a92df0c464d616e36198fce442aa56393412dcadc6922e9c1cfc9d2ed6bcc29914a0dfd77532523636d9d7fdb0d0c1256779b9705a227d6ea9a90ced4eeb6a4972c472db44b9cce9d1d551abf0c0cd546fcdc7f84864c443d82cbac617313b044604332d1ec7a861648f6fb75ce85fed92966793aa335f5dc52bf2838e1092c4f6a4c834d5aef1ec65729c097e357a6daae4f1a4ec1725d66a07cd14566226d17a68535e7301077024ceab26805f93fa38e8fda17b3363d1d9c7e90a8a86a62187470a6eb085dcccc58da8700d8b3051aa296c57714d2924a8aa66178496e2ddd7cf3fd35335086e6652ed7266c4c42e4a328624b490cc2b5063e0a114bf787e2065a73f573202cdcaede8f6cfd06635e44c3b52ff266e85c88f703affc030203bf2cfb8b566c3ca7b15e39bf89e7de7003c067b5b6ea47d442186743bdef6b39b874c89784015dcc809d3183f2dbb11ebe1d330100e018feeb910636be66db570f9853ce73ed5c142924fff419e59c6fe0af22c5ced1d64503fe03f48327417ecccab9463685bff8153a3cf3d28344f4f352cb8211a4a14b1251f6fc41d5265549de64a985153fed5f3305e971ef0502911697960fd955045c5efa77b546e007d5c3599d1de97adf4f8b427966fce27e5f546d9b8b831ef8e3e92cc74179813bf50e7fad584e7eedbc12adb282762c425c58f8d442b07351740d5309c3dfa401c2795a9dc131c8d4055b841a8cfff7ce94da891aed7c992eb8cee0cb00a5d04a498a12b402782d58f41e273a291595d95441d623cfd69830f02a74ca8c8967eb5571aa01fa3796453fcd70d361a7ee543e51df79f177dea4d2302c4289864625a1dfed605f789d2add3f48789b46b3bdaaaf6072b29b201b46dc9f581649ff41b43194c197944c41136870baaa31819b008ff26c05aaa2f395dd7cb17959e5adf3efb1ee9acd489dd20f255e269e4e5b5f36ef81ebec6455719965e54f330595bb607bce3281a9ebb9a68dc2b000d915351ca75b5aa3fae3ad9f35a48714c35f9e98afcf2cfb801bf7df1b77d2a83d000108ed02bca4b9bed6de8dbf0cb3716c67316f1f6802e9982bdbd2f6bc7114b328244599f128a4f77d7017d70d82d1eaaa2d5b244cb96f7d63b22bd730378f54ebd43d47d2f72fcea816c23f29f82e73aec7a3d7e6d5432314d40effae6f3f1cb22e4c61d34041400db30fd3030d8f31a5dc67423c8cb736ac0663b4fa849d2630f46283e3eeca2d1068a40ff158a4babf623bd512e1f1079b9085051671b30c70fe8248972f4c523930b0a522c90e0d332c6f9f97b8f542758603ce7d22503839318514a3c60a98a28862640e939adf519d340f3b6d243f9cbbddc0735334f76f67560a16ab89e87220f829d2b10c882049af566ddc6831ff4087ca127c34f34b2b2338e1b67ea4b37f21e402e53b27b242d92d22f81dd6efa8c7e62d99ab3d546e75dfe174f266e21ef25e1f8b8761d91dcc6d8987bf5cf75fcc714be760c36fa3e8db892862d40682821307c88387ef725acfdf0b09c15d5381a6bf75d9cb4e98429ec4fe852e65873bc6d690388f178828d1998ad26778915b9041c04a8c258e2e41e45fd7e575cf649260bee098d79ec26800471f2172ef9dfb46c3c3a48938898ab8e87863f5f5227bb8bddca56d7a8b8e3b2e40200cfa0933c0534520b5c7167475505eb3a8ecd8862d1bbae49240d17d5f998ff709e1ab8f8fe09a64b40d587f3d04cf8f852f9a0e6c4bad8618132b79cd41b3e1a692c8b4d10c916a70b6f6ed8a658fd646693f7d608838911266c536249683c2cc0a319b2839796fe6f18c96ed6397353e86c97b23f20ca77c08fbb9700c127ef2e96d84a14d1da8455d93b7e309bb0385caf935a6f335133b8eb568be0d55cc2a2eedcc248c82f30524db091f9390afd44176a6f3fa2edbbbccde335930c8dcc2fa0df8654d5ec8015f05d2e44d5cc09d4b42ad9dd08f56add0e74447d7d1e2d7e0138d87d969f03610a262d570b7e7310d02677db5d97bf5d2f8f2c7a67d14f748713615f9793f83427084916096ad5e909a388b3f872221e29ad1e370e368f2d1484f876d3ce4241e2ae5be5a5e3fe1219562e5fd82e73184b920f993fed4f6fc300ae30195320613c4c75207d791a1d21e768f0db98d3c88ae58491595068b9b57a06ac6933b8966dcb4430ec49a4c3a5087400b5481e5d5acaf1b95315b91935697caccb0e9e8ca0d38ba653bd777e62d7d0919c5a70fe4f16167111763bb92f576e24a42d7ba20b56328857812018bb4d9b6f7319cafc5db1a2693fb3c622f1195a3f82e921d2f0d4e0cda7823e251b01b42aaf7f5e012db2ec3eb15b8cdb7a784c83799df38ea0e6df3cc4ef005ec0bc67178a0eb94c8a3c1cfd300b7fcfafc6e7c8b00f61891f7d5433964cde3a62e3d733298cf361540a6a3246ffc0e89970ad7e2647e7b871b9b9636530eeae91f30ee797dff5dc6d37eb722627af39f908f0fb60dd13c54b1b6bd9ed634b7b7a4bfb02a32c0b16d190c2524bee7dd59d047a4d6baa58fb3173300b2f4723eab77128889d507d76c7c4c0b25aea5569cef44dd7af7744be40dc3839b25e4ade214ac796ee4a35a67c4e738d0f9d3977c572af2eee773abb9931c1ef49f277ef87f4208a54cd10365d1935f74d47cf477737a050d9d6ab3924e21be25af29759728ea996cb482468e0c89f70111f8f6b6b59357543fe6b895b95399e11b8d055de6271bba0bc13d8e263f0960c73e1524102be178e71016502bced79eb813d2d5c440d08f9b20ad2c30021b5efb75d7086091cd07cd44eec594f759dd9feaf7fd6495e7b6452a6243dd6ae2bf2b49ca568d816c675c1e6f38a0c517e9025ed775d962a7d7c95a510e9c67c264cef8a0924300cb9633533069157bcbc4c8356f08eeee0f8f8da64e63468be729ae6b09c92e1b58ffc6eaf46c5ee43b21300d41abb41a2ebfb4924d771d876162d8f05d69de8aec4ded043ecaf9c1394c085ed8e38eecd3782bf171ca633680520053a500f53f4c0f7951102b8070f86dca6b4b1af03c01cbe334cbe5d677ac2ace3ae35b63092e0008d6579323722198290cda45660a95762fe86fc598039ad6c789b6528c3152c0473f00d7d7703191f3f9e8a319709adb82f6206d6ad95df737a4c6c8b4f8f5ab7614a7568d19fc1a580803ee0dac5fe7e0eb603fc15b2a43b714012de5693a4920aba77921fd7a63e024b71d9f7738629510ab4e8ebce651b96d1d188813a59e7e6d5b6d7350217e01acbe5fee09650ba7317d3be3a0e46363165b1728623d92b959cdbc9cadb634b6525a721eb4ff7a8b7e2aaccbb04a8be9c82eac52c4c8fa3be2089b91ca79f87664c9941ac4cd41fb83a331d893e0d6414a98f12c5ec1091c8aa66804570d4fc6efb3e10e1a6b949b82fc8dcfa823d0f7a639b74d2852ec11c43ed77d0180ec2a2f4f4a0e9fa2ace0802e41f7d03f7add5a8b01cfbc2a9214bd36384d24e6f87f61be37a108e9d59089139dbd933a25a70c4c324dd9bcfc8c45453cb1770bfc12c8366b317a93be50c380fefb26adb26b611a45d9d87bc063c563dbac87e8c146a907705016ac2fc42ded3bdbd1580770cc713b0200625f9cd20efb1dd853b2b17d80aff62b8f847bbe97c0d055072f2439824d6363b82343ad55f7838763f91893c5e83452f297dc9698e9217792e5f4d1f020a51ca54dabeae6a642bb6e9b5bc098054bceef08f6cc699d5cddf76456f80c5d17766ca8838bea35cd5170151dbed2839eae2164a9b8f08961bc59e88b218669f30911fbb2fcfd842273654ce0d4c1df17a5e244ae2c99006c87d50a0d09f0f6c1412521b3e53ec33ee3767791188db63d469885dcc50a6ffbb10169b8dc952e7d190af3ad5de688fd707edcb9e07ecafad0533397abee5609c99a14151946d1da63a8b7c11659dd251908f8d63185f0fa7e64007c022cfd35a4bacf130a1dff6c9abc034637e0ed9bad30e8a138d7f2076b54b5220a56a41610eaafd0b638a53ffcfdb5e0c04b1c5333052860c6cfa2bf3d1790b1b080ae57059535b185dce5d9bd575c4e5d2f18699d73d3576cdf587bfd01a535015280929d3efa18c49ff42cd8db1822d290cce836ec737a4421ac918ad408f35eb973c3464f7f9c88ed5426f873d5bbb669583feda20aea7992018ba789fc0f652447cf90b10deb10f5b78a50d730e86480a0f51a9401bd50eb242e5d907478890be920e36c5b11aa206c9a0cef1ff8f156a7396baf4ab5170c3d8be2acb25a95a419f028bf48870f4052cb4ae8500d1ddc3b25d4fed716e726742b47f77f7a260515127388b5cc3eda09bd89c55f7fc2cec85b6705171360073cf9ee9ebdd6494f2969b41f971911c5e40e9b378ff06a2acb4bbe0318d20f248409dc5ea63e25ae68acc8b9cc582338670552d1e9beaec7057e5c76d4846d5b5d6bb43cc3615f3e84d68a6728992154543d72016b218b2c82b59305b015cb01510398242c51601d2d09bd08186d6de18ae705625da543c329c1d6ff1ab9350169c14226b4db1b31448be9f394f61a60b6cdb90ed0380786751cb5766b5d1b71a6f91816176513a8501911d0a165d75867f5c295acf4414b5849fffd233bce1ff055a23bd3c9d84f6939b3791ce218c39efec31764a864d74cf747cedcd0cb5f6dd3cf89ee55219c1f36c5a1c65dc7d42f2502f877a6d47e1ab6424c00ed6bf6fda65d81314e75945cc923c601df4d46dd937c65a6e9c5e2b6710ed0d05ca49d6ac14badae90167b74795658a8809d3f92cf3dab98e3225501bc3a6eedb11f0a7a53e21dd32c497701afa7b6cd00cc3a12878013d26cf50592b3f1914b4370763ac9ccb391ce97169e4b572cc6ffa7723c21359183482f1378ab9f32ea027f62faeba00bf9bef07f185181b48b6a405bfb5bdf776919daf1e84e726579d20976098b3ece81eb77afd2a9275c64de32e73363f981413178171dad7afcb3aef74b02c82aada8587a050528e9d62ed080197b96369584cca9cf6f9b42417b3500d7219ee3082b8ea097a025e2f0f9dfcb7f2409c03280cfad6754bee03e1073b9daf8c62d852e914ef380a39d2b09afb7bc45286e6dcb35cf1fd59dac7b776893c8b6b7e10dfacc73613ad594aba007bbf19116ee7495d0c363b25533cbfebea32d749389f81eb5fe7fd33b63a3763f47242129ca3e80c31b691c469f457d63908d367793e0f78e2431c4878db23e2cb7a4a5d4e6211b3698e909f228c6f20fc8106e5ce22557f525ffd840cc5fa5a976219fcc9f100988c1c073b068edd2ede19dfa276fe94bc3d34745b5532d17130d5f9906dd3dd0fa99a59957994e0b7c85e15b3b48e9377795149951f70f0a22ed9f65216d7b5887c8570b88eea7b1c77f4ab3795b74a1600b91bb2343d8301c9a76117ad4d070209e12554dbbc7b2247121e48ef4644f3e1345d8dbefcf5999c41a1541b5ce94e66a3e64f9609c55ff8b92e1e396c87cf62b9ef87cde2758ecb5b599ddddf76c96e4adc1d22a82e38c97e1e71e4732a88fe830355a160545e4517d629ca4617100a1ae6bc12f728bdd5edcf8c6d133a14702910f36db910dcd29299879cb6cfc9506797c762743a3706546720a7bbfb28f8b2aeefe9963305cee5ab9d544abcb1bf257a107542ba7ec966bdbffe72cab1de5142e5a25ce4061dab290c8156c7a733f56f2cf0d47dd83acb9afb6f2447eaaebef401a83015bb196f59a97f184428e198c250558ea7f78e447e510347fa7e7f0e2ea66e6ed6dc0d2ba8a9b8f638aba8a102d59c5a0274906dee7da48c0608cb8b73a9dae1c80f47ec94938e1f128e2556b1a811c06615be7dfb4109a1277e1a19b27d91c53cda24e971f1ceeebba2e6a2b21be14a6ba6b02967af133cd37098e31a168af5f58c2b6b419b656ce886c241251dba6d7bd537ceaa35ca816824555752263770ff2f907b8405084c32cc1d168f99714fa042727deef097531637a53dd6f4cb0627a6d2031433807c862d356caa0842ffe4b0174f6d30256bc969274dd9d519ea21cbfa7acb2c5819d81ca9b5ec01c1d4497806420e324420378d31ea479835303b324f1b67d51149c94fc65f9e2fd0aa62128432c16ca401a3132be0919e159f0afa8aa62097970bd3f79283b12ff4bcc2542a845514320c6b81f9fae10828ac9f1d5cf6dba50a6b73b9b6b3256f748bec31a9d360897299d95f27835e591117831ca0afdb6c4f307a171915d063c2b3ebad363195dc1ff65e09a63aeb281d9216f0c1e1884c710f0ff3137505d9ff2a74d3c2fb25775249020b95beb5192e00b7f3f780932b1d740b6e30c4316f2589c9631c7eb0d1852045d03a737a231e5c0d0cc598cef65cc7e173f216ba3d79b34488553917652dc5c1319d107f123eb8c63389253747dda7eb02817a908e8e7df1baaa3df9c167c1c50cd3f42b1bc5cb6b1a9687bb1b022b27c74120c1290154305606061444097e9de2e789d444e071b736e7ce9ad9e5b93c9dd72c8586950c6fb69961ed3d93cf07fb453800585808254535fb58a9296889d66a38c17e821623a43fcee25d304218105f4eadcb5fa38b180f84aa646fc7f5c87cbfa420e5c19c4e2a7723ff0c19b1d7b5cea67c8ba9e54faecbba70dec61b45911695fdce2b4843b961304a4fc13a6000795bdc3e366a9326763f9ea874a3896602fc1fe4ecd70569ce8947704afdd8377ee2451c2c52d93215513ce95f12bd4d071271bcf1aeebbeaa59c25668377ddc792824429df32f8ba154b73412f9fd5c0fde02f135d16af05e15dfcde97c3046efa2aa0de7731a859c12fa2de8d04a3e54ac2f4fa89e67b71f2c86d3493b2c0d8f31ad1476f09df6a2d27c254731878451e0c480ec1dc5eba55e5590ba13e5dc8ef8a78ce6c92731de864437227193136025502d786354cff148f64a73c1b909dae7f5d7e3814cda9fe02901288e464531d09a5ce07064ef8bc653e85c273b7c499965d4fd67ec9d8c12ae7dc912c30141faf1e51ad9062015c769f158bfe49f31e8e238f03d284aa410375e2c19c9ffef0686e2dea43743ac997ad4385544b56eecf26c173c5722556ecd4faaa914ee49811209030272bb0c5f517efab6fcdfce2d6ff14f243c4ae768a1dbfd36877f94c948e7ee076034690ff2d14a3590733217e75c0572a80a5feeb6c5c34d9275e0a52e409cd140e240c52b4eb2fd58c21890f73f0ae8ad68065b297c1b5fe228bb88820e7f0db826afba3f4d5ed79c6d89f931301426fb7e4b6bdeeadbafd27416a22823133ca3764b656d064f70f865ffd981b02ed5e7b431ab452fc48efa4fa6ac0764338dde120487701177684174af6c550e32d3adf96648ecfccbd5ae35eb709ab1fb740e60112fc48efabd71e4a2384b4ffa8c4514ca892cc9ab649adfd8616c34857ef8656cc9a743d8d6ac952d376f1696f05dba85b6ed656c0f720487dea0cd96b13d455cc763004bbc5e63eb737ac77e52d587d3b55c2d7c40874c756c6a6cb392faa633b7a1e051b547662d59eea07fd69d32756fd4d9b7b7b33e7c2861fdc7f7f5e584898de986cec9e18b7b42dd7cf703058db3f6971b23040bdf287833b567e44a4f0012034da4e1ec9c7e755bda0c892b573c5f8a101552696836cb1ab690a9924a2833fb62c8e44e5d41152802c819b848ca3072f49dfd6f7efaa76f960cc926a1a6599aa5c75cba8b7d19605897708286af076d17b0ab6bbfc85fffa4e64bfc50bec9d14fbb6ed3136bfab94c95a9d5577b5818a670be245fed66d50390911835c7ed2dda64a1cb7d5fad4cb13b1a72cb9b72a386c6c5cfe4bd50181ee2a33cef70b926f2354cf05f9f1a13b6ceb7aceebe5257e35f1f6b72627e9180835caa6de0ee8498c74fcac4977a8b3e7352357aebd0eba369769d326f00e9b4469181d4a5a514ca85d04dfaee3482ffb4d0206f01303eb50d3cece8e738766558e336ed0574732e797c47058619ffa763b3beadc0aadd8a83475135cac5216ee7394b0565c933c0c81fa6852c2dfff95d5f366b160564467c16430b7ed3fdd079af7203c92c1a29027376ecdb8ae2091ea2e60496114e62e6700fd1a37e41ab033412ff53601ec03b999ccc4f13c234e5c531c29c834fb8fd8570a1e8f4018d26f0a6ad3f2dee2d933d8851a6328b0b6afb04a0069c88e98a9e557a96ca4cdcdd5f5b0185bcb59c1731f2ccc3544eb3cbf354b5f6fc835446482702fbedcafc2bc65ccf68a630944f748e92cd8a724ec66aecf4ea43c2f549d27a349922e98ef390153ef346c8f73bc9b297a07eb68df935d34ba7fd7b4e4da2330cb6059a0b1e951da0907d7ce1fffae3547e8e9f2d6bee289b7a5ccc0e6bdd04c52d76043c44254b4869adb119715753fddbd25695ab94730b827c1cdac9c55f21d892ba57aafa603ed7ea54e7aa13e5c0aabc4d262e3c3260a7437b036a7f2f85d45196a33ceae8d55a4dcb7343cb41b0fb4a6b7ffe5cb5b17e5d98bc56fe1bfbee8f4bbdda039dd4cec009efbecd2e88b0dd6ccd21359125297cad19dece24e329f1bcb688b5f70cc1a0c6cc762345695d3c9afe23756afebb3563efc71b6e26bd19e869e6b66bbd6500a41b9f4676edb94a1371a934bb20912ade8b350526c4383481196eaf6ea4dcd7e27256b8fc07a6d15240b3e84e58e494563e18d89e82edd94c23edf4d44695135c2f294372ee52f2e04452961ec3f394d07e2d18dc1c3a4fd6ef75fba6af4299103521a4c627e8f213ee71cb3abc78b9bace2a249f891e5c257729ecec54376a308ed679b9320760a2d593b0e457a6aef6a60aa20b84a4cff0c4322719b036d02fc4369f82f8bfd1cafb3af6e8df3ad9b3f18019895651a7c671518bb24b4b517928bf1a382c70c50c2832a68ca129c1fb4b2cc264179e043e4d0137947af9ba944e37daa69ff9ed244c108cbed0fd21282bfa2717870449c4d6bb8d1fa2a550d82f750118be3e323a9728eb5733eb4a129fea19472fd7656a33e71c3cab8a0fe5107e08eceb254923c541bc273c588d884466fa14dfe4a079fbe2e6d58c518755881695642c6f38dd7bf03eed2e2a1435eeb92b6080a92ee958ced28396b2509f9237d2d91f602ae8df832154da13af63869fdb38f9592d7f4b9a45f90980b0f9a4e793a1c93e80e2c929cc62890d610c72188bbeec1313aca1eb9eaed688ebed45ccb0900aaf23f1a505974dfa866be4e48de369e7d6a282f1f7077c483b4f17b19b0c58032913c8a089fa19b815a24bfbdf41b8ff681c2bca34c09444e39fbf31a0886bdabd0befd9a7ebc5097565c0d9c3f67fec8864b48656d0437058eab44c2c517e87bfdb6c59ddd35eb8ee3c3b57d69bab756dffd6e5e669d9f6933e283aba057b0ee4fc15ac158372da761c96a587b24f1abff40d1d37d1abee44bea166f71aaa47a45d6d90fcbd16e538465a6789fd268322cfef538ee21190ddd5c13fa9a42653584454a7dde1085dabccd9a00215044b81976a3e345959651f37dc056608e2d542ffe43bb98db1cfcb97a9bf27a943922e385d9c6bd358cead5d78ed8220e8c7a1e9de47decbbcef885c3cdfd2af37eebf903f445c16a1c97c344ca54cd7c692f3a03b8c0119c13a9ded17d6c1aa40807bae38a1deacc46c5dd08ba657b0c500c617f290d4df57c7c66b733565483df30f2171dc0d61ced0c81670659594f9c1417074ab65eec8abfc4e13773e16ab6fd09e8699dec72d273d310d34807cfc327f17d6f1ac54048c8d8f4a95ba252c7bb0b7154b716a82fd1a0c9f75667ccef701acef28616415b48fe793526c93ce0bb524b810ea3f0a22eff8676691cb40ab54858a31aedc7c9f359e9465e810ce6306fbad0482df65dff3d2d898b48e5b8e18e08e227374eca8566509ec1e29b9bc81d3c6e0a54b3cb1b006e1dbf8c564d043077b3b38fef15f16b8b72a0856280d53c5e27ec512a7584d5dd4fcf66ebdeba6477e9051067d283a639212dab9badbe067e2f556d88fe7241f474e3da3572b55adff2312c67b0133607193ab6fcecbb40b833fd4e893e8deb6e34d2f326e7bf3a435a419a7840e5fbfbc349e7ab4654c53ba7b8c9b3e7d72cee4962c03ba247a08508c8503a90a65d62a1fc2936509bde927f316d92525b326d558c7e14930cdb69620d91e483577d4b1cba74f88ea4b57916c7390e4a4a1d6bcd58c2c762ce7981b7c62b3bf052b9821084f1b2e83412f5fe5c2e9eac8c0d36ae8fe07c4844506e46a6963731ab0eaecedb0953420b0729607e5243cde9dad28cfe3192eda86c79bfaf96e202d13b721512b6bb3f741853b8a526caee823176a969bf8834fa818197efd0c530ca80ba90dfb74e86fe4b3c3442569b192fd0ee851bad6df457daf302e377e55b0d02ddebd8ad2a7741ce78463e31a7533d2ccdd66e0c5b7a5d28dc2eaa51aea72a6cca25f933b59098482356e08f97df0a5566be2c3900b4c9cc6a9a26b7de30f9577d9d424e2bf5c07f7d088c37b23440f175e6a7b4921ca561bdfdf0e5c4e7b9b54226412c7db51bf32be006ea7d6b3983821dc9141536dda57f0be50b3322e233dffad3810b47dd9c9f90e0d7194ac10c4033a83c09ce8bb3c91f0e6341ff461d4776fb6e4550bdb9f539c9fe884cf18d906858f98e230a13a96cab9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
