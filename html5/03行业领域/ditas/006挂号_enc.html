<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20a5f4500d82d7d7e6c2bbffcde96487bf74def65d5a81606c374b329bcd18e2a3aee70c494245ae3f030536c52632c6d2183471c674f674f33708236f6ead356677549adcb55263adf299c4c859c31d27c7b4f36fba663d3f3251462a754d726a4c64ad41f9918fe1184edd99ad6cb3df9ad5e742a14e02ea7efdc88ffd450e04b8a8884a2c1eda552c9e5836e6e17f6e70e20fe5e607fbe9c0275906093e8caf405a354f376b1f3556961aa14eb13206c508e17f27f7f0fd98e74519b4fcd659245b13c5aea89c101840a4e9e1b50622ff010c911c924ffb7f2bc669ad90a90a4d294b1ea7908324c04a35b291df2826a276760e628b62f8c6073bde6712bbccec2eabcf2b7b76d3e0d43b5b1550b2d86e19744a60da855822dd1c69ea781dfb1aa05318f06c5bf787c631b5f4afbb357f0ce1e5182b81febd4e65099ef2694bd9f2bc6fe9a4080b2884ca188399a9e83bf58d5301c2f41575c697776f2d74823340263bea926338a4239b25baf153bd9f47b0b5810dac85fe5f68e94251e06e5aed32e1e27356a1065d5c447018faadd5825145c17dfc22fb6c0ecf2146289b6b4ba8e61255cecfa7137222af4110da879ef1b1bff7caba4f6c466e36befff32325f71ec2f50fe336eb1f280c3ee71e8e844a5c0f9667b13d9b99566d0458381af4c965a2eb4446f37f8897a226c4b0ff55f83e2faf6f4a461856980848e52874ce84c9ed481a11227b9ec37e035b2f255def9792c439033dde272a75a839b05804bbaefb419544975c8a3d417931dd3e91c7b5a196f96fdaed3d7e7ab117e3c9396c11a05e6ee3bff206024a7f559570da33d4d8a90f9926689c20169f217ebc08039124a90c672033e7d3b82d303b4c67f3c9326e154e8d9d08457562256701af252e86d452470d815a42c84b1a6574b3ac4bf784498d088b9e652f5e90890b2c5abf8987d647246471a027722f8ae5a80a8c8827fc2e35ee28325717af1e203b59e91fe09f81a883aa2d00afbb8f956ef059da2677c0ef1e7a502f64e2f8f2410c139b431df93d7ea0e00dc9551700583822cdcaf83886e8b9ef495865b7d46f71207b16e92d683cf5376fa1e73f0b89026d527196222d958188c97f4ad18f7717b46e583a773b3015ed6af14bb8cd8b0189f7ef314a3418784db4a24afd98f74e3aeade9928dd305de9c6eda7572a8e78dc57c7e165ddfb04d11729601760683112c3fc5fea1eee599d3d78454a481e6c66c14df919d492f3237d38ba805f8945127be8c19da4151e3847331fc55b365d8000ff66ea00fd8e2ef0b62d90b01a9195357b748187f18609954385eb3929b478bea517b8630e78b92f5c3b30bd90471d88103c2441f17735d983f29576da01177c7b5348025deab8c438a94c4df24a1ab19e92bdc3d6ba25cac5cba711db16e72f4fbd32a7859cdeb66aa1fe727c15bb5dcc93d3c3097bb93e9a6a7b797ae11b7a8114bfcbf7b214ba5a368c90407f6fafee289146bf2f34977758d2ccc1e147b93bc3c7780ab2fa1dfd03deba3b81f965c345839bfecbae4f15114066ac96bd4e8f71d85a68c1f492df46f96181e4703bc5d801fb7db58fce701b4931f1a366b37ae3ceb01583e99954969634066667b6ab110dbcf99bd23b328bf19f3d95e708b96fd3ec2752a013567f9d17bd17ba9386856426e5cb395abeb69d7be2601ae17dd913edb44fd534f68b3270471a5d94900db805316c84a96a5fca8fa18c8fc12bebdd045dfc60a91e5071cd6ac430b4729e4945f55b6ed31e5014078d0048760bff5ca6dcc2c1bc27f2f53b43e69ef01f7e1ed4f5631b7704aab835093e8b724ebbb2254d64f1a7a01df538abad4ceb3062777f0466829df905e1fb0eb42aff0ebd8402ba17952c3be7f174b6a64f7f319a47cb79eb2e5886912b57de483a4b2fc6f94d4f5bf46e3100a7ce689b7048ee9248514d20820029deb94ed264da519dda6d77fa68ddad76b8c148c4d6b7aa27fc21b13f7ea19acde4e6ef94ef93af5474295f1c1377a280d0eaba782aa83a384db1d803476951ca0374d36948a3b06f55a14ede8f25cac1eb5433633fa78a289f542db6d37591d05982191e0ab3d9c09d75f4a377074b5465c4e8f0533ef90e7facd2ae62c9c905f7e11952a641b0f2460df93ecb8527ef1187f15ceac59a7c17e5d2d75e258bd06db85f93dab2be2623138116a45d84175fdf4b530090e13d9ce8ab6dd79ca5f8e5047a2d132c9d780f3293cad28407ed7ad882cad0d16f412c2ae0793212abae81de3f45af1a64b4af2110060ae8e06ae576282a0e7961bbe7d4e85ac7550aaf2d52a4ac30b8cc71426d4ba152b1feb686ac82d2387f02a63c8a4f46a9f17ff14410baccf68739dec77aaef82b1a6dc92cdda3cd8289776004c4217241848e2d4f23a82e3e86cb84e74edb6237145f179def7d855d022a4ac28ed6d2ffbccdf5623145f206841df47f38b6b6690bc492d09b167ec3783ab7ac964ef50541d85842a657bbbb4e0da2de4e5acd12dab8d6ddecc2fff0cdee96245e5840f4aee50548581e297bd5d0375a9f6a7a98a1bafe9a7fbd905c4f6fd6508274eb825bc1022bb1da02b2814c05916b3ffc120cf1977c864c16d58d69c880d1be4f37d40b92f67dd4872ebdc2235214175ddd43aa17d0f828995eddee0f7b709b631cb9573031262952720d3b1a7b5fb6e83ee4f879100979fe6baf089bc9d264d1f58edcbd54fd91b42c3514edcad9405a5df8c9a3360ed427efbcdd15e765eb7b112fa77dfea0aa97c7929ef965e479d71460cb8d38cac94a1c34f933e5245fea17a8c8333301d8616a41b53cce0cdeedf75f740ef31198982b54f89023b79be8867bb4d1a90160ca7a6d885a6fd6ace9a3b5ee1420db9524352b3eb11ee7c4f5a230729f6ad34be38301c7b872f7a84a2425a23f7fe2bb9ed92d6f8997dd63e380faebc95e0c251bd79d8c8ef2a07ac3ed277e88e3ca10de8989f06ea039270673608042fefc21111c8e90544fc72069f72022933332ab1f5a49c5db88aba885a776e7102b9906d788272a702ef44a565a091e823bde7a54fc1edb8abdb89fe8ef4d1ddbeda6b746a0fb5408b72a5037fe785063690c10b07a8504c5cdf66f0201782636220b94a97653f45d23746a9c29586b9262c2b74184b5c38eb97f6023935c500641f814fdca5d30ed2922d24130ea013029f1650c03507449f52806b2cbc133a0b6baba32bc6428137a528212249d80bdc8bc94c9bbd4cb889574e8b8e221b3764366d9f0ed7f2e64bc5576f154ca7e79a7c20706fa6e29b036e9c7c8bd870f7657056bd6593ba6645540f950d69f8ddd6060d5716c15acbcb66e64cd2d615cb4408812ca516f8817b158d2d901c06559526e268bfba2532a601ca00ea23d82900a99047391574cfcef5a1d636429b9a21afc59b5258595dca8599d26c7ef5749abec913b042231d071a276933ecdc6b460d27d0a8a775d91720b8de63590abaf88f5fd4f7f8f888b92b0207a2666cab3ab46dba81467ed901d84bf7e5a8e98d992f0b7c5a9b18fba329d9626aa73d4ffa265f454d72a33b0d236f230b2673a27c80e8c1c7150ffb6c6820024acebf7ee2f19c026a20b89541deb9939c79e667ff3babf8d6492f35161131de587355bc7fb912bb282597741f78653eaa23ae6560afe46c0933b0e76062477523e17ff4ef452a75428e2e57c4e58e246a4917743b0619e171c87f8e586269a8a641b649090a93cf023fc84c3003cf7184c7bf60c91d173ae0c714c4557393e6b2f0f8c1a478463f86457c886e7d156f05a6b709e1a8433b276c0c815b5f9fe8c17a8ad34e62e150fc6a35c258592f2df79d19b6b65b56da02bd889309ebd3de5ba4faa637ffe426a6f45b39ffa494acc5832798d2be6e441e076f17054aa5efd3c9a1582945a1f036d9a5aee706684fa4fae17894b7a976c3fae414b2959a65d7dad33fba3f5f87e517eae0f623a3b6bbc9aa366d14c2d73508171c2bccf6e3dc3358322bd74ef901c6ed2105b7c1898ab3f7010f5e3c56e69d37769b8bde60cbfb305939515e1ec9309002962422467f7182cf82782b4bac712a4b0997a7d8f29b1b36d82fa76061d687a80793c2922a497916ee0a26a884a097fa4d45804c8bda9795731f38b117479b70a59d4277a721fab74a663c031773098a2a5e167591c754d4cd3ee5d53264122cf990fd2fa34586c96f1000ec619a1121c0abc545657a1d95accc5b554f32e3c0957ca073e28a8c91efa3e0eeb828379797e5b57cfe511742ad4b26057287a30d6c649c642d1779f917dfede67b94c2788652f8f3994ecf5f340b2b09c7dd18757ccc8686dbdc1d2a37f74f2a7183a19baf9f583557e528ad87ad76e49b9b6e0e333d11e38321f20f6034053fb8c8de9ca349b39c69f87808381fa23ab21a2d44cad2fb9b18671827f1c0e1abaa0d214cd08e0e736ea0d2dc94aee02a72efdff645a367b1c512510f262ed3b71acdfe03df0302c8de8ee94039fb402ff3a0fdf951829d7ffea430afa6dd11b695be3d1896c04a4538d770356d5b0ce9a461836ca2e3547c27e908d27b654fa1c31100da4d9bb2d3891e0ca2cef0271e937875a4f8aa6881a8497ead77d87277ba72ba13f32fbde1a6c931f1307dd9185f4bd159026a7531af7391cda8bfaa351a5db4f1a8784ca22c4aae962246384da286f3e1ce430015c91c41c03c6477422366df3124375a7069cd5bf3f2e28a6609cf660f7c1e452fb7ac8e3edaced4b6fc3cdafcd244f67b18e186755be6a55d08206ef6d54ad517f8baba992b2dd529539879f8211754e3147a14644cde5d6472c3cda9fa6a627eb65e0eab46329d6fede9d850bf05ca851513b68b00832b10ff72d8ef1372b2b19dce9dbd661b5086e433720482ab637f8f6d6789a405ed8fbd7f4990f9c74fdab0b5e2bd34afbb163c711ead0135b1219dfe97d036d96a56fc48fc7fee756773e561d874cef54a6be529f9f2bcbb29851465b5fee9bd7ce2df09c86ebf94d458da43d7a37116e9d913a236f01ad273c14a8f73be41b25d48bc57bef991cc31e1054142e54b3d3b0bc21fd70f67c56030ef639555b1b40d714b15eecd29de810c686931495f739864631827af3855159eae19546387531e964c375977dc9b0f2e52b04c971339057cdafb078728b85a21f5327610c69ae53bcd6c75ce5f6e990417e3083ac4e79b3db054c36ac6adbc0db43390883ccb4e9ca6ed25c36a919a56c51cb84990f3082943cec62736629ccf0053e8cb0fafa6c7271a75961e7c8294a0fde9a0ec579f69aa7463651b38e91846bd80071f80fc386715d1943fed2b2da5ac608b056c58a681d46cfbc2841da052f4b4c46a909b80fe3c43d0b7b516bff3eb216996e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
