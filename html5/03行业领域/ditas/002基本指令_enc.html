<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0db2909454acfae315d06ec3edbf8fb88a49b5572657adbbd279522edd6fe91a5c8d01848d07c8085f65d637156aceb9e69e264c43a77f2be645876298e2d9ef8fd030335b83784d55d41b739093a63c2767855d157f01e01edddad1a861d5e77a7b6be69b9769a2995a11fd4d359f19531d2f497718f10d85c7b00553c2d0818e88d1cf66bc433b726aa45f80d6b87681cb0b016d9aef558ccc5c06dc3aab9e8144facfe2cef16adca1e1cdff4a40a121bf6c0bc242826590ada68413928bfa96deaae92b1b121f10d609b43248d3ad119acb0539f2081873667e2e4c1c1994e4cf448d996db8e9b6fd87c18c8203365ef2a972080a833de2edd08813a8e7e9a2b29aafecbc82206dd94b50f1af18a049566172ee7f2307e4c861422987776d277b6432e9dfe396f462183d41d7d9ad79e855684dbd9123603a5d1f76916f4be8a1e03d759b1434b8e13a18fc652911a9bc19526abd5e52d0f9c91a390f3a510635d3e363bbace6ced656273ce98202fb43b8d196932a2a9f3113763f3f2838e7526bfc8a03ba0787b7386ce8ecbc8e4de4bc1116555e31245f229c2621632d8f863fbc6b867d9ad23ae7b161ea12e68ecd22ff85267a5acacc335a7be61d338cd78c31aff91aa729aa0fca4c8f41480dc49274f36eab5aad159e7094ae4a0dcd6607ff270c624991de4ac02cc5ba2098eb2c4d1e5704d63eb8eefe2612ef8eb4787b6b2156c9363d864704f5e6406d14baa06aade4f7f98dbc516e9658b60c1b7f7833c8b3026b9ea0166c4c383a869ec057ddd2f075a9b4ab64aaf03a201308472990c2bb7a3da9ed5d0adc146fa8a1d5edcad3267a427e62ffce362ba5217cc28bacf5f246c6027be7b6e79060c30eed46a1b6173db8793b2cdfe7fd6862cf274a598ac75f4c151f164a186b5904f452ac5347eac0570d98fec145131fb284611c12de818a8ab6e54ba02d667cf8cc03ae13e1787103b22200f1dad7e7a88e238484c9e946464c01aa941796fe474498c0110142e00697e2fe5e607f909963ca6be72cd963bd8339a7f2c610df764c090f5aaa507b39834cf53c13ba658dfb9053fda101f497e676a61f5b559d31ac4253df6374e2385fc52d0a982abdc89c17ef0b0697610247c005e8582318ca5c453a9a16902d627ce215f37d9dcfa587a958a4722a549e6f8a2e5974e231da8ca0144e20b29e4421e050ba512837cc604bb2ae99e73fb6402798e2373dcbdca372bed7f75fc7528c26783062ac994a7550d121443d0de3beed4b0794b18dfac6f4cdca03508b82e07237f6c317b54f4f721d3e95166013bc7cc54f7bc4e8e978889609638b5b9f7b733920b111903053c18bc8e5b958d2ffc04d3fc1b0433d1e58454d51ad521974b6599ada10f44f1561c66813b3433cf6e8ad26b19e0b6fbc13b264014c5f007ae0341e67cec54dc5624624e1f94f031bf47626c455f5b3e6b4bae3ab3ba46a3403091ac28fedf58e3146cb7f2d6972e266cc039938551510f250e84afc0496cf39c4d4e8b0c89f6f316963f6762e2241e455210b4e94c0f29ea197e982bb488f83a7b119e81d8e351928c5f618b18a87c0287f8b2cecd5989653b4f6bfaf1d49959b67883c8612b6e536081c3edb189a6933632f8c360f28c62fa39c35dab3e92f5d73a8e927c391262bad1ff64b8cabf6b13c3d87d598df4056411ee3fed07f20649855e0c80abb204aedcd27cf97f6be29289fb0b6274044a736379d19dd0464bd241691dc1e0575bd83ac5aaeff37ee73840ac0b6447267670c82a263407bbc27cfe41be4254b90fb7889fb1d8972bce7eac84d118a355c2ae7f0eac265c94cbcc6b4bf6ab6475cd6112b2228b0366df4e49d0805e2be562e4622dfe2325a4eff03b6ca6655d19a416a674049801f10bb9fb9a7b1f3489e5476bcd9c9ea85514611668f0abf2a3f95714ef1737d923df073556e602da519527cc748d47df9e4f72ed14119d63888d97f3a481a95d83d31d3c6e69bd0c1bca97e458a0c69746d97832d128929c83595b233625e781c3b0c33ce0fe5c2f2e92664b3a75c45485c84331dbe8bb99e62ce325d5dc4e5dd483d7a0f874a0c1198dd1199e71483eae7a8860e144444ffcbfca5a0f36155d73c41c3ff4f896243f3f5ad7e258101cc13cb7644a02719bceeee4a4346d620a7e469bd9871c4cbfbf79504e6f6e4236ced4cc7f1065ebbb1d99502e1ec52910ab348841c58754882f2fceca0666b2d3941f5fd0673ac119e730e7df6ce1a330ca5a851eb341bc334a3e0fadfc4c1da8e4cf48a4b2627506020c96c394ca28f2b1cca39c24b655af557100a055ad24196e5518351f2f7c66a78e26a3d211e791640a1a1fba863111cd91e9cfd59334b3f310160fe9b1ab01bad8c1018722209e2eecf594fef1c76732137491acd378ff18d65a667cbeaea3fd8b6dc5c6603669d90a58c7417d9c0013809c451e7d47b5328424e18cf2e86a2e6a0f488a4923d650ef234b459b3983d4a53d7e94014dd7ed5727be10675247d7bede9fecb245c9800bf2037b9caba14364013bffd42ac9adf5d5373fc35ceb61be51cb5fb9b29cf1a89bc3ef7662dad0c62e9c572af7b9e8080362d1f3527bb71995edaafab4dc3a44aeebf8891c6bb15e42bfd427f37155f2575001e0be89e67cfd939d0cff62719e287a3894b4bf085b2a086ca2fa1b44d5feea26575b8923e580e6ff492d6061714efed5cd98aa91729773a979ff3eff5fac9857c6efe4660cb6160327884ee62850e67fafc9854ea70f3df3824abe3b45e6e2021d8bccfcae9163d9d4ffdff0a277204a68e10d0952dcdcd4499ca401642e6751b5397b2349c9419171abbac26842dc746b1c18c06afd9a7ddcd2cee185bb94f4f7cabda6cddcfc1991f06c22f40d33fe3e5518b4a67a4c6b51103135d5e9909980cb0bc84e79ae805b36fe16406ab380dc4e507f402ec89c2e9d0bbfb6d2f98e73336636cac8c56f1c29ca517b3b662285ec1153a400db55bc661240e2efd26512f97a765b3754c987bd0b51e11ccb77b447fad8916857598d18d80de86b4fefe96a85f5a7b616845c8ca8c7ede30e666c1aa87e522e570d3bfd3b3d46c5fc237f4ca849e463e154d1f1004b00fe9871de1ea829f85d2e3916df1f00fc0088ce5da19c103545279d8715c5badf0b2d64871ff68f6975bc2483c9f2d123169bc14010a6e0e7b5ad175aa7742af801ee82af8a4f0e1edf49b4ca1194968d97659206091b0d0df05f35dba39330f7350987f684b830892c6af23efe4f044e06087c4320bd4af68e2dc6d3a02b9216308b0e793fa0d3cae5edbb1120e462d39285c05d9ea38e645f20957320a190b7bcd04353aeac678d01fa20b3ea4e8d2d0fd97765f63b4709fc57a6c6bee4b742b096c9f0c501e9b1a7e88f316d079183652b03d7003ea9d05dcc10a79a2c64641fb40c18f7c87f1f277f0a3201200de5d1a1f8268b9d31acf1d91078c6e8e12114db90ce08999d217549926d1db51fa95de26efe24b28cb540badab4c5e477eb7167c97cc64233bd7bed0eb26d92180e15c7560fd1ad985421316acf0a64f3f8afaae47c4f7d823ce3bd0d8b3cca10b852c49ab43ea33f338b879961aabf9a6723eeb0e39fd828d640dbb8de81f6a52446d69642131cacc43d68ccb4df10cff6687d16baf0c51109e695b48750bd8b06f352aca4eece4fcaef7e83b4ef1d3b552e23964b43898db6f0a73223acf18dd71027202fbd301a9cdbfd28d4d633c8634c534e4749225b13eecc6bd0acebd597df1ee57a04a0011154f2d9638bbe136633d3b1c4a11f0753958dcbd758fea2518c496c64580ee256e80abef92671fba8bf0fcfeb4dcce8efc1fad6e62ec815648b21072ffd2b8627bb7c759b56bfc234d06bc094da98a6418859ed30a871a30f95b727d5b35b2785876f623c2b428cdd4e2d1e2e23e59ec50ffb9b372cf00e24e17dee4c7826fe065eee17ee9363b44d6f8ad46dde8ec8a1bc51e0b7182d61c2e1a106e15059abcb74627247481863005a8aee3fd55fa733ed45006ba7665d46a71a8f43492321db5736beec031ae3699aab9b5e1063eda7e03820e0dadb3c97ca49c55a66db39b1229914d4f2aba7653ead1ac24303a2ae306a4e0439fc6911ed8f29de94456c54dc5f3bb31820527f8474ff682bd89aee97ff1d309d505e4d3b6329a95a4f1d682cbeca23a5c467087825a1133a4e94b492e97c9a27f5f3d90e16d39ee30bb19b280dc654199398c1dec723db280f3b0d6aef675126fc1275ed4e74960f6208df619fb39859ef1a05935b6371c19f7ccdaad8378590d2d141fed46928f0d64188ab6d010583d286de737c14149809baea820ac09a8ac07b6f77013cdf93f5da6c3839362918868e3269f1633c07424da0f1d0f59e2cd58bef293b4b03f9b355a7e9f755f062ff473008e78bd7f653ddb76cce119ef8740ac8ddf5b561076c24c38bd37720a86d510d8fa8498212e67c22286b11f8a1684d478f744ae8b7f6e18c599ff4296b79c633886669bcbf41720b71b44c586809f7eec4d367f5877aa75a62002c1e397fb5f2be6b5f49d3502c22c40261bafe8d5fd39a0fe83d38c79ba952bb3dca5dd0e316868c3e681b609754b409cf88eeb47ab1df39f1b7b51e65c631bb9cec7c45effd01269af50f862db92a327cf50bf66c9595a493cbca77c629c6b2e17340348e254d7f257f6d8f82773ecfe743e289c1535aaeba1a4a86a3006da9e55ac277e3b5bee3ce5d3a327aae13a1f3cffa2248cb860ddf998d30e5948dd0af4825ec98a842e366d6b02b8fe5661e1758bb2d5189d253c1b2c3a45788b6e542d7149470d41a4ae36116d6dbf9e05a4f19009d7605298d3d40a9ebcd005ad3a76cf782afa2a20da4fc605b63e6e92cde1025cb23f2d505ddf7a9a8e203b843047b6f6f77b779e46caa5a9f32404157fd164e368f7a07bfd26df707d15596767509a56529e50c690e3d2ee9c296811a09fb08b1ed600f13964fb60306719e9e939e409178ab43d34819842c309eb8eb9542fbfebb2adb4e3421f802d100dbb8e20ec7fc113e5256f8b59876721c22954b749864c75a89aec9c78c043ea5f80ea0572d8caaef5e7848f8c593e8a72aa76099008e6aa424804611c2fd3269e6f26bfa0350b99efdc1e09fabb2c6782fe884f7d7cc1379061c09b5b2663816c34ae18e4f4a3ab742045694f9c2f6828b9702344b91c9521ca019f0313f44dcb340b6bd371f4c3d3ab10778526276196bbb8f7840a859c32a32e7ebb5c554791989b7336885e17d0df1775404d3e793b807cbf23da79e69e4076a47da3e2996163d10f29d2f6590d5265007b5eb1c3e0819d10bb0aebd1f750ec6539f9e1e28c87911b2c78f4fa28464ebd3ba6b56721a1bb910cc9ca529fdc239816e31fdb07fe1bd945fb0b0e8c50bafa13e7972ba487a50a45ec63f92c00832b21f50dfa5d0cdd0a3b477b7d36d2234ccebed064658bb2c530b8b803abe6cd0df7100ae36e4a564dd6e0a3f9ddea0daed7792fd9971d93b15cb83417f86fc414e6adcc8c09d6c0c76ad77fdcbde2f10e64a662a274f6258b4563893454d6bd17341732f08b290479406b4f962aa791096b171ed8b270e2ca4bdaf112cfa6dcff935389b39e32571dc733fb55c1633762fdaf57379ce0d1e83d9e7985cd8c45978292a2125cc513873a00a618c6a68b56e3810bff28ce3a1dd9f84d25d3b053afce3992b26d2dce6fdf3b76e15ea72b7bdc5ec8f72c8c031b570b8f74dfddb7ca2719a64265d6879247f879facf04f3ad054549768ab288a10776d00a54c6a00527bb4bf29316a32b6b4cf598c0b029d8c79afb314a49d2c54506f913db2a0fbb055d5c0176b59b6e6e3961fcfe9125517f39401830448304ac35dc01f2848ae4302d182bd693c3139835145436b7f93429dbdf48115521f7155ab729c628a1ae99261254225004ba01959008ed6ab5d42591457cc9c7e8753823c7fb23e1ac18194a6bf79b9322434b05fa45ee14f7b6c871cd580c04683ab929b33529c2f1f43d3d270a918e0d8ee6986f69ec477fdcccc0b43511b3a390ef3d2c8b284037d9c702cbaf0647e787d9a76e079627c7ae4dfa93a99e763f83cdad6231fb9a00e02ad035b32c8679a4c2fb2eb1cfe34835d52b4d86d71f6fc4b05c432608861d79a25ca50418e361da65db5dd93221bc1a684921cda6748119a925ec5d639a145b261da5554743efb54cbfc225f728ce271a7db011d3315dddc84e35aff2b4bb99854dee8b162f91f671043a79e81c99ccf10fef12b988d76453af13f39eb334e6ee4d3912d324994d3e656e82ed22df87598d8795e5ce8e323ea0f6a2ed82828644c4e91dcb2a67e5c8aac23bb1fdee59089ed81ee10b921af7653541fb98b43f23a26da7b6e8651b19079ad1f2339af90f7050e55488fd60a45f9efc55837d7d2ddbe9e1f29b21aba859cc98117fcab6c433a5cc8a8518d5e8139b8991460eae8f796e4211de5fca43de4092b17454f42987e55e4cf9a08aaee8c1d3bc7c28c823c1e7fa836e52ee7ae88f8e995d75c09d5cbb9149cc5a8551b6c6d3ba259dbe6a7033386df1c3c6c820a3a91d0f7820ab98888cbd288c47e16b79aa4d1d391f68d07465907b921a0a2b52f6b4214ffa4fecb887bcfb86c5bfb1135b9ed2e72f959c5dbe1ed34673a7fa7f8e1b05112da641ed7cd63ab58086f0ce40a9bfe066a9722f364d218a34813322919fd0f0a5724e4629877147e1848accb9d196b1e5c50b92d2063a4de64ec8c0f98f8fee72306f3101033d3c0abc289c3de34396e8a6201c73f56d27a1277d8f0f1b1b67db44fc54a6bc8177fe175a78ae1acd4528820aa52f9aed06787e5bc76900911956f215670b554024a7d49b674221d2847a5497c5dcadcc8cd1fe6721a16ecbc1c15de102ad6e960cab171a0d85a944be229c16c8a2000f32243e2295127e2a348ae1be8da20fe8eb8ef12392107b429080f2b4a1f5e064df6b4bf201641df73373ca481538c277f69cbe1c8daf4838e70035fbd3ba8d71d839b7faf3ff7e7561e6067b89b8967ff93396b3be082c9b4f0c1385ee59da2b590de1a777f21113273805788219443640211a7d81cb02ea8efe3ad9f0b9b4a7abd411acf4094b02163b7a17dcf353ccbfa577d40ad88e6e05ca2c620545dbbc4d46eb3543b7d47eea3e68f50ec7ba28877c4bcabc7eefab22f41105ad15282c7944343b25d5be6e65e30fa5cda5cadcdc886399b941c512983dd245562dca12c6a180799c314496100245d9ae41fd54d839df200635c502b8cd08678cab3afe940388565a19f6f5f4ee04050f44e1c01621ef05190b6cf95416026b7153c4d6cceae4adcc2a9498aa60c87c31dadcd093f4bf17438054f4a6b6d0500de6e237bfc49b85ad3ab31b7b747e9afcacc61f8d61bfc2786545f2080f436e1dcc598ddc327d7cf774328f5b3f1f40b6b337422b1490205d766e2aa56098ca5b34fcb74f39792ebd08e51982b553930ecaa378f44d5f68dedd8badb7e8e2ab09d7009d0f1b169c005a3067d1eeb8cc167abebcf837d7c32ed3b9485467abfae28cfd4fd46b02391462dbbb38620fe43b3aec73e6a190415cc1262d876df3f4a81ec9f0e0199029dec37eb05a28bab58ef5fe4e04289731a99b7e669992a5424107968e22d5592d22b43d375dcdb09d60750bf34515ef5fd19c3f8c9616748e8e649c395a9d36e40bdcd1e755fd7c756074e3bd852bfc93d3532abcd287bc522cb8599e58cb1c6c792dcb9c1d14ec45acdca926ba82c264bed3a43fddbb7c0b997c219ee910771bbf468442851f308d019377282ba1386c1fb3183ee72bf581e10a2a50cd854cfbdc55a57f6c7ff6a0576ba28cee0e4a05aa66b3c4e92393f6264d25cc2bb6436f581b08131cde5e9b2bc1ff4e378fd310abfb547b62d1c562aa8d7bffd7eb45044e2eb072efd62250f2ef81b2ae94d5d579f873e8555e9e737c5bac7ae411556b4beca5b5e2f6fd7b824c60542c0cb4420990200f51cc19bf188302c2365be6233fbf3b103e10cd744e93f3c58b963a116e667e7beb244ba7c6eec199292d9282d15dd6a3d458ac7697925a7a761e29475b170aa21be1b658e76a6fcfa21a5c147be86d83bc49107ef09c3fe4e5b4151f139951909f0896791f30773d5bb04d083629fb0b7bf86c5b3a361a5c92755fe29023e441f218fec950d095edfaab0295d4cfb9b66ac711c77126887827606192fd642633c55d7176740784e11296a252ade2cbfc95850ea339abbf8fe654ff52099b3c0e6aeb615773c2bb4bd2462efefcedf09bf462e8b25db1defceaff22599a0732c51afab9dd6209a82cc1ba0984a3b59b85f6bad75bb2e142c1af10b6a17bdde565af7b659ed0b68978e21c8f8e168104b90951082faf843341ad5d95abddae5572ca7818687b2e2a22214d8eb1e888d00e052d4a92c6d463af2142bc35fe95898ffb099655b31f0b067f0d7782318c72df11a1a8c522eb88d647cbf81a0006f3f8b1f10ddc4c26ddadbbb2a9cd8ee59e41dee3a489d3ce82632714e6ce50311cfb2bd271b4d7153c2f7aa10b0f3f5519f4f38bc3cf741aa301689762fe7de2b86d0ee288e46f36a837dfbcf2045bc51ba2dfadc2d2e1de8700dd4e5e3335c666c516f32cca14a209ffc50315094ab6b7efd70e7cb84b10a8535f1094c76c5984920a5416cc2807c16fdbe6cf5124a689320464e06fa2dc807b8cd75f9c38fa8f4463df4cfc6bf1a9f204a74e75d95a37ee572ebceedbf414726ac582c50431b1dfffd5d8964457877a568819cd08b0b4242b23dabb138274756c60e14f1eae73d72a38e2bf9468fbafb2792b71a92db0d476bdfec98f899e4dffbeb9b36df3766f0a44f66a2d8f681a3d4fc35a03a2ea40dd0ebd0c44d6db821f35023dab933229dda842b9c59f44b94c721957ddeda9ed424fd063c4e03bf2fc6f1e92e20dafc422a4dfc9fa8b75f44948acfbcc8f01818b2df86aae0be661f61f60a0321fc70d4c3eadd3cf5782ab6a3c64d9744e6752ae30dc3a9b6e39ee260bbd84eb1ac5e2c6302ec54d8e110bcd3db2cb7a8ec24de637653ab3fbb3bd7eb995c3b0a440256e88a45c2ce036bb71d58f476f2e5f7782b2fb77c1a43788d43412db12cd6c017e91146fc017a9864f8f9cb57804a76f6bc6c0be58aace67703a0e471698702b6d15f53abbcd516a3b32256f7737a8483249c49d80429c407a424aa943efce609a3610d1f00a67f375a9b06e6931f8712d3cadb1ee8223f091105ee4ddcf161f8489c8fc0770f63aa3f3e1587ea348ad30bc051b0faf2bd2906ce057f837644bffef3bfad5280b2228663b4d81eaff4a926cb576f1de03989c95c8ca8ce31547303b2968d9fcd7483d36fd2773be7366fdef88be773391b88324b8b31536f5124bb7fa9ea25b8c37bb7da8b73877bc848c90a120cf80ce060e651721d359ee6a90c8e1048ba129556fb1d4410396f9b86d033065b69c73554cc42b6eb5d8f3a74216a03978d25a37cc841880ce6fcb2cb11e5e9cb2c44a321a7fcd33ab10e00c71efd85b8c3333230a7bb0813f9646139e64b8ebcbfd08f96db7dc36fdb23131e8fa4ca068b3551b2f9957a6fee83e6fbc4d411a45388cfbbe8a758affc25261cf392e4c5e44cf627aa99992344e0f35683dcdcb8b09fa2954922735ea2ddaf7cde9fc3a219c4062daf0d14166c5d148c425cad009a2b8dd13d1689e9f0a033c2bc416d55fd93e0c98fe95eac0602e3adf643ce3c1edf3ed5ad31cf8fac45ebc914081a1e1712e48c4a344ff85e1ce6e498fefc12643db986cab65dc185261ce94d54fdc1db6fdf14886a5c30dce089576c504d4462158b805a95ac34a2ba61d59d68c091fbe8977b63e6eeb461f326b32377f57f04692aaf2c73dd068e8155bcba7302a0f231dcc9ef99ba8927c39a0943eb9d1c3b31ebaa920639c819ac5768bcf45d13278be87d9dff722419fb5f4ddddb3a3eafb48b78f2ef0f89a5debafa85d626cbf204056475b1bc48301ba71f0834233d307672bc79ec5921058614764b991ec5b3864b59442cbc200a231813a125213125f9ab2a28eea32c5cb53d9ce4d936de81ce8710de57100aacd993c08b441f980a280d24f999394bc27a8e4c57e386a558d2eb1c45dea88a2f4a10d0e6f4a066a65cd09635b0f22505fd8313c5d887cb92a13e866b54ac68c77634aef5db29b9d127c0e0baa08467d81eba46888be163c82f8316cbf6259bc49e474a5fbb0d4ca75551f6bd42533e37140cd3c835a6c63c5d2db7e893a7090c18dd44ce6ee95305bf8388d5edca58847770c35db79a16727897d786f77a3d1a52a86308f157c365a06c0b715d756e811ddf65bd23bb4786671f1214f3a111723ace15ee3e2acdf09c1332eb0eed5dea52c2b61c2e7a525f7cc057cd348cc96c0825e876eca297347a86f464d19b773df5af27adc657a8e9803ae4af77cb7ade4b72c469a9a4ff56e68968babf6e21257ae8a2563abb58b9c198b04586d7a42838e3fe8cc16ca0b8a52ca38b1d134f299179feaa58d9729d02119279a2ab5f2bf2e3844616296cb542ef3ce8450bc8011b4159e6230cab34c000cd7d1dc26a9b42c78024d48b8d954a1e50758bacdb42d7d8931807ac5471dec4f4fadb245c0a008633de87ba419129a416b9d73740cf3bf2f2b3305e082ff7fb2830647b528da8407fd20c0e22d877e26a752dd4eac0b438adc4f792a159e764a76d9bc2185ac601d06557f60967d52c97648281d53fa2192f077f390470b78cf93a703bfa4d73bcf4189bb88954b3ca7ae74bce7d01e6ef491996345f0af06a1e9f27605c610e364e539f56325560c16b5491ade0bb3dd9ffe7aae36632af9c54313d42f6ce2dba4168deab8fb86fa9df71192c780c3ab4c4d8f9458c8ab040c3175e9ae442d38d5ae7ceef5751f83db3eebb91b1ad2aea6d1a937cdec872ff5fe0d726afcbf187e4fa021e6573b785ea50c182490640dbcb1b38080aab19bb34481c5b9d0bc7a78aaaa1abe3cfbefc94b0991f9e28850209e6d1ca2c0df4e83423e3b80c194b6d50ea357b21c0024959f695223ccbbdd13a08a86b289337c4b53aa745c8483033294cc81ae44cc55b679cd0c1520c906d50a9f0ac3ebee406c794cbfcc108e4fdeba934f862542e89fff9200a81a26312f8f3645593df41a9ff46b00d9c13486535a03b7e44cac65b2f9e4a6c9f461da6a92a8e3779c583d50d63cd552d586134a5db116e2bcef2c59bb4a41c27851c0e12d1904a47489956ebb5988bf96bcca697c2303aecfc6390368522e408632af2eca8edbbeffcc2e75263f32913c835e961ff90c0383e330ab3b4f4e18a747960b44fad1e4c5415b090d49f3c59ed9bf2fbfde7477b0430cf444bd4c9c3c7a4640e4530589db2a3b6054e9a8b8071b620232065f91b1ff8dab7f274e6ee120c06cbfbd5f3f1b24fc8ef5d26bed1e9c57a09c1696c770498c721c7b597e899eebce2a8111eb76f619dc8981467269422d36b9a1e577d093ec475edc6373863e4e2a5ed721d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
