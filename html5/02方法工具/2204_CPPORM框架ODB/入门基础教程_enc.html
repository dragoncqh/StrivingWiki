<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6ff3663cc302be3d98302567f7f3e083eea59fc4b7137407a683eaa5558b760e070665eaa6f85ba6022717474126648121bb69b94438fe73e9228cb15bd4f0c4af990b21bdc2aa5bccce8f28e59dbf0e22cb4dfdc1ccc45b56f1cf996ee0f9eb61bbd0fedfd0f12541266a9cae53149787ebe43ae66866270f25cccaa1db73f092670fd072bafa0e0f36c819d45e32ca433ce958cfe5ae122fcdccab38cf10d03e61b35bc7254bbc21f77e9a038865c57ae26643b835d1c2ce33147bec77e34f71e4072708d43020d6a1b390ba806fc08056b8b3fe3b7de94c2c7563b8d4d9fce710f35b146030201de0201a65a97d66d67248483a0d796d2c83d8c6f662584ba672f277667bacc141affa75a6ce7c8f225d876dfd9cc26888632e9f8d55f659466b1655f7da44620fda3182ab5795d34671c0952214d40f869bda83443e78b0f8bada7571f9e5f652ad2c1b781116994b1792215e6d672af689fe30c4b37bab3560b7c33062839ce952c435196a87e4c765770c24e459794b7bb900eb13af87f061671713f770d15e7475cd915cd27a7d19591541d12348c7f44512e8ce6033fd20fd3783f24514851ebc17b9c84ac0b37b3e7e373c50b54165174f33b1ee67a81a87a14485aa4472760452b4258abcc6802f75ba838c89fca9be1b942279ef2ad9d204e364e629daa6787c137a1f7ba75793fdd61c3900d5b5d0a37083d9b7668ac4c9a5625bf795dfa62f747c57cd27b2fb43c65432f4ad840ed0b418a3bdd3304478798feffe61636c0ed4f6fd1e730106e38f1e646e7e9200dfc03288884b3e4655293f11a098bbd14e5bc06267bd3fa909df2a58445f0479e5c7f8f5d2fea4c4983174ec23d1517410c2697df126adae925981ca6d6dff5210c9fcf916dcbb4ce8a58ccc388566cf06c116f478e763f025e9ece1a37ca97667790469edc3488da64924bf06874354096dc7bebd93c9a0d761d7bfc1a3be02384bbd2195fea56085fc267c5d139168b4c40926b123e35cd22b7087d99def820ef2a48ec7c7f7c74ab11eeedea6a1862e25677e6ccf6a5b3a3ac528e9c7070c4b8ac551b8dc49183477170e9ab5b2a383170f42e1ff48e663d5c79460bef9959b6fccc6277fdbc299690e906446cb9cd314df8267ff6d7546389b3c48c69f20937f6588678d08a6314bad64f80b8c587f532627e7c7641e845c87576b9d4f84e29121d528917b5a2a48628ae08eb2361a5f10dda189567e282d534dc5545fc038e1fd14c11eb019406e3e1ef3586660c01680576b1f5f12dab78a594b584273f5639fbb3b53c3a016ede8a31dffa605eb0c12b8301fd6180d21b0edc304850d653c9993734a12df3283750e5dfaca36adb8073ad232f1c027e72accb17357aed11c7e72b1077b962e4ce72a30fe65db7fe99061f7951c4c8689417d888cc76be744996ce557c7ca862da227aa38bc824eb7340cd2edb861516e26ac2aa12734350dc6b277c4b3df29bcc5a0e2a12e881af7b68ec27cc02a1b3df8000134c0ab0ba9c979e895d717fe0b9dedcca01dc302a73956b0684ee915d988a15644bd987b8dfe2d97db0b3bfb89bd17deaacce64475afc34b325f3f1c4d203332ddc6ecb77a8906f0c00c753e4d45c9037b9d50959cc7d435717c506af78b588c3ed05a80d2c74f209031f1bdaa13f37449683b5fdbd47a11a413258dfcf6b933b14a80974b2a5e1117f93edcb5333d23ec76122a9c5defda8d153c7e7ad3c8a8cc85e746b61e4c9dbef6a6a7b0748af3e7ebc7828d76881aefdee6b70449c91f78de69cec18e34b760ada78b30d31e17450b164dcff632c16e50d18db3892767dd79ed5804abaa303dd70aac8c9c33a40f90eb71cb63eeec9b7c63ef9169cf0d366874938638daab6166023affaaa860c0c4b8742e2f3218161c15616e46ae6fdcb4a89bdfe3df9bc3cba08f8855abe078d4e2e612c32ed2091cf47b76f5496782d4597cfa106d9c1a76eef65f7389387cb9f68c9df9290fb799ceb17d2a7132be8bf91620c95392e0509aaef98b3139b71e767dfddb6f1f23863db0635b0168a9df5f2ffca4ed888cbf92d710f1c70ac48d805fb9313fb9aff79a3204365ba8387442b809c0fd3671faaa70182c3bdd992677bb8f408cd3b0fb4fa35bcc358b2de81fcb5e8a28f92779f45168dd89a4d52f897dbbbeb59e8f670dc3a85588ebd351cf5ff07df4c5105fba59525f2d0cbdd98f1d13edbd13b85c5bfc4c98738b4ee226cb3df7f915dc09fe91c38958058f32ce6acf5c13ab054791dd4f657e0e7ba428ed1a606bfd4a8906b9a331989f49c5629e1c63ddb7685dafcb494bc14962b89cea056f3ff25ebbe5d4510d02f1fa8d2edf3aea3a0ea24862a9d57cb5fcb912ea973a09abadb76898c8dd7fe7aa481d1cd8a5a273a944f5d6a9e8cbcb49698b614db493e2970beedfc9e1e43b712d287720edc098c1c1606b17e85949256978109fa8ae577bf5b3a4fce445f587f96a7af182019a95307995e1f6ec5f7b0216d85e3783eb4201949272defb099c5863ea6cfd50756d713c9d9aa87a3c4073d6403981e707e1135289336fa8bd0b7b917d5f705d001183730c3142ee6aa8f2cdb9fbd3a7694fffd55a10e23867e862d1abf20ccfd31e3b799993b657b0e4712d160cfe412481484d21d3d1c4bda1bf77471e65a92e4f9400f44014797e0c7711be724b057204c71647ce04f64ac9d288015aae361090941868ffd216ed6deaf2c1f5e125c97d83f99ffc09ce930f47a7ccd2ef2edc5f324659a38a097ba6b2b635d0d1ade85ae1d24a8fbf89b74d563b615d699ddd32417f11c56794ce00f8cc98a8862a0333b61530c1dfc37adaafcdb4d818dc47eeb25859c568ada78d4842decd48f0141a0c8416d55d23af2cb9818ea0c14fc5e8c99bd73d356541a9c103cf4563d679d12ee5985dacadd85c9b40635786ac2412b1fd9fcdb0163b53368cacc100b3529eefb0f75305284d8b1b374445268afa74ffced1759690771eeadc9e125f20f2f65a85f69e6246d0507d44fc227f0b4a4a0dd81cdd2466a87db695866b9d47e9c87783dbdb027c8e9fe845f24e21e13243e676e2180e9309871260291d48957978298c084fc7dc3b35274361c7244d69c5e686772fd882b0fb299a09db7089c87a007c393fac7be0a14f6950990f7fe64de7f393caf42d04adabd4a099be4e1b6b838782fded42262f4c7b61681e6754613cac98a2bf415d736c8d366712beba23a22b4c1835fd96139c4d013fcddce999154fda6606a0af509e5593254707c258a22613b1e1e73665e12b3ac6375ae0caa400e4674d88d75ca331ba77f28b125eb4e91de84794a33f594f96c1a8c98bac046bbda8f4617bcc3c35339c384d5e81813f4400c2d18387003f341cac900cec95c0468124574cdf924a4e005ab2140391f0d0853366e994fccde20e89a65e7e2d6f36d5eaec18691b323ab7ad28fee66d692771b90335a4adf5957d16bb489ac6a4cc2dc13a3c36311168c932d4502edd92b3107738e13884aee6c4fffa6fe54d9d04a1fe5e6202ee7c9061e41a77c8245a4a0bea3c09353419b5f8794f7bf9a7e62721a42b73409013503145f1411aa753e5bf1f2d27da364b39bbdf6374690f4e58894d790293108bc1c8322c031f062dd0874c835c258161c58a7697b74c452c031da55cde853b66b97352d30571456bf99cf197705612213d3a63441e0c68e4051bb6376b8580f34e51f0145c271277c3b151ec4a2ba054facd9408efe2176e24437466ac9f95ca0696a043ce7a105592f932bb3a91e4fb186d86f8161c323df579c3a7713e65858eaeb35eeb7f3c7ae9742ed3b9710c932ecb376c69b731448c934f28483f7a638ac56fab64d5d2a1a56c1aa46549fd11d9cccf7317a2835dd85d4e2d8f2491a86b50ac6c424c3ab02d2c44018c32f015aa88364eab734c43aca1348cb416423766207cd9771ee5fd0a214ba399a101b073c02b5f5d4ba34e171585d73b9c706c62f305cfe11f59d8813b23e89a187b6c74ea06156e0c8984afa2f4e53bf3349d1d867e12421af790303417105f7b2f50ef5b9e61a37bbac3fc31fce9547b1482ad494cc9839ac7a7142de3937cd6dd0229e52a33b530488ae10c1a3065792a36f2bbf49ff4fa72ccac2c2f5621e1f00284868e8eb46ed7aaf76548508c09b7ad5edcfac9a366c39559e8237219b1cc2845787bed749db6982c74f1cc3981372e557d523c53dd74e182d68bc3786a7ea630e73b67412f274c6bb09959d115bf00170a41b842b6f55e9a0fb627144de6df3c85a4f3cdb085e697486dcc325a9d48ec8ed5d758cd99d0fb65b32d050f57a88c6f51762131311962cc76fc8e3828f7303e44b388341a93315f336f157d30639bdac24c08ad3dd49870f02dbbd3cc5115166789ae698868a79ac60a5ff96ca76c2a993bb492798215387eb5f168db9dd10caf4df3fea49147be2b0af15bc5e58d49c01d5c0af724315248a57404cb45cd66f861e8561c31655480103106b4d14b91d5160d9a5e4cfbf4a7a22c06e54c2bb634c7a17096952264c7b29353c0b27c2e894bdbd7634df31f6e7e377cf0e80d134fa6169b2daf534f37979ad4411b0fbbbda3ce2242a816af4811d87d12f643a72232eee0f2ca6b0421f1389f35b80b3a14b82ee8cb91dec9fa01848156326983a2eae04ec3dd9706113286cbf56fdccf1fdffbe6cf676e98930ac593a9b820137194443a61293f51862f61000b2f896a86057bb0351a6dec09f7e3e2a102fee9992d55332f682710af438dab6193a7655f9dc769c1eddd0e57aee5ae442a387dd0fc308ca322135900a03ecbb5be960c3a93c575dbc9527cf94cba6973fe7f42d4e0ed15ee2fc9a72ae1da9fcb1b297091bb187154f13a0136dc40151a83f6245af8fc68aca08609cc30521bdefa878d83f41d7d782b047ddeb74418338e6247828e016535e1e98e5fbf3f95367bb02790d43ca8a4b8c62b86730938c273c88f2d50dc8cb80537ecf9ce33bccb68f1324bb37172841c9e4daec58e2d757e94de6f6af0470eb1c5cb97337c69806d104c15403e07b2ad57362d640aa32229d4a41d913464c85bb7162fa976e31777910d7db0a8a47eb46dc350eec29c5c9691ca530584ca9671eb177452e1b669f63dd80e437d93c130420f520a4bccb93acf7032b987594b75281ed9b17e13c5b8cf9f0333132d22df06a5eb48a6609dd68dc7fd91c3d871159ca258e54039dfe3785d93cfa466bfa72eb0edaa52e62c3d25ad05f5e21b44d7d82966572524c82bd98c7cc34c37900f887a53b284e5f1dd1b42a4926e66f8632c9cf7f85515e7e7dcd589b18577f678ba2f82cba2ba6f2a0e01e7a59c8bced76f070ea05601655e9574e652cc4faad1d751c53c5faa9e6960398ab8a7726c7d297e6fc0ce644c57746eb0383a942581507db62479b7a7034beab66f3afa798574ac36e47d8de7306cab96348eadf5730cd453c03581c24c84baac60cb1e1e3e95b1a29c122e7a46b1c27819713c89a69f6fcfcce3fb82fadd66d0afcca209b63847bdc9d496cd7fafab85255afef484b5141d01e4306cfb0bbe66b992cb24ec3430faef3451484b3f152460fb4cf0ad268b39ac45d49e33696e52310ed36896a1b62f4b025b992c74d8ce55b09a1612aee007a7202fdafe575becbed950c2faf6832ae7b3669a900746f569408bd7657cbbaef4f91ae1cd3c8261cdd41bbab1b973c49e715b6ba687b0fb3a308b1642f7370da8fb694f17d1252ed389b7964ee7af18274f328da5bc07b32e2f2668914c7aee1fdf2c0b9c36ca653629d946a157db824c1e480f8dd2e886e9017bd216328121c8dac3ea31f695dc290f16dc72498a684b4ee9d84b598595d79c8fba310d140a377e10d70f9eb638e8c5bf126094d86243ce185b854a65c1a13065ec04d5ed8d4cdbecb85920710ea9b00550ddd66b28e0ac31b127878172076b053c72efb5dea9e95f87e334277101e434984b4853f4f4ebf3224290a16d8cfb0661d3930e26530e8c1e6cb201367514ff8d513e5d21fe06091b5b0f485c85e605459a5a6a96877cd61b889b30c8f7f339fa74a3831b855afb6781694d5e5daa1890ae94cb58b7314ea37f403e7737e18838f5afc1ec59ce133beaee0c1c55fe5b7be47e49abea8875a050b2705b20d600a4fd93d4c7d06b7b8bea0ab35be7ddc8f75dafcb7e1d173a0f30969d01128721431781d19089436691b72996789c47f49e28d86089209c2b63a0a13e0799af6f0d40131d70945f6aba8253d42ab77160dd6ae951f35f5120c2bc01cf5571741be13a9d559fab301ce088a38472e42b7eb441effecbfe2ff042a7fa277f0795e7fe7fc75987ca3fa2f4be42295c9e64bc94c3134d1c475c6d6cbc4089b7cbcb0b175cf20b42772b899893e11b975b2a42e6ff1c7e0506192d6e284611358bee1818f955eca0cf52797e983e1578e78d01c5df639cdc810023344f5219c9842c64af98d6e53df05fd46baea78988c84727a3be49b23227649ae17d7b5fe456fe4d83243016fb93e6acac042b5f3dfdaff6c254970fd0a46647afedcedfad99cd1ed517fd79869d845c562b9db49f1f78d6d3ffe9d11ab98e1fb3a4cea03db92831d9c8e1a397a3adc4eac4c4a794dac362ddeaf857c648f9b2893f3b7a1b2ee06b8a864124686e36408d9769416ee5c9f5883903b71a7fa8561ce49cbed850fa26c4c86ca15ebe89fc44bbb0cc0f6bd437dd605c81abe22900b96fe5c2dab8fc8bb149aeeb7ad394d0998cee17c050bb4ab1ae0f8cd7e509b05419e211273f94db4332cf59e0537f86bd6372852e68492029cf161c71b09009c2acf728ffda9ef72b242e19d447f0cdfbec311cb61604c76993191fbcc317c64a9b6476d0cb28cc2f54754ce40719b7e9ebd81936974fcf049b8c055e18630a15766d4ec4eae5f3ef216630e2060e2ac262e8a31785ada6fb6e4a24241ca65b816084b70ef6f42058de4a83920ed5f686d056f70778ca769e7ce9227cfb559712751454cab05de4deea50a5c9c93f9ba2d6ba896df1cb3b570099eedc2fff4cbdecf8cacce84a561eff62ed3f659243dc8c6affa7f66b4fec2274c3e1cabd3d75d9f0be6eb2fadd8af6e4f403c0c141d78ad4e9f62d57b09416276c29d62c45e47c214355dac1b2d2d1ca0f7ba239c7afc4f5c49aa83e67d91ff8e2b56de6831c8341cad1e837f49acb88109af43d56f1f90f2aac64f6180ccf8481f346f343960411c70cc454eddfec8f0e365fc6ddc9b1a771f5ad826b027ee79576981cfce197faa25ed5aa31caec5705d06a0fa6ccf046615280feb91f44e3927bf3351fce87d8f8874dfdda120064ea90012b67073b4c26bb585053384d01c7a9f6e85f5a35a6b1927da959c92eee36cdd88eaa7a4d45167e420863d09101eaaa79b88ae51a02a1922e1684cb3cfdca775d16a8c9b9744fd973a26e0af12dfa694507ce6827e278d9f3e92614d3f803818fa1d67f5d7f92702718f3d8bfe439dae08fcc935f6cd136203552a0cf1315389c5c590e6011ea0db4bd3f323e171ed72afd048838e80e617f155045eacb007beff615e44ae2d12ab9eebd42addad5ad09195cf624d84dea79146ab4e875f06214be4ba50395d528a15bdc75328f19147bdd32938d75c5b72227edc5ccda78e9be80140ad1a4393368295bdd33711094b36a0fc775c5ef97cdd9663d2bbd2aeafbd11b9489751213d71de1556541473a9fef99b4c582d34cd879bef7df72cc9a30031d76b65b05ee095568ae52564ccf26ac9c940cb4afcf6c82d69d80a525920bbf136701d4954629a428047a0099577fd31e1cebdf6d4f6d67ba2f2aa91f61028d3a8cb7b78ced1bc8f7b84ebe583850394bd444a05e4fc5f8924185e3dd463e1751d7d875fc757903f5773ed48b695e690424d6d47e945c3433ccffd7284ee69d9c35b59124293c6fae1d68aee27b927adff1dbe97e8f302dcd9e127d4a83bfe8a5811e86ab3ed61bb8463b9ba0a9ebf709d5a7b19bd6e18d7b46429f47cf6afa40c72a2069b85736f03d96fe9655985371e3d497a89159d39736882cfb8fd4524b018ce7dce48ad4b06effd14dc3eea18296fbc76f8d27485911ed4373791e7aedf134fb1f20fbac288139c6b08ecbafed87907781c0feed2647554756b38dae337b98f46f493c9243df67f9635f817a2a9b1baf16f06450af11433f515815f6adc13708822df28410c9c18d2f91ce2ad3dc17c3f14d1fb5a6afcd7081de8e2aacc5a0300c7e541b579dbac9f5b7fbf715b11485b01a95f7a2cf9c1c4a6bb29638aff37c0ac5c4a95100b03e3c61fac0419cd243ef519897ea1e8ec44aa0674992a5d09fd33accafdc8e977a4ae837ade84188f01454f6de2696a7db0a78e65c1c4a2fff051e620aac080bdfdd20a16af5233a8ec5e51b36e2682696a6977d038d1d082761a5fcb515","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
