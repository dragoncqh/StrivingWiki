<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1cb8836e5dd67ec78b7bb06b66f4656c9374de9cc567db21941e3e9a9b881d637bda1aa9eadd311e603aa25481d0b5c5eec0c1e2d66d1af3263fd3409f4719f6e58cd90fa3738d9b51d9e84abdb4e9793bc2817225b9a4502def4c7f7076fa880a7de9e1761e860354582a31e4475918f0674e1aa50fbf2d54c89c8a4c7155944a54ad4627adfdae9600e215ed7ec76cb8d51fa418cc86da342f9d2412f670d281155c48836b484e6ba053df3c1ee3974f9e0ec94929a4d252468853daac6e9d94b3e41bdf545b448da103e3def9bc1b402ad930c942fd17de3e720437e7254296182b35d894c72f41b981c47b71918fba53be7995074b75ee43b7275d24d83a2022f551776de553b185cbf4950125a4714a620ab62fcfa45316ba6860b6f79a15307d576c93d5198d0507d4aadddad2b2a55ae5badbbefbc2f37b2f516693653b39b91badeb5fd4c7c4e0c26e93bb6b597c52256b5fcd32da07d92d0020b6b7619dc43def32cfa27de205bd8d4ef01eef8af5c0a1a5aae06cef2859db717e67d1bd077253097d469c747073e9d38f99d04e2358d4a89f645ca4c956a00b9b8f2ad18ee3b9d0a6165e767b52204c2d2dec5f5f7dc0bae66c4a9c2fe779b24e063f96945f67b2b872efd6939dc9b36185beb68ee8227f288705f84f44e3ae78b883857dbba3676e131ec916d7226b1196517537f3c99f03bf09fff403b6e3e8e107b625a195cf4ae5d56a28fbdfddaafca1b3d8d954f58c0895f0a4e694def8d91c5c697181ad048771adf8a59e1271835ae08fed460bf8d072447a9b840d14b96bd7cac72dc532da5c7cd3688a12bead902aee18468fa2d3f5dddc2f0ab96f26e918839caab9580c22fa56aef3392385e237bd377877d64c6f8e7413048c9e0dbe64502cd57e9d717086e870b45661133b9b5917c19a98d73b1313a03a847f943111577b2fe0991787e16cd8c935db9f0ad25aadf1cceb918e89100ca4e626eaeced460a8bf2f36aae0f90116a5df6fe738971cd2ad941b24400581149f4d230623621a7f71b9f850518c5f7c015062f107e4fba12acfec6f57867443ec6b9adcfb945c76df664e631f239720cdc9eaddc9efa91a97c6c124e29fcd072c73e667b1c22b125c3cbd48d92afa50e17167265aaeb1959b62741f79fc3a7ceb67d00989f3bce83172eaea21ebccd8b32d06bf3aa7c21c53cdde29395cd4bace9f7d14daf1046d62fe59349a92e09be74f274ad949e28bef4f37dfa52d6dc4907f5c5dd01a8791d34a235d12674da004b4fc6a953159a4740a9be4b6b00c910c4eba7ba528cecc22a7d6d4f1e7ca0efc8cd664a533d47a9a8a9b6fb6f3d2187de5c367c2197f91d366dbdf069218c2e2f56e6888246ecb81374c7b2efaa30be37dacee3bd4ca33c756822cf1f369b189f12043bbbe0353a9c7d33e57f36443a9591887d5628139f272ec4c2116504c367c7467530fbec8d3f1d8fbdfbaaf4dc6772404bd458787009bca82d5ec36e1c10be8b5d385b22b6cb99a05885a75ac661e03a0a06cd24b8ce412b88899730932be0439d247ae063b96137a05e7ad79bdb4fb67c1073820f1db634182871a63289b60c9d516899db885a5d8113d397772dfd53484df6b29fde8e1b2e7dcdb4f88e46b0cd42fc37a0aa184766090816bb331d19bebe2f6db16ccda08ea21232e29888c82ed0e472abb120e6326daabc5bc4672b1e569a0d7695ea0cb576911317f30acb0f601ba63316172ef251e325c3740603716d6da6132c6c09a1ee45b5636237d294b2b37b0796ea077a654f57df2486e7091e5db055bcab29e081dbc5d1c01331ff7a4065420f68c029b41edfad9b3e11263a0cae12c6682115a3ce3fe0eeebe088a4f7d719456eb2e256636c2b6a5d24b214e3de87da9a7647e46278331864d6cd0cd378e34001ffecae8c3c3f1f7ec80ba0da0c51fbddbe439069b686eeb585100afb44529965f4ff9078587be45365289945aad5d7e46b0047d5ac89370b6ce2ab17fa3ebcba0f91b71eb3ddee3afa831dcc457a7acc24833154244bf827e575240c2faf98fa27ae48da0ab321be7bb1528e06985be27d9f756255ac2a7fc0edb79a1d2d96c8b41fd59a5bd9370d02c8babe0b265b5e3bd18711f2c8866bc89316a05dcc32ed782838c8dd2c4896f32cc24f189a5aeaf2693af603bb0f8e914ae57780b39f98fc24069513d3a38c88b4ed4b6cf1f1efd3b8ef47f141b0b5167a5c7dd72014bcce338768a322e87e010b6537942fbe373b8d5829b5dd4d1b3f7e1e54fe4ba01c7203e6605e3f205274b64359e33cc459c13daadfc7960adf831d6c81bfc060907bad33be977f97034542700fb06a8087c9bba9c143642f26c517824314c7a6ed2ea1a49f9f8d0fcfb541414caba83f42005c486aea00e00b6065125e86d62ae01b2182003fa22205ca7e24ae0ce84a663fdd1efb7f213136ef7bf99c12aa16a1517f6255cbc4034e4d00822b51735450ddb067e96080b6816b99ef02098b887b153a4f19024b85fb1103424531a0b0dda55596b871d3e32659fb5a754439ada85a749fb3b9f83ff6b187bd9fabb0914f73156889003619553b6e58ba8ea3659aee16558917e064bcb02d4e02c0df4cc9f6a2b828d9f4bdbf472e237516954f4114be19ffcd9e7ff016023200a736fb3c1eccc948a97499987accc559338d903ab7d5fde06e138aa4c9b339e0f199a5ac3a92d9bdbfea3a71698855d525b5291b5d3cddb3a602b03d5d0bd105026d8d11ea0dab1a9a7d6bc3691cb056077198f95fa47067ad5d9ea1591e6e97b7eeae3f1376f7784faaada7564ffbd74cd4563c84b722eab960bae99df03c530954bc0351f7835fa155ff641777c29e9bcac43862aa6be3cfc2e41653a957fe048c4932ebf3b4e1f76c8387d66af41ff8cf4f06fee108fc8c21e6d9190a9e662b6df664334dcf9e348cb19268653ed35a21a29f06774e98ef1ca0ec5a8f73048aa4b7282964b1848f19b5a55163a0501c4dfa640bd49e5f7d658498effaf98877616ba58c2a66c8d1d5d41ceeb699070bf81e1450b073d459a4328f3df781518e46a7a4337a380b394c58afea3e6b89ad698163a21b2905bf44df686e856744d671a4d5c7493fc56233be6cce0218dfec447bbdf99832fbb0a91c05bedcc7b957af6f324342cffc4db0983d43d973aedd255cdd3947ef82e08906dfd993009d7f160863273286a942606b5436fe793825a692b554b8a621e768229ba8857e41efb6a820fcafa3d61c9b4c23b670fccf8b061c7b27f6d47d21c3f9a18f032a82de5eea8e286a5befaf2ea558d63e82d8d27f081d396de445e7fde2f1d157e3dfeb2b1243d2e0ed60a6f42eb53c7753ea0e1cb7ea7e179c9b1477991486b3efe2249a7fc2546ef9cd36f3c58c935a629fcb7c2e636a7b9620a5d830f354a7146e911c50f7d2c46bf6fdf2b3a5471d92c52c3b947c304dc01bc2d6c3ce76109046ee79aa6c02431c7c77dbaae35e2789df4425d4919b497be4e9496ff0e54bee1ab750ea238c19d9b1a4d11d5eb9507b1d440b8578067da19523d979de00087ee25a5916ec52d2e42e12c3fe5bb342a450d01b4ebd989a5b0f9fda5255ba745b7d60abdc66746d3ab2bb6529c1f2bad8a09a5c016e7db38758f4a86103cf306f9254c7d1d0a91a6b904fda4d06686d2c140423ac1c4eecaa215d41380a74c9f39b93f09de0c7fda9fd92d0fdc39b3d933122fb7edfbb69d712647dff6505f34020588f67742a47db13032a27a5678fc1f96f5e581ef33e67a948c743097cd05b3a91f92d8dfc52689757df8e86aa125f6dcaa155f01b920e3e3a8b21e88d184a90fd712b37097efd4469dca2d0ecc3974c6f95125789c319cd894764e4cfe8b5a230651b1526efde4a8f84cbabded28d00b3a7e93abe2e1c5ef02351deb36464031216844599d0b7d6847626527c341a33f36bd7b497ce6cfb4550a2b0f98d030798f4f841ee86d75ec51f4826655dfa0335146f593bee162ba1956f0eec752842317d8604c48605383d4a7401acaf68d19d4f2dca456732b2d412d61c40537bec10ce529465396f8a1181a278fb1e73e26f224e2619a1b7995ddeb1254812fa2078cf01e019c53f26020e877850263ab166ef7417e1b6dced03fcbc08b0a7aa88f1b494881f9bb0f3e1ca2ff6ba62e3d0339171fd69cc2512e5b02b2b45bda168089e1ac6fc7b80ae51d3b53064c289644885daf9bf12d7918fdf4adfa7f7f9f30af6acc320066b262ed9253dabd084030a1a97aa3624c0140b798ba2617edf7661b001d5fdb2c8dfe3accefe009e7883a6caf80f499e3fd2817ec96919f0976e6c8bf1d1d0811794755c85af66d047341f8deeb17a3cbfdf633b02b26f9ca1e7c1241ee446d8766023856667d1d027e170b0b64a4bc60e0dfd1a497fb179672dc46dd596b8eacf3aa8cba473889c072e070673803f784656b147c60db70d7c6f0742dcfbed9afe67cb6d2d0bec7735629995a7dd9a7061d25b7a982f617c467139441d6f35f89f50ef2f4048ff99797f52dbc8391fd947a850c4d0773010c2dd0a9c923db5b038f0396912c30a2aa803a108c6d824120cb3a6ac49a9895954f0924721f1dabe8313014d2b50dbc998634f8c9dad98f42c320ba0f9afe24d04c38899a4614260c63772a3f4af94affe6c47330716af87a283ea813a83af15f21a377ce7368ee287c0638aed660d5250432180f2f056f480ca3ac97fd0da280ae2680ba34ee19d66f7c919b4f44104ba65f7688178412af76a9c0aa09f14b1a30ac48c91614a20dcdf3a87b92cdbe270b8abe3c21c8d9e5fa616d5d82ab877ba6d95107251dfb9373c217ae68dc62a046435b64ba89393dca73e782f8c208abcb8ed9c48e9a1e41df1a8192523783304a90c0d279ee2d3365eb2548cde2652c11c730a68885ca85988fb92b6281d3fb3f7fc9241cfcfddbea383b036c6a34ce9903b67a7ea94de7425b880c7212b094cd5e3d766574f791a22e4db020645b5c9ac434ef8f139427c6151c56ba2f8fec41a9b94ac9f1c1fb9efae33d9eb4ce0879974c71422d053cd5f9445eee9e650269f25b677f471721e298638865a05a2eef34543156f9126b4e48b921b5f044da6803d2b15074e525df746f24a3b925c071161cda5fa72cc30009e186a15ee6c8b16f9eb71a2c6a12344b3daa438a40ea72f0630c86dde81524207ede43f96a6f63f4a03898cdc04499042da878ddc5b3b6b7484ac1ddfb49ef213c88570d1e886f069959df95372f934d7b43b93b3265775c52fcc94141d407fd9a8aa2bbe07f87a0154c58f33579905b46c53742616b640b6dca02481f80eab04046a1a2520372ad942325e84cf1273b7a32f39d4b7f6ad3c6189557563408538d5b296b59612e56054e0442086f8dceb12722bf277351c0287c0cc3481da55b8642fed38dd39bc7eaadb252e1d9eeab038fe85439e107ec1340f6a184436eb65c6302b31d40db4d5c61ce1d1ed3b7eb1ef113f711f383406fa498fe2a9445f1b5428b053b24722c594011fe0e0d9c47bf395243732a1c0a66c332ebfbb38b44ba138ebf96ad1ba5399b04d600962af34ed390d25d3604ca4f89d424fb865260cac00efd2e7169757d379ed9ce325dc0982dc19f3f4ef041ea67e0404b7ea2fafdd9a8bf579e8ab463d74bba015464122dcbdcdbfa8779ae2c0c7c653f619b465bacb57144a48a7716bf6a3c3274899ec5c2130f2fddb0887120b22235b5527f2041382b33cab1e7a7f9ecbb384eac6468a384f2190ecbbe3b4195f993ae3b145f93ac9a58436c6d7ce14d327949d10d76e2e7c385b719abcdc635db2e697d231a0fa9aa7e54d3d0d10c02070048ef755734a5dfd8ac5454bc9ff29fbc8679c7cf55b14c8fc473b35434d03aed744c7a1f82b1a5260d05b2dc4f974c84dd3203edad3e9c2d17514947598b650d51b4f766d81dd0b04cfa1c824de6fbc4be4a9f359ad3c6c2bdf13a458154afff3357397eb3de084dfba16c7d380146a3d99c6129ab535485d0c53367f470c2cae34dc947aa3d7e4b81d277f5d7f3f048f1bfdc2578ca82d25426f99314e0f7f65f31c24d1b62f7de7d6031b853d81dd8b4dbcbc31d98f255b78029ed6477d874616de34e201fedd89dbeae275be41493069fefeac71d69ad1147f7a3d416ec8250198d15b44d954c3eacc5e51d781fde3fcf298c4ad0249d2f061075e63048a1048460699a2884c6f364bce5c1d0422c51bb3dbe417c455838d4b2a0dde3b76be9c649bbdd4b8c68878fd993e5d2dd6432c023635a9a2ac4a5a6be424d282d6c644a8487be12704b7c79ba57eb16f88dccbad5e404a9d26c5f6817f4bf87fdd95c85aff42133cb41ceb627f4590c29536596b51a14acb1ccbb45d4af44dd9df63ca8657410dfd928a70ad445c5fe921e8893a8d1546ebfc0f486073ff2ba3c7a543f4340b7700d966e2ba493f814aaecf33144f92bbb76fe843fdc0dfdbf2c8984d5d8d37d21c0d85f4cfc9a9e7d55fdfd2ce6457106e570ca7a45894776c972e6e2c08ae62c45f7123a0c5f27485cc32bfb12fcb2acf527c502a172e20d05f52480b15fc60953fe9e2cac8a5c561eeb2f0f9d01e912798bc6e75e02d39b38296ab5eeff71610e8820cf0fe9939a35738dd9a157613a359e2a2cbdef3d50dd7b3af2dbc7571d8c5f1e8fe67dc170397febc3d48d49f2b295ecf55a7acdeffdab4587394a3031d0e83d13efde57416dda527b52c596ad9f62fd75c0b4ef4ec948e409191c75947404c6bc75ac4314a4224df477b81fead75502a734dfeeb2154fc70756f2bc6a8a6a03cc0182d97795eedf581f86aad01ac56609714db7430508f5e5aa476c03471617b2fc4c254bce33c3622f861a6801f078b2af1f05255f388ebe171b10275f0bbd1f61b2edf86109ed26ed9d9e06facaf6ab11c6dd4942c7eb5d7ef53324f383f6b4c930ec5e8e261c01b4e2fa03ba9b07daf37a8871d22f2e13631866eec7e81afa128ff3f53ad958d77800cbc29b7bbd6ba75368329e48e495ead2fb7478f8b100efe99b8509be4550ed1c66410e90e12f7771706428f963f1f2827ecf17d8e6acf3df7c3bbb874527284add5875ef33fe806601a46ee322e6e2c1ad1d1b99f22f78e24e49f54eeada3928a23295d532b10e95628cdbd2377b7bbaabf148bd2fe2368ee87d55216332bf889a04ec9eeb3caf0c02f7af8c76609b7b7bc4ba712aae9d4c5558cfa4d841316d3f6eda837410f873e65d35db625b8cd41b1d4eddef7202a410b50e08773d7c134be709e2371fae5d8e0a52b314efa091be1e5ab625af32d72d05573320a4e8a4557374ef6608fc15d24d49730e38bc44494644df28f533725d5c256e3530f449ecbd27bd2a50cceeb1a9be297ed85b072f6d3545f54fedeae94a97870c424462753782c97029290e932c6adf1a04845d40d49c354c1426a3dadc5dd04d4322b06f12311827ed23abe266a35d8def4597d87e488aa658680f5fa6c5beae73922156bd520a703562135e12f24e6b3bfc74242bf3e1f4ed0318f3bdfb269933ef6fd6fead4051c4f217afef05bb52c0d3fb004a4d1e2114af4c285ac09391f0a99e3930c36409df812964b3fff89354bc49066c536ce073055bd37ea3b9131fc27ea5f183b9e1645897ce8f2b1283e3eba78d822593bc13296b3fd5a1c5763e4eaf03db4ca7b33023c0090b4b30883a71f851f0e0207416b6286136f051c3ff333bd0964473d58222fad8041a6d92e0f67f7d15ba274c0e809ab77156fa478bb0205921cba994463cd48a26535e93d3cf315505d6655cf87ef890c1114b138d2f05f480cf7b9b6021317684244145aab07d1bd4166003b602c2f690d1b5de48c242e4628636355c6ce45a1afa58c149ef300dc4d791f126fe52e086e692725a32bdb78a6c0b7dac178eabcaf3fe93b8d72f88ede0efd5471034de9f30dfc8abd94e7b7aa7764fc8ac681b558b4bb2de86d94a5d9405af50e9ba7f8716ff3403b84d2e72cedb6fcd75f4f4213251b25adadeee349d15c512617390d3b40e87eb98ae7ecf94cac0b1436ba993e5ac68cf45031c43ce8d2a19bbbeb95c23ceeb6d9f7517f9a40b66db0d8f0bd355c5bf3eb2a651da7e7a858a09f8a8353ae09035cae7f4ee5b9cd7e014324bdb077dc45464838bd511b4627b9d0246a1848b830f7572ad63c583cdc3100f662b941462abc758cf2009b0a7575150d1ceda8248fe7eee6b467a4e91fe0b030f76523d6209453e0813a3148ad71539758553bece48980a52f3544b7e7b0c12e6128c6dab839e95e006577e10665f3881abd198cb3163de883fdc8d762f8b3edf2ea58a24c1b6e57d04720badfad65d7b862ea2bca5610c2732cf647a2a449d54bbc50540918b307ca1b72d328ea0867ca20eff2dafbf40288ea70629d5bfe691bfd6b6d95c120d753fa4e16ee7f935f70433591d21113707f6a09aa4e4286090547a0c9eb0059014d296f2b5a141ab38dd1db6386172d29bfdc6de0ffa882980fd4c35964e5f054f7eb53b9949c7de8d8072a0d4db42fd22d764a8533617f9f4146f2480405ba69179dd06122c00c04899c6997130d1562122cf02b5a6751f8e0850ebaf973ba561f39eecab17f2e1f26309055bdfdfac8178c61cafef7aec041e1b62444c602111eb493097870dfa4b5599f472889349a2b61a6ccb45101e035cd20f68b4c441017592cc6625ce8016c9ab0ca982eca3ffb29259b3ebc489ce79f5970a460f41f450002a3f5ec931000783e8c57657220399ac352b5d0b20777d8b78c271f610c45aaf8262545f524cdb43b3f14e88f4d1f7d70927425d4cd0704aa1e277fe665d93a8fbe8378dbd672f3db3464b0b41bc6a1b23b192d3217b672b8cd6b2bdef7254a11b200469cc15eba08455541cec7c0ca3e658e866abd9407be2ffe2b6063efd9735603bdaa7259b1e3c040616b750bf672b68128161175d6c89c3c95981ca950a9873738df58d9469bcfb34e4018b73b6e8ef046848fa82530d8d14e3e29c3f5ddca35f8e37076d88f7727b7281feef521606a0f6e2667f834ac6650ee4133e045a4997732798e9b79a97fd68f9435691aa9af06e2a2294e164a31beb0b28795f82a07f0380fdcf0bd564eb90670c3e563c757f46538b17da840f4e312fa81356bbe75de9358b8510f509144f53f1ce9cbd93dbb6245bad2fea30e2229fb3b87e917d82727bebd1a9646d5eec58259c61f3b938b2a06d4a2974d1e2a3dc2c64f8d2d48414e9e3f123cb51dc477b96fce31a989d7dc97d0cdc17efdbbdb34633a0258515cbf70e2f98ff538cbff3d3ca32fe7f8e887be2d5602fde0d4a6741a4ca1413562308075ba674a0f0deea55e18c22e19453294e0b80242e0006d093caf9a871422e0d9a102c8aabec8b4f7cb8ef72d0e024b7c9d0e23055572470e28e3cafbc5a14f7dc74841454b83abce621552f1b9b31b3d410f3747916256d0f49a70b282dade8172ce8f8b094778411bb52f5cab37c242877b1c8acea6c18bd33853dc9f40486b99f62d6777884fe73b6d3bd8c13f47dca79536e1837655dea428bfd915132527ef943821badec1c4f6f89f170ce4971c6778f3ce49b6a4c1b5557ccde3e2dca8ed0116b91ef1fc031d1646e08ea943419d83dd74e0237632dbe2075ea16b15638127b87787da6364cb867c8b2ed9dc821646ef01ac35ba745cd80e0087111aae5fbfdc5ee777dd3e58be9b5c200e2a6e7bbd23d3657276fb0c60ce6598bceba16c6b9a4430828136b72a2d4456c6e09bd64ea61778762a32800da9e6452f5eba5d2869154737a602df9c4021c2969f706753c9d9dde8bc217fa5822c9011a402900a745dda208b8eee71ddb705fd8f2115a1b3cfbe0acb8d4d7d0f25ed51c61fa7c9bb3586665dc758974118fa46153d967d65659c70eac5d40b4685a5d0687917ae112442ddb9836343f01313e1f86e6e9eeae786f21506c65d5cb5eab6b0f87227c85fc87c5f42b71e37c6ac9545a0017e820ccff0fe1ec6a2bf82a980411ce7f90c6ec2f2ee4d96fd30cbb42a7015e32e8e960562605ca584a5780e9f5ab1c1e7ab75fe4dab3daa9079deaee510ede0696c59c8013e43b27aea6addba34dbeebc2f41cb97d1c77145155ef21ce4d508e6fcd87bdf89c4a993a7d268cc1826b017f761ed2d443bdd7c5727623be889cc0cf8e4ae013b21bd5c30b078dfb8c4d69469fa66203e55c6547abafc6a46a01e932f31b2b28614aebfeed9b5337733ee1cd5d45035db9864fac589b795be9e738c3703c2f53f99b387636fe06f2be903f0acf65d233e314d866ab2b5d908afd208094154626e41e003b4ecb887628e20859d83120ee6d3a692130b5e40bd077cf7ec7cff627dcf8f0b0da56f48a01ec4506b2e93867f550a975a41230053af16ee36c0490aa8e6154bb0fc4210ceebeb3b379b9eba2ea8a7a176b7c7ee0b8e72229dfbe4c7ecbe33a948061ff93b2bbe26a14bc3e95d4782ac1d7148307c09f289d64146887af3e22bcc47dfc1ccb7aa0c0074ac538389da144bb1a2c203d72842a7a374bc5e396d8489c1224df50b80a18146f5cbc598724275892e9d3e6f94592a94d227660584f905e1c35881031674be15a11b40e434d617fb055e36a69492b31178a23fbb3290432ff58208230c3fe6b29d5b2506cfef25d34487390412fcc245e8c3592f8ef0b2fcf7eeb70ca15fd114f73b2b9c2ce4d8c1b1639fbd8e3ee91d69deaad09b4e6de73cc775675d9c4368cd76da5979f11ec9476f2a728ea3c9152224a4b05d4ad13bb586d3bfcde052fbc974a85e3a5afbc978da3196bf2a6bc11ad446224d91c7154340951f404dd5ed41ef2363630734c92d2deed9b2d61eddaecd48ffd1381eaa5012bfbb69e42b83146c0a4a7ded9b8c57a3b99c4d6b20d89b29e2d7dd7372e12f26d6e2362c47b9ccdc545a80d2250964b00d66940737d5ae55a600878ddf5e29fa938191ce19b8cd6c64676bdf6c852eb298e921c556ac758cab2664cd79c8f416f0b46d8999e97f4d87739f3fceac1b5024186613b6a843bbdcbd4ad2e1fcb3e14f686defd74960feefc68e529fdd8ebe3eba84236d0bbe64f9fb61e0bf976772f8b9416ce8482a6cba81e051417c8fddc6d660baa243d6c672732d34fa3afcf1c13d03d4ea4be4e266038edd77b96b6ee806ff954de3037f6eb10c3131e689b5f5c9cfacf9220c504e5ad4e1d1c85c901621cd512d247134a225dfba4b9a09a087fa5dd8c467b4334473d8e3e3884b6df399ceebfacac0603b117143a27032732b605bc00056efa363e8dc92922804c0964bc5f4a176bf93eaa99e42aaa7bb18fc16181c0ba25cb291e9ed15063235ac99393a32842b4c208294ab702be1d69e0d4569373ba0ba58889705118eae6d70d20d806cc682400a8acd2799df0cb2c42c03642500f75df3e8b9e04e7190f1744098b555474df852a0e5ba67c19da494d400cd881797ef04e21b239427674d771b752e7f254b72730502d5a8402a46d8d2914471629ea21ecf3d5accdda20d057b910d26aab15b05dd735262baa055a7a28ef92f17d8ad6db57719b01f736dd570f1428cdedcd3ae731cb19bdc5a7ca762c20222ab66ffa6fbdc4ced114fbce221700da88c6b551e80fd130544650f2d9efe6a40ad75abb5b669f02e3a48c28cef8e1c7bfe277c17d62b73d4a54253cebc29e4d239cfac668b0635f8699d82c810c4db2cda9665b0e3ba0903d6fd12e8071d2653b1a49129e855770afc153bcf847dfa9c0241cbf7aab2f228e19bc274d05f776864150bf2349dd92f34376b996bd027b9f0cc4a03eed0112e21a811eaf5898a76f2123e770eda9eef077619ab92b0227ce6929fadce37fe6bbaacf5bfed41e8cf76b8959f2488746f7b700be58fa3ab1b1a2bba72d6c462d8141fc77851cd892e587c5c168e06d47d651d4bc470f112979b1263f333d4f6c16ea55ea1717cbd431c0b1081c000f1ef47cc713a9a446421bc2286d3c5fff3230e2e9cb399263b073e85e794fb49267cdcdcea799d37ea18dc87c41b55a491e7297b959e6491b81726a2c35db61ec3e9994d7d53c1e09f3f9208f118f1369fa1db0b5668af10d7e6c36fab2a4ce9c730750b1bcaa595a340bab003ebb004a3cfa7506f23661046498c07f94cb05bade8afbeba4aff29a98bb67bfda899c87a17d32f12bc5f6a11c7a7317c2fdc3f3b1777670e1e98383ee2667d8a3c63f683d7c151358a79a1cc16fad3abc9de474f3f81e0f8aa3226964b317d1c1c253245b21b07c068a232f43e178064b8c976f5b8792425532ef55700d983b46186680eab4675ce672222646fe87b9342c226a040ed459b590df300e0818f2f195976b0bebf6dcf21dc3259833a46a417eba040d481e36156deb01a5bcd02a49999215774d25077079c384b26067576f7b2f68b6fcb669e0f8420db561f64cbe4188e29a307c9a93964b9c8fe8a5b65e80650d136341445ca4814062ededf055ff11b541994042c1dff2ec671021c4ee9e1301d924745f4d3daf456ef74d1ff45a5f6e90f41d8efd5ca610d45d7376f1ee2e30582c313d3a74c7d3c916dd328d4d107fedd3ccbb67eda77d78b90eb2b175e5a45685fbd2db55a715165a44b75715e315a17b32839351342ff0e32acaea731d6f57a99ac575d40467a31f712e24f39b45cdf3843dc88503e5c29113146d22ded22d3d7cf5da76c0de75cf46a27ad0dac6ddd9e0efd7943e85e6a347af5dcc6e269798a01beb41d06a241fc5ea10ce12efd603018ef9b57041c6febc33de8ef4c4ad6a467a9be268463d984e942530375fb8a7d6e402a9f8e67f2aaec168e121443283041ee77f27819fa844c0c8067c6ddb4a39d14b35c6b68e11e80ea1d1f780233974957abf662e87104700ac00febbe8e17ddc10e28fefdd600f9a11dccff1820387d3008580ea6edb873bc8b19d91165b30dbb90d3ec8a5324411e88121cfc9000496ab9b11a247ad1ddf1bfc8293562858518740ddf85b598f2cfc7b352f107253560e152a0b4ddd417e53602de29aa9e5eee38442c8793894da7e4cc3bcedfddc2efd01a94f8bc5907fcce8c0b505eca33ab01346c58ed55320cfadae34c48ef9bbfe3abda92b98e845e303f3996b9bc684099419f6b9409aad12e391d5f25f370313a0841d3a50e8f6a15a0279eebaeeedfb9dbfcc74d1cd8d52d2ca42139cd6acbe6b35dbeeff2617e46fcc9148f2839a05c5ec4ef1a4c752894dc806c7da33ca142e2b84897f92558996d2bbc7d0762b8c15d76215931907dbc732333390d2a0dbebbbfc05e864e5c16be92582893c66e9c87f9c44795696493fcf0f18c2086eb2d0442c0a19db8265c6d63020fb61f85e6c5ef70ab3a6cabdfb61288873d0e2b3ee627d44a56a62c04d77930858aca6cf1069710a070fae6bec00554f234e90d963f283160e5e66b6fe25e43a1e1b12611162100be384ebc71e959b6d06cf703d6637dd996ba49316d72fd876f95474af642dff4aac2fb2ec2b50ca22963a873652aa8b2380a2ba2e32c2167372abae94351dfb586eeaa14abadc49666242c1b2e8e89bba406b34ee12cb71d3f9e4f7908b581655111edcfe1ecb91a70cec96b2f07902b9cf71b479d7539824dbe76ac2b0fe4246693e4b61081ac8de4dc7755a70afd3c05d104d78aa16bef9169a90e06e9c18663049786de489c055da6f245db4a841ff8f9e1e75e724ccaf90c3ff0a23860266210e460af632b7bdf9ab15fbf52158a5cf00ddf85f0c90f9bed72f0dd50c443eb0af463c5c9425a4c8ca4374c7fac5f4f135590ce88d97d719c58181272e73b834fa59ec1fc5f2d9287dcce069406e58cb6e3df597f5b90371162ac5ad185f06fedbbadbe79109fa0527029dc6fca4a035d4018cde24d6a4ea6ff1eec7848786ac635a7faca56d013019110442dc754d9a1c5768b9d61d4409dbe0abcaeec88494009e16ba177a7d6ec98ac2aa9e93585f8c6d0907b582cfa7a594720dc4478573d19d3e1673fe52ace42be708ff1ecb7dfe9f8f20ec6fd79004146d5a5d14ba54cae59c8c570dbb12d6ca3154796674822d293aa14f065afa90e22096631e5acf34ac5347f08e14bbad8986b5ac3a03412fd68d0085f477f8c3a736fcc3248ff2344e94fda0a01c8a02d0cddf22e8bc340830d6312493ca8e9c56b767756cb2aa4fc74b415d38e9d4ba11dd0c28bdd7b7f13f38836f5d2f563d709099814d014b94578d279c3a0b799a5b9ec23d73037d1019709f68c24409708246aece875c4edaca6bde4285450c5f30607822c738823c9cac794f63cef8d14f5def627e88e4eec4ccaf2bacbaaa494ea489cc810cbe06a5d7c1b8967a5fbcb901bffe1db7a872e394b79be490ad5c6b440d7bafe4d3ae3262bfaf862383c75ccf7b4d2245f7ed3965aac2d8c2833de56bfd991d928c48b910cf0e4fd86ea04342f60af3d0806d45218ae05c0bdd87c1f1f45d936063e092bfcc94752fd09154b03dfb5f99a173b693dcc8d82681deaf60e6a50689354465f8bd5c4dca2fc0b9d49502f7fd2de1e973b71a07fda3439131f10b20865f52d2634d552b993333652ed40909becce7db5c4ca960ac83134b86f38102a466783fe49267cc3ddda44b48c0fb573f6e2f1554f80a673be679bbbb6d7b485216d1ce81d7f72ebfb7a660e8435ac70cc73751cf9cb5e0ca45286d6823919c08e31922e9677abf9494c557d15e80c461a8f03880e8fbfb02b034d367e4b54e4a515f477dd23c5e76f1d931740902a2051154569e69557cad434ea6b9a104a61c1b5346832dea7cf6dbb50396629304c4b4ecdbdd7fff99ac8b7ba590b1ac344dd4a7475f6a05624370467efbd574f561ce4be5ad9f208c90537b2e175e15c091ac922bbf9e4e61a97788d187f53719db3940adb6e823ef728131769c6d204115eb176512dc176bec778e25acaef806ddeae0d27f19e2c45a00df716b4bf3bd69f5690fa6c053f3ad608e0bf0569d7cac2ccec91324999a149c6347910236da724000ead52fa23ecd4a97e99e7688373fb7577838a21694b728c0e2ee26433f0ae7839279238ef211271d249b00f9ef42fe18ac424c50a4da8d2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
