<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f5319e321b50d0afb7c2426b79db1e9f1548b3d59b8755cbdd09be5826d9624a3d81124201b28a19219797f649c161ee6c543646d3fb64b0b6b245dd663bfb164b5515cc465931d18bd7e2c1e1a5e149057a57bb3b037ea3dd0515e2253c71b3bec5681edcf234008571259ae083dd03a1c6b4ced326e8ab5a446d718adce3dbca57e4e9e7bb5874b2a1e64fd04fe18d8fcc43fed8a568b013ee2de1b99c3b963fe8409178209df271610446d3f3b727fe47c6a20be2ae8db9c538c5d598969ff9bd601ad3ebfe217bc698599ebc57f00b3e72a77bb1f911e4d504beb6b861704c748ca65381c2ad42974cab696b63a54e3cd10f240db4ecd2c0a7a034682171b15927f218e59309d6605957b992074f862a8e2e9f8624bd843899037f994de3f67deec00a8904f037b51f965e7cb7f6f0e0710b4a8a1de9a9ddaba35d2d93f3e2429be44c53851f94b583f8af86c181db743e73dea39ae1226df2544d20f5709598448b65123c51e14c046bc1df5ba09665926ad0b93042f769fc0ea9175c486aa8b349cc5e8165497af73a49faff84dafcf0ba4cc891494e22258f053ec08f293e0b01c29073a3b4f79b567c6926efbde7a2cb1b10042551ac7dc72f7aa4d6d0855a48a96f66df5c09ed215dca246dfed9f9f65ddbc556f2d3314ce4c978b7867da6f47c70152999f1c44f183b246f4ff97dbd15f4963fb8986d69c64c505b85c3567efc5e6ca1d2fc000eb2c079efc5cbd5a1c0f7f12e65ff180b1b96e819d731998b2c15b59d0c7eb20c43c61ec051e4769553b4b6718c8f1a5a6d20ef6755130560ae920adbc193220d1fe2e5e96a9a041f0d52c3e988f287ab0e7fb2a28b48502d5728d5d7c03f8ce632344f2c8774879fad64766086f5790b62a8058589eb3ed54c1a1a7d5c7f63dd6a9475f5f7471f4452d962d855835aff380df83750545c35ff6ab044483337e6cc89ebf796f446673c3cabd23e9827a3cf2083e423f9b3fa1a940dd5d45510c13af88313d7d4a1ea533270131e6d45af50f18d5604bbc2ecb0990ebc8f57516dbd747d8c9b49ab0bbd7f831652a8e86647801dd58051df1806add81689f931793a0badcc2ec76592d4badd8d095fd557bd174c82e55480a9eefa3304a33fb8a0e824664dd471ff0a21d7708b498b8d11a81cb3839db1937a215d39625c80d6dc1528f77e15f2f1b2ae57abc403069ca7a6a79705e3bfe2fa33b1b0c73962754598e383dfc9a46170e3121135f19154411a83086e20dfa801431ea674e2860e75c1a1038285fc7efa9d9eb21b4fa521bd0d3dd797b8dcba9bc2afe08ddaab29c26c50334f4de8a078b95ea723942600b4c323e2d2e0d44415e15743ee8033455e411eb68f5a23221edb48ddd1c6d65acae3b102cc6476796ee1d3937c49743922a4e19321eac4c9ddefa3ac924cad817ff62ae9436c1cb3cfe0333c6d0a8676f44f923436481f05099f0bb8d276345b7ba49151b772e7a7521ff800b3d9c3f3faed81d1a6396c5279b6fdd60b7e66673fa06d9f211f5f16d89c6699acbbfcaf8409ffb57d42b5ab284e15005e977dfdc189fbf7698a0dc7376f37da5fb0f595cfcf6a78c324177b7581e5ba53840347305f75600d327c795293b71ed2b1fa638ebc60c44ea51a6bee761b08761caf0dbce18401f25981428081c71815b520097fae8bebedd1b18f3012e40bcf4d8e9f7ca284d704eec6075382d29c4157deb9c32182381bd0b12ae42ac5f28b86b6ff89963b741362142599f8918459151a8c0870bdacce55b2c558746977d6e30a5c3b2b26eb6487f33394504d2e0bed51dfd0f4d913efc6af13c2a0a0f16590a35fcf78ab73aa975d68b601ab0d72d708a7500c0d5e70cd107b7d231dfcce2427e7eed4282d20430c17159b0005961dce624f75207d9264ca7ee0e9294d5f73d31b1ca57b319ae375e74a25653a765b71b8dc9f3284be38e289afe22c92fadcc37169b881564270c7722876f6ced1133386afb75491ca6c359d4e74c2a4b760d684dadce3087f6f0862a74e4ad2b81763ddbf227fa8ecdd90020f7362b6881231ee833c1a4b612f386e50b6faaf2c96ccb722b1a36ca8d4b4c544bbbca0c7a47e2fb61a5b427af0494d8704765c92f34433a027c4b0b91aa7d5727de50cd18707cb26f2f1d5ccd6c97033e429c0c40e6f112a1e8cb028dca86e6050d4bb8ae6d0a81179234b63bd282b59993b3e63fc40df37958fc3d6959e5a4ad89d2ddb93fdfbffd25f794135a17c8fa2f81bab1003fa034868d4de6a544cdb0298c99d6058781e0cc83c1697fe240e6149581826fc7096c543a03729565cd15b8238a11205c1630028594864bc97e9f53865228412b05bcc0f4a7c9c7f65439f59f65c2bbfe836358bd1afce83ec69d714191c62af5cbc54c5227848c9a8a9d24006674887774d002bb3d3c8301280c82a0cc64067fd2e8e35e3faee68f7e166a0143508c32b772cf10ad6f0e063b7433025a6c9102419d28be840e8730e2e26cb8055b79ccede33f8c587a3eeaec946091610cdb69a63e650e1294e78967a9978e339fce85276793d06fa311ac4555cf65fe8bbfa9b69452385bceb056ae3e704c0cbbec20af1885de3c9decc36679dbfcbcd1d29a6b11fa735d2786d7861d0a2ac32b763b501594b88a15738a927001ac3c9fcce520c1a561b03895c0fd105665ee1e77db2195b891be5e167f6a7f7eec3c331228a95d9d0e327390f035b9b0deea266ea2182a199b0dde8711485d8913b44e753380689d08abbb98d29aa4f016d9f762d808b10c0bc286a5a759263c54ef83a7e678cc6b9ae023d5c27db87bcb0f7f6fa3d8451eb94d2a2b4fbb1677e4543875718e1ac9926cbbe320748014910d93db7cd8799652cb76ef728996be0c9f1ea3381aa871896178a837563ebe25f5f5774d397886d1bc13b0037d8c49de9e4cc227b34c3237c629666d527c3affa4477b00de749a9d5fc9999d546938ab4b2e2a3c68d99185c5326d971a545394d845fbd73c96d30e3796b0fceedc4c59c126ec304db61e95f2e9537e16254dfbc89d5b203c140695f93d706b7317d5c164d7cb836b078f69767ef98cebc559e783f62d29878572cd27daa32ec6879c66e54f831f4cb3ed20b1d981a63c00fc13ba26c7faebd0fa8a1709c79aa5890612e6d9370f3b11e89acfce1c1393df5aea287f8a95bb890358a1ababf5cf698f85ea1020e37304de2019b48c57b7ac7c33cba5e939439be15d3d7264851aa3dfe4f21265c5ac5b93047ab5f666f62bc6520fd6d715f31b7b3b3c5c797774032e73f76fdc6faea63a8a450c2a8063c779f1a79a332f131c66dd6a276b19e280d99b810966f0da0a128af0de1fcfa50d256bfb27f085f189f444259b02562f8974c7313fa3cc765c79880cc906a2ec0a0934424ee3fb211365fc6df93f117dfd4f0c21d891519e057fc5ecfed5084e72c0620e6656da118446f2ee98fe96cd9e9ba7e0f88947775fae4a7ba6a6bdfbcfa8182e582bfd9d4e399b379b2994f8ef9cc91e43b088b561f12ccc1c85e94f57c7900ee3b97dda5df22de6d00ed511c582038a145621a7b6dabcdb0563e0526b386541974d54969bd20cf6ae1c3284524bdce2e867b9d18ce945313bc56855564545fb87f26113159e9c051b702db26dd1b50488fb258a1826fd040e5fba5c5c1347526caf4f3df4294d016e2e5f0cbab78592a3d14d5bfd1ef056011954635e2dbf137ec1e85cc1d6c65af98137d2ceb736002b3d311e8bb7d01befc8ad91611ec9236725fe7f8f39b99d954884268c68fc85d2678ccda641e24401e1b27f990468142c1032ca23d2f5971de2410b112ce2652dad7096eacb505f85c19a7fe8e4024d469fde9efbe7d6294b75cc0e9e92ec016939524c09e224db29dd3864785e0f6788ba6091a9807a897e9590269e17f585757a4e398d38004a883fdb92a0e4e0cf1e234de25a5f2a8f0888e43bffc83bc191abccf85c3f1eaedb7ab8acb25fb10acd495d7aaaecb3451809dab5717b65bd364ac40853fab451eb88f8e7d19f7115bb87f542f9a4f0568fe87a97098f3fe2e73bbbd7f97801d45ad205e63053edacde1477c3e1c6c893fbae248aa0f09a2e88eb7410f3221ce2fbe0ef12d625a58f7c4b5b6803cb59c37d6bf98fe29f13c53f95bede6cea5077415032398786c60b40bf9daeace5cd00fba797dc1ca3390dfcaade9cb9de79fb6bbcee19ea843275a7da54e3ea729243eb3a19452147050d6e43ba22115ce1c406aef7f1c8206020497c08c1baf156606b0847a6d7fd7833db6ae7fcb10f541fc739393c1b3132acb74e2cc17f740ef55fdef28ffb4e3aaf68ddc067ac6e9a08fb4f41d3fe5d96d39b0b21d537a9a63c47b0750d50d02dabadfc67ac57ea3ebbfbba4436e269a2e848d5a8a022a2d9291cf5dfcf620af0aaac8f791be1b3841146cdeadb717263683475fa40e49746f44583ca54b521aa1ae7877971c6d4b077280b1b57906daec6813464a0b57390bd4f352e009012630b950d6d3435e42e398070473408f56f9fcc2edee9402aa5d9f9f59af04ba8b86cfa102ef1dfa52eacff5663d102bab1d6f29be577cd43b025bbc050feb25d96b20c1ded330d2e96fa0446bb9007b1d589ac9e46f9b68f39f28bdf994243b9972e39d4d683d34d49c90c33481b50abbfc70eabbb42bb16ecfa34480f8b3c646cffbdde924aee6cc6efdf929f0ecd1e435b2dfcf5db40222f41619742dea29e0e80f027c9007d04730c53ab7de894c5c9bb190ecb08e815abe84cda1edb9736a66e8c4f3da5c5bcde6b69cb24fd45fe70ad17443449856e0770346e48f71265af947aa4dd2fd465d09e2991d0cba18cdadf267285b75450b3c4ce3d62f10efb7962df1e136e824b4675140ee90f5d8f7558b57722e5e7d1943b8ffc4a0ef05e10725432ac1430cb5f818e28901bb64ee9ae727338a4ed50c72705cbdf0c37f540b2fbb10bba35d0a9a20ed4b9e42e9ac78482a25203b65c4da1fc809220b6e2ee7609aad4ae71f877473e8edd1fb63fbf9b509119ba6109f467962a33a1bdf93878be6d98f61a9384441e53d75e30d80f40beb39c40c3b723c7d9fa29643108dbc778030af5cca8321892c0f2e2e1a1cf7c2de9875668619438cc562fb249308ba6615099710072e3254105a8971fcb77d717da63c355dfe2b4666cc27d3cc39f5e740aa5bf6f068450daddca7e13b4a4d8f86055b73070f2c0b4e4600233d2da9fba11fe8f5ee9160a4817a7942add58ffba42dbaffc11406b4875c1afd2a8d840d7e42652dc2a4b625cda95c6f272f5851e7df2aa01e8b4c3f9c28f1e029a4df8aed1c7aa47c45f54a4ec0152883f41875394c3cac0676fbe78d5c2774588dbcc50116e62a0ef529dc4b1ce46076ea843584c54b77f09ba9bcf4a92720d1020c6e3302ad480f00280d2939001e5768b9bc1220e61aef36c1b6a8f8280d3d68c750a174759fcb9f9f6572de9646a245ada9c6c903a4f71f85a05872d431f7b8ffafe7ffe1977d03c3a731f73311f9e3137f326ac4e0732ac2db2ef5c4156f245eb425b42ae692fe592af3b9c89c3bb736070bc41dd6225c9cf2b11d90a5d8c0806bf917539db6256f342c96a387fe711000badc99e393d1bbfdf345d376633030f3094e6bc420e80fe4ef9373762fa6f6fc32bc389710cd62866df7872ac87c9c2f90d56916d5106dfb981597553e23a0b227c40bc68cd593d79c4851d9ac4c104dae7fad088ae96bd821a18f90d65330c0b8fdeb20ecf5e5988dccf89b65dc6170dd0603e189e635d18655ea0c91046e498a770cfaeaa33d5e6c8587df628d709017abcea7ef3b153764daecfbe9e4978f4250588bf68b8c13e17cc8e0f0b66185e9171e52797abe0df760eafdc5b402f022f0477bcdcf6a8f61594cce3c45307190fb012847472c503645d28a30fe21186a54c9d3d8cc758440e5b0c0bf27cfa21ea552157eb96e0e771c0491cdc6031a232010c4a791b85fcff5270453e2a008652e5803933940216423a313408f3dd29bedfa84f9abb133ef0dbefe5a99a36399445df99b2345824f957078b535c45d23429ec62c362e3be22481c21c740aeaae1bd6c8fcce8210b86201273c831df63565a53e3eb63c756d354f7d979954132d8179c3a01f6983b620b7042a037f0f38958ff7ff5b8768a5b310cdaf1709f1bcfe207b0ac0805b17feee88bddfff6d6b16e8e7059775b22c7adda749059631faf6a579396924a1c45ad7d287090fcfcf7228bdcc03afea76aee5f7ac5c7a59ed5384b5fb9c892027945904c2859ec632fdc88cb402cb2accfd195d572cafc1b1bb609b93a4e38b0e1ff7040cd77f8f3f2f7098855326c486fc18940aa91ce61fa3f2984db9de42314fa21140704d1199aae6beb0848a680840048079533db49a1116fdb095a0d3412fb2ede5673274173a425148a26848377325d6113dc5d8adcb4ca370ccf6081ad47d7a2812cc96cde780d7cb69a8795d405244e78ced74d23afc75914c7015717111ebee5bf845fcc8f99edc7e1ee490257bbeafac9d12b3003e19420f79a59ffb6acfbff7c9f9dc96fbc538ea1ac34b1011e34d83c5b3f1b2e74a9c60480c732fb50f1c143ea8c54ce9717baafce93d91bede1e9bdec5c90b5a5010172cb6be6a56da480aef54743b189c05d6b2868b87885fde5bafb36cbff3a6a7b80aa827a1428b51bfef1e8fb6aef4ff860bbd3d8dd972271ab4b3061a69ec55f92fdfa8d7402658ef22729b4fa1548b25c9559cccecf57015f9f3b8b465ab75c2d0e6e712896c4539a12858b24a2e5f0833ad36040ec0f471f33f3b2ae8f10f49e2dbc2c742c390df86b27920210def91e44b01709dd49d5c3e74d85655a613abda5f1ab5b266302550e6d96b3df7fec7470f6162381e7ab33e50af6dd5333e5243225f892f5c68187855826bdeb90fb4a9ccddcf71b0caaaf130b65795571132c02dc065db78a020a0465d70d718379e4c7b534a798a0cc4cdf0d866a521ecccfc4381c9cd9b17c55578fdf095f2d4c0e90122e232a7d3b19690ecf8a13b5b0a5456ac1232d62ada658b4763a6550beb1d7670a0d0dfb2d273518457e385a87ca613ebd002b90d0268300567b8013f37420983cc5f82285a334437400061ab199789c3aee70961333f307094a993d16cd262946d758a00e6d4c3679fd4f88ea2d9242fae85ab439e64d6baa6dcd9be57dba21d604be675e9d1d8b92135d9444161cd56c6c09053a4262e815ff1c00152afec705846ead0736fd30dccacbaca6d9e624da10d8187b28eb738c63b80e4557bead09ce7d21a819439774474eada05129decdf2c4218cd842c2de88502d400bbcca8a3c848aa1b1fcba2ec2297bdf919aba6fdfed3977e768b96319cd9fe2d2bfa9bd90eec5f1986951c4b77a8f26b8421e4a17b5d4eacbf84456b0eb2c39a4459a08885a520bc10c17fe54162f4f25ec823db99dda8cc03a0d496bf5afa80c48e3c8ae93f308fd347addc0fcd6c47e594261c88ef7abd50519a3e851805d90dd8cbd5a3ba0d86ad6ca5d1a7a8e1582742288ace47dff3f52de17861044a1d2c69606cd2063ad3890a2940c6bf5384d324b04d43e4192c0368460454d1aa2754068dd7e1037ce6ceeedd67059cc4b0a27ea8b16a942d792c21bb8981ad5f0c0b1f9348ea68842fbbd8fb3a7e8d9e4b619529038f7af563df4b95a5a4b7ee1134704ea477c76fd335e3ed8a170ea22e25d944be38eb1e5408fca572567390f5d810800e8f50411077a3ee1289554882ea1de54c5555ba32bd0836b27543a08d6d52a37dd4f3ce24aa701e5c9bc204cd5f5995235b848d9075a65465ef588453665fcd96ce3ab7b703f4c399c456d367b2e3db69ca82cf541316f5fc85f0f4cbcc38c027d38585120b9cabf5ef9018c50f0460de2b48817ff72d9587553b8efca97e972c27e980b8a1d7af30d4ee94d8687dd7448ee631b3a49731cd3f5d3736bf430b48c2f46049d5bb50709fcf0fc3a4b95f9cdd46d91509a9008e43c51ce23719aaca70b01cbe28a09b7cc996893fa9461e7dffbac8b1de87b9b7dc6efcbfd228a858749ca63afdb8414bff66868a6894f5cb0b58b674ee8c3b19234f69227adb4da3a063d60e3db28eb6d1e6afdf640d94d3b2ea42030e5418e3187658dee33fcccd93388f093898c0dca0748e6b25f01a47623ca37370fe10de8d053e19f886421c3f0e94475600ceda1fda76900cf473b9ca0ed7bfd0dff50a9acea097ba18921db23e6dab4a4510b2d09550cde088be831f8f38c2cc0dca18dc818ab6d7e91e8601db8e82220c80e976d5d52937e654aee3e34f5656a40ad8dd823de009077fff69a23bd28767749ca0bcf1b2b347ee52c8b384d3c33eaf3847fe5b89fa171957a27dc238d09636c9a6fec2f96b996b91d0e1a40b2b52953a3f279dd98057d5d120f63662fb1c5c0f86a08b5e68e5f5bea4cdc9de3e3db7c8d371e2cb5d8e5cdfefc3d17328fe602b93f10c8ef0368d4fe2a0f6cc80e325368146ff2583fdf583fa83b3425e5a5e83aea475e6517eec0bb2d14a363e4049a775f40035c4903276692070fd86afc5767a7c6b729256637820af142b9cb2c515e9f08d9dcf72ed43a41785c5055a16a6ba0afb75bac77c5b9c36e3efc653384b4b3f070ef07ed8c121bfcf9a351513f096a1f39db949f3a845a0276ef9871c46ac047b4aadc7f5e51f359785ab154c03a3c66174e8a21f19733494dc188313c9e5589f18bfb8a81dc3ce483fdc2129cd091e9f7df00865dfec856fdbcd9a5872d2ef55639d5da7e865679fdbb82bc32f0d7e646a22849e8a3346d9fabdd00410c77dbf0ec4cbf223809990e2a4d2b41a2ca5405cce50fbde98c78833ec6a31a66112269a457532d36b08ca743ad3df438689a3a6a51720813ddeac938580b8734b66315a5ac18f50c0409290ddd821062315ea4f7645a604e0b4db98df131120afc833d9ccb3e37db579e39ea30fafeaf9a83c2ba8ba2437b8c252458bfa6cf76eea363c344e49d149361f8de0fb4a0a65ac131b9416323dd7133ce493729afeb824bc88cda8d07c638fcc4f67b2945da2d5b3ded3cbf621f0fa79dd0e35685bc3f64af022d2e6cd556415390abc13e9e6d06a61897b5f986a221f2a34df2fb049a29c436a6c775037a1b6dff24177b87acc44e4673ba4589ab3e2f4693ed4426b5b00a8dde2e60014ab37c9e8eb55bf6e56be9d8e2e583a31a88ff8211d186c9d208c5047e4db223da6fa30a870371c4c8e4e7b8e9d0c144f4e5331ee69d207c9e6746ba822508cfe240c5b034cefd12eba045cbfeea8da29a148995e3912977ce276aac493882fc309832856ed8a1fc47817447dc163b53b1bdaa02a6250624e7d6b0eb2893f05a5aa5f935aaf64436d37e2f7573165f77ef426b13c5a1b6e0aa7d63b38f3e5e286a818b4a79de8af9e72829f1943f7c7c0ff63941a3325fbfb1a98a323cec354b9496b51e12d54ac5d914bbd62f46eeb84cefe32e1253d6c890b162465b6807ab79da48a5d5eba586769b77f42c359e06a835f5ec81985f7f10d63a8cd6b66b0eb61b61339c86ef64aebe11b1462de7837127147a9c0d900617aeb5bf74effda73b0c80d04f138e9e1ca53a62d233d5957f8ab554d56234abf67dad39ac092672c3e8093869446cea1cf51963f62e1845af1b61fa76ce05422a6110b3dee79657a20e7cbdb382212cb25a0b5d1af7034a3525267b8d37a10d1918a6aa0f319aeb84f44a98d0c50b2e9c238e05c2207de839c7402e612337432cc5b784d6da7510d8cf40037bc5fe4efe066cc897e11a0201393fe298107b22aa04a010d4cef3d01e2afdc3bff5e541ea502f8fafd0d48d9d72c854f48d54821f616fb001cf336fbe89f054eed22f4fea9361cab63fab40340b25cc399c10e89c66e543e84ec7a67ab6227c5119fa811ca0720c16f243941d7f9865ee9faba6826fb19310a111dc8b154430778e4a110b7d9bc4b968a9bda34e72d7635c847071ecddf1851c9b45e0b79dff24a8e85ea29719fcb3b4d387a6821ab995a0ebe7887fb038474a43c5db82af62021b1e7eff18f8d8639eb233d3dde0905b03028a6f7ab28a9f28fd9d7e2a25a7cccf3e3dae386fec9539c041e64a26f80870cfdcae6210fe36730bfd079804cd63ce38054f2c851a1ae1bdd6b9cf9e6e0c5c1e916c4973a220d02c7dcbd03c15c7a5ed4aa79c42a7f0e11abfcd0d4d4eb4cce3ddb801b5dfeca1bf61e5eccd92e0e1f0337553d78dca9a3e3f32130550d8be633882371b9066a5c04194f73e8f2e7cc33553839def42f33c6de625b11f817870429cafba47612b5ec89483da3fe4539aba265939e7ba8361d5f8b320e3717d86e8eb5f1089fd7d034338ea22c7e58a307c43a12bb4fedc6e89ad2e2e37c01d7897fe71e8156d3c4b752499a6fffd34600113fb0d0b82f29805b8eacdf42fa4f18a1ab11159052040fac4078ed70bc616825028f3430945bf840702c500baa0ae8285ffbcaa6563ae1b4052355269f49f1f7eec8da40ee62a6018f0579882281af30dc3bd5c0f191a5346b88f25d6961bc4b2e61267a80d3c9353a05d6abcf8aab4a23d347a360f7db9b6f242a8e1ea7551c1c39ad81050bcdfb0b04a8be21e0fdf765be2f2d13c14d0e9f263dc5ab74f2423da2d0a9c8437c19b991bf95d4656f549debdab4b1addba6b88118d5b9f5bcae98de01653d594c7a61ebf528533a2edcbd84a02f8180a3e0f97539c2271827a2b63381b967eb7fa2dde1426ad1a450aa4fd84197926434d56883145d45c0c15716db9e22b75d2677adba2d69cc36339553cc602f26e9211bd5618a5e1e4454e95df42bec6dfdd471950b10af9d980fbc92f5400c5c29af0ff31393cf4d22000ccb74b1b4050d7fec9d39cbad7c082687220f507a38c3cc61f6a6f7efbe801633cbdfeb248d28c361b02b1935664e4b8e6eed444de19d695ea096b126be1980a1315fc89480b41aeda881f0b7d190269b1bffca4c7ddb6c6d568fea26b206e885a4822482df7e23058a9109a1ec2b8641716be82fc9284f99dab5f4cdb8884d8dd220625f31f67cb5dbe3c2f1b940fbae52ef5ed8d186d408b3cf2edc16f89ce3de69a558765bbaba40c653155d6c98ee3983dd0c4b2cc533d8ec1914789bd597e4874cbe5605cbaf68ac912c3ed5435ad6f74d69da545033e4c0c49b0cc4382b20ad3bca85e37253c0bd126912463f3a4e4456436e1aabd90de9a55fbb470d8d3c32236194f99f3f971ef018083b46cfc56553d7597b9896b7a2260e53127b4f463d961358170f0f3fc93215b8e560a2e66b6277282ab72d69532ee8a337e8b68172ee97b5a9629bd08682b243429e996ff47e2923c2bc9aaf39ae6b16a2c3122c641f1623dc8ef4e622598171d93b8276da681961131101e40223778af4df774e02917450ce76a36f2cf039f0f8ecd9bc9fe265fed041b96cbe674f7e33b3937b3c66db564db2486d4d15e1aefec3a8faee45d68cac0ff8579a76e13d89ddadec36f80f3e06ab4f4b196e8083b7ff9ca4bf7893adf965756a48d65fb6cabf36eea3a8c4e46272b7249a5c93d809640769b97c5ae8cf1aea872914c87abced235332428bacc642558f1dc13216af7bc441be3aa97416d9d5f4819501bc9ccee1e6dd587ddbf5910c35142a2bfecaac52a73ddd1f0cef84fd404b34cbb5d88b2549c60826093caeb7e810e0a0a024fd5d4acaff4cc927ff581a5a7ff8b50904b88c4df05b21dbc1909ec5b004bdb36aecd4ddb05269977bf01d02553c086478290be5d1a608d9d64a1ee7a883ceda7a0d263f3803b80947967cd9cba02134e08a9bb12d0dede2be456307917a98cf8f109f93cc3b60c516b45c50db94a630eaca4089a673ba5fca4223c573c9ee377afccdc80019a799989bf4e12ccae58cbf83368fd21e177a5221c71f291e171c008efd9227d5e4da842274b9d4322d308fdc0ba3c23a89e7fb8ab8634451a9f84b10d44040838c835e0cbb1da9b85374d2f880278d7a53ce852d5561167f76db15b583181080833689c8b04d5b67fc0c03e7a66a0adf050080c05aef1a7c027a7d5a3bca0b1c0dbebb1989aa7735832a35257aed419156fad6e4aad709771d31199b4cbc72575acc1a80c006480cfe4c92a249a6593737f4282af235bb78e101906b4ebee1f887fbe46a8dfe7adb4801c37f4f2ccabcd25e75072ac9435f75953ec41ec71a2b2e27a9cd35167a024ff6c1b6849209240eb2768d75162aa42e4bded6fbc46e8bad14a14d6d531f5fdd9c82b7704f7bd4b6decd6b62e666bd02d1772c0b6ea5067d329da41b8a64681a3854f307387b62d77ffcc373c30403d6884ae97223a304ceaa19475e500712c0fb7a0fd0eb542d79c8850a32c8e71bd843689328611d976525d22e5ecb9a03d44f9d6ec8a3e1aa2ffd18d72834960a77cc753f872cfcf703bcdfc5ceb24f1068cf3fc9d82039830f6fe79d22ed788883d1af4897e81a1a4cea5e870da6378deecd25919c415b713dce3d3175e70be648f0e7c6ad5e548d320c40764c5ece05ab38eca3555ff94e86644ea5e7fcaae2c1e81c708e64d89b780d69ad51016e4bcc095238ef8dacf7bb59389721d493ec64f0bdafdb2c0306f3d86d1e44b1680bfdc2f4d9d32de4ca07c7a22b3b0d940333315f430450e4d05327a2bc36d92e7c6657f7fb4349ec02d53180a633e218fe1a05a8a8ac9294c4657b6728d4ccfe58f5099de31a7728491e2a8752cd88e339d17bf4261dc56bad42a3a69d6283e9ed4b33258fa22bcb07ac03bd7dba95fc2d1ceda8b67110370d17aa7f6f1009463d4c58243948a015f584d586030ea8d707ee47aac994fbe0903a48dedb340ff6e430d4b9dc54fb8a8ea2860e0fa7999414f400626f8df51df84dbdf9ad04a1f643fe3a8fcaac7631ce26998ce1b9fa326778b171e3131e5eb07e6c1c36bd891ece7a6e7ccbc491517beb330760db472e7a486d0801c8269edb9d7822b250acc0f4e4050d3cf069486cc3c730727e03aab6dc5e7a586ea203f74315c18869898b9e38677e09b325d1e2d44d14bf4f33bcfca250e220424a055d5b67886a477202c1278ec2e983deb4ae9fa59973f279687de3a45a2f66ef8f0449c2e7ce2457f14935522c59b0d6aa2eec70957ca8776a5b6d92ca47f0de6af0d1c9cf1d1cebb717f629e66fc8852d8bb3a3b288c6038385165d4e6e1d25638b9b4d1b76785910b25774520fde67d66ecf26053a8bdb8ab09f6e1c73121d5a1a62ec806e4c97d8e1b1c88b7ec3d2037d6008f2726495756a08590d2dc37bc974c288c7942724c2468a03e5632de29634088933b99f0e2d56448afd60d42b28265add4ef42e8b8347b85f71c8a858f0606420c13a3ea2ef5ee0ba9412668a916ba0faf79ea7d1ce9df1095a36943e5c6b9917ffe1fab6479a351f42e953eed07a9b355eb06d7020424688674e12377728536ca3bccb53816e164096652b81cf6e6426c62a64816a3118ed254012e99ebdfbd8cb71227c27804c3d925e08efc3fa7bd49bc3334fbebb4180cab49a2e3a536e0324902825d8d89ff0ed3860a1c169a615db347d8a5fd218aaa588b9f7d4c84422c91c24942582c358da812a3384433e590d668e49b0fa35defe94f86a05c0065103a85910a1aa81ff49f88b029b6caf45c127eca295502f025e2fb1284bc88c0d8cea91b0781ed416a208dbae5e4b56855be783c17d864c14434940cf5cd70ba5aea352c0fc7f313ec1b9435ef6ef8149ba98020482e48eb9cda8281ad7b841d7f36c03f9739e3a511c7af6db5bca8925ebf6a1fb9ebc38f8ccc9807c5a2f4b94a4a2c2b493db0efb006da3c62cef62a5494bfa75195cc08b9632e90bfef749a1fca50c056cd682708f6211418c3f0e25b83a36e26b44e55c11e2cdd09abc8ddc592078c9fd17dc1077b02c416f99e873668ee57e869e4a967e0339dbfc7fa7884163a3ce252f226920b9ea5e0d05469c060bf44ac053c45151f22a84c85755ed745650cb1fc750c630e28538f7e1e31467d617380cce3630886e8b7f49723b51325df52ffd9da0db078b4a68a1eebbf4ac01376829a6e23c35eecdd077585687b6176447c28c3d56f010821e7463d75dd3fe11ed5293eeb81c72af9523e0534e3befaf75c2fd1d0cf468a0030d24cf8b6bb2fa3121747572754cff952b83870b33fb87e4722a6ce3e0dbe638e7b71b74d7f59dec306f9e6f08f94f8df618955b55b8039ca55b375fb44904b2c9e488afc10f5f6ca1d0cbf29f9ccfdb7b4aae518faa6605e53c97646f5b5f204b7abe7b0177dcd7bf8afbc038b0a25243207be9acddeb58caff1b120a067e2268786f3c84f995c1f1e63cb83a83d1617dc32e2448ab8b11595b0f87b72c6f1037a01e9b70ea5ab85e2a74bdcd2cc02a3dad5f689c6fb5b76199be727e1355eaad50e06a9953abec46e5f424f676a2d2bcaefff91c3ea5f363c209aa939fb5bc4a3e96e7a31072075f615ecda1adaa058fb077bd2d1f9b8112d4130fb0ef210e1c50dc87ee2fdb20602694ab09cd5117beec194ffee40ad92f0bccab2ad5d1e5ed490348741cbeea2d4dab8f2dd791e1f96e9bf92ecf19197e74730d45b5d7cb3771d89f8e98d24486da1435121c0946a69fb91fcc220d951480f3e23f9eb9d082fbd2a230c574e800e79a6440e24aa2a2a12339473d9d8070be29030fa88f79112a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
