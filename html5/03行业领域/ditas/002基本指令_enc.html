<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50ddc491b30385a7e087458550f0aaff853ee324e278b35187b836e2bab0d0b6e9a06e8c165560fc97244c56f220c98e384aca68f31b81618f97ad3c2ba3ac41077f004033729228721248298010cd6dc9dcbab575998954d173dab8e64c6db97d7273387f15dff85759ab73a245b5da6331bd2b6f679c9f27e4e4713f6e8ebf44c973aef8783fc439c9dc59b7c6ba9edf361650c04518ce1cbece05eb3afdf0b6e897aa29b0f7d62ba7e8d1af4a92a7a92fcef03c5817f35453625bf9a2fac24bec2a15ccf4857aeb1ef724ff957588c26689ea2c963739a970527c0091fd9fd642fa488d06da4062f8f08d7b8be77ad689dedf108aa6ab60c5e9260f369dd426ed4436cb011f257407175eb687dd3e82088aa3995da74ae26a187b9b671dc9bee989c4a7875040c09b17296bc43b65a0c0a4028cad729c371b5c2d603847eab45f7cfb76ea405f6371afe4ab1c23898a914b09f35029c4589004a47eaba063c926f136ef975323de05383130dd146e360b2bacacede04dc4d31345df482a3a8acec455cccbd1042668f57daeb69e29a5639d8a7697126e22b66761439b553dc01309f23c7d4f133ebf63774f44c5d7b31bf6c958213d29c0fc204c589a74c22f799e740eaa82613bf6a26924e1b9f67cd18e5f7bccfa3bcee6c0dc5780bf74d6bbfb984668fd46d0d9ce5b1f9f80f97316e1a57ff369db00378dfaef35dc1060c38f077c31bbfdeecb7689a5a7ad9cade2bdee9a33c62962efd8d1dc17ec8363c1354455c86969d0133cb348945eb42294be53b4451df7f207aefc0d2a64a7da5678822ab304ba0a1e4f59869dfcfafd88297b4d5b5628f78b61e3e02642140b5430a734ead802007e82accc33b3dae7827d499b219bf1a64d48bebe74b3dd38428c47f575086a2a78b3ae163790b349c54d5b66b65baef0c04eabf9f923e0703e4ae668a6dc0dc395c4f5d25c9dc4f8bc3e67b76e9104af6371974233d8d04e585c8507243b1bc2840acc24ae4c275f602e3652d8ac660c5ad82793bfdb55aaa582511cea98dae4f4f62fba843a9318d201a7b32f0afb7f518706f04b806c4faa151c0c64ece9cfa2240edbe2b76b9bdc950c7a9067c56de086c3244ee1c6ddbd5a34f70cd37fdca724598a401b03740ec333b87507ecef40fd809cdd291072ea6c4c7a966f17ffe9400fbc5f26426ba7ab8374c10966be1ede7da42deb172937d5fee21320251139b2d032fb0c644b71bc65d080c2946a3dc8b8575f78fdc09e372353ea10482e944250686a48d1d909f22e6b1a90778ae54a3da934823a6f321e7c11ea5a3dcec5544444f7bc5ec1f942f7b8f91adb62960244f8517fc52c82d4a53c124f9f634188b71f185af7674abf2f65d4f8a3741589d1a2b19e2869f7da22662c5d03dd63749769b0ecf840b59fa113d54d2f3effa2328adb43059a0af285a456431affa6f4b0a8c51512bb1747c1152427aaae018480073b3845d242f6bf232bb212901a72eabad3af24adef984cbe026d0c9c00f07f5fd616b6c7767889fe41da934cfd4a83570c1edba6c1ab211499b2d3dd4d5477d93878b79442cd0d84e3592ddfac053b9bb4119cf73d33d82b1efb7c0dfb6d0b481f1411ed5db3132fe91e0f5e9cf7e01a12f8157269fe4b2b7d38145730f63ff805fe08185836f450160cc1f4ef2bc04c3cddfa88363e46eda9a3b9c25f2ab755c66a73ade8c5d751f45f7deeea40fc9954695a2c9ba3d8b5243f0bb388b2c7f1f2e456011d6ea3f1b1ea2e820fb6f761b709207a533da6b3e573b4bdfbac81a7ce16397a301a93a0c92789e5cadbec25dfbf23a7d9cc3f7b13e0b04a97719949fe2caff43f5dc2ca24d09cf90a34fafc2a8054f9d20ea2056969dfa2092bb2018b05b07f0d955b63a13bb19393f28c960759a8d64a5c0a2e2fa3f7d623413cc4b18d96899288aedc0ab5239090b25d96c73fc6c5b3e4092c67ad4f815429aac8bf2868e5f323ebd39614325f38c6571bdb533b4859709d248ff529bcdcd12ce210ea20a74d933e4b16cbdfb004c1bf926e1a687ab8f8703bdabc92daa7421bbfc77bcfd871ebcb53d687ef5d59a77454e677d918269c24b395be5755327fb94e908884bb4faa24360216f15d5b9376fd19527eb1261743e292d2cff4ba3d9eb468d6d4b35a8a7f0bbd9628f214c5c7ec0f009a570e278ddee42a1ee780683ce8af6f127d7b6504be3fb6b4e98b6d68d63077bd4a97b0115fcb52b0fd3792d9c892ba41a3e856d561ed75c91a6726f914ce29467cc21e7b54ed295293eff1ca33678bf1df461883a3db9d4a45559a6e630db4f7ec1c7de022a6d7a0b010c59cd39fbc5817a20bfaaba5babf671efaaa0b3dd3a5f51bdfe4f42e314f1bb60bc922ae1fc68192f2eed6ccbf882865e8cc4c9de005dbc1e67b7b294f98259650824da4f5f51d0fd3b00be07136f242ba3094094bb0556bd2ac099e4c4fed86cb3db294254f9cf5da1bd04ecfa4aaa869c7c1e3777be7cb8f2ba2395de2f2a0da2463db815c9d597e673fb9faaf73f2e37302bd5833f67bebd2b3c81a2cf649c46568d57f316bb22fd766397db10c1d2e07d3152e550847b8d0d89bbec91673b4cfd58b896e53dd2e87a297a9dde7e62352ec298c9a42763b811b5d02536fd82c68d34a9fa2b13bbb4b29dac1661a504e722f52f839695fed782e65c2ed983bc41e7c1e1a5ef1d6fd257e055c5831d5760342d031f0384194574497ab5c4036c20e939789f8a3cc21ba10d639703ec42423a7731714008d061ef9885759532811ec31ba152905987879d30f380493512e34bf850647a86fec203d8c89d4ced043ee21b8c3f3acf1f86c53286dc9a2055871f55932c3a49e05fa48283a6ebdb14d1d5d3310f4671f83daae5f21db56af1af98aabd583cca9e6e94e4c088299acd35a39ffe40f2259117622e00fd8d0abf8410645a8dba430021095ee6f018abb38bb9db94f404a8d0419a581a4d1e1301af466f27edf2a38d02188f8f54f7e6692c2d258c04e5c7c53da996ea6fc761b9d92fcfac02439192930d2172289d24d56e10525949c8234bb8ef2a9ab85f155792ef6141b0b813cfcbd3f2c3712f006b892d3d250e7b8e249d523c6dfbb0c0372c9880e534f19b215eced8155d29a4149820e0a11e96b02f31b4d9cff16dd63b6c16e4c4ab2bcd8a3a96124e4be9182aa10b1f9d1308959f1b809ce03d846536803627feaf2c3e27753b56f7db868542181f659baa64ca7ea00f303f5787a70773fc0f89a33a5d2f3e92c794bacf34ef8bb71ba6bb6b28cc3ac899458d3f978b8e557f994b983e7faf9af79b45702344d69c4195424fd1c794b406581614f7ec1da7869e6faac0f63557ceabf492cade7e2dda92839c72157e5f38452ceb456a702de698b12ee0f8489d34474e9f3526cf724b9a0cde01ffed35e051ccfbed70284cf8462408a74b7f6b308b29aae5d528e4812436655c6cd202aa30dd4522c3d2aec50de475e573d42b9023a1f40188d9ec3c002bcb8e58031cdaaeb308ed5145a5487638b2046ae927f5e02c477174cda3cd12d3e59dba1d4d48532a00c04bca8588d9ebc47dfcb5fe4d6f305cfd0ad7ff4c4f1547423058f9fdc155b18816f92ccbe20f77c7d96397f05d1e49e20b878672ed5519f93c45bd902fb65405598348df80dab83a4be18135c8c3a93b35011aedf8de8f34ec0e2abb72d7632df5a9b4a40d46a43aa11c9a29bd51fcbf87d9b5450d4a5b4563d72a70a9c383a23c560e82fdf32386a7334490ba65cf625ba08b9192a0e2942d3a034b42e8ea737916989e84c6ea55424fe8b470f58ba4d482441d5589ef7ddd8ca5d374d480a793b3af36b5c8c4900abf29a2ce01ed880118afb639b739eb5b94402cd4d472d6cc2351da350fc8a549488ac9d7d7e7f368f5e5c65def4a8bf6327c3ee8b14edb3b001897ed141de80f1db239108c7f58c0d3f1dced7970b5c45700ccf9083859a8ebc527c59eb669175a0be79f5c7b73aef0e0daddaac6b00293ca86ec04da2bc62dfa224ceb3825b1ec44b1c9fb5c8c8438c17a7a7885213859e8aa3f983c49472135800b8e9036a0b794deffc1f73eefe5a6f7094ec292578164c6df3faa7470e2cccc4e27369a579ffcc0a8c2d127b1de3d6c6b7b31d75580f3e28a31c8d32935b3b1b47e8afe2da806acd329a2ef7f23a9c944a86d7dcc43210da89c6ac81514c23de3601e04dc854ec22407cf31db5ad4bff44d12fa494e425ff4c80c4b2ee6166f1e6a05f5cc132947f00715d8ef917982e1a25e1b28a1ddd5f6668e138f39026d406b78355579cf22b9b2db3acf8706071d20dda560aaf23ee27965ed5f4033c90e77b82b268e2eac0d8726838168abf2e5c89698b361b2b0d662fc9b792ec0fcc318a929c3f67c143cd2213b454251253538d86d9b9bcff4c5c808977e2947237673e3fe8dfc7ee5a0f399f79993d1d3b7615a775cd87586b7bb4596fd1c5bf1df4760da0a55acd45eec14fae98b2cad21a25cd164cc8be54f158b9faad9c29aaa3c12d8fe4a056e3ea92a943e1a922f451fe199477b2f7411d938890cd7c2b491ae0517e3790adb35ae30d00f96f2901fc7d5729a4d10e783e3107868b0667e9f3981d95a1e667cb6fddefd512ea759d0b63b3466592a9cee6cc0697eb9760faea68cde0c77d5d589e5fc3c9789bfdabe4f27108b0e32596db2044314911424679d361849585ff42ad912b171a0bbe16eca9c3d95aec27912f13243e3b45f2cee60e1e2e8c649ac45cb78d84b9dd7d14244200c5f8f31ba5374a5da343482116ca9aa4fb54ba9170727ec2753659f9360828bef59f9a895b90a0b48c381cbb6cba7c17c07ae5c17525c570ea084d66947a3b4d0790362bb12178234684b11c1994a33dbb8c65697491734df809cc150b969ced5324c56124c7eed6336a4c4cf7c743d3dccb2e14fc962bce050cee8da2a60d4661b64fbf6712a03245ec55c49567aa3d438853d27fea4b40d9a9edaa8a06d95f1d6f10ad2e02ed9be470d3ff885f48839c1ead1cf444d479ca7def5096027dce2479447f1e6f7b2c8bd325d92cb57952a153bdd6d7d83d9fd5b82ad7fc1421c38448258b969b0f76f23bd5d44f768a2077f8332df0399aea64521baf1d95c859bdcacc6148f8c638b4d7b127b5b79c7939504102e95ace275363889f569450deaf54c20ab5ce9265a5bdeae21e9095134b87507306a31bc0db3da570bff2105ada4c9d0fe55e851961651bdf4e07fdf79999d84f2cb55f8a09e292952724057f8693892bdacd8f5ff88a1908f1b7b85db5d37615fec4c01a2fdc35b809cb636ec7a8082c9db9abd7f228570a67b9ab01136fb646f11205c785cf566e8dff973ce724af776fe4d017229c47a44710eb923b5a9788933f672f39cacee81f93d53482ae10637396151cd8b8578722e04402cc6925f2702738824a25095e759f5004fa64a814c6ce36fbd5ccc5dd16faef350a6cd9680f797ec4fe2b7897f505cc111531a76d9cb7b83d21073a2a50448283d0ceb7e06ef3f23db80a65e3ff495a0e86159215cc08bf8b0aac575c56c1ed92fd0d3e18df697494edc207813cfa8bea1ebee003c8e1c5dca28a98324a7c9f89057ee31b020cb7485faf467a4a5323b000b98d40fac0fee62021c633dd766c7e79a278c2f73be3d3a9b723fe664a78177a9e79c02cda3f7c955e898600c555f51b05849ec6674d65b3b6256c59d7d364faad0d82781444e6ab0524177e5b73494bd920fdce245252bb4a821e392091ce9adc014010609da293f7e0380f06db9cbba4f49f27e00cdc02b2651eeb33d8a3b6792d8b6ae620ee55e99fe359e1d49f8fc844e0aaef0de76eab418100a079f533240801d9e297dfb6d24ec06b3100c9392969d8b2fd6d5ef5c92edf3a1c70997668fe108465b163ea1888693c9cbe297ac5e864b01ea6f0a6b6e8d6f9af65b98e3414f2add81fc6d5a77bf37616087be202de1c36043ab1a0e4bcbe43b9042f4647faad11e5e8ba5bacf2aad7128f5e9df6b64a840b33de849fb504e2615f4c47a2dcfb9e8bd178e92d148b2a1ba14fe65b8ef1ac8023bab3103bd2a9a2c581d87a4638d345073118122b080eb961dd79fba57578ef43b6b01ec5ac9b3841bc9a01037fc1bb81a1f378a260d5965881f423972ac6a5e10e7b61345ec7fb5f8848b2d2cca6b5bd32529e1eddc6ebec0083078844170f64489ea28df6da6cf5493e2691d7e1a86c8b3fb65f7c84df0a067f944a7ec5e49810e01bb540c9be8203bcb1369fe6f9033d072cdb28431dc2bb0a1c1d602939f05fdcb97619e317104498a68c2a99cf0609f0a35414ac7155c65005ef46d5f4a5fe669c6f7be8c99ea0b22dc09ede37852ee888ce804f7f5057cfed3c7dcf4bb3ad9aa45cdc64abf3acf1f7ff974ef783edbec555b22923c4cd597b8c2944eaf5f5f66ed293e96bbe484d226b46783423ef0c2e73f23e47c4d384efc592faa63a755f0075bdf80e545d3411f442248a9f9c91d04dcd87d78eb4f89408b2f6789217b7f513d8e670df70160e723ce41afe23bcb7ded3e4548648af87649d95a2e294aa034b0d1d64c932ea6ba399e2e1b79ce22585620f3a5271e27bcd82269e8aa20c0a368d666200547930c01ac697b426be72d50d7c3c5bc5af095eced0946acfdb1a986cb3a04879d29bd320d5815dfd5663981381b415ec8788826691a9b14f47df0c3b1b2fde851cd216736b2abf2f7d4ca571257a351890e46c4affc5058a5d49f00ef89faee37f61bb00ea00e75eff00276279b08e92e8a4a5c881bb575cbe9f997b9b263f046afb3e68e14a4d6af30cff119164866aa9fafe3084e610e554d7bbebd6b4fee6173efae481dbe78e1720fa2673e77b5dc75a29be5418a09439d8a1bc8c874511a5ac0efe2be2399c80cf33e6381a20b68efd1b9c0e2bbc51957fe11aaf928735725349e1286b584a8dc2b7e497395ad1ba689d7dd19cd1691ff9c414840b4084f9fb2eefb5bdde9f51f8a1ab14897f33b5054f52fc40752f7c52b0dd370fa873004793326e8d45c9230a852a633e746b71f8aa4683365df805c0eb2fbcf9bd72fd355790479c30007820d82612e9e4e9351de0247be9e813016440cfea9b67288beca2640c32ee309bf75f38f6b21f4db6df9c3919e1d2e160d4644e2d2d3702be8122ee9df42df708d93b6cecb2f3a06805d57d9bc5afad49328f81af533e0d0b74eb5228374eed4851a4a44ffde2956f09ecaa9a4d8a6a0c752f537e717187cdc42994760b47018324ada77ef7011f799729c1508bf510d7301dd088fa683a89171dce643ff80d84f6352c3de5185bc727f7ddacc00a3f66ee847671c8c2430ee69d02cfb60e51ba3117289e25ba43b5a41d1815bedcc93cbf264d2ba689313e67acae3f09d2f3de003ac028a5e439f524c6b8c93f2a122154ac1673dce5bff6bad8761fddca949d8cee09715bd3d8424a553cd78a69da0d2025d80f34041e9686629108ba2c5bb184e137094b15018d82f6694b3544ce22aa60098fdaf4140e1e830e9d6600ef6e354dfad359d72c3f56b45e328ea8bc372fa3d022b500f1d1f0292d4259a9d4d81e1f552510e3a7c9724d0681f4862f302891a10f08c80b9f301f15780b59a083faced9b675087dcb36a7f38106588e88c4d63b74c0cf317b7b0c0fcfabfa31aff29600ccb1b0d9f280c56084b077b4ffb9516be031157c277394525246089834245772f924c2544f8446ccb8d426584bcaff87d91dae134593138ac3c076587c0e3c83e3946ab6bf536b1907eaa0aec4e28a9f5f12421c82613b4aad11c35a5032fadc60b564eb63ee75fd8293dc822cdf64dcab6b23c540814c580aa197d9b4d6ec8ffbecb297d767a1bedac0e97380359ecf2320c92083473885bfd3779d84f6b0e5d7c11b61e5e579db51bf726926a5ff9375c6f4e954c9371a79ee641636a5369d40781ee2c1ba4ef4eb70f1a891f0e4e6fa9d5a6998da2ab0a483acf14f7365bf8ed4631b111f1650e16c9f153fe90c342fd1cb2d12d5801563bfebb9bf24dd6a469fb913c6fedc392c6aa3fc009e1ecaecf30ee7d8a88486056441902c9c66f0857d3b67b0a7d3d88a11dfb255176e371d227fffad8503e0024120b91aa519627c50caa9e288bbfac44b56e6f12bae5d326772632e279d8dab0845e5ef2e35d14f18b88f669590602abdfd9d1d6b2fd46db9f5d46a2e60f581be45b77a70ae91c76810e23a2f0fa2609775cf7d9181714e8e3d1c30dc891b2d15bb134e590c986a61ce6dfefb0c66ac2e7977c69ade31794e64776b3f32b941a97f694ebd84d1fda70f4bd8d66be9bfdfe5f99d83920daa94564e3bdf2e4edf8e1931a5d7419b12450052a623a508adf00e48e65b67919ee8d48fd9b83b0add3f3f2faa667ff1808c34d56f01671b5a82901a225eda1c103dfe29c4d88833761484e022ffde6e5d5fb363d0cf08f8d18233341402abf3d03fdb8d1092bf306843f5a252fe208ed672be75330080d51efc5d41df437d42d631b6b6eb46183213d8b66767ce156c3c540ea462f34f69174852fb12ed86f1a6b1542e1464ab3fd4b4f637d49c4c206206f32ba74bc1be80899fecb6eb08ac079b8af0aec813af38f9933c8e55dd6bc182d0435a78fe5af4a0fe4ce53396cc9bdf2da2185a8fbbf1545634f384056e8ec4cdcefaf2cdee50b53fc2712af054d231d6b80795a2f86918e77fef2430be4d8285c4571fe5abca0d93425f06125bcd7213c3e345d98c459f8299fcebb5d7c0e7c1ddd075ebf128b8d96bc35f0f3e0f3aa0aa6046bdff8526d7a82d726c3d077a9eec826f8d1839fa798d883f123adf7a7f1623a2a41e920e84ab627a0636aff00310901105c5bd7ae15fc2383d41577af2a402f5bdff498522105e4a9f8bc585e68f70837cad41b0f0465be122434884f0886b814b7230bc48c4e378a3f6f650916c72d58ac3591ea2d3061b4eae9dd68f3635dceab7e3e680c52b8c602ca1df1c5dbc47002ef207cdd53a727694bd0c114d1469310ff34cbed7581dd51d206160d1e40ec6d8f06746aed2082dc31767e134d42a95610cd1ee2a89b0ee91f1654245913ae0f48c29c8e259eaf5d80e4e9542b9cd74b8529aec1d254d86701c8cbb871c9455f558f4627fa9a1b71b65b6dcf869b9c578162b6a3ef3b221025fbbb40ca74d8df5bb31e4565596d61ab5e9be123a4f18c8d27876a3d1fb0387762790e16e69dee198859619b7854871f51801da96d8688ca2ddc885417f81d2787190066be485e91dcbd3387e89828b3ea27dc23174ce2355e8b7d588065a139c020c191b069d827d36bb8f3f146e75f26a1f47d3b2fd07959ae504a00058ec820e74455166056a903be2dfd539de8063a3324492d207476023cf02a14af388b986af672e54439f740c1470baaceb08f706865a4cef842ed352ed19db5c0a6a19bff9501d52de0cf7fe92cb237675d3bebe18468619bcc7464c815d8491baa8a0d7075891d828f439240b431dc4b31ebd810e006f55bafdf4aa5649fb82a27eb7d8d67c3a24a0da7567284aaf508cdcc6d56d31e24af90a66f8d76ffc3fa375b1e2c67c3c408e9784cf7739e8ca48b94f2f8777702609c4d051880b4a4aea56727042d3939bf9a61038d9bdb30193707be79835d7812a45e3cdc169cba2b9220ceb294a14f19a3c6cade2cd6783d82e4a75da29fdd3744f952ee72489165c429cda81185f5e0fc6bd7bfedbf0712df88e963e3fcd3674b7ce9d297323c9f92b9490eb42fa96f223d2ade19f4f79e16b58cfb1dc2898a02123357ef981cb798b57c1b5b3859cde30defeb8347ea2015b23cda65f822dbb08d8e7bcd8a569e584b17bcff72c195921932a004ba63a856e73d0bdcaf960c295e490d2f8ea3e506c1a306173bea3641d69b130e931818cf1fbfdde0c91c3005118460f8829a5bd608095b36c2e79b243d0d5e9955e9712cb19e9da189604ac717c7fa937d45e9f0146d1d8e34b343a18838a299036e33828aa4465f6200de54dd3f24656b634904882406809f142b185ebe73fa2d57592f4eb751796c9d7ee6f14beb8040c3573e5734091f17223b8c6302f5aae07bcfba74ac6e5ac725e621e31cfa76faee4eccf95cb8c1fcc2728b22df9f8e54b1adfbb5b85e6f04140c91ef1ac20c7a0fba32af046a448a4cb83b8f4817892cd0873f47aacd67dc863231317b4b91514da4ba6a58395e9fe791f9b1fac476106362572bebb422c3c2a14f8df6bc639d02ecd482686092cd60bd8d3fefdc50d174349f8630eacaa1314df82c4f916647605dd102735298550fb01f1ed523631983d96ebcec4a7463e20700d14f06402efc55e952105100b9daf655e62bd82fa528c3531f3205291b119f82e90ead825de90378d1ef15fd122f01a5cca5259f6015532c5337291ddd1b757fb957b9c9a2fcc3a20e74a33cd18a5845e5fbb9452455fc3b126532397bea5ca8161e23f57bd00ef0f43202899beff31178d073116ecab35664302a324b247a89f9bc4d9ede8aabf9252dcfe40cadfc04908543760f970b58ec1db53f7a832ead78654da30049226f65b470fed0871e0f44d12803f6fe353dd1dce76b2cf62b525e39793b6608f6c0381948a5d4e5cb2ce41e80880ba37cd8bf6dfdd097c97aa8d54804ff50a5cadf698ad24c76370d79bdba6da61a3dda812cf4c5bd760df756d6f3389600e8d4aa38f99eac78f13a88e8451aa81c42f4a3638b2d8d8d98b966e0cb4a183dc7b2e5db8d0d03d99f6d52c8a67061bb570ea1bb16d3eafab000efaf60a42d09af4dabb91b0aa0caa625c9e3aa149dac5744034b01576437866812afc83910a24e414bdabd18fb68398b9f29c15c692b786447476c8a404797b746ce19f6485bffa138851264125577c760c39a2fe60900639e9f788660a1c627cc6c1759f0076a55c4ceff3becba26be0214e1c560b50c925a868d12a8756bdade07209e21da7380e764ef8876987ee35acdfa825a8ccc89beec393ea6fc1604a108413a803887bf1c541f3ef1b093b55d128addb062ebc71c3c75e5dd37ddc3939107e66c277d5bef327d9772ec9112fc269669a2f868d38297a4862097b46db9db5b0610ed20bc058dfe15bb1e89d67da53726f12be56db2cf0bfb328f9ae3406e9a5b8d6a8a75b2af2df24c234ab2b002021042b6a514fba7f3a1bee066bd5e9a83210ea745310c8816d81a7c82f6915b8dc12a20e78421740f7a0fc0b30bd5240a6ea1aaec63193ebdc635e4cfbdaba1259d7e3102847eee00e716cebd2b245607a1fe1c74afdb4621cc1dd163e3170d396f4f7194b5632ca39992c5f67e872d2bf4fa0091342248a3ac6d9e73baea13d7c74e98bd3f0bf10a720645f236fa1ecbaef658ad1ebc41f01e9ffb56cd42e9350c6686894c69e15a926851492bb648961e0e02831ccc0f177c8e3d9d0bb406b1184dda6b300b8b36cdf91b5f6c12a46e0eaf369f4233aea70dbcc46f2169058494e62a83fb77fa06aac2cdac0527e3c7893308f7a791c59dc9dc683a4184a097b6556fe81e7a7c23ec9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
