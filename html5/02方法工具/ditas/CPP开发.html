<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>C++开发</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="C开发-83590AA6"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">C++开发</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p">一，概要</p>
<p class="p">C++是一种使用非常广泛的计算机程序设计语言。C++是一种静态数据类型检查的，支持多范型的通用程序设计语言。它支持程序化程序设计、数据抽象化、对象导向程序设计、泛型程序设计等多种程序设计风格。</p>
<p class="p">贝尔实验室的比雅尼•斯特劳斯特鲁普博士在20世纪80年代发明并实现了C++（最初这种语言被称作「C with Classes」）。一开始C++是作为C语言的增强版出现的，从给C语言增加类别开始，不断的增加新特性。虚函数（virtual
function）、运算符重载（operator overloading）、多重继承（multiple inheritance）、模板（template）、异常（exception）、RTTI、命名空间（name
space）逐渐纳入标准。1998年国际标准组织（ISO）颁布了C++程序设计语言的国际标准ISO/IEC 14882-1998。遗憾的是，由于C++语言过于复杂，以及他经历了长年的演变，直到现在（2004年）只有少数几个编译器完全符合这个标准。</p>
<p class="p">另外，就目前学习C++而言，可以认为它是一门独立的语言；它并不依赖C语言，我们可以完全不学C语言，而直接学习C++。根据《C++编程思想》（Thinking
in C++）一书所评述的，C++与C的效率往往相差在正负5%之间。所以有人认为在大多数场合中，C++完全可以取代C语言。</p>
<p class="p">C++语言发展大概可以分为三个阶段：第一阶段从80年代到1995年。这一阶段C++语言基本上是传统类型上的面向对象语言，并且凭借着接近C语言的效率，在工业界使用的开发语言中占据了相当大份额；第二阶段从1995年到2000年，这一阶段由于标准模板库(STL)和后来的Boost等链接库的出现，泛型程序设计在C++中占据了越来越多的比重性。当然，同时由于Java、C#等语言的出现和硬件价格的大规模下降，C++受到了一定的冲击；第三阶段从2000年至今，由于以Loki、MPL等链接库为代表的产生式编程和模板元编程的出现，C++出现了发展历史上又一个新的高峰，这些新技术的出现以及和原有技术的融合，使C++已经成为当今主流程序设计语言中最复杂的一员。</p>
<p class="p"><a class="xref" href="http://www.deepcast.net/wiki/vc" target="_blank" rel="external noopener">VC</a>&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/bcb" target="_blank" rel="external noopener">BCB</a></p>
<p class="p">二，发展历史</p>
<p class="p">Stroustrup工作起于1979年的C with Classes。这个构思起源于Stroustrup 做博士论文时的一些程序撰写经验。他发现Simula具备很利于大型软件开发的特点，但Simula的执行速度太慢，无法对现实需求发挥功效；BCPL虽快得多，但它过于低阶的特性，使其不适于大型软件的开发。当Stroustrup开始在贝尔实验室工作时，他有分析UNIX核心关于分布式计算的问题。回想起他的博士论文经验，Stroustrup开始为C语言增强一些类似Simula的特点。之所以选择C，是因为它适于各种用途、快速和可移植性。除了C和Simula之外，同时也从其它语言中取得灵感，如ALGOL
68、Ada、CLU以及ML。刚开始时，类别、衍生类别、储存类型检查、内联和预设参数特性，都是透过Cfront引入C语言之中。1985年10月出现了第一个商业化发布。</p>
<p class="p">1983年，C with Classes改命名为C++。加入了新的特性，其中包括虚疑函式、函式名和运算子重载、参考、常数、使用者可控制的自由空间储存区控制、改良的类型检查，以及新的双斜线(//)单行批注风格。1985年，发布第一版《C++程序设计语言》，提供一个重点的语言参考，至此还不是官方标准。1989年，发布了Release
2.0。引入了多重继承、抽象类别、静态成员函式、常数成员函式，以及成员保护。1990年，出版了The Annotated C++ Reference
Manual。这本书后来成为标准化的基础。稍后还引入了模板、异常处理、命名空间、新的强制转型，以及布尔类型。</p>
<p class="p">随着C++语言的演变，也逐渐演化出相应的标准链接库。最先加进C++标准函式库的是串流I/O链接库，其用以取代传统的C函式，如printf和scanf。随后所引入的链接库中最重要的便是标准模板库，简称STL。</p>
<p class="p">多年后，一个联合的ANSI-ISO委员会于1998年对C++标准化(ISO/IEC 14882:1998)。在官方释出1998标准的若干年后，委员会处理缺陷报告，并于2003年发布一个C++标准的修正版本。2005年，一份名为Library
Technical Report 1（简称TR1）的技术报告释出。虽然还不是官方标准的一部分，不过它所提供的几个扩展可望成为下一版C++标准的一部分。几乎所有目前仍在维护的C++编译器皆已支持TR1。</p>
<p class="p">虽然C++免专利，但标准文件本身并不是免费的。</p>
<p class="p">1,C++名字的由来</p>
<p class="p">C++这个名字是Rick Mascitti于1983年中所建议的，并于1983年12月首次使用。更早以前，尚在研究阶段的发展中语言曾被称为「new
C」，之后是「C with Classes」。在计算机科学中，C++仍被称为C语言的上层结构。它最后得名于C语言中的「++」运算子（其对变量的值进行递增）。而且在共同的命名约定中，使用「+」以表示增强的程序。Stroustrup说：「这个名字象征着源自于C语言变化的自然演进」。C+是一个和C/C++无关的早期程序语言。</p>
<p class="p">Rick Mascitti在1992年被非正式地问起名字的由来，他表示这是在半开玩笑中说出的。他从没想过C++会成为这门语言的正式名字。</p>
<p class="p">有一个关于C++名字的笑话是，当你使用后缀++时，附加只发生在运算之后（因此，它应该是++C，而不是C++）。</p>
<p class="p">2,未来发展</p>
<p class="p">三，设计原则</p>
<p class="p">在《C++语言的设计和演化》(1994)中，Bjarne Stroustrup描述了他在设计C++时，所使用的一些原则。知道这些原则有助于理解C++为何会是现在这个样子。以下总结了一些原则，详尽的内容可参阅《C++语言的设计和演化》：</p>
<p class="p">* C++设计成静态类型、和C同样高效且可移植的多用途程序设计语言。</p>
<p class="p">* C++设计成直接的和广泛的支持多种程序设计风格（程序化程序设计、数据抽象化、对象导向程序设计、泛型程序设计）。</p>
<p class="p">* C++设计成给程序设计者更多的选择，即使可能导致程序设计者选择错误。</p>
<p class="p">* C++设计成尽可能与C兼容，藉此提供一个从C到C++的平滑过渡。</p>
<p class="p">* C++避免平台限定或没有普遍用途的特性。</p>
<p class="p">* C++不使用会带来额外开销的特性。</p>
<p class="p">* C++设计成无需复杂的程序设计环境。</p>
<p class="p">四，标准链接库</p>
<p class="p">1998的C++标准分为两个部分：核心语言和C++标准链接库；后者包含了大部分标准模板库和C标准链接库的稍加修改版本。存在许多不属于标准部分的C++链接库，且使用外部连结，链接库甚至可以用C撰写。</p>
<p class="p">C++标准链接库充分吸收了C标准链接库，并佐以少许的修改，使其与C++良好的运作。另一个大型的链接库部分，是以标准模板库(STL)为基础，STL于1994年2月正式成为ANSI/ISO&nbsp;C++。它提供了实用的工具，如容器（如：向量和链表），迭代器（一般化指标）提供容器以类似数组的存取方式，以及算法进行搜寻和排序的运算。此外还提供了(multi)map（关联数组）和(multi)set，它们都使用兼容的界面。因此，以下成为可能，使用模板撰写泛型算法，它可以和任何容器或在任何以迭代器定义的序列上运作。如同C，使用#include指令包含标准表头，即可存取链接库里的功能。C++提供69个标准表头，其中19个不再赞成使用。</p>
<p class="p">使用标准库（例如：使用std::vector或std::string来取代C风格的数组）有助于导向更安全和更灵活的软件。</p>
<p class="p">STL在纳入C++标准以前，是来自HP和后来的SGI的第三方程式库，标准中并未称之为「STL」，它只是标准库中的一部分，但仍有许多人使用这个名称，以别于其它的标准库（输入/输出串流、国际化、诊断、C链接库子集，等等）。</p>
<p class="p">C++中的特色</p>
<p class="p">和C语言相比，C++引入了更多的特性，包括：陈述性宣告，类似函式的强制转型，new/delete运算子，布尔类型，参考类型，预设参数，函式重载，命名空间，类别（包括所有和类别相关的特性，如继承、成员函式、虚拟函式、抽象类别和建构子），运算子重载，模板，::运算子，异常处理和执行时期识别。</p>
<p class="p">和普遍认为的相反，C++不是第一个引入const关键词的。Const是在正式引入C语言不久之后，才被C++采用。</p>
<p class="p">C++在某些案例中（见下「与C不兼容之处」），进行比C还要多的类型检查。</p>
<p class="p">以「//」起始作为批注起源自C的前身BCPL，而后被重新引入到C++。</p>
<p class="p">C++的一些特性，C不久之后也采用了，包括在for循环中宣告，C++风格的批注（使用//符号，和inline，虽然C99定义的inline关键词与C++的定义不兼容。不过，C99也引入了不存在于C++的特性，如：variadic
macros，和以数组作为参数的较佳处理；某些C++编译器可能实作若干特性，以作为扩展，但其余部分并不符合现存的C++特性）</p>
<p class="p">一个常见的混淆其实只是一个微妙的术语问题：由于它的演化来自C，在C++中的术语对象和C语言一样是意味着内存区域，而不是类别实体，在其它绝大多数的对象导向语言也是如此。举例来说，在C和C++中，语句int
i;定义一个int类型的对象，这就是变量的值i将在赋值时，所存入的内存区域。</p>
<p class="p">与C不相容之处</p>
<p class="p">C++一般被认为是C的超集（superset），但这并不严谨。大部分的C代码可以很轻易的在C++中正确编译，但仍有少数差异，导致某些有效的C代码在C++中失效，或者在C++中有不同的行为。</p>
<p class="p">也许最常见的差异是，C允许从void*隐式转换到其它的指标类型，但C++不允许。下列是有效的C代码：</p>
<p class="p">int *i = malloc(sizeof(int) * 5); /* 从 void* 隐式转换为 int* */</p>
<p class="p">但要使其在C和C++两者皆能运作，就需要使用强制转换：</p>
<p class="p">int *i = (int *) malloc(sizeof(int) * 5);</p>
<p class="p">另一个常见的可移植问题是，C++定义了很多的新关键词，如new和class，它们在C程序中，是可以作为标识符（例：变量名）的。</p>
<p class="p">在最新的C标准(C99)中去除了一些不兼容之处，目前也支持了C++的特性，如//批注，以及在代码中混合宣告。不过C99也纳入几个和C++冲突的新特性（如：可变长度数组、原生复数类型和复合逐字常数），所以语言的分岐可能还是大过合并。</p>
<p class="p">若要混用C和C++的代码，则所有在C++中呼叫的C代码，必须放在extern “C” { /* C代码 */ }之内。</p>
<p class="p">C++的Hello World程序</p>
<p class="p">在使用兼容C89标准（也称为ANSI C）的编译器时，下面这个程序显示“Hello, world!”然后结束运行：</p>
<p class="p">#include &lt;iostream&gt;</p>
<p class="p">int main()</p>
<p class="p">{</p>
<p class="p">std::cout « “Hello, world!\n”;</p>
<p class="p">}</p>
<p class="p">在使用兼容C99标准（ISO/IEC 14882-1998）的编译器时，下面的程序也是可以的：</p>
<p class="p">#include &lt;iostream&gt;</p>
<p class="p">using namespace std;</p>
<p class="p">int main()</p>
<p class="p">{</p>
<p class="p">cout « “Hello, world!” « endl;</p>
<p class="p">return 0;</p>
<p class="p">}</p>
<p class="p">根据ISO C++的规定，main函数的形式只能是</p>
<p class="p">int main()</p>
<p class="p">{</p>
<p class="p">…</p>
<p class="p">}</p>
<p class="p">以及</p>
<p class="p">int main(int argc, char * argv[])</p>
<p class="p">{</p>
<p class="p">…</p>
<p class="p">}</p>
<p class="p">尽管如此，但在大部份编译器上，</p>
<p class="p">void main()</p>
<p class="p">{</p>
<p class="p">….</p>
<p class="p">}</p>
<p class="p">也被支持。</p>
<p class="p">语言特性</p>
<p class="p">运算子</p>
<p class="p">主条目：C和C++运算子</p>
<p class="p">预处理器</p>
<p class="p">C++主要有三个编译阶段：预处理、转译成对象码和连结（最后的两个阶段一般才视为真正的「编译」）。在第一阶段，预处理，会将预处理器指令替换成原始码，然后送到下一个编译阶段。</p>
<p class="p">预处理器指令和宏</p>
<p class="p">预处理指令的运作方式是根据使用者定义的规则，简单的把记号字符序列置换成其它的记号字符序列。它们进行宏置换、含入其它的档案（由底层至高阶的特性，例如包含模块/包/单元/组件）、条件式编译和条件式含入。例如：</p>
<p class="p">#define PI 3.1415926535897932384626433832795028841971693993751</p>
<p class="p">每次在原始码中出现的PI，将会替换为3.1415926535897932384626433832795028841971693993751。另一个普遍的例子是</p>
<p class="p">#include &lt;iostream&gt;</p>
<p class="p">它从标准库表头iostream含入（汇入）所有的符号。除了以上提到的常用指令以外，还有几个额外的预处理器指令，可以用来控制编译流程、条件式含入或排除代码区块等等。</p>
<p class="p">C++教程</p>
<p class="p">《C/C++程序设计学习与试验系统2009.6》（这个C/C++试验系统2009新版免费功能已经很全了，注册后可用功能增加了些便于操作和分析的功能）</p>
<p class="p">参考资料：</p>
<p class="p"><a class="xref" href="https://qyiyng.bay.livefilestore.com/y1pzQmuEun911QBk08Wgqi8zXOSo0QtFPh1quKX_SyM5ukT7z21ifGmceO_NAZe0MumCqCl-7tCNBOU4Dhq2_fKChf5Ys9LDY7O/21%E5%A4%A9%E5%AD%A6%E9%80%9AC++(%E7%AC%AC%E5%9B%9B%E7%89%88).7z?download" target="_blank" rel="external noopener">21天学通C++(第四版).7z|</a></p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93Code.rar?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道Code.rar</a>&nbsp;908k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_ActiveX%E6%8E%A7%E4%BB%B6.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_ActiveX控件.pdf</a>&nbsp;285k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_Hooks%EF%BC%88%E9%92%A9%E5%AD%90%EF%BC%89.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_Hooks（钩子）.pdf</a>&nbsp;128k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_Menu-%E9%9D%99%E6%80%81%E8%8F%9C%E5%8D%95%E5%92%8C%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_Menu-静态菜单和动态菜单.pdf</a>&nbsp;95k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_Text%E6%96%87%E6%9C%AC%E7%B1%BB%E7%9A%84%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_Text文本类的部分操作.pdf</a>&nbsp;114k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E5%85%B3%E4%BA%8EMFC%E7%94%BB%E5%9B%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93_MFC%20%EF%BC%88Draw%EF%BC%89.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_关于MFC画图的一些总结_MFC （Draw）.pdf</a>&nbsp;131k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_动态链接库.pdf</a>&nbsp;192k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E5%9B%BE%E5%83%8FGraphic%E7%9A%84%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_图像Graphic的相关处理.pdf</a>&nbsp;135k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90%E7%9A%84%E5%90%84%E7%A7%8D%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_对话框资源的各种属性方法的使用.pdf</a>&nbsp;131k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E5%B1%9E%E6%80%A7%E8%A1%A8%E5%8D%95%E2%80%94%E2%80%94%E5%90%91%E5%AF%BC%E7%9A%84%E5%88%9B%E5%BB%BA%20.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_属性表单——向导的创建 .pdf</a>&nbsp;133k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%92%8C%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%AF%BB%E5%86%99.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_文件读写和注册表读写.pdf</a>&nbsp;133k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E6%96%87%E6%A1%A3%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_文档与序列化.pdf</a>&nbsp;303k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E7%AC%A6%E9%81%BF%E5%85%8D%E5%A4%9A%E6%96%87%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E9%97%AE%E9%A2%98%20.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_用预编译指令符避免多文件工程中重复定义的问题 .pdf</a>&nbsp;52k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E7%AA%97%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%98%E6%8D%A2.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_窗体类型的各种变换.pdf</a>&nbsp;161k</p>
<p class="p"><a class="xref" href="https://sites.google.com/site/deepcast/Home/technic/codinglanguage/Cplusplus/VC%2B%2B%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%9F%A5%E9%81%93_%E7%AA%97%E4%BD%93%E9%87%8D%E7%BB%98%EF%BC%8C%E5%9B%BE%E5%83%8F%E6%9B%B4%E6%96%B0.pdf?attredirects=0" target="_blank" rel="external noopener">VC++从零到知道_窗体重绘，图像更新.pdf</a>&nbsp;176k</p>
<p class="p"><a class="xref" href="http://www.google.com/url?q=http%3A%2F%2Fwww.prglab.com%2Fcms%2F&amp;sa=D&amp;sntz=1&amp;usg=AFrqEzepH01jGWHQy48EYhEr7DJ-kZSXRg" target="_blank" rel="external noopener">C++ 基础教程</a></p>
<p class="p"><a class="xref" href="http://www.google.com/url?q=http%3A%2F%2Fzhidao.baidu.com%2Fquestion%2F52774371.html%3Ffr%3Dqrl&amp;sa=D&amp;sntz=1&amp;usg=AFrqEzddKUvY9SsaeDI7ay9AZjg3hkg20w" target="_blank" rel="external noopener">求《C++程序设计》电子版教程</a></p>
<p class="p"><a class="xref" href="http://en.wikipedia.org/wiki/C%2B%2B" target="_blank" rel="external noopener">C++ in wikipedia</a></p>
<p class="p"><a class="xref" href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%25AF%2594%25E9%259B%2585%25E5%25B0%25BC%25C2%25B7%25E6%2596%25AF%25E7%2589%25B9%25E5%258A%25B3%25E6%2596%25AF%25E7%2589%25B9%25E9%25B2%2581%25E6%2599%25AE&amp;sa=D&amp;sntz=1&amp;usg=AFrqEzepyZilC5s5JzyS6kNIpmkN4vfGxA" target="_blank" rel="external noopener">比雅尼斯特劳斯特鲁普</a>（Bjarne Stroustrup），世界上使用最广泛和最成功程序语言之一C++的创造者，在接受computerworld的长篇采访中，<a class="xref" href="http://www.google.com/url?q=http%3A%2F%2Fwww.computerworld.com.au%2Findex.php%2Fid%3B408408016%3Bpp%3B1%3Bfp%3B16%3Bfpid%3B1&amp;sa=D&amp;sntz=1&amp;usg=AFrqEzdoQ4nLK7kANiQzlXPa13n2px5UKw" target="_blank" rel="external noopener">透露了每位软件工程师和程序员都应该了解的C++的各类大小事</a>，从开发起因（需要一个工具设计和实现Unix
kernel的一个分布式版本），&nbsp;<a class="xref" href="http://www.google.com/url?q=http%3A%2F%2Fzh.wikipedia.org%2Fw%2Findex.php%3Ftitle%3DC%252B%252B%26variant%3Dzh-hans&amp;sa=D&amp;sntz=1&amp;usg=AFrqEzdXjmTcx2a3B0s12yHQq55a_yaijA" target="_blank" rel="external noopener">C++</a>的名称由来（最初叫C with Classes，为C语言的增强。后来有人觉得原名会冒犯其他人，最后他在改名时挑选了C++，许多人都感觉++C更好，Stroustrup认为这会引起非geek的烦恼），除了不为人知的历史之外，他还谈论应该如何用C++编程。</p>
<p class="p"><a class="xref" href="http://www.cnblogs.com/volnet/archive/2006/08/22/483421.html" target="_blank" rel="external noopener">从零到知道from0toknow</a></p>
<p class="p">C加加基础语法参见</p>
<p class="p"><a class="xref" href="http://myhongkongzhen.javaeye.com/blog/393048" target="_blank" rel="external noopener">VC++学习笔记（一） —— C++经典语法知识|</a>&nbsp;<a class="xref" href="http://myhongkongzhen.javaeye.com/blog/390783" target="_blank" rel="external noopener">VC++学习笔记（一） ———WINDOWS程序内部运行原理|</a></p>
<p class="p"><a class="xref" href="http://www.pcstu.com/program/C__/sl/20070213/27044.html" target="_blank" rel="external noopener">『VC++技术内幕』学习笔记(目录)|</a>&nbsp;<a class="xref" href="https://qyiyng.bay.livefilestore.com/y1ps_JAPtHlpn-MEViVimpCfPn9fV8iWnaD9Cf08XRroOBw6vz7N3aXST7u62_LE0yE0syKiZRyT3AVzooqe2hvzPAfgx56zC5i/VC++%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.doc%20?download" target="_blank" rel="external noopener">VC++技术内幕学习笔记.doc |</a></p>
<p class="p"><a class="xref" href="http://d.download.csdn.net/down/1129028/hostbb" target="_blank" rel="external noopener">c++学习讲义（ppt）|</a></p>
<p class="p"><a class="xref" href="http://caterpillar.onlyfun.net/Gossip/CppGossip/CppGossip.html" target="_blank" rel="external noopener">語言技術：C++ Gossip|</a>&nbsp;<a class="xref" href="http://caterpillar.onlyfun.net/Gossip/" target="_blank" rel="external noopener">良葛格學習筆記
- doc.openhome.cc|</a>&nbsp;<a class="xref" href="http://caterpillar.onlyfun.net/Gossip/" target="_blank" rel="external noopener">良葛格文件下載|</a></p>
<p class="p"></p>
<ul class="ul">
<li class="li"><p class="p"><a class="xref" href="http://blog.csdn.net/liguo9860/article/details/37043911" target="_blank" rel="external noopener">C#调用C/C++动态库，封装各种复杂结构体</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://blog.csdn.net/xxdddail/article/details/11781003" target="_blank" rel="external noopener">C#调用C++DLL传递结构体数组的终极解决方案 </a></p></li>
</ul>
<section class="section"><h2 class="title sectiontitle">STL、ATL和WTL的区别</h2><p class="p">STL即 Standard Template Library
（标准模板库)</p><p class="p">STL是惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David
R Musser在惠普实验室工作时所开发出来的。现在虽说它主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。</p><p class="p">STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。</p><p class="p">从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。</p><p class="p">STL的目的是标准化组件，这样你就不用重新开发它们了。你可以仅仅使用这些现成的组件。STL现在是C++的一部分，因此不用额外安装什麽。它被内建在
你的编译器之内。因为STL的list是一个简单的容器，所以我打算从它开始介绍STL如何使用。如果你懂得了这个概念，其他的就都没有问题了。另外，list容器是相当简单的，我们会看到这一点。</p><p class="p">这篇文章中我们将会看到如何定义和初始化一个list，计算它的元素的数量，从一个list里查找元素，删除元素，和一些其他的操作。要作到这些，我们将会讨论两个不同的算法，STL通用算法都是可以操作不止一个容器的，而list的成员函数是list容器专有的操作。</p><p class="p">STL容器可以保存对象，内建对象和类对象。它们会安全的保存对象，并定义我们能够操作的这个对象的接口。放在蛋架上的鸡蛋不会滚到桌上。它们很安全。因此，在STL容器中的对象也很安全。我知道这个比喻听起来很老土，但是它很正确。</p><p class="p">STL算法是标准算法，我们可以把它们应用在那些容器中的对象上。这些算法都有很著名的执行特性。它们可以给对象排序，删除它们，给它们记数，比较，找出特殊的对象，把它们合并到另一个容器中，以及执行其他有用的操作。</p><p class="p">STL iterator就象是容器中指向对象的指针。STL的算法使用iterator在容器上进行操作。Iterator设置算法的边界
，容器的长度，和其他一些事情。举个例子，有些iterator仅让算法读元素，有一些让算法写元素，有一些则两者都行。 Iterator也决定在容器中处理的方向。</p><p class="p">你可以通过调用容器的成员函数begin()来得到一个指向一个容器起始位置的iterator。你可以调用一个容器的 end()
函数来得到过去的最后一个值（就是处理停在那的那个值）。</p><p class="p">这就是STL所有的东西，容器、算法、和允许算法工作在容器中的元素上的iterator。
算法以合适、标准的方法操作对象，并可通过iterator得到容器精确的长度。一旦做了这些，它们就在也不会“跑出边界”。还有一些其他的对这些核心组件类型有功能性增强的组件，例如函数对象。</p><p class="p">原文见：http://www.chinalinuxpub.com/doc/pro/stl.html</p><p class="p">----------------------------------------------------------------------------------------------------------------------------------------</p><p class="p">ATL: Active Template Library (活动模板库)</p><p class="p">可以看一下潘爱民关于《ATL Internals》的书评：</p><p class="p">ATL是一个产生C++/COM代码的框架，就如同C语言是一个产生汇编代码的框架</p><p class="p">ATL又不同于MFC，它完全面向COM组件，其技术路线也不同于MFC，MFC使用的是C++中的继承、封装、嵌套等常规技术，而ATL使用了C++中模板、多继承等高级技术，甚至还用到了STL。所以学习和使用ATL要求我们必须熟悉这些C++高级特性。另一方面，ATL结构完全针对COM中的诸多规范，这就要求使用人员必须非常了解COM规范，才有可能真正把ATL用好</p><p class="p">对于COM应用的开发，ATL无疑是首选的工具，与MFC相比，ATL的规模还不算大，但是从上述的介绍我们可以看出，ATL涉及到了COM的方方面面。
实际上，ATL的内容还要多得多，比如OLE DB的支持、MTS的支持等，尽管如此，如果我们有了这本书中的内容为基础，那么再去学习这些扩展的内容就会容易得多，结合ATL中实现COM的基本手段
加上这些应用技术的背景知识，我们可以很容易地掌握这些开发技术。</p><p class="p">但是如果我们要想熟练掌握甚至精通ATL的话，那么这只是一个开头，前面还有漫长的路要走。原因有多方面，一则COM本身异常复杂，不下苦功难窥全貌；二则ATL确实奥妙很多，它体现了C++语法的博大精深；三则ATL还存在很多错误，虽然本书作者指出了一些错误，但实际的错误肯定更多，这就对ATL使用者提出了更高的要求，如果使用过程中不能发现这些错误或者避开这些错误，那么用ATL反而会阻碍我们的工作。</p><p class="p">虽然ATL比较精深，但是这本书的讲解非常通俗易懂，语言比较简练，条理非常清楚。即使在读完这本书之后，它仍然可以作为参考书指导我们的开发和学习工作。我想，这就是好书的价值所在吧。</p><p class="p">----------------------------------------------------------------------------------</p><p class="p">WTL:Windows Templat Library</p><p class="p">见：http://www.c-view.org/journal/006/wtl.htm</p><p class="p">在ATL出现的时候，一些部分COM的编程人员开始觉得开发COM运用是一种快乐，因为使用它很方便地开发小规模的COM组件，但好景不长，现实的COM组件是包罗相当广泛的，特别当它们准备使用窗口控件，发现ATL提供的相当的稀少。因此Microsoft推出了半成品与没有技术支持的WTL，这也是WTL诞生的原因。</p><p class="p">很多初次接触WTL都问“WTL这三个字母代表什么呢？”：WTL全称为Windows Template Library，构架于ATL之上，采用C++模板技术来包装大部窗口控制，并给出一个与MFC相似的应用框架。他们紧跟着问“那我如何得到它呢？”：由于WTL是Microsoft推出的，在Microsoft的PlatForm
SDK中就有WTL是ATL的扩展，也是由ATL小组开发，包含在Microsoft于2000年1月发布的开发平台SDK包中（也可以从Microsoft网站上下
载），虽然Microsoft没有正式支持。WTL通过提供一个用于编写Win32应用程序和控制的轻量级的框架，一些特殊的视图，GDI对象和实用的
类，来扩展了ATL窗口类WTL设计特性--附带地，相对于MFC的优势--包括：</p><p class="p">模板化，因此有较小的代码量。例如，一个简单的“hello
world”SDI应用程序，基于WTL的程序只有24KB，而MFC静态连接结果是440KB，MFC动态连接的结果是24KB+1MB。</p><p class="p">无太多相关性，并且可以自由地和SDK代码直接混合。</p><p class="p">不会强迫使用特定的应用程序模型，尤其相对于MFC的应用程序框架。</p><p class="p">WTL类包括：</p><p class="p">标准控制（编辑框，列表框，按钮等等）</p><p class="p">公共控制（包括列表视图，树形视图，进度条，微调按钮）</p><p class="p">IE控制（rebar，平面滚动条，日历等等）</p><p class="p">命令条，菜单，和更新UI类</p><p class="p">公共对话框</p><p class="p">属性单和页类</p><p class="p">框架窗口，MDI框架和子框架，分隔条，可滚动的窗口</p><p class="p">设备环境(DC)和GDI对象类（笔、刷子、位图等）</p><p class="p">打印机及其信息和设备模式类</p><p class="p">实用工具类：包括CPoint, CRect, CSize, 和CString类</p><p class="p">WTL AppWizard允许你生成SDI、MDI、多线程SDI和基于对话框的应用程序。多线程SDI应用程序就象IE或Windows
Explorer（我的电脑），看起来象是启动了多个实例，实质上它们是同一进程的多个视图。这些视图可以是普通的基于CWindowImpl的窗口，或
基于窗体、列表框、编辑框、列表视图、树形视图、丰富文本编辑框或HTML控制。你可以让你的应用程序拥有rebar、命令条（如同Windows
CE）、工具条或状态条。你的应用程序可以包含ActiveX控制，甚至可以是一个COM服务器。</p><p class="p">WTL = Windows
Template Library，可以说起源于ATL 类库中关于Window 创建/管理的类。主要原因是用原始的 WIN32 API
编写漂亮的用户界面工作量大，繁杂。MFC 虽然提供了一套很好的封装，但是也不是很容易消化和使用，特别是各个MFC 类之间耦合很紧，要用好MFC
就要理解很多 MFC 内在的运行机制（有人说 MFC 的封装是“白盒”封装，呵呵）。WTL 利用 C++ 模版的高级功能，提供很联系很松散的“独立”的类库，使用起来比较方便，而且代码体积小，不必为了学习某个类必须学习一大堆相关的类。</p><p class="p">但是 WTL 不是 Microsoft 官方正式支持的类库，虽然有相当多的人和越来越多的在使用；不过有可能将来会支持的。</p><p class="p">参见：<a class="xref" href="https://blog.csdn.net/xdrt81y/article/details/17143135" target="_blank" rel="external noopener">C++ STL，ATL，WTL之间的联系和区别</a></p></section>
<section class="section"><h2 class="title sectiontitle">开发云服务</h2><p class="p">为什么选择C++，却不用Ruby或Python之类的动态语言来开发云服务呢，毕竟后者开发交付的效率高很多。</p><p class="p">&nbsp;</p><p class="p">James撰文（https://medium.com/swlh/starting-a-tech-startup-with-c-6b5d5856e6de）解释了他的理由。</p><p class="p">&nbsp;</p><p class="p">可以从两个维度来看。</p><p class="p">&nbsp;</p><p class="p">一.开发效率</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">C++并非动态语言，但是现代C++（C++11/14）提供了<strong class="ph b">类型推导</strong>。人们对C++有很多误解，比如认为在用C++时，必须使用原生指针（raw
pointer），必须输入长长的命名空间或类型信息，还要手动管理内存。而有了auto特性，开发者不必再输入那么多长长的类名和命名空间信息，C++会用类型推导来推断变量的类型。</p><p class="p">手动管理内存也是最常见的误解。从C++11开始，一般建议使用std::shared_ptr或std::unique_ptr<strong class="ph b">自动管理内存</strong>。这要比手动管理安全很多。</p><p class="p">要快速构建服务或产品，<strong class="ph b">高质量的库</strong>也是不可或缺的。不过在James看来，C++标准库还严重缺乏一些基本功能，而且有些API性能很差（比如从iostreams读文件）。Facebook提供了很多高质量的库，在构建OLAP云服务时帮助很大。</p><p class="p">&nbsp;</p><p class="p">1.Folly（https://github.com/facebook/folly/）</p><p class="p">&nbsp;</p><p class="p">这是一个不错的C++库，有很多高性能的类。James在其引擎中用到了fbvector、fbstring等类，与std::vector和std::string相比，它们性能更好。另外像Future，原子化的无锁数据结构也经常用到。</p><p class="p">&nbsp;</p><p class="p">Folly的容器性能很好（可以参阅：https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md）。</p><p class="p">&nbsp;</p><p class="p">另外，阅读Folly的代码对C++程序员成长也有很大帮助。</p><p class="p">&nbsp;</p><p class="p">2.Proxygen（https://github.com/facebook/proxygen）</p><p class="p">&nbsp;</p><p class="p">Proxygen是Facebook开发的一个异步HTTP服务器。James使用Proxygen作为HTTP服务器，将JSON数据插入到OLAP引擎，或从引擎获得JSON数据。只需要一天，就能创建一个调用引擎的高性能服务器。</p><p class="p">&nbsp;</p><p class="p">James将其与Python Tornado服务器做了对比，在一个EC2实例上，使用200个HTTP连接，C++/Proxygen每秒可以处理1
990 130个请求，Python/Tornado每秒可以处理41 329个请求。</p><p class="p">&nbsp;</p><p class="p">3.Wangle（https://github.com/facebook/wangle）</p><p class="p">&nbsp;</p><p class="p">James的OLAP引擎本质上是一个分布式的数据库，用于存储和查询多维数据。该引擎以Wangle作为应用服务器的基础。所有的逻辑都分解到了Wangle
handler中，可以链到一起构成一条流水线。每个服务器都是对称的，是相同的二进制可执行程序，没有主从之分。每个服务器节点可以通过定制的二进制协议交换数据或消息。</p><p class="p">&nbsp;</p><p class="p">二.硬件、人力成本</p><p class="p">根据前面HTTP基准测试，一台C++服务器的处理能力大约相当于40台负载均衡的Python服务器。服务器成本大幅减少。另外，如果开始选择Python，公司发展到某个阶段，需要提高服务器性能时，可能需要用C++重写，其实会浪费人力。</p><p class="p">&nbsp;</p><p class="p">总结</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p><p class="p">对于创业公司而言，C++可能并非最流行的选择，但现代C++确实是可行的选择之一，它可以提供接近C的性能和更高层的抽象。随着代码量的增长，构建时间可能是个问题，不过C++17的模块应该可以解决之。</p></section>
</div>
<nav role="navigation" class="related-links"><ul class="ullinks"><li class="link ulchildlink"><strong><a href="CPP%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.html">C++开发框架</a></strong><br></li><li class="link ulchildlink"><strong><a href="VC%E8%BF%90%E8%A1%8C%E6%97%B6.html">VC运行时</a></strong><br></li><li class="link ulchildlink"><strong><a href="CPP%E6%A8%A1%E6%9D%BF%E5%BC%80%E5%8F%91.html">C++模板开发</a></strong><br></li><li class="link ulchildlink"><strong><a href="GSoap%E4%BD%BF%E7%94%A8.html">gSoap使用</a></strong><br></li><li class="link ulchildlink"><strong><a href="CPPDLL%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8.html">C++ DLL动态调用</a></strong><br></li><li class="link ulchildlink"><strong><a href="CPP%E8%A7%A3%E6%9E%90HTML.html">C++解析HTML/CSS</a></strong><br></li><li class="link ulchildlink"><strong><a href="CPP%E8%B0%83%E7%94%A8DLL%E4%B8%AD%E7%9A%84%E7%B1%BB.html">C++调用DLL中的类</a></strong><br></li><li class="link ulchildlink"><strong><a href="CPP%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0Callback.html">C++回调函数Callback</a></strong><br></li><li class="link ulchildlink"><strong><a href="CPP%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90.html">C++文本解析</a></strong><br></li><li class="link ulchildlink"><strong><a href="BCB.html">BCB</a></strong><br></li><li class="link ulchildlink"><strong><a href="Socket%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B.html">Socket套接字编程</a></strong><br></li><li class="link ulchildlink"><strong><a href="DLL%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF.html">DLL注入技术</a></strong><br></li></ul><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80.html">程序语言</a></div></div></nav></article></main></body></html>