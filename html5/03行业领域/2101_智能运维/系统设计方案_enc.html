<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a090b89aeaace5274e6363ed88b7079add98ff9bc672fc512073782d46c8c6ac9dbb01185590c5a12bf673a1719499062718de0be8f1be4973bb177a3409ce6e4a787d0da0ddd89cc304f90e2742697b0e4349119f1956c142f01cca977fb8ae6a7515f1082d03531f03f53b41afd3a9712f0c2b2e9e42a73f346a8060f714b9a3b126409c652b08cf0d6e142924de1037db0622fd5fc374e2255b09054ce859b85aa6958c29611a8a043bf486971002250314e810827ca564d985d909853ccb6541a49fd49731ed9e7b150eec6c6a46334f4e5a87e3409979c35a78813e5e6e1dc4345d7cc042b0bc140a573f74132605ce65b637b45dbeddc42f0f7ff8b54b053f8a238c8dcdb1327105cdd8d9d93d263fc5f1486f8ce70fee45de184178fa3a8aa4397592452050f48b89ad0f263e8e71566f15bd0c59698711944762859807e0bc037ee0da3ca950144dcf072c9e4d88fce5885cf924cfac1b6ba61fa6d0c42a2bbcffb4778bbabbdd8d9fadbe26c6d40a9925ccd896593d59f7fee1f3aacb27a0f567b9ae22f6906a4fd80dacba97d3a92076e9eaf28ff8dee90a3ffd0e7958dd3e041bb6dfcc8f6b6c35a9a1e0716724614c5e8b934cfc01cbc726426598a556cba61668f511c3bed669686093a88775ba027ace549a79ed732f633ac51e722b19fa8ab5f3193c41c4a2614ba17b46087506342841aba7ee65691d4264e72054ecb788faa0f77a12edf3e7b43090522b40d8ffd68a88c23cabe3758c93d996fb79080addaf7b9b52f02fd0cf21513ed087745f4beb0e8295633c1fcb8f16295241905ad33a9e70fda2fd6c1c5da81e800bd2053f809add8b344c6ee0a2de892cb220b1c8e6392ba7b56e60aa3215d56593c1aed5b83f64a48de805dafb2c7925718bd2fcd9714ec212735c66952a4eba34794637fae8ebd486cde4112566e77d969b6399988047abf18ec93262b5756d15b76700aceba46c8de49599ecf194f27416d22fbde0be1f49066fabaa414d43b9c77c2a38486697e94a1924ca4d77e35b67bc4f62a89dbe5afdb14c40db55655f75f814d99b6e9c4ed79ab955c92da6104de02046b05d14776a62c30a702c4d7a8ba1ee2ab4fa52614b1097ab89b87011402526ea8a8cfce4285af338cd7c88346d340479d41d63d795f56f035c33afc8407fa63983995bfce22bd91b521e4dea24fe4e43791a2a2067012fd1acfa30773687dfbde4625bc1c33ef049d4f07a42d0cfdc79c7d18a163351436d695d4b00c676adbc0b30e830188a9324f42963dc03b63f4d1eca17343a486b393297b99e8920e310e63a242158d27d8190bc1fb00d37dda351685536bbe4598dc9990936d7564a98d53706caf45d78030d08fde6d33b5a1259a7383a30de13501bb537cd65d2c6ced5c3afa17614a65224792664da1257ae086dbdd84decbf7f31ac59222df2a098ecb2c37a1dd26b87575b9560aa77a037be7193f70a599eff28e34cacf6db6d233d35bd03345c46d5893b96dd2d07301fe99d33c786fa4da827e989acf42da5cbf7cee4740387f8abc7f33208c3e66e2aa34630ee8360e3a7822e9f8c404cc2d7ea4b5b65e49000921b4dff46ea236dc3acd12be6510ab71161df46168f798b67639e6dc31ef6a81ff400a0d4404bada2ab32f664f3dd8c9b8f0f9904f28785d9ee5390d3aff87d5d5f9ec53a46a64aa74f59c50f7172d42b8abb7bb5d53efc118c49bfa5d332667ff08e2120f12ae91a9a063eb7dc01f53297254625cc9e24c937d5035689f439f95923f0c7923fbfc42b4b0e928513d0ebca9400f8d285d2a9d5024a03e47315596b648d66594d3e22d5c65c2c18bf3f481c0c58d312ffb8b2e3f67d70922acfb6b768026a24848824861ebe716fa0ab8ac54755224f4ce4e1c909f665cadf04df3805ef2d7319b7242b961295e76bb4a2c202d12b07e9cb33d3ba1ac60a79f3ff3af83a86366d40424ea12bfc62571f8552ab8ad0df578e9ed1b2f79dd7c415a34104cab097bd0718e87594924d85de63b2ff94893c689d06b6f5fc10249cf9b05d26b53e64adc0ae8d03ef39c0178147412afbec24d5bd5429c73a6c6e2e162f3ab4a4c1421af6bc2780942b0d79cf88911e63cb17053d3685a50c98891af69ba4b41006b11d419f8c5c3d8089202d30158d91ff174bf80cd96c5afa910394dd98092ac00c949c1096431f8f50092c1fccf1bd5dd4fded552d2e9bd62e81aba278e24248af07649a8cc46a4771cc9049436c90e57f8049423ff612f4f476dc79bf62fc106f0a35cd0e4b5db2557eea100305b7ab84d02678ed8adb89b93de1499ff45b8e61dfb13736f25d1dc2ab0f15989b3652862e8a6cc637a0f77902693c09f3845885c3a721dda39414d1515a3bcfc39c0a24b28171805bcd853b5eda3b82cd38c24e4446ea4e69e029636cf7d9c3e3d70934b071d97e6da3b547497ad5afcb6fca3d7ff6c165320fcc410f4e3b9e13dd97c43ecdf836e6161000bab436fa7b6e35e65c3167158fed8ad4c140debded273ea0e3a567b32e8ab8f476cb49e06148f0960a55845cf9a4373e829c2a3547e9d0b6eab7792b01ef29985485612a261c94254b4187229e93a2d3d409bbb5f8aa004a826692681a3e1291ddc9604660ff194eb8c2197db8fb0a85a1611551d515f2656091a867cb9dcbce0331ddcc1c4059646de547af7612f81c92b2b31be7496373f953468fad74b96ff0f80d310079776b760abc1a4d00d33288ddde0d96e7efbd9f0106579498ef99305d5b4a17e962075e9f001925fa54569eef9fbea95cec69c68a8f6e1591f882ab2de896457a3d85f7f2fddab29570c0c4f01a9459e7cd000d4d1cc337a8a391423a2c81a5cbee1ab5a8a0b19bcb276314d97671db31aad6eb459b97e13f3ee63941699e15c6627b4f47655bed96abb41bacadf2c3522e458620d3c6894cdf91325512e1c79a2b945c1fab27f7fec40792b045c37f276c2cf29d6800ae1e4c59e58a4fc32858810b7caca05d95f3c6e4b3642378229ba0c7ba5a73b5e512d1b15d53ef77548369396344ee78833a4f7cd1b6b52888368f82e925c38afb4e984676ec257a3bb6922cab64453bd5464c6ccbc4f242afae76d792fd727ccaa3d59cfcdc49bc8ee882cf859bc2f59491878ec123db6c6e20901691d96a25a9758912c41cff2f6462fde808429b88bec9e7bb1772e0cd045a7c1a6c88c785727115c16cf13d61db908205c836cbb1a01e287f82b6a4ae61b5fd9d4db0b667c5d29700aba508f0841e39a3451b28612a6111503871c8ca11d07cc77d47effb228efabcaa15f8ae43929eb8fabae72cc700fba07205f1215e8439f0195c4c3b2ad0dd0863496c099b4f15a6d7e7c8ceb7521aa373937559b6bfe15d4628f3796ed8405f547ffe151f9af5456ec2c09e780be98ea0b0b247fb57b3335fe448c845e7ebdb17b918c9f89b6bd367129fa0a3f18df13eff260603e02c3367ec10d156ad9b741c00f55505757e9ef588e2adb7b3d8b242e7711c6b3727e1e928528ca5d2a8491b393f5c048efae02a25bf29c02b817b7b0dbec889d5b438aa5d25fd6ac1377a8c4253affff19b0c5f65bcc319a349fb2fad4a9863a86366191298c42e6593c7586008a019079e4580da4adca838a1bf3780a343eee9781bd510bcd14b7eb28f5395a8cea5a03d519ee71adfdb25c15b10b10a50984da83e4aec2bd60b0d267516acfa115e6eb4730d1632a2a76165cf7c61ba8f48a9a94c4e21a776a24db5f00a0c37e1af4998ef0d07bec5d5e932d15a0f62f495745add3c51f7057799d3ecfedccf07805731b5cb157c4a1336f492dd27d3541496befda808ee28ee807440879e3fd69f2092681a04aa2bf37ae11e268401615aba91d8a58b24a8c63065fba9c179ae6d7c8dbc7f2cf172cda836483fcebc59948d5380a5f299535cd0a0685a59bb896bf40366db9cae83819ea61d4feb114ab71ad2e13f613551adb979b8b8431d3a9c8cd7a2e17bae7bbd6b94916daced0fbc2bba4f7264660a9be5c1b08d1e634240a6c360fc65615b0ea5b0c2e8d4667b0a8082a2b1cce56953d97af5e73f3d53cb1d4a6108bd0357a6bd9d68f519dc1360adecef937aed04bd1bc78ec9662c45033348c4e02246a866b042e937a8d1ff88ac0974a5adf2488c0a9340108eb371bcc539d98dadbb804ff3bf6807fe5e4d95c432025943388952a9279c43032e3e00e80bbffce945d6607aaef55f3666dd2046feb045bce08717121a0426962122f851f5a65b8d63c1c20bf561a87f75b1cacc37e985b42570829a3f3db97dc59ceb842a236224de5311efeca40a6b5661bf65baf693b907e68ce2714da90c94ec78dcd8d3c536bf9f2002958f9944d5f93a1142b6a23b7c998b7c480a182d0e3c668bd7868cdb6a2a34e4e7bf4d411d79d47f7d8a7499c4293f33d3bdf40fb50f932f3fee10accfd1bb96620345b6727ff121e7d622768334a6c008601e704be1101dc8926e30e7b7cd7c02f37bc0dd916f912ef5075d00798d08a31ba5648dbbd33483d5faadc8fb9b8d359354d3e6e6d4c15a35de43cb2e37168a754a4090f3f11ebba3c33eadc1ab743c5d27faca756d20994352afb3d6281f56a566c477b15e7f46cb247b32dbc7365e73b05cc5b08c3fad55c0c0aa8b6747e1a18180eacd2d0259a49d69380b0bf6d4ff072e31bbf1ae9cf56d871e5daaad527cd8f935be6d2e0002e521d4d73c07208baeff1ad60629ee4daae45a70be4a1e28937f5bb85ecf84e0f628a6d0dd17959cadbeb6db8f7c03cab3b3bc29337ef190f6d821c984e3c0cc88c5070962cd505483bf7c44d278dcb732a0665a6360fc71861b5d735463b17cc96242e921450abac026b4dff0994aaf224b9010f6967aacf0b39494b5f22029427ec19bc82798ba78c4874f094e8babd2cbc0130b519853546ad9e5226913baaeaa45f54807de5daf2ead6d2bb864aeb41db6d5c8e3b02063da059f511fa8008d5184dea5da684d0aa7daef549c91d3c25f2e1c51acd604b71a9befa8eea66b3cae0e3b933f86f44811f8be9108e7ce69b0318d4154e38c8e16843ff94290cff9312977626a5aed848aa30d106ec220c5618c37b7134c2cb1f8fb64bfeecccda2cd8e0673b66d6dadf9d5c7c52d4c3d490b55491504c5ac0a1e21edb3bad5e06c5d27a05d8f47c2d197df8d0e55e2521514ef69dcd63da669c2f4e84de149be19aca9ae0d38079b1005713038299b2335e2ee2ee7af3e258f9db815cfc1cd47f330f67a2bd5824963f4826b0a8eb8410dc0986dd907920afcf52574659bbe91784c74686588b52582c869c021c21e68d6b8cdd7bfb7bd8690681a77cfe56582285583a760df852aa6d152c962142468e6735eba3878ddd5b7613d7419646dc4f121f12e54586ad700c76073fb4e9e37592e1b411867b6908c6baa2357c0452e42a9184606f5ab5185aed5b85f54c0b089a2db72d95d94bb7d60fc8cf0c321ca6a01e29f88c6d995bfe3e49f2657951c3194d6fdc4f19e9d64dd037a071a68064773ab8e66ca12051c02a1893ea5693c00c47ed6552f8a9796967fb09333d658a3dce97ef957971314a7df54f9178f5664e5eb86e2fd482a9664bfb8a4f182361d28378f3174eb4b6872fd4bb6b036f0c78d91d582f8a702b0dca7364be685ac5be529d7adf842021b0906df7d5b8f3ad2305842aec46604b7880938bfd216af54b09eb72427981fd353afc35dbddb318f05cd3c426dfb6c5e1d276e58dbb9d8314e9614e88414dd30cec518bcb6bf5687483387891aaa4a6815643062fdbec4a52017bec77763106e19d187d8ebda740142a322e80fb513f93254759b4979d1f7292d78ea79e60882dd18356c6a7f6a2a4bf1ff7731dfd99e27c03942f2495607614078059143978e1bc77245cfdeeb757d54769271837ad2beb8d066ef21afa948008674fbefb43e2578ebc02b784dcd264f579d318636a0805c111d72a5336387e8f27418a01bbaf440a6d727d92e936784c5c8f95c2adb3bb97da7a31032e4e8fb60e0ca2a357bee7894d69548aa2356fdad1e9d9bf821bfa4260fa543466ca45880b67a7ca08445624a05ee2af6f65d53918dfbf257c7ed83b90bb38a8932fe718ca61c35766820c1959b050d283774b83265ba609c739ce2edd43ea605944e01457b766cc3048cbcdaeacf01ae3e2826a9c3e816272fa7ec51c46da66b5be0fe003b2d9e54aa9e293e7620b3f92f31c3ac39a928078226e2b5317afe3d2f00511f101b4e21e705ce53c078d9bc4680386b91d49c8e867da94daaee45160029357e0329af61acfd6660f0be299ae663104b5df885dd528f9c28da24e9369bcdc6188e9b6454429315fd2f55c499236c5cc1230e5f6a59279b16d6be9008dbe777fa52f9faa38c260321f1a2ea5cece539b03b56e5bd57c83f683a2d2a0c96343739f7d4783cc4ed323c4c9c6eff2792390f56a0792253a2bb89ebc759e36f50b3bcc8efdd00a18c72143ecda674ef92956e11e8047093dfc40c4f84dafe8aa6eac69a2a660b1880d8506a9aae619cc6dfa9bcf42b6c84277ec128a9a66695fcde8b2e82ad6d2e3375d5c8368397f0eed30702d8d68e835e2a00acc06161e50b02ed7cdb2efe1babb6102d2dd11b55d9f3011c400a8fe88965d233e9a426abfc201b1ffc6d92ae06c43177c0b9e99ea87ee7cd50fdbda450dea7f067bc78e168f4e96ab3e8194e3c62ed24beb6c4a869b89b8e9a6197c85b04edf9f1bdb28a8f83d95f579e83df20dcf8dd711e483f64e3c1ddd408b6db7cba0bcc9051921216ac2b495790bdcf8b86b9859bc8b81e76b08ebc2bf5318e349c3b96dc80fb0bb75ef1f0f23dd4155c3ff5938ffee0a618c7fbe97f7a87dfab0d6e7a71a492d77717e2586ff574dc18fb3268fb24120d63d23019eeadc2ceecb239e438b32a67b16789f036e50cbab97e7e7d2c2e2aed5747783d8a9c668251071d521b33bb4596e691c1df6bb8aca6465cf9d4940b533d33be1f82a7b98ed5b9a4de5ced4c2127957411555e2fb66546895400b625175ca242b2e3a5f6dbab0d65f580bb9b1cfad23ae54db9763663048ce62f5e4654ba7f4e691c7f8221b455deaab21bada4936ddcdd23bd1ee83a6eb66918adca0b932796c4c8852af26f05acd9a657b19fd2796506a14d29153261a106f6cc8d8777cf4bd0887f5604f89157b21f36665a1cc6d5c45913c79756248401d4e2ece390d4cc32b976e016e820030e7d392e2daaed1290bf5489cb580e6980ba5dc7ea33e77227696d7d27c24b4bbd3992fd25757d5ecb4418f5d174d07228c11b73812cb5a7774d2d91670e389bf4ff30f8c372061bd22d5472f0574c73f20def70124a145f191a02dbf1748719760456439ab9e83621f26f72f96353559c1dc245265a7550af1be5fa14763297d708bcd148072cbaef4d77138aab3599ad159245ab0472f49a914c7f60574309c9bd6263a4ebff4c9d679a7394e1d85e453171923bdc4bfc7f8878d2b99146657bcf480f7ee4fdf12d3be8af149133d4596ded4ee9444d98d8a9f0f3c76bc7967a671473cc4cff5325d2ba233de1650aa5665bc1c9828f85f84c6c532b8693ab756e3e9d874c8cc2e1b294c23b22ea53e777cbb7f7f0bb44e6e75e94a8e67cefc435a23cf25e5ff4863ddd97725d643c16bc5ed69f3425d45ecc98563acfac38ddd574aea997b61ff9142762ef451e8eb875fb07ac67ed1973df81375a12cb955f27d3505d94b04897ed06ec9036f818002a11008335df1d1347867f912ede0a9848a7fb1a25f1faee801e48a2e2d1405b50dcd3cce3062ec1944493693132a8eac503d3d4796696ace015a125768802d7d79451accdc6e1702bc005831b0f4639c54c312c15af940e224a6f0baf65a0bfaba6d4282ede8e59e343f4a4df0324952e2afcf88660d7cc927483523c34e2498c891e011953fc209e718f5f28171265ff83741c2e6a91a3ce49e15faea857a6af9182da0e1743b1e430bc933afd6b31b4404564ca358af16e261c70b8e1b420009940c02c502263c5e2e41a670e7ee58e5d5bf94ab608e21b52e3911ed675cd7bc9a2d231b1c28134b2f33fd35a46e3abf8e3d0f9f1ed4d381d39c8973fbe5972987901debe8716a883094556b38bea69858a9cf1c6a272e4302f2b7ff834acf1a3ef4c7626eb6cfb946faaf9b02e75ab3e0864f10fd8edd919decc15fbc62d2d8a3e871a99e254a85a66602b42ac6c579db4c7269e2ae49fffef4cad78288ac5dadfb87f89d46d33cf47a7fe2bd5a3ed8a582c19309fde73675dbf7fd616d1bad8500c2087c0ae2ba1fd4349989dc50f7f543a53be9302b3d659f42b2bc101b4647c5b418edbd7afc088d409987c0194f12cfc0d2511a3ee12fe3fdca2f8cf6bb75d283d711a1dc24d64bc49fe7240ea633ed40544783a240a281d135e7b5e00c0d2755ecb72704be4d7dad451de5b343e67e81b065b9af40b004d28a0e06461dadab0272feac30a3cd8ebffeddaab3f7a39df346a7696dbc6ca1bfa469e33e99e0b726d39c918959ab45ae6c4ac690cda591cf052868570010d516aa3ceed3565b2e0a31c237a1de91dbe7646889b4f04f849b1a241ea871384196b715676be5463b06879182a992f516e3751c89c230ac7068328ac997aed4b358ad163bdaa61e022b5a68237c58dc3b3335bd52b4b79f35ca9fc2a290aca97d83bb188c1dc41511c8f157be790caca7e517d513f2d374be5964837e82c173f3ec9c747c69083ecf23c3ee0b48b189de77a87f1bbf95e5d6ca74d80eba3d67c802ba29f2bd23b1a8f18046d41ea949f7d0f8c1bbd4dc3f80111c8cbf7f297d2d41b2248d0f6bda0d506234103020c29865890af939a07cd93560d85e5c47616ba9e8996c678fa909105dec4eda2d4cdea842f1476a77212b1a5c12c1bac50ebf90115017484c4860116f8a511183da6f9b717ced36a69700b554ccc007691e890e67757abc0a55933a4f8e8e728a812606b2a3741239979dcceeee4aa1b73a28751b4f06efdce60039a9da19bbc60c202137341def329e3fd94feb5b708b1a0a74ff719c7e72b57938163e70b34cb1c26e060e5f5a13f9d860e9d48a97b10f5dcd66743dfe4bd6577a06c3394a9ea9e20691af2a061e4f7e4a4d7daf073e21ed8453ef503114db9478a97993818642d39c52a3396942efbaa02310f7da50e23d917a24f1976f87cfbe2e126e7c7912154d1a80d677f7dd1bc84bdcc2b86babff505c1530b12e96e9fe519b3253a4cc797239c216641e70b648112ade557f015f85a0d2390b1700a5732635f5356fcd88fbf9684feca9c8763b688ba077d08dd4a55deacabce7d97b243db93125b64608efdd4493b4de1f33cc7c40b740b08006a09d77da53d27388fcfb5933c6c1e722838fcd49db55e45f3c271f5226542a202be6d4127c72546e55d35f1b5a0ce761ee680d0b4ba654af0ffdce0c9c9b54783d9a516a0079b4c11a1cbd90439f577aaaf24885dd77f4cfeaf431b86e3066739a8fca42d0b870b0b01889d7061159e5ec963e572f9d6b4bc9ee90f0b03792c52f8f052ff0856abba9adb9dd1d8e111c819acbbb28ef999401c90b0d3431a84da30fd6529e0a21c03a79a025070a866532aad0d2c3f9612db6f32a4bafad19ee82dc525ad04c32ce3b939fce1dde3fd00441c3a1ed672e0f4bced45c0245cda5b45dcf78cc92b1c9dee696b36216e5e874d02e106626c41e9e5a0d6ce8172420d12d23bcdee6100372ef3bf11b9fa51171784dd24881932435b060c7a55b7720a43d56046d0250feb690aca9387a3bad52e9a93a9f50d1821105917b517739e201c379ca7b81d406b66fc05c34f1e03d6025ba881959fd0ee345e63d66717e9ec3195ad92d13598ed039ae26ac4736cd73b033689ea6677eeed03214f7f30a0296c2869f1b1e79e12bb9b350e321ac5c6b7636d42c81a89326586c48e6740df29c7e26dd8fce63df2c80b5703741736e980dd7ac2c0ad259e08ba2ca4ea81555e109d30d10ba79b5051eac55daf9a200cb95eed10df491b9744880553e0497c5d26e603ba0f801e6c9bd3ff3c477dd709f7e965175fba67a0884bffa60a12771ef410104a9cb07a2d95a3314596c87bc8b0fb28905904d55b7752396f3d2ee9436290dcac464043945ce624db89b0babf97b0c1a7f1d5a2a015deabdb0d9803434520fec0080dfae419d812e994bc0deb97a1c07e6b4a3593bfba4e885696eea0068c15adca5e214b27953439905dec0cc00019c70f9297053f4793ed74474d7de6b27df486dd67dd1d2b7652af8884167950fbae4208281e4d74c59f906a9ad02889a36f0ac72849eb4a3c927ed7ba895ebe86da344ed55813b3b40cd6948b5d63567b571dcff36f897993ac4d7a3fb41c29bc192eb8e0c0b9d573dca29757fabb651e3c47e739ce5b21082e7cc68bc455a5060c22bafc4e7bfebceaf8bd238d1234ac88b58ff2e73d555a8cbd50fe36f1b704a6c8ff8634d358ab7c40dbf0409dc7907264c5145e19660cc809d8cf1b73466125ed28642f815359d9e95723d4ac71ec8b060537aa8d5709a6c1ab707f6e856c86c37b151d87ddf99b1b4dd40d3568fa3c1e97e42faef8e6b955dfe0662bd1e3b85d00b22b4429268a9cc5cad4ffb3d79a2fe8d121fab5517ae9bad2627da95b0a1e368042c0f1b9ac95486c9d0ff95d56afe9cb5c1c42f22e4720e7e7d3d46486ccf78b522afcfccc7b29d71e0a676dd0720088d8f46e7f5f8856159f9e2b936ecb8f6eb11fb4c8c084136fece951302ebfc7c98c084a995b817d942ec93ef528c439a9cc9dcfff9094825cf7e3759ad619101fd7cd84a9ed02f96509747b656aa5cc072460eb1718d410059194c971cef9e339fc7b724a92aed6039fffa8d05981e421c8e4105fa20a7364cf417228b796c6b3f1990db127b7955ee9a69bc57106a71b3600c1c7f300b3921aeea409e5419d457b83cae157f59bfce977ba44bf1004531267bb39e66b959291217209ebdbbb59ca4ce412361efde43b640496860171d741fd77f680f7737831bd5e37585826a86807c245b82666b5180bb90e10ceca2db07d418844a157d169ed9c6bd1c785d9fde0a213e6b92bb24cc7c043b17ee80bb643ca37afd4cd30a71105493fe4f9d83416034338f6067ff41fd115531bce98dc276bea0ac833cd5063916e5ccc62dbfe65ce87fa55038b87363d7afbaa41b8c0f026f74508a41bc2d0769ba2aa7e343180808ff7f237fc742e7e4b559b36e3bf78c034edef01236a6cc6b4d60ac33c32369615095400e41c5833bdc91418dffe71dbdfca1ac25db6f4ca5d995b9fabed35b6dc98f265b2531a7c5a49022ac48f38847bc0a97209324dda295015545a5985144f3a850117ad9db75315a622362ef4ca61c5eb49780783c27579ae12a908b8917a7c3dd70547e5d876c275da9edcb57a5d5dd01cf8d71e0d61bcc2e260854fcf1a93607ac052f6e0a19e60c4d269466344d7fd5218ff651b31121faaaf9d644218c88279054d1cca3df8cc9b0da66efbecddcd36bc169bf6edc3b96cd344385d02923a14f1c31067ab6d1d8effb63d831d8f02fbe4d8cb280ba90607523646dd9274c8caca1292f05fe21bb56b99af2c71e2fdc50a46fab2dbb9e6e5e237609bf86cca0e72b693f422a710ad994593a0a7f6d2c291ec16d1e2125f0bffe1128bf6c0eff6d79755e6c94b16956cba23b9903c3b5e1748a0b9e1c195f5a1bcfba2008257ded1fdd32f14f4c3f43764c1158159128ebc84efc2e926ddd465dc5f99d48d2b40cf9dd088e9e06375ee07629e976752a51dbc423832ba55009d11e614752f6c1b42d14383a9611dcb1b61e42f3732e3c64c5a718c421396968a2a319db96182ee8d0150046b2b690a19dc531b36de1fa2e59ded6d3790728b11641a08898c1c18b7687d533e6b4537104dacab587434399b41f967b029bb71ccd9c004f55218d8d48bd2ba720bbfbd4ba1206c19c9674d65978b3a72dc85d40bb6d08357fa0db7e40894b321275afc47ebb4e9b84e1596073edff7b0905138d2aad936f1730c3e69b528c9ffd8c70684634203b7bccddf2d7cbf92821824db51bd44540e7d2ddae098acbc1409df1c50b55842926c7acbb8817b53a95a6d5c9cec4d8ca26f163a8bc3b72a9692ab4959cd5b80c00516e675be51cc8ceda498b5a9c5e08cb99b36dad05d9326e931013d7272f6f2b101f5685ab478195bbbe988e363686410e9a118756be523cc4687c4ab4b58e59a4c592f34af474665253e9434ce24c4217cdf8c0439dbe69f2885a6c6642bf6847a9acfe1be461bea21d6cab236803e5ecca5cec75fa24630f69b5bdba7c03685984bdf937776affb5a193b8dc28360fae7b03ed670805ea158da10c7ca0759cb1ce09577fc4ef52ecf2dad2be7071b3b0a0c8e12da02e58c2d0894b634eb1f3c17e99cb1e3ffd26a4fd135fa7fe855932e604d443d0ff63a3e9126617d580d1a99293a74ee1b53e0ddfcba86187d9c206c6050f317c0ffd96dddc00aee0469788c1920eadc08bb1751aa47064bd287adf3226f9f4b02f822e7175bb11b252e459cdc7f1bfc6863150c4811d0a144c590701a3f021e6085290ddc876c6d3c499da965915664e7b53d59d941fc00ba43d78d4806a07c9294c8671ea6c7f17a36eb9f365cb47e89c0b55acdf25ef0c6e718f7eafc7d24ee48598e0661ba9a72295f0c42bd573f5ade3d2fec71af09f75d6203d819fe4da9094951fc21d4f4950b9b4412cc58456fccd0ff5ba20869ae4c44151a027096e13a10cbbd3f0a2268370c2d75964b17186eeb42fb7fd8ccc8b828ead804e14a2bc92b17a858724c22c6a6d569a693bbe7e6af0966f089eb066b52f1531870e264c4fcd1cf1d3830a5c4d61c984228c4c5bfc822ab0bab9884ad0e7432cecef4e10e45f1f457a546dc1b6dfcf12f99ec251fd6d92e631b95dcb2307c3df5c205b9e116de64eb94c07542fd18a4b6dbc90dca3c2f28de351e0efc763368a415d839352403bf1b3de71c48794ece6e2fa6971f9c388b9608122ac68ef06bd3abf077d4d0f8913ed7d90df1445255bd7bd6ecba56361a934d86a4eb1eb7433fad2b4cd855bf2af61c63ca718936b73e2ae37debf40b78445ba454ff998a3c5b93713555d7d39cf4caa13a8bbc7d6ef2e2fc24c97df3958162147f5a5329b3c0fc727468cb4d8806cef8ba72189c040f83b7427c7292ba3edbf8496d086458dc3492e1f884bda2b6aced3d68b7c277204cb5f7e2657733071259a33c08c07a400b1cb4d8c2e0638d89fbc415eb28738a273554815b52442279f840c6281ca3185950c0962407f1710757b5a13520cb74860bd6a06fc98d9673c8ac68fd5a371acbc5c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
