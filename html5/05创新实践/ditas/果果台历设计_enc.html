<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2b933313314bf00d2aeae73b347f1950d6dd67fc6b769c5cdec70118cf05fe18612d993e98bc97b0a7f0af8e6dc4b386e67cf2bec130514d89d9ee0676486a4eab1485f8acd602af2cce7331afe8b5c11f0f5156b10940a74e8e36509acb5936240d15b14f1c7472ea351b4186d15a8504514f8e9cbe4133b1b0a2842759709c5a017922df26c8b838a96a33478cce50cecdf9fc5f7a0d469b51b83f443db6ba8d4cf8f1412a8c6bdd93bb07887a9acbcf9c19f8bd6c4ebd0c9ffb654448562a82c16c38ca47f3a22dd36dcfe29866a564d3bea7b90b5009c5553e9772d91f9190bb3aa6d2ccd03a224e6019e6bbbbc753735a15b3c09731857bad9cb9c3f27e8ccb6696dd2623121a7805c37aad3cd2617a7dcb225465d7222756376eac0702fa42a291e938f54f232649f7567b4f267e136f61df627d62d0b86eaab0d4ae2def2eb5e7133ca2fb3cbac9e8a2bfa01e9d36e40ef3ea9fe6a2f988a4308d9048ea6669421771a6d34be493b417c754e9377e408fb9a662bf6c1fbae5e216f50b4eae5e67fb258276604ad857a906729dcb7fdb454ad1cc64a5b8a9316e8e9ac30899c277403d206cd79684f1f5c29fe7a296d2458c58f81ff32341eb2acfa0ea48dc32b3b56fced805e16c6c2f1b4ccee671d847084aafc6bf9246dd9ccb40efa697e769d21b4dbd2c19e1115d1e272d1646d5bd3a5a82bb411b028a992f3037f004bfc3521829667f6238d8886cbe2262a0c8a8f27b58d1200afa3eaa8c50e88809c5eed8a0e9d946e981b63a6edf7a8201f40666e5e449774502e7d4ca1cbb78c19f1a32e342a2ebe0c15b1a97148f77f5430e7b9cdf5637e94cb70b49d3eead6ff65a1b87cf663e3542c44c86e005557fc3371a6837204df408c528115e4e2dc15f31015c61db4a62eadd5ee3c574bed65ce69b61599e0579b654fc0f53cf163a00a428f1f04d1984db8c6e9ab3f53018172aad5177a0d0e696b2f0d0e4036bf3932116603ef8cf3570b9b8536d6ec333375c6d9bef5dd9813ea3f7c254ca4dafbd1a14d3ecbaa250f1c199ee411c46e2eef23df5cd5d2ebb426c1451aae9de92804cbbc8ca44d260d51e553de3b79d619321a5fb340147c2cae60c1520825103e84246839bb05cb4c432a2bfcde52a9904afe59134a26b0b0385c8643f3f0eafa0ca349963550599adb59db8bc09dced90354fd3527b73f5c8b602cb6739b345bea3dda2f147ed53b23080ab74fa66c635c7e57c0e7028e03128082e5503ca89f75a4bf22d2f4f118aa70cb8a030ecc0a4507928b70531992fc0cc125b1650901eefdf0e012da4abe98091ea13a9feb8067c952550f54ca1d54a28e92f42dc1580c86ba9b11a76c525dca3c32c9dbc6a3aef9fb80091c77dad6dffb2d027bbc145ae2594eab0b141972821b629c9df291ab058e6b9d06114f16b9e597c1872d3ee11a4bca288818b6315ad37926f04cf459611ac379e56a8fa7f9c9e7a585ed5f926aa3c50d14b391d5ab8e23255f8e84c439bd0b951470a7f5cfbdef7f9dc4cbb71aee563d211d5aceaf8cce0e13b65e8f3bd6e2cdd664d55a20e8500a53c915a0fbb0adf815620730fd23224a7be974871b541bb80a4207b9c2baee90dcbf6263c48bb0bcd25c20b8829b7c2d1835b82d840dacfa0272aae83d8b6ffde117ae5ee511b47631b0ae01b2f26f360cf0fba6afbaf4bc79114d11a76c01dfbd68f3e73adbdc89b6dd19689bfc97ecc1927ab97686b665db9b8418d62aa0e55c5bac4f56a0295637b9ed2038f4158bb92e5474d5416acbecf14edc99ec33b6f9e8be244596d953d800867c7bea0916ba491b1433081e122b35f9ed9569236d98d8b7cdd27a14c056d6a1327adf4a19bf1fc9bd2b5bb786e808b59d2e61c7e8e1167a7d44d8053f7b31f05189866e274d4c5eb352e7c53cc22404306636b0fcd9ae2a1107d4da614e60c37b03820d426c035d79042e5977a16ca1a5fbf20540752fa0e79d68592cb7796f0277992b3e1fc2611ddb902d5389bb5ba5771554c80d3ab6ee0a12dde06e8355be2abb642ed036b32972c8cf30717257b9d1fdbcf0a677d0a46c7b4f43e60073a67061611b0f85ac5dac9b0b14cf679f0800f489486a3503a565325f18b689ba872ac4fe328b43be0fd578afab6cd71c897f21e799dfaae328cd56eed1bb22c4d2e598a77cde5890249a99729029bf7e6d3bc05192c0767bb7120fcec6d26b4be7413c40e62775b50b7c93c7c42f9af35bceeba030de3d9f82d9381f1169656caae5be9b0beea46db5d905ffdd8913061d400cccb7da1fa7ac8433711c30daad0757c2102eaa6ca28f4cfd0c6dba5dc384422dd5d18b4fc568c3e70e3498c4338dfdd09495f978b5e543491e155263a7f62358994a474c640cac05174e1bbb3d38d36fa787cf0bac47870aa272e63bd4e6922dc63586aa588bb15a43c6a703d47f28236d518f24327859e8795cfb93964ac8be30c5539cafce592ade518e4655ce9367d9202a1dd13001153db565384f738b6bef810fa0df71da6fa6471b891741c05066201e4563ce2728e5b6c25e572635b502469b3705dc557a167fb88a2edf6e9b1ec7b10d9dfb995ba4fcc83ca2aecdff34af1ec8a510292886cb3fc3cfc91378b2e95a3fb3fc277941769ca66fa15d8c60bf3bab553ea5eb4721e4e9480b57d28a3839c86694b4d3cae91db88dd2976e7cf628908e2866d71ffa4ed94b1c3a6ba614f99527455fa15d667e2774e66578b1a16b57942f03b7a2ce86e1b67521e57cea0cdca850d95b4413d2e0e0b3011397ed8b9908214966ccb388ae9fcf261c095033908da86e167d5d24c78c8dba1a08ac1f8b7af89463f8fe79d9ea7a24e04a8f7f23022e7f7b04f7e5e1a2ec59dd1bd81c7662dcfd10a64fc2358c7c7493b36ffa24d3c7cfed09ff4ff16b140c58c3f4250a42b7ee51e0b310308fdc8ccfe881b449facbfa3746fecc547b46134cb364f987611ddeb188e2b7de7d53a3871624ef2906b4eea9b375175f30f182626fc35d127b7cfbbc72011097270fbaf317dab94c17da5dcdea55ea8edc5c9141227c361975e795107ec86c944145f9f50c944788c739e20eea4725964ee2e7fbb1114ff949a0de706385afbf9a1903c40628e5344a7eab9b3a1670eff8ee033f4e7fdfc7c9761dd0c546cdc15aba46ed7b2bc3fdbc9953ffd4b902793a779b005dca402bc61f0221d7073108e610029b3795666a03cd0ca5f04366c0db380c9d9590c3c98e7ed4091fe112d18b53c00784bf0c9ecd3222fcfa35ba66987d4e88511e15fc2c56791720d3226ce39cf589bb04d33ca5b97f40e32752c0cc2917ad49f758a3ae25fa85bd3265185d1747df3c1511fbb50a1bfcf6af1ffc24f3b05451e57158c2e9bbe909b200b4d28031a7d8a9ef521848ca8dd77686c91ab45085a24ff43c3612b5b50e420f466ae9d23bf25403f3d9c06fa7e137ffc904dd33c4a5793ce4daa2be055a66f39389e49a4446dc86bf0eca6b297eed1aadedf1afd23638a7ab3ef691fe1c1dd817270163e758c359a4e7fbe88dd4a9ab3c4738de70ff795f96b048b5f64829607666be2eff6b142f22f91807cf608154c12c79fc90927be3500b92a064a97fa5a65782d6156f2d9fa70c8a9cdbc392fc180f0c15d70e0e68c830dcbcd6c0ccd45ead0ce2a63a505d71da442bdb9f8b5a7321c589f036fc94beeb87e316153d65aeba8dc724afac6cb238065e95b9ec4523406f3ec916cb56c3f6c42e8ae7afb475fd8114fd12b24584faac2e24927568e549291a08f4385c61439a8f444b0578823fb60f6ec08dd5852968dc5f2c4cf7b7e91276e5fc88212a6f3e470ec5cfc98c8cdc5f076362c8646eb842261bbcce0aa32fd111c23168858b47289671bf208f2456dbd1bd77fb3712e99569d466276ba0caf560cfffba3715aa3b29c0751cd378ffd6e561dfebdc0c9d6e6488134b74d49f03fb8b71fa538f3544a53c6024060bdd14f32d990896e1c06cd5bbc1780051ec95b6189396fe42bd1f2677f70c9ef1ef43cdcadd2e8c73b22c351c7b9c89023d0ae70d4e48016f40441e8119a1533e61e30de0ed6f5d812f96918810df3b5ee9dbe2c4a18bf70acbebe2cb84f8c1c0d346a93693c81d193d8b359ee05fa402d20788fc2bd8f2c6b86751a14779c3ebd5e278e654d9e6a6093af52b3a66278f97905a024b677a52240dd357d9868e80e1b5d1c194355bf749f38acac52824e7f2efcb85c7c4cc44c4d6e5bdce7ced1033d0ef569643f8a8524d79f1f6801f253ac490e95d28a37ce62d96262488f01c8b2bd293f018396c5c0ded13a117630d0bca1a98c18bf6148f566ecb31d7c826880387a582846b65b605ffa7f5fd8253c5bd1d6bfbe8327f91a9f72042d4b3d279489c9d83ec87a2864c17f177c953a38ceb04e9c19e104bec3d901727b9fd2067cb281eb7f855bf95a4ae4bba0b9fc8ae0c8bd5c660483a9f09a5116bf12f21ad5757264ed15c7283f98eea808779d3c098265d166ba93ff0e61578643884dcc3a6001d82697078c760d1d0cc6ae54c319c99f4cb90b530e5aca9737726051b7e5aef1ebf3ef84f26d5b6749d2d1c0e23753a0738795c6405bdad3950d1d18f45b3bed03132594105457f4693c2426925c7863444de3097f65aa6d1f9466251f6dd69329b3d44dfba7067bf91a437bf9576cd5be8d810923274d0bf6ad58f6d34bbc982a1181463ffc5165f71cacd63a07047a58836c786539999e0b749726ede03985746e1874bd9d4afc1647288808dbabe998ea1e84d19ea9dcc690fdb9756b9dae1c215e7faecfc7d460c88526d88a768c9973149e80b77b648839378d813bd386c75bb01d47415e19f53875c182aabba887cf872afd708a621f62496a8968349a581332126db2841b40fe7206b43a9593f72b7ada7d42135acef8afd56622cd0ec8d865b8c6be81e1534bd821861d8c0828987609c12cb4b1c05c68d6792f49dba95f85102e025d9371103a5aa84483ce4cff91dc6e6e41602e694f4a1103ea8fa90a225e421c2b2ef0429c64bbb5597751e390fba0aa805cdd66f174bedd5b99cce1bf58d32288501047f428259ee4e9205b252a5d1b1f2a930580771f6b93ffbb0a78dbb62355376839fb13e2b3480f0ba29d2db7a22c3c0157dce8de4d1740c5e90b78513280d97532d9ab1f2813c33bdc03d65989aa9a5f5910465f6258b398263ec33e16983698e31d9c8c11d46332388a9780fd3c051ec0112f1e1b50dcd98d12b1b87087ad9acd52de86ac4bdee0325468d5f0cde42f0cc0e3908e51ee22e6367c88871b33ba1ae3f9e3a656a982ddac4819b2e09a921305ad94b84d42e4f8a1d5683c59621667c94922737b5ee876e83d4892d6e07165680bfa9e438f4b5456bc4089f5eff336543f9296b6c277c88b4ab1e1265c65899cd0f4b89202fdd195e6e3632d7b0411638d28a41849936db61ff48a08afd283b8a7d9d156668b4747c4aa028c328dbf6da5344185360f1a3905a88aba6120a9c748c4b62f9be84589f15bc5e872ea0a5863c9338f7019f1cb2b1608f2bb3ef723ba580bf9e06b4de7273d2c51069e7398a26913e225be8b9e8ad4fe12f59cc840a6b29eddca7767e32243cd2545456cc9dc1ea4e94635a8416c5c5a664bfd0d7907860da703a196214a8bb92ba73ed245b561709a7c936884c2675395d89a76e6dca715d73a7a0c3967a8f8ac5b44b56edf1bc95a49b6c5310cdc30d673ee741506e92691551729cb11c22af886ff0111394a1e21cce1f27a199170df65c90fc38ef3a5cc91c89cc23422498470fdd953d5fdbdc1f52159c6427726368ecd3c64e1e22234aa44480cd4551a906768c940f9aa17535083e476b6cd2eaeaec73f770c5c7e7c3f8e89bc070dfc0f11f776b965f87f8f4e7abd3182d4eabd2f9e95919191ac91497f2bed756fe3ea261216c4f0cf39bfe5c385540fef1d9664c80168b594fe8dc81698e7a21493e8a23e97c3331f0593ba5066004d571ef9c560b48fc5f179ccc4fe0f3d3897cd6fc90b59e3723bf84f6e1279400a20e608629d8e3915973bc25013535494e8d86794824e61b323de1025ada81aebd0b6dc6c48261b5e147379db8b1d8c270a32cb864b2dd7449ce5d271c986a2b580b421e85dc6a0f7e53121dce661cf70f4184a7dfcc70f146147436699c6aa2282d924a1e11b95632edbbed280368ddffabebf108144ebdfa4006a54bd59d43da8e07a89bf8f3ffa4c1fe37af725250baffc08cb359d4d987d5a4826ac1d18d509c9a0eff9fa14ea1acdccbd5b4fb7d8c0e3495f52e73af01d7af059d8c9408f8abf20d723529e814893bce13d168a6cbaac0348bb5125dfeddecce96bc09e897aa4cb023625d33b3fe9c74a2a61442025d5214eeff9b4db4361fdf267d264e38f870d4c0d6ee1e738628f46b76354a0d0bc98d53b78141ce22911bb79c9a4dd4163a249d442e77c8b9bcb5e78c75d84575d33d90a5dfd42a9e9ca4c09f70c3d3291c37a616fcdd0b6cf7c3fa9ea839cb7a88910f055e6e11912bd6d50cbf299794e178f89845834d5a5bde1dc6df5c84d2517c552790e58a43210eadc85f2a57821745402b47464dc37b6775303dc5b50fc5f0fb02153a6026c5dc48e5c6c08ca8a0c82011927e43822115fb8d27c5357461a95e9b8c3387dcb86c7a2be16fb894a9a85213d2da698aaec98c96832f3348b796081d5e20e254a42538eff99b27342610ff484e957425ecec555f24e5068a9d2b6bf06d1b40c3300ad66b32d2d8320be430328cd9cd4210e54f16ad9c03bb0a808f3d6f614ec1511702253c9a1e2a2f650264b9c59c6f4dc350bf0d0294102e48fea24710aacb854f919ae0fe38a833bb8e189a95bf3de498c9573045090b1455f89cb6bb076218189970","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
