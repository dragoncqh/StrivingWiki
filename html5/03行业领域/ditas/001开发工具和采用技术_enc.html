<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efb4b5f930cdc5fedad8f9a8464c4eef1b557c36a89000faa0e2765d2915d115dbcc05124033a4b4fcae24f46d9fe511b730979c0f0f6eb7f9e54fe69e38f7b8a8ecc2049afb2a41604af3149394801d4ad14859f2ef139617fb8e6ed6f2b1b9c8e2211316f0f6776594529d7444b52b89302582b5fe9ebe1a38af9a13543f2883386eab435a37e8a09583e347c81bf5e9ca42b8f07fdf2fe080a66cbc999d9ecef7bd7615f9e539f8b5b7216e890ca86bd38f7869b07ca62e9b2f4f1aa6102ae276a5c8e59d60679c887cfa061f49c6eae7c17fe48af7a65ecbd6e103cc132a1102b4923f4265234aa680243bac4766e71c2fa0b198ebadf5179c2f195f4fb0dfab5066432a0aa2e700f42ea6c00d42a93aad913a82dec617988ccbd649726af49164aa9f998322111cbd9fbf0d568e4597b7967c969c8dfdd4b92fbb09a032ccd50d63167bd36877e9355fd5f11190119582cde15a4604e6900f524a7ef111c99097805abbb126968a6dec1f04fbfc9853d8cee35ace9f3e3fb33ab4ba3a367bf5b3b481f6986272b4a2b6828ab77e4cc03280e68aa23275ec9bfd9f272e0785e8cc861c1db5b749fd27cafbbb916985307d164f8ce950d441d99813db28fc4675ba0e879a72df73b5eb07fcb8efc0923c72b201bf49f96b2aea79f5b13f68265265283e654ee1ade78f4388bfff3e7ae89b69c9ce43f5644eb6cd77312fad0f914310c534444bf5f6c6a652721a0d5eeea5e4147711dbbe213ab3081d0fecf2d76823ed15a8c6a2c674222b5812b20268092278f6f4a545273ab9b26a555656f136d94995932fba2c3123dc66be9c0786bb021b2f5756ccd0d18b887f398332204f1e27e58c4a35fb6867352611a3f9104ec5d29c2c3a13a210757af1f278cdaa34859b8aab11c8c41d933d44263b827515868dc771e09eafb7c26b6f4b0ed03a800381ce20aaef1f137f540158bfbe2580dd7f8a6cd9b640684da7542a6ef7d0ae4df32d0dfe8dbcf9cc2c88b60d65c14b1fb7a1a0a91d52282809bd7311bebeb4816b143cbc58f7c25b0e7550afd621d89bf97be07c5aca5e30cec78d76a08a2f15256624449263aaa94379f0f133e03cf1928fd68a5b0e623179e0a87a268cd306a8a432cbe02479abbc5a19418ca3f2dfd7eea98f18aca4d5f26b77bec03539d5628ff36d39ce97b7938c66d5d774492492cdf27e1dfa2f603a2cb0694ba1c6e624bce33d973f7e40b6a2a6cd3cfc096b85d689cf4a94a235fc41854feb2a607b6b791b17e96b26ed02baf08486f3c5739fcd28040bf5e9e7b54d7ad782e8051e923274c99339b8a22155b1cb0a1a1581876e244d8c661025c1375fac9dc63976d6559572e5df71ca1e595fc697a42a4496a20ed4cfc771cfe86575489189844ee551b9bf78150f4aaab4083e3c35643978cac4ccb4fc39e9fcfd8ed58f25af20b6ab3a46a2a8d99b0f92375a53989bb5396226afbdb8abc068889b4b711cf0bb286a281fb973533f0e00b7b1b8f564ef8bf08acd041207a92ee83755c435d589c3f8ff906979fab1fc10974ea422983ec4b0ab58b16e75eb2d1b97d624a2384ebfb8485a68ba96dc16330a9d839e5056ec8fdd40bafaed7ff5e9436b70107e831977ba564002e1f72c52075c17fac62f1c7471c9332dbb4f748ab02fc05feb04076994ee5e7efd77587c82c84261c7cf6e5bcbbe312a1afe92ddb95c698207bc8185a385d077281ac00b2fc9d49c21beba1bfe7e0cb78b10af20bdeebd7121b12175972b87eda528685b0a9590870596c3efc760a614363c33d5b436c9a3cb90c41fd54ffa4f069c5c04999acc9bcfa1c3de588b5e65dd51c049334e3ed3132ffbeb713a348be5cbc14d098fdfd701d76572c44fed6321e286c5eb8d13c1478d5d837ec6651f5f7546d910e3211fc07dc668c9be5fce43fbce45c1ef7121fac920e3732e23fdd5ed3c83f420f44cefea60ec0471c6931577bc69b7b867bfaa4240f6de102c3d733810712292965d579283e56631c74cdb49110992e58ccb43f80868cd7a040137d1f6a0934415e8a6f17479891ade7d0ee5bfc9d4a48d87ce4a00ca4330f3ebcc67fe932da511293a1b2dcd5098c48a60e94e0d8d130d379435b21eeb065270bb67a9f8d7917b4e6e9848fe2606ccc18f195ad5c5e6823bc5a7709a8cd593a497a45caf0fbc1bf402ba05ca3b9d52cf58638dc4e9cdcfa8d143a2c758a0485c2b3788ed385629bef027ca7c4e6db63d660937176a8c408c7eaf728a3829e6f40960932a043413835ff5b66814202003345174facd0f0aba1c87d18fbd2be43b29fc04845061b680955c15fbf7b60f9923e9ba088201b34db2ce9bb94e9ed61a17ba766a564fc8404b4de90bb514f9261e4eb94ead73387f30b66bbf7d04717489c3fe22f842c49977663e0896311fba06dab738ec206745147f589b126fac2db2c5d24adc47f52418af3af58349c5a3c84eb1485928ca813762a2e9ff7279707157d2c0771931a98641c5cf19c7471df208bc4ced592b469a67eebd34c07a320b71b48e2b1b54527746f877e7db7392e6e769fc61610365114cf72030e445d6b6a047abb31696e0f53f129e437f69d770d70cb438f42b34057d73b526fbed3700f664e59c8c93066e45a5bea245d9f1a012efbe698c6dbbbde20584821183dd1ec07b5b3af3c545145d2b689376fa1b71bce4c5e989d87bbd8a6cb88e508df493c6240d57a5e4d0c38187bd2ab16b45ad0d429dd600ef8e14a3b55090e3ce60b1b4eddfeb37cab6333863fa3c73d4ca930c395d02dfec2f56ba8e471caa85dcba016bb93f429873f835b536c5d9df36b3258a801750ffdbec559bdb8b2526911a1c9c3238b4286f5582cbe5a6253a92e3b08e6e70814f3ddc8bff8593bc99635561f9debbc18b5d43626020f8411301b98524b6cd28d7168bc520694ff3a64ea1cb706232de568ea5610155d81b376d7186fb5cccac9dad570c1f0d9c58e430295cb7d06f09c088312aeda19d28a15a139640bd4bd4cc92d03b6a1994481856673edadcbde4fda3b00830faa377b5bbf906e7c84ff16af3a2a40cf3fc93d3dffb71b8908659337c48d637a665837a17b010508b5f91a7d5f5297d6cf3de4162e399988f49303cbb9adfc4e823d8267dcbc9f69597427ddf8ef67582d38ddd8965bf754625bc223dd4c5f3a240642bdce880dd25b40f2ecd6a9381c4dbb58fa5c1c78758d768a4c7fe902c851849098081a4c3a907e7ce3092a04727bcc1802254e11a5b548f61d32ed901e8a845e337b697ef45697632f8caf49b3c070647ac962026aab2540bf360df85a27411e974c982686c71ce97383192ef11351cc94f2d4cd023df0f49304d58e177a9f7047d9dfefb43b2493a228e42dd0d99d5329495e119a1776a003b6ccc317495db0925ce0f985d9e7601a275982ed6747e08e3a231fdfbf6329b8139dc977a0fbe1d49b18cfc0a1a3630067be8d96a2d4bcc6b14b38190130f45d25b41d1ba848d6e1191d7dc14f8d81ebceb2ac9d694724471d427636dc786c463432ee07d57926cba9b616370a0be85127e520113ea929979b10fd55e44bc98ac8eabf9ee532867238d676ce5d4b1aa3d448bfcbae06b4284e75464bfbcb54b03884a6a7e50eff6406811f515a3ef6c5b703bfac61189b3c1e850ec40136e9dce4b147dfeff9eb91b9d99d50ef0ecdab011e04888fb14e8303a49ad638df33e0ad6eaa05192f92130b86a66456f9c3727f6dfa87633189ad138cebf39d8472924051a2362677e607db2a51fce4cc4bfa61c3cc431d160d0b9cad7817da7c97d52ce1ceaa20376befe2e9fc2b6b28b22c6566c6d453a2cbb56023ecc37146f38040ecb5e409c898bc07111107606cfe51a34b190e8d2ecf8d0fdf09771f076a51bac9fe161a3f0b69eacfb3e3d9cc94443541b6b89ac8f0f69e3575a28d2b0f7be3bc41afcf33e92cca4f0cd38316751db308793ce432690b6e8db4b842ee9fc12a458d0b1cdaa43e8cb5fa5084877384e7af7dcf28c0bc35a583c1ef40aa3469951088434da2595fefb19d214ee4fe2e00237b1b48d5f148bf9e56ecce0243173af2ac07b162cc2d7312c240f0d67b73aca2f38adfa19b1cbd5b2aeeaf3d13e5f33566dc84c3c7770f05994d2731b3de24a182ab51d4f85dc75261235a35a6b2eec1b5b50cc120ba634904fd52dbacac9f8159deed3425a057f2c2692d1af3d038c81d002084e38829be3878f58c179c06f2fc9766a5c9c7cc6ea10ca561ffe9d5a3f9a15962722d79433e62575ed1ae9b21ede490ed4a1ba55ba12f2e338fb2f257740e4e7dc802876d76692519e9f1d0963f690f1afb4670b179a3c7ecb0ab9a2c2a8c1b55d4b199b89be79518ccdbef841587d9fefc438e649f2c90f9aa39561faa9e18290859a91a228b502e1c175d458a9396b7c010ffbc2d74a31bdf44225d37fc3e5f5fcdf8c6d5d0002595154f641d52ce3340307ab30427ea726b05f603a81ca7d6f32ce84bad937f4a06745bd272501ca63bfb019928c9f93a7d67443098cedc7af24ff8dcfa93b13f316ed391afd3534fea382b3e88ea2b63377fc485f471c26019a517a85787a7e0bb5ae1b4ceb84ca85020fe7846abede1c8488d9640c49083603dcccdeb404f2de58aa58a90c5665e697e7ffbbce5bd90cbb47b852fad8b3ee9687185c7112f5481b8a5d37456e62f0c1d55714bb27790f6bb521b3bc0d23b668b219f6da2bd558a54d5b900730cddf8d14440814acbf04715c936e83b9ca5caa76f081443e465c494b0e402f1fbd75d7c71d444b002c901d8efebaabea41b1180195a584305a48a909930dadc8bff46a6854c10bad781153e822fd684dd01d6c6da5c2ff7ddff1c34a26a58e6505e3894d09918ba138da6209ad98416b797f9b289538adc2f1a3f244ed4510576c2fa2f1c93f6793f76732d20796498392d0e0accf584f28e60741de923e0e92d54ae85001d75c97290c6b5ea04d38660c6e86cb4eb710907390f22a4b496644ce815977316a196797055d0657b90c98355af7f5768f15a0e45f987145a242d6db3556d3cf9545f29d49852778988dbf99635b76168521a7398cfee4ce1e6ac4c8ef64f197884dce67f45d406d2875eff46f9415800337e41a95c7744b34aa79c86224d7b2cf9224da47370206f7f1f257214118dd78154d52ee160bd7af5c0bd9e32e7f41c051622b8a74defcb64237f4a50ae17ad7691012c503cfbc2396a2b5b097ccccc9fc4947395217df836add649264a9b4b90af3da4c747981d4f5b6b45368bc47fec7c50df07c3626f3e45c058bf889920348672fed1815519b1f2e13bb9c69c328fcbaaf77b9ae67926aab297046a07bac4fb8c5b268f17bd3a986e10520cb02f381f99859ae1349a13094e0fd0c6f510b7d2e63af7b1e7fefac93c1da898b57420d07acce9255714f6f1f8e93f06799dee2222b6671237ba1bc3a19eb696365374970bacad61a057e399685fd690d49873907d28c1fe04d63e6a311ea938a0f9d81df023f6310a47675734188bbf54db23e035be05e4ff61e3a1eac9d9d498aa817270c5aa181c2253ca80d72de4ca313cbe0d7fdf28b0be07033641d54279b6731140a9058edf914d2774b242d77a2cc80a32a415b45b658834e21e37b3e5fc1d3ebfb1c87eef02a53390108e99cefa68e18a97d44c43065e3e57b1f5ea48e7f7cd17ee69c40232960ce99d1c9ee70a65c0894e7d34eac2cda7419d0260f4989ab917b7b2054a95180bdb9cb77a3069c1b2ca92c477d3d79cbdb8dd84d73393d5744a3a1ce13ecaecad1b9a7b9b2d47de23bbc3a1c38e90899b27484b47f0d4ec92feb99f5b111c016dbafad5c7475caea4b09ad88129069f170a6e7199378990ff12d65eb99572752e7e148835f333528fa45aced834bd74b660a5b926c221c170eb4bf0477702ca5a23e8b3cb96171a6900cb4998eaeb7592ec262710af6606dc4585e10680b4f17f537aca291cf0d4c74f83c3eee9eae95150f3a8fe7ba45e751c597d740b027cfefc301b5c20a4439b887d9e60027aa10c23342efbad97d2310723344033b3a06deec751739ffdbd819f78c2dfa5a8c13bc4613a3c32a3f01860da7d86f0de6b2b8922d9f72b8b5bc1344c3bdd7ec6d1e8c2d8ba11a72f0110eede116a637430535169b682199ee450c79a451b7a52665a579ee6a3f2b97fd94701a3e4372f4fc5baeabddb47c8466dc4ab345704bbc5e4ffdd0b2e27c23b6005f66ecc0a3a5d7fa3903dce77be8ce480326b359a2b3deaa557d02e7f815c2732fb2154107bd5f552af5910c4570141eb0c0bc649d08860b05cdd4ca3347fb3cd7344b993b27f18098624213c03210361808bddbe09a541515dbfddd244ab4e5828bf622c7b0c1674bd71ff8aafdc1771b25d8e2def174645b8a36c694a01cfbec69498c36a0e707e9a77f51e8ec2d78eeda7331dd8d367ad7050a2406748e050dccd9c7c86aae20960c3047ac1bbcf83ab694f7f87b76ea426a8906359edecce0955ec75197cc41310aeb37c169155b31b922b05c9fa156eec4e9beb1c3025db1fee96e68a697368fe846c8d37f71eaa397e8ad88fe74de5014e08d139cff7ada9b713f88627d5337d31c9581078c3058a8a84a02762a2f0a8eae36fd054a9d823c3c0d90a4b89a6db7ffc9023906e957c0254067d3a98ef3d32fac07876d917d05c6923dc5a9407bd6383f2e481c4bb997da385a77289d8115db517c576074dc2e28b7979c6dbf4b43b9c4b6eb5ad10c987e3d4a221d6ea02c91e988361103381789fe2e724bb2b7e5dbbb17d3a93706091a32bc593df3ad43dbb31ebcd235e81cb189ed8b4ccfe8d3a00e78c22a2c2baa8c130f4ba1f7e967e2138a5726d241614081f47531db693c996a7eda6f4b62b5432d3097df2da29a2f332fe37da596287eba5afa42f735e0be9113180fc04953b60822bd46a1e168eb21e939fe590e5fd784a5d0285939d68e38fd3ba1e5737c76f6ff2ae425f63c7bdd9b391d34e6b4bb86252cd83316f19c6bb88e89c4e3e8a981fb03de58744f4a04c24f08fd13747da231fe8c14e76524a826f784c399b5d10ead228ff4fafe50c5cb28e5e29b2bf0f70fdaa7ae20b315710beb88123fa730968e198ebda4b98ac261781bb4a7bbda6ad0f060e18ad1965fd83daae4d8c3e6b8c1756aa4c91c84fa4dc1c8305e0d9f8be65fd0713101cd5ce35b0b96c499ce886a482d2c2055b606f034bc607433ec408a8c81069403a6e1a4a32f1cdd9213a051baa65416335764b3ea6c79ecfb3534327e80a6a5e665a2abe2fc11c2b62aa79e49c157c0d361737d45a232c72155550ed83921b573a67cbd7699ab23fa972d415b92c2d99ef09bcd424b4e38ac3cad9539635417e1f7cee5391a85f27b8ca5e4b8f651a5438d23645da1436c4ea9b73676d137cce82f90ea7b91ebecbecd4a54714b635b0f592d61c86a124c33501a5542429ed431a2ac3fd2bdd57e48cb305f7bbc43a3e9e965516ab2ef8709f503f634225a9c5eb84cefc41e2a5d94c31de8872c866e39db205f703a73f021ca75785a162a787753b4d70499a697f92deb8cebfb07cc96db60684e21dfa61f9f032ed0cfa0e9b2e1b81e17bfe84b9be6566e57983a94c1626b44a7bfe43b1d8b548b3e88cfd81c1c87f14703a63ca4a26856fe467b68178d1fe04bc44b12da309a8a8ffc4bf96e74d9b85976c67b381776e5982f33a6b8e8f8bed607a33ce08653bd526cca9728ebd43222184a0313b1f414c0b7cff6d50f786ed6fb703c0b3b906d5d71ceaa34acd507ab90a6655c1e32d8a55b8c464a8057c726ddf94224ae7de9de2e497cf0070558a19502e708b63cfb20a13e4237604b26ff572f347b23435d4d7b9cc8ed1a199ac3d360a4c279b4af4a82b1719d5a1baeecddb3d98a9231bf08897415b10d2b67f9aa734750ed6c34d9833a07d1c5fabfd76c60f1e57aed97c4fc09795afcf9e8b45ceb652dfbfef23518eec4c0e2438a1adfc968fd0efe79fb7b9e42cc875b8c24eb9b272e0b57ab71461f6d9acdc8c2858da8d1d6fa5ceba4a943fae6db4dfacdd3741181e12afebbf5e5e7c9620eba77985eb30295d784e3d13dc1de51b95bebaa98ac38a5704b1c16fd43028373e65eec8a5541d314cc3ba6b9c496faea56096b125606c74a6f1f95b413b30ae1d98d1bab773770721fd34234337284f71c0844335df16029dd5ebefadcdccedd4d6451c2a8da9f18a90d6e3ab3c917f5b8a9fa226cd8692394c8370d6bff894664611c5695e0d9e3784b38263bd04036eec9f573732f676fa2dd75a1714454de2a5b7b4a1535913290a05771bfeb23e5a371d933a0281520756a3b4b558b8b51b91f5de946c970da381c864b13b19b76f3d7ad82461c5969b842cc74ccb4e94f6a1dc349242b7aeda31ac6d49078d1e990e35115b3c510a5eb05f2ebffbdfecc24c02b8b97f717e2089c12e0760e7e4ef22572384c401bcc32d87075b623fc0fb4beed51647bab7e2b3597f319a8b4a34b046d7b735bdccff70f06476575ebd26316137456ceeacd6cbbf91393b505c644defcf66aab28e122f7b89f86e6279b84afff3b23b4722be31b11051665e82414fec7991c948d1d01791d7813781df1edeeb401ee40a61f5f789be5fe59cf26d3d9d5017c459e8d2ba80c73c2701b7cf79e735f5b29651fabb472311b4380bf3991c1a4a666be3c259a7dd88e2d1ae673042ec81352ad2893705b389009af60cbcab91651404a526dbeba4bc3ccb6f267fdd9bef2640da30fd67cad5276f47e573c664e3b08b0f952eb29db58775cb05caa60f9b8f3a3f34ccb7e92de05294f59d88a424573a92330a2ed328c67ca641a05096bd391b636da88245b556fabd6af7fa6d1589a1cd52c5da1add0315e45790294155677d5cd2266dfb3ce4be2c5d0c883ee87c49c56ed460e6f312c4d6bcae20c47a2a2497fda92350edb8398f563fc9c45c02f667a094be6ba1c898ccfe3b421fec46a64ac405ce8b3d3344babaabe66a8f09517fb9276e691cebfe8039c826eb05b4cf05449b8e29b1e62acc7ed0d07972b9b254e11c26280ff4b24dd0a494f828891a4b8f4b27294163811ae96ee19bd9bb9643b65d5857e89ead5cf64d460ce54946343e935dc8ad51e3924d097fd9e7d1365362c833322e485fad7e14ae520b43900f6b3e301e264f4fed93416fdac1cd16fe908d92f5dabc323c4950d71a91b1c592c211c8853fd2aeef6be85c14e09f16989217c74ef36f5ef807aecc611cfadfeec70c8e1080194d149406eae293a4b7fadffca31ae1e42a3dc575286e3ffcb503b52037deaeb6b54f555af676c5c8b3eeed2127f023629b71c0fcabc26602a7d65739c766686e36668bdce358dc0e7dce5861f78ab90c4938ca49703268727c13bc14f3162c1419af5eb20859f0e2b5af80634d212a26e2a05477ac5ab57f2914a619c54044f0777a01a8270832e685627be04412c03e43f6a528710261b128b4e3e613618340bc0b69abfa717b3e6e4dd565a541193d7c0c36643c51f68a81206f7e9e9cbccd0e6ee95555891ac66174ffbae21bdf985b86082ae027717bc742f3da21fb3ec8af301adfa12a7ea6c6a618fa93b357b6dd25ac4a3042751f80302e4a6c5860fc0b4daea52cc2924f0c04fe2beca95adefa1ea9e57f6929b37b0dee1bac762a24111f9eb2523f7d7125a93aab387c8ea01ba1bb512731368b70bbad8403888c4342aeb327a61f1eaa0018469679a40dfe7f284ae21e5924e09bb04389e7172d34b91662673c0119f13cce09fb13384d93d7cf7c0ce0cc9371ef37b7a856ceaee755e9283cfa260c56044bce4bd9bbe42f24d23bca5dc27d6254439b4b5f37235d7a430b60d3fc50bb62a537fd28239b7bc3ab8f8e4e2b96894b3f89b5d4f118573f2a648e200c5375da0b81b0d05b0805f0248b41de2cd9c92efbbd4132631abfa8f3d0329f899c934dab0fe38ae82b7f737a24c242399ee24664970b4edf6d77fd8c88b4443e2dd0ae95cc9a79088183e0a1bf81ee1bc59647df0a006b82e25f0a527920412d92898e9518cbbcfb49e2faaf87083c87da2a2e0fdbacf4502ce2c540e7437531da46325dc0700dc927964a6deb9ced88743ee79c4c4ebe903a21372a469c1b571b1cfe15422ebf608c959e2888b83aabaae8c5d5c7861a0bf2ac3ca7af2fc70030b42d37d911829e6979bd35aadfd766fddedb4ad244b2820d72759199c659ce3e79f66c6a449c68799ebf233d79b3e45799d4d3611403ee06cf1def887ef1d3f590a22a4428dc36ff12aa523c9875c8e57a6f05c29b8bf163c54b69dc023fa650f6e81de54f7b97f52adbc9aed840cbef1973384fe9173b2906689c325467d386fd34b56bce236d4844d0b8774f19744abbf871eda357f2c1e81a849812597f761297769be907645debb9c82f50931369d409898eebebde7e3fb39d7688e651ae67dccf0fe2b1212828788294d45dcbd3418f2129304823e639ded1e8b2fcb4c6644c356423392a9bccf5021883bd6e8e57758599bd40b100b5c9cefdca42ceaecbeca314079bfe5870cf20eeff6731dcd9f5ebe7c608ddabe182e8a1c713bc0a43fbe1318c25b98ca660b02ad808c297f125e58294f901fa3807481d0d280d09563c2fb5e005eb5424df7d601458d5388bfdb0eb60999264de032543a44538bf3a28e90c3fee5aaaa7f503d8eff922edcfa480b5b7133effa06cae5bbd345dcc153fa58e4052923b2e7b271a2310a0ef2f78478a4ade175ca81607d64c2f4bc787b96a1f5c33e32fe5a279c3669bdc6afa97fd6bd5791d8e1f7d20164b03e1ea81350f7570f8ec7a495733c8580703129c242611c7f15b09240fbfa4592b5e164759acc8acbb9d11fdfe7b550ce3d1039802f2cec64f3cf4d2991fdeb9ebc3d7aa688f53e695743f9262b498ef70c5276461012fa0371b65a44cfebc809e2f1d3657949ceb0c3613884ace491388c6fa4903f973e79e9fac5185ebb44e2576958594825613da57dd58d305b27622558d911850c8d6d23123c97666a2209e1b8acd1e400a5ec3765bb29bd5c27b1caa21d153a7ddd378265a2959625783773658114068c6ef0acb87fe314f0207bce6c0b6b9c0ae335b313da447fe254c916728e57c56aa6b114a2b01d350ab8fac68f83511ddbfa8cad71d70082b4b361c74e220584dd23bcf03c09b6033bef439692b152870c0be97a0b9341d4f73fdab304f3476c72b5fc7e3a3d6bad25fb6ef0e0272fd0db0280b92f072052a3cce74c246a9589b778452ab42edca867bbd508d060808bb8d7a5af2f875da4c00ed102b648266bf4b5633910b2c8c49930e47b52e28cb6cb8d9b1c088a56733726231c1fe5f1f02a019989895e3a99b222d8a52434308a8b7b8c111495bc4cfc843a8d9c134b989ebc94b5ae06979e9e9e795c13579c19f6c41b440b551abef9ec04fca79dd2ba94a81612f987dc4744f9a03af6fe901bf83d410869159ba9ce9abb6a7d4d44e6d6172e2dfe55374a7a78192c62b5305d1e224df00586638ef28956a7e5ff41fd33474fdc7973a77aa76f7715c6b5e460e7cd742edbf5c3f7737f36384537ee6fa3473a578eaa1d72856968e254bafd2f78701a6d1c5efd1b5e7c109fec0a3c5b69ca5c58b4851d66b5d684298310d15f9fb88c21dbcaeaf16c51847a7f6f3987be471fb619f5c2bcd30168a8da0303e6401e7bfc919f687d87db61264adbef12175ceed517221ee20fa559e13714157925d855bc85d9ffff75a232051bd769","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
