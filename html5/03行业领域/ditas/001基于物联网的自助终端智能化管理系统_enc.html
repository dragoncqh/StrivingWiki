<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37dc8e520ee65a81fdc129f7c9666bc29ff0c53b77aeb64853beb194dbafbd944533c1bffefd8be6b0d0b6d3d7f37c0ec28cef9fd5bd8416a6aaf17007c382b940c59fe7feac007ebbc134f87b204534d0b7305a888d7e0f73675f7ab5cb136b5a61c3715a65be58229d9b4fb06d05e59d66773e52008beefe5f5a3843bc8199beec157f353d71bcf76296779f3805dc6b2aa421860a344cf17292344fb0fc4dc1b14b8c11388442a236e3c5fa330ffcf36b4fbc91b3c5135661bd421ca560542bf65ff9b10c89e1bb6db668b943b686b4047fd8aa0dad3f8ce27191309b2ef573f525a601ed697c3b79f614c9847c1c783708b19acb1c7612bca848a1ea862b57fc2b5d01167139f2e83c4114a5fdb05c95b9a7ec1977eec18f9110d941f9fbe383af6b853c98b01f5ac29dc7c23cffed108b73e3ebc5e13f5726dc5dac86fe1461cd28463c8b089b031b2d2c9caf90ee08a08827ab48d6654a098efb8c8687b17913ff75ab9a1b4317e80bf48d083a1440decc25c8c0d31c7eedf3e8b09ad2c7aecf7caccd9b0a6d5074827086382b8b79700e3bfb3e1f3d49c625948a36a5bccf461339c395dc5f5c8e319f96c177386f8bf05203f928bb93da3d2ea16c5e078983eafa81ea1cfb132dfbc12c3fdb7b4baad4dc7a479be18bc6725b1fd4aa8a85fa8690de952dcd56afc1b4682ab3c1d48331bfb8f3e7ae76ecb1c4579d10e5c4e80b2afdf57a57e81ebb5cdcf3ded5273b5cab20f0b39c7c0c27a802f73695364220f131f98a0a457b508d73217d7875f116af6fd9f27f380fc23f7346093f3432fe4e954abe761c36f66c08f12aa92de857565b06b96a3312bffc05fb895e3bcc94e14190ce4e5d69674d5f436a45553e071f0519bd69e4476e6fa8c2b835f8dcdde8c835f1b688761c380a34d26b502f8242fa4b3a8bb84f8a393fd8bc113cdd44cc748a04b72c9b0b297be804381f5eb201243413cfece92ca844c4e0ae027ba785bcb32eebce2190a73d085aba591182b1573f03be58b625293ddcb143ceac51cdb9b67be5cb260b45ab4c9a803c6ad647ad64f8c957c0d3f8891d949f992b67e8e9751f8427bdef7ffeae16641f06df960f159e30c330ca370dd3e4517f143258bf86ee261c52f5f6a18c939fe705aac090db8a6c7e76baf08bb558f96895dc4de9a4187c6f1327d921005d0e46cc36b8450c5ee444bd28b677f0de19f21cf564be66af286b78e2181af0daa33f4fe0d5703adf50b9f650a77f2010d9cc78f76a0c7a370b0e1e763f87f24d86d38c2b52aa30da6e00edf0f203ee5a65bbeb8e6bf9776274d588e135fdf2d6c3e36d77f1b153359c13e9845328af0bf3bddbcffd78d094a3221c9a133af51292095fac619be3873caf67c878f17b16075152d9b6c165ad16a059ce1235a45b82b173d603246e706e1f2909ff3cdfb88b2e4a92f0fd16f4658b66b78be157f7b60b97d407ddb25523f0b5cda7120b9c362aa7a3e73b314896161a0190153c2e1e6947dd449fddd9c29b06e90dece17827714d4b3dcb3b325ade19857df75bf6c2843fd86cfceeb27b96d8a2de605f994c45aeddf7318bbe753ba15f22089a1b4222ef6df54913ef2a9b261544e550c6c16b67118b79ca2fe4ad9ec53406914525dc25c2677b7c53d13f3de61f11b3dc086d73e64081be74884b0b40f12cbd38b2d40638e2013dd0e52131617af8845331eb06a75446e2a9c118fa12a06a188a98727df77dc10957e092e5afa308dbdc3e605677ff36167b2d62f72076c42905debec6a45ad9013bac9c0eb8f8a20f62ce4b0cdfc59d8a4aa35bc0e64d956c06aaf04310723b7ded1171b979c3aed77ea2b96f9c558a041dc74dea028c432fe7c867e5c58f0c6ba61b15ade16da226b1b6dcd9fa4deb804fade6956526caacd166e7321d5458ce790483ff87ba4b2fd98a98a0847e8451ef051c2fe4a4fbbec5ed0c44eb21a220cdef311a3ca4ea033777c9ac3b692618a4e5a19bd05d56201d2f65d9256efb85ab26b61f8f6c2d6d3ffe2cc695a6352cc5bcec1f68b81238ed179038d935388eaa6c18e2f758424457e93bf1d6702907b7440114e845556c31b3a20a5455fed7e12adb554ae9736dbcaa03aed4028051a73d12aca7d9a114cff17d3c6fbe7ca79546cbc069f7c933b44be6b2e08ca30e1bf779b518ca30b156c26d18bd183c4aebd10517f98345a01c2f79d38604fb5a89067745e3746787d6b6a379f1389a6beb7cd664da1a9733e7cebf37a4fa65522154bc7a5f113b273027921544937f388958ba1e5e836c038d466ca35baa4f2e42ac1fea58dca6607ae19bebcf00889f5613c557b84d410d315d5b0121b62f82c0e906713ab350952c9478147e646a13cf65d22b447171b0ae88663d5383ce1f6b3f2210cc0cc62154ca9d62f20a52716017d5c619314114f2df4cf06fa16ae5ae532e6bbf69a832af7519dc85f7111de9af2eaffcbfd883f041347c72eea61cdcf12334f08d86bbf5d6586be720e7a10d5b3d3844270f52e65682d9076f7b44cca06a12ec85e728d365b388ac048ae4003766a4b784f0d0bf3212d3fc3e4b72f6d526646b16acef951e88778727844d42ce5a0d7fc29920917cf3a7359544a06f11fbd2baa22d3aab8a2df1fcb022533e58ff9354f34396fda81cf8cb825045269ea533d7f2b1703d1d14b22fca7a7aca707c719732dd94644d28ee950630911c43cd02bfb992cb30efe1a6ad20b35650a53c79230a80a37dbe2f3b2914e36fc72e1f738ff5c5dd3022734d95bc555878f0537245e002f50cc1bff4d97136963e7e27c6ff272ee766cea4c887e32b5d9a94fefdab685b1b69dab49de0fc41f22cfb37cd28f6ca3191dc13b0c15a0382e9f315d9aaada4ad57c93c6a5245e482688650d0f210ec8a59005831f1f9d325abbd36e8425506c45a012fb82f2c69429ee265bfd977cd403b24257f315935d27a2e40c22ed7476c819278c990ff75705323521f7f53beb7aade6b62fc1e2f47f8f53b1ae216d37153a3b3cfe9b0c2d87e06468ffd4c105d9d08301bc2cc2409faabe6ceb070e92f80c1cd9bee1f068b900541f567f6860a3699f569340d28abec9b0dc420e61cd449f9c169bd63b756cf64c2239b37efc675ef339fe48a54425f79aff99b8566763439c8172309d69c7ab366394daead7d419033efaea8ac7c40d6f683bb93c23934f1e25fd20ab596c2558c3d730fbb097dd02b441f5850a1a0280e0b6f031027a89bf5e55ed2ef221114d71d55d0f21ab57cda827e1d41ef01b113078fe94370b6aa7c601b5d79aa2bc80c22cb57e745f28ea1b0373b6abd2ebc6c744b93d903f3d2cc4794355f70df3efba565f2ff4c28c77ac869eb1052d4739df55dab49104c1c63e776a778dc6a44f3275c76b84d5c0deff93e6271d6315c9674f45c191ec0891ed39b4e973eee5756a9a72eed55638fa03fdee4eb20b0cc8455197543244d1259273485743994b026b55b91143fd08c98f59a64903cc5177f0c66dedb2663995dbdc9e54204ef5b30283d3832dde8767c7e405dbad4e626f0cbd8d9a6f36628238f8948d799836cf5af03e2884909dd852ec8c8625b31254af439aebb21005af4cc18dc5101d66869bd46f072ebb56554501d07930b657e09beee4c2d665e4d93b91e1c92c965e84d0016d08367bfce4f88cd8576fbf8b123504d19d614599b7bbe74fa5b0d4e0bf274acaa8d4df9124d749bc605b3268970b92682c8cbffb0bc00c2bc9fd83f9d19fcf81ebd2392c70acb4249e5a77aaba4db9e9df70230779fbf9fc6e7b900fda51116c51224f536ce2e52e51a6509e326b175070d4258c81a79d9e0f1d123eb8d11efe081e2652936d65a629952f8afd0319ad000e53eaa605f5e6879f9b67d5117ba02dffae9f2e92da274a49f819d76abe299b7aa17b6d56e88618901a4cb1f9fde77dcc083696556df9a5e809baffeeea39c5d6d670fd6164e2a4e85ff79c339dd562b46dd04c937595fc1c5b2d2976f41864d7827e1ec6dcff4efae99e2af49f87dceed8ca91d0f5155c1a907b92faa0b5a7867d4b40828124c3b901b730e4686dcd36f4476204c9277f171e2c20deb925e8a285dac982aa55ca5965f45edcc22a09a2967311d13da21df6e89a3cbf33d39c90f7fa1ae9bbc721acd7d334d0f3ecb9ba6598affd9ab0e93701868bf620738ebb8294238bf6817661cfd2eaf7f92800f950a0f4094d219e28067626f57c1feefb20c3eddbf652d32ddde77871f23c2f4f60ae0a49fd2e1cf51781990eae19bdfbde17c2902d5cb91f045cb07772ddd7aa3daff6cfe70cd1fdc550b34786e83dfb7c7ffe3e966185e211633666b249278542be1c13d7c809c7317b162b800a3591f03aa2a92b088ce225a3b88294bf65092eb960e826e97816cf1c1382374931a3f617a71c85f6056cf8cbd18e92f7220a0455a8ad7baf6596d533dac85b111b1c4319e56330ae212f7f30c39c6897f9bba9102716a04d937174847100c409dc75847b94e6574b7ebf49568c9b05986de478e2116d41864319fb4cc2be0ba07d7b48930f373a9cf5cf2cad042204e93484a377b3e9ba60bbdb0c662a6f4b692e2d117b3e799ab4dbbe40d2923f6720eb9db80a03026e8f8627ebb3473cb4ce258c322117d6bd77822351d64c1afa86df2de87863562a65b90a937c8db675722285b6082239c402dbff3eed3a67a552d5c2a3b6a441f8b2cded368b9827dbe650aec7be0b58f1d1e46298dd9ff8632594d34d169303de473b0356e1835da602beb2be2e16aeaf9b629aa1dcb18c12b843b469024ceb26602466de42bde8836e65fe8d929687185698446f5ffa46065ecf64ea3241960acd0b99ba1c19041cc2feaaeb966f1ca1d30ff04d2d0028ccb6c5eed1a467482d50f9d0dd701f18730b10fe80b43069e46676be45ddbfba0f090286b506e3828e552dba3e427f83092bb066ef3d8081178c569962ba22f26a2dd2ddd03958e19a7772a09dd4968d6abfee2a60469caf6cdfd104c89162b0a28d03d9d3a58540ada7422c5f4d5343d946d5bc4e716a7d837815ef62ea0a75a952af37321b7dccd7c196571d9e0947fbcf225b4cd37b71888be584799bf1216ccdf0090c6fda7ed6a53c1dda557b346ea673723cb74a1ccdd686a8110f98e72dde86a7c6596dde02d0bc753c755ddc307d988fa37fb47c658e58bfdb192ddf65c335245e1a2e01ccdd04296bbc5a6fd3e5de1c0d8a39991e10560f926f9ca4a3f8fe74ee8f49124d56e8bf2086e026817052cf5c691ce519eb1799e3584998d5cd298a16ccf63156970de3c6f4a9c88f18a30c345c16949b9182a962ccaa193d9a278b1cdf59df1f9aa37efdfc6990c2ed5dfdc9bc208abeb470b96eb0a20f049a8d1077e452260ddcbffa263727712fb4f16730ef0968d03157cab4bb902bd443fe611052b486fafa89a722298652905811a8b88b0f6c5910cedb1f37715d30e735b5cf1411a23432c4849da4d3c5eeac80834946946dfa44b7301ea999c69a7a00ca12a042a3a3a301e0b24a5716474773ddf6b78c54ac4c62b08313dcfeab162bf45e82c5e150a6b6882400a131712ce5b2ff219c4fb943a17ddbca02f7d8577c743caead062997fbd104cbedc5fd87bd378224467ccabf195ce6c5c2b55b7b14b5ea8568d861c861342fdacd923c3c4538cd5792e5598637498cb519095664890e1ac92f1b8f07bc31f18c648e324129a699bb40632ba430a0a51a5b4ba4dd5dd6c7031e604d945c81c1fba78eb89831b54ca187c1edc66f9a0db488239c1ddfd291b91ae91b74268d9aa95eaa14b43e63f1697a8c5a23f5e2bada33ac72b9f95a31c2581826ba2f67b26236e7113ccd9ceb98d45a2bbb46b138a83a6f80ee6878af2352d974feeff979e945a1fbb0cbd36aa0a5233836c36ee52fe5728294e03b5ec64bdd8c9d3e5c4fc118cbd36ca297d859abf79aac910739cc681aae808ef3a48888982ccf2cc342ea258284884ac55095738dcd407702cbcabb39620e15d972e640c38d0c174cae58d1502614f82bfcb8d0bd313bb044731f4242a687e8395d758701eea310af9c409d8a4024fbf7d8712f65174ad86d386cad4edffa521ede91e949fbcd0fb78094170e314dd098660673ebaede71c5cc4fa459720c31db6f3310d4e533db74dd219850ba47b3b850d6dc323236cbae703feea8e4e267f9eb3ba87c22cc9be0a04a08dff1deb62fdf3d497361f8a732a159342cdd5fdef60e1513a9bc73b0320d581eaffb400ea64dcff62a8287280d35f03cf670f0e3fb395f9d0af4133cdb9bab0f458aa6014616401820132495a7575af3f221b3cb2246365e4281ded56d9cae4cd92318b30c823b58a10f4bdb57ed422fc1a612b0c2167ea0e3119e9f23a2604ae40924e6e657d3dc137bcd2cc1263f8b9db9ac680ee913a49d0593870f18b2390bc4834b0daf85c54485ed03dd6603b750b9c8e2aadc7302944cfa25fe3ca1c61907227c660e3de37f10cc01b57c9d8a812fd2a3bd8cf8292f6549bee28f42576644460444e1071b6a3d959401eee55e68a92b134a836816364aaa8eefe4add0324587c74f2646845774d813908b3060e69564bb79d769c2d6c2948b42fdbb15b9232b69719d69916429dbe5e3a81b918027fd947d16fe355c9de138ea64f9c16e7a5f953bef7abe3198e872c5b44c8c00db86ba3c7c1329f159d036b2e18a2f82c296196a0d104648e78083404ca545a9f162cfd7dd4116335a215196e6596d9bce10ebe437a68857940909f682bbeb152c682d573f10a62b45d72e9b93d852bd13f1b3cd9cf8f08ddc03de4c576de8217ce77851cf7c9ff8144ce935c26b45caf8656d12cb9943d2346f584c5b9faf96d9324ff5f3ee36089517224ef7acd852253bab2434a3cfb80c822bbc5f45734b7798c18e8ce9fff772c7a9a743fa1309162d4d8cf05e07977f21a829cd2eb48cbf81e7f6bdc9988ca198a33217894bf38d204c775d7d8d685f0b8ff3dc7dbb0693e9c545d1dfa1adcdb1a53608e59fbdbaee93d1949781a413b25a7a760dfaecb9d5518b3cae7958bcee71340ca2dfa844ff5f6f847f4bf298b27cf1fd7d2ec3afd48711cae577255dc5075c3c1d30bf5f99397fb6004e52674aea083d8562d7f3d54a6690366fb1881ba376b12b2cbf2fa294a623f107810052bfbe8f19a75d2da1ec22293fbee99bfc02ffb007ff825fdd222191f4e9037ae814fc9aea5ca4cc4a0c8479335afcad3ca8767e059e7e5f664153ea8485d68c3fd0b221cd4cd614f5b7ee18a0516cb99a8c043f358493a59bf8cfcbe4695beb8d15f179ee21c63483484ecc5fab628cdc896b822a4dd8d57ce5231d36a3c20cccd3dd1704eaba7a40b22e24b1f20bc69f66086d04c7e4c13f0ffdba0a457c5f03442d2febfe1306d7d759f3e6dbac52fc30ce5e194a5d8a4cd46af735aa6a6765a6c3c036cfca97e6ba60d7b7bb3ff501c1c8c2e23a013671bb2b42c6c5704ff13ce62297c437a56d8431235385b7b3b334be05411a1044148a6b5897e3c6999076c2928fbdfc4f91c23ca26d31e380ef6afeeeba3bb7a63f4b9fcee25eb8f855cfb191216733dba95ddb49103ca6b114683d21ee510c6b5b35c44354e5f600b7ab7bf5a6c300a7f71f9a79f3f6aff600639a7c192cf973baf161b314dd2563ce49dc6a043d5b8117db26e382c7b6ad5f39163129c15d6203388379c9806236be3d963ffa731a3736faf4f656d87c09039693b05a7276986959a3c1d440aea00a07ff4ee92f1fa1b4a6414af84fdd0f6cf9085168d1c16c1acf3d3df8b5a83f408dc10fc1f06237dbe69fdfc47fe0048c7fff458ae9cba18855928536737b112c8ea82b59855e9d64426c5b526965bb04af5567989f5111ae024c366383117c67f1d94d59c64b1a663a94a0c9833a07276dc509bd1eea7f0b91702dc999537995d05131674b7481ac22b6cc1658a370e6e83a408f798580d43a6c28ede44fc833f9761577bf91bc9bad3860ae06f2e4d3a3c97e047fd2ce0455f0055a30df96b412f2ad8508631b592f1d658bc000e84cacd0b544030aa4705f527425381b9a0d935802c444ff3d1dd46f0d7e22d9c7edad042edfcf9e6cc5a5dc438694c9723a31672d260c0184a3167971d14f66d1d59ece1052d2621ba0a9f6af6fb448d4c6bf9fd97da9ac8b610dd3494a068ee220cec679b3d1b131900b2a99f663dd44497a9318b61b1c3ae672b5091d90aff76f13cbb20ceb3fc6f788cf0de744e88cd74f1169d63aca85705f61dcb83b2271cf18c2dfdce59f14d59147216edc706e0d5ced3ebaafe2f7c58f1964616f1539bb2e0bd8376e63637514cb381c90f9b745430dd418704c71c82e8271c1c0f3903fb007711ebddec95066e9232a83d742b7ab1da83cc1aeae7646d478d7cfe2cfb64d045959addb014f3fe524904f1dfce37037398acbc0063ed45b4aeb4c2c51469cd54d8318cff16d542676683f21cbbccbd1ce38d512b359ed3aa5792caadef84f758e17cb31c318abf2094ac7db909e1a6b59aacd1b11f29bfac90b6ab135de03bad6c2e125d6807966066c3434964493ffa50051870096137d568a98ec3dbead9625bbe813997b9f3bb5a3b5c5072f26836550dde1ab77fdd94fd8d1b74de6b6f00bfe0f2c3ff38e60cbdfc4b3a7c431dbc5139d039125bedf1178ae5eb7e56d75707c2a1109dc14289b6ae542dbab8486420ee7b281322b49889c8810107d935e4669d5914fe250e2d2ffa43d6ce474f0f2cd219504abafb77eb396441620f0d50a81f810b1217905b8f1d915376859c808f70555be2e25b440833f6214ae1233cae6f8a6f1cdfceaf3e14e8be0556508183f1f32b22159191805e11a767f1815d74500b56b66ba091805d49d2914142be2c5b4b63d2e22e72dfbecc3947f2c0d1d39c65e87aa3e00d8f1f72e298f80bd863db8e2b7765c0910948e77e38911b3d9c67d6162afbac09abe7b3267362e91a4f1db8675e439f43382d9428f27655ee54fb200f9ddbb04cbaeb21cd8bafd85e163f5c66bf9a492a0dae536eed4e4052e328ea73ed202625bb8a86d19c90b71413b160735850f32fa117f7a0e764c9d8fa95f1b68b99a58d845aca64afef4dee128d493d99cb08ddb8ebb483b259cb65c339c3fe8787d6473af440193c9f783ab1a449981d7875451e4a991e8bb481ac82cb9615ede35de3f5ddd6663e09dcc8e7cce087c6a6d387b0b4b553707059f36aeb64f884ba0aaac7106bef175d288d7d610407175a294abd1060eeb3fbffc1525d7e39f1785f251914bdd763193342bae1b1b828cd4d4de7162fb9b4b848e08421cb9a847beb233d12a905dc231794f31097187c3c410dd74c5a0b9146d190342ef4a3b6e5de6006b601f2368c0bfee85392b762eae6946c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
