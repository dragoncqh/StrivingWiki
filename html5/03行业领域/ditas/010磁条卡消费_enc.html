<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67842bb92fba5894621fbe388258fba23b7fd89b8b7039b9f0caea34deceda68be4f044ad32eea3ce750ec91ded2967378b52a4affd042bb181b957238bfe3f75aa72b3f6c588cecdf8c486ab1cc9cd53241b4e3310adac2e19d196f4670eed9755e9f871778da8bca27ba189e1487b3c78367c28a8b2cee9e1b44e1ac99fc787fa85293e7d998678ad185c2f4fe74eb3055b2216fd811712efee6e6d736a2c33c32c484586b8d74d6e8dadb49598dd8375700c899b66d7a226c31472d3d042e07ee856aa7bbcfe1e8448ccfb15b802b382947b7e12bde2415d97600cc126016088e945a4138043889926f040e1306610305e0a97067bc66bc6f5e14268c4f97b7550f8bd8bc839c7f3ee257a6d74047b9cd9ca80f6cf4323465aaae78592d86eb2163dfed78a35b9f42a3b01d30ef62a7125542d022a62f4b4b08453de638f5e298ed8f8e8039e0d969fc40fc0192b7149a280d0526f87159b0ab4e308e578462bcb70e6f19847568e66a46c8f32a933d2b515c1aae54416996a6cafa4c794373e5103d7e65f8e83287e65702ebe08bf6b3890ca6d9b0a51a7fdb366cb8b025ace53903637f4c17bed5693d34681550f1c6028072574cc029a332bf140376c8a57fe9dc73eae3a2be162893cd84cdb85dac1a6d436d6a4dd46de2a3da59063d70175f2238aaf8ef8e5600ae4ac61768a29c0747950d1ceeab30602e363a4d1ac34f0b360b3fc545d93d4a28d5de42530f3060a6cafe99b13ad667fa93b4b7f9bf538119c140f96c770e83f538d832dc64c7371e16cbee051f13b0209c48b0103f7a467c9e6c54e54c72acd68401e9d06bbdba78021f6db28dbe6f1d49ddf8edc3233ef822bfb08137c67b1ea33610d066d9d2958b8248e98663490dd0d1de53513c4e976e4cc1c1beb51bff1dfc5140b03b2765c5151c625b18bb4892803131a5d64d7a8312bd53b4f74a35c9be5e9fdbe7a8fbeae087b964e67582b65353e13c09d22d26d8b3c8d36b7ffee515f440a002fb34b24eb974e545b657580ddffb75ef6fee8a61d10eeec5ca67f8ba06ff3b22d35fbc7dc4cc7df87a047c0b7f53c6fe69d23c0a2778482e010525efc3f9e07358e94c03d8dde580c9068bb8e19fe24a96e545214ba7ca7853c5ba200ca6389de9e16d80f25b49c1a1431f253fd3f2165820faa59b15e5f2c9c16acefb49c7830049a5dce3bf1597314f2e4d2d4492e37588d72da8bd28f27e7b9e7868b2182b49db800f2dfc185e309101ceddbd60643fa5e8b7996c2449c60534fd47cdb30270ab2251bcee651cebd164e67b2a54d984a56261c950c8de83bdf3f8d073a5da7b17945f92094e37a592e792adda80d27cd4c87887d2be9e799a0467d4cb64b4dbe889b010c5b0aabcab83d2f346d12fac3d318a0fce5064bedd7d52a07ba043ffec23aa3f6bed29e380b3120b6e9817e8ba29ad8898d26a563d3a735fc84deeffd2cd42f8727bb604e3d415d3932c30063f6a9649a59f6becb809edab775400071057ffcb2ccae664e5909611b75fcb15e5409eab2b08009308e378defe4d54b96c3ada28c071a7211f4283ce770af96497d047f3075305beb22fc57a10f71857311edb2db4180221d0ef8d752510e6a6b595f5a5999cde11866fac90ee7d577d988b0f1385049077ec3082fbaff3fd945a2ac13e0b11001068c8b0ebf7b611e7563fb80ae5c6b210bf96e5efdbc66d52ba10b475be973265311d3041452d9c1765d4944369aa0fae8e73d22638867ac00b316950f78a17a3f7e3231ef918924ff0cb3f2fcb4879cda756891e5b617f983db6746b3d7e640ae6b8928c1042ce94cdb86cde395721b5494c574462749497af3226a45c978f15882636be9bc9b1c3a2f06545874b318fb37ae2b617620b378ba5aaf3da98b34014f35af3fb90d7d0fc9e201d38bdd44d0eb268e47f16c2faf5e97b4c7f40c3ea5cc1a93a6399f9eec3289491374c8b4af6027ddd295ba4bd03b8c37497b08f0f84bc6255b23b003204cc080de298a57d39b5243490945b895dae1e75ecbcd507481f9ab1b85ea7a6c9fa99f5f180feffc89af566de9c57d74175254128f20a25b8d86c618c381688201ff079ee8360af12d77da856fe60cd1098dbb7a829b403d487c824dbded5f70449e9d8ec89e81e24fef381c879e532d328f7bfa243d15c0d0fc36de36ce94cd44cf7960045154b97438345d1a26e9cc6adc9af5d35de0fddcd3fd46d21b70a44973be3b8a8466f4b5da3342b5237da72e61bb4054a738190cd2f4d60b9bf709ea5cf6507fdd19874dbed96e84834460ba23ab75e4818e553eacf10b1cc7f630cb80e5425b7630737f8c58370d1ef0feea3f7fc27e20c7611d77a86623d9fa11bd248be0a6097a971287cc06cb69fec09e980f2b37e1d7a46bb299ecee96f60388cfc16bfdfdedcacb77aaf38c12ed54a95f46f3b1e83bd5123e7d3eec832633112d0f60d71459c3e83711b640609c1bc04bff57ee5c5111dfc203eadd5fe4dec85e55751b288e9e8059f34f3ba6e41ed765386508ee2d0396133ba23236c883d4b0298da5dd6b5a1963367d635ce1bab771754999e8dda44751ce60bcc0edecfbd6a3ccafe002f88277e54d9042e0e8d29a54cb068c2f372d84c6926bdf117a56715aee0a48536541827957f31f9fdefbcab4125383f370b14b3df236c1f920391f9ccdc857c703d9bf05ae161b6b1b2b572054b25010b054f371cfa987119c784ac61b967a2f5ab4dd94f78d709feb7069aa6d9ae38ba8d9494cc7d8c5da5ab2c8faff32639ab5c03f4f60ab85f7d0614b9ea92ffef8288b09a4840e8cf44decb25314c531e3187f2a6d8dee6a17432d513ae0a60e916d18d6d2b2b88e42b977944290c8dd9f50445d43c25dc91cea3646efca635d0de0173208ddd578b9d3eb09ec3f0b52a8912965734a0d5b95e804714a83bd6ca2f5276cfcf4ae1d7ad437171224c520483dfcfa469d2730ffee0c4cda4bc4f0b686e7239552109fe58b41164a6576fa1d5f44e645a65e7c36525adf7e749985a3c74188fe72c51d20c92c767cd606e3203a5116c17bb3b227094c808fa899d1ec3e7c7ba369651617574573d01ccaecd7610922040e11cb0e75eda5efea86fa60c33190ca10921f483f6c5a8e3eda0873f78a09125b79b33860e3b34814b7baa9d77bbef4028d72cf1d540c5772d9bf76d9bc8282b5c407425478f617b175b008dfe98a1e2cac8bcea71d6f899e66312eec9c03caa46e2539ba0221849f36660521ecde60f84f29d620f051ccc6166c4ef9a8514bb8836a1c955783144110a93389f19491e8b5ffb13c8a2c255c5d88cb81c0745b55c12458cd5fc57d4a8d71421cf8aa2010f4e2cb8facfd6b876bc9259730e649beff1ee045b1414e3288507cfec712c88736df6ca6748174faea28c4614fd81ee7d88005cbf09822da026f756530b7c4db0bc63c10636e3b4d060df6bac400a00136906162155f1053d5899edbf16edd0009d3ae641aa5d3bf80cc431a15ba83cf079876ed0f21ff898ecdd1b5f5e656d4005b41f3250ae5fab4b8828f6bf713388e4061aadb59093ead4413d229d65917ce8dd978a84766b52006589c166593e971c57dcfa28491f2c8a13c6fd5c83ee3665a277d39756023f4c7b2ad3608d4c792c9475e821eba19622686e94dc18c916e46ac1f05be2b468a75bd1fd7c9e13c874f61f8f4456cbaf8de25c458d62633972e7bcc70021fb182229f7416525943b5a45dd3aadd250ee949ae1cc41b0ee90f44f9af01b00cd34fd3dd53f8a27275f7ce74a9dc364c40fe0e5d3063237935ee5bd6bee4fee9511244c67d542e951be28ab5657c9407fbc951254af3065081b06e7088b0e47b081a83ee8f5f7a2ac48139647e01d5df6ae8502c55d54f4bf96939c0886a1a341aed9aaba72ac8499b5e2a2d196a2406381153f6903f0c53d62e8e006f38874a5f3e1f03c6747b500f4e842c39f8f9a125b39bd90f305c56b3cee51321587abe856882d4c28e1301efd0bb92a471ad2e6b3d07229c4c7c616953551dc028b90a61ff101df2ce38178c74380d971436b5ba7ed7d6e4ee9334afd2d38a496d41c8a4f2ee54b8928a50645b9eb5eedf2e171bafb0eb5a81f7fc66adc2b9f7e327bfce5a0e142a3079bc0a5ff9d66392df554d13c0f8c060ca9b1ebcb889652ff1d110f71b48ee114e074790ffb12146709da0a07ef9c5c9b697d24d38cc18ecc2f21290e88fb554e65642acaa7971c97368e6a7f03833338796759254da3f245d729898f8866f07d98c51503e28d065137788a1d073f8bb1614892a7405dc4288c2fc4d0ff5dd929cd57e4e4cb9b86ee747f2ac80eb7ee016a1726842350759527e3aa131d2d9cdab5dd0baf2dc1aaaa2fff0a1c1c8b3c44952f979720494ef5ab14b2cf96a4dc15e6c91b52c0aaea2a78fd1c4dabeaddaef051eb933693734ed7c9a476e57a338917ff868a2cf9b21bf044732a4c70080cea5e415dd994d0c9582c5917af4446e23d79f87da563055f48b55e65bdb9e68d6d51af728c2dc27337dd149666b11c3927ae14d05584abb9a0d5537bb452ecbbbb6fa40450069ca17dd73569a0c7eb6d5aae0cecaf5cdaf98dac961081b390e305d212f859c6b06700ba120cef2d60e60eb2f9e11207be4dbc84436eb0ae10381477b6a91fd3d16a8ed7c565a38220d2d77ad7cd9afd6e93df8eabccc68fa819de5efaac2424df3e555a570bd1e8d4b516b36022a0e3d1fb7f1f4c8d71c70388f701e646b699aee8a9bfcd2efa4b7475b1ef6efdc3e050caee56c5a514a4e92f4156859ddd7c5c81e22833a9a9f8218777f03cf33d366b50b3fcdc9f08af175e5628efdfe3a57c5ae7f30f7461bbd49ba29c40585c1b8f693f5cd8699de0de098429391226b89675a8dc30aab2ac0abfd6ee1e6976420c83280b6eee1fabec9819d1f8e4d9651a93a8329a6396637fdf91b4a96ebfbec1113e6916ae07689856e92d3ffe506864401e0915862a36cc817579c7028c025a965bab08c11f7bc28ceb77c416d522d8a29f4761f000494fd43baa3982179ca8fae5f75127ca2ef614e1ed19a1fe7716459d54d3530c8d3b10f747fc311b37077dd0f5d5d1cad9af1047784f1c20a4c23cf6198d9fb555146e7aa611f5b507a753edc5b8bb231107a4b5c37c7083ee6411fc2c46c6b6db6f146fd59cc67a27283ec1917ccc57b814df36b96ee11096f12507801d34567d4ca6ca51074eb86373367ff85c2c7e2ac5bdcd2404071fbad70881acc5abd901fbd69a524a246aeaa80fed540aa7095ba17e00cc2725e4d2a99e1c408c9e9220fb55141006ffe4b6bb3a81ded6b83fee86e5ae8ef4e87557c5edecc2c2693331dbd97d0fc077979a0e8c4f66d7b06d64278ebb6b9d15919c9953e8af0f4252c7bb1c52da80a43d1614430209b37cdee1e01c0add0e7a004f0e3fb787f74e4d720ce16e5b672173f0921df2a954e79f2c27e7fca4ce12ed479619696c67b546cd59bd5485cb3761eb353493b4bb7e3a72f0c47085c0738770ed05f0d9db05bd6b4b67e376c0374d417e8d4790d0b2b592f3bc6a1fe97bf6469c4e8e66f98b6686c660e843bb96ea2726a83d50ee3a49ddcf96c1939c030a274231794ebdd913b5f67684e15c68125d5704d4d109c8c97167d1166bc0e351d7bac52ab00527050d8f587dc5100734c43a578dce956e04ea46634d1c4abac62a5593e9a4221d74b1fd2722fee60524270522f90f2075473007b6566114092e85035affbbaadd2871f6739fad3e1387b0db6278325f063108c3fc4465d07d870d18e87b6cd62d2856f3e4b2764fc87c8c0203661685b2a6ad085b5bd944c73408060c71822144e26bf3ab1c8c85baf0cf80ab929b21ddeed1cf9165dff1b9dbcac24ac7a3351b7c89b404770b56fc220b1779be64f4c4939ffffce9de33140f4b48aa572a5db4f3b351dcc55a059f62adba5f527b6530cc61534c2b5f2f7b67a34ca4fda0a915a191ce07bed1055cef8175396033cbc771e9cb87fc9eb84ddc7f4d9a9966c3b044a7c08744ed3135dab6f242301957a855f52e3ad9b219a8e1ba4d5378d8279b42dd3ea2be17983a127a0154b6d7cbdcbb00838b4a5818a54b921eaed467f951fce2e8cbc75d1ce2ef8907d17db5bf4e82ae53ee0d6a86b030d8ac9dab05c8ae449c40fd6e2c68a9f16ceba2702fb621908ebe820e8e016acbc1cd49ef70ffecfbadacaa2061f62643353077b3bc285111882da76b6b1e49c0c90bdc4d0a89a2006def2630d7fc5884c92705668594e8c289cfcce16ebf389173434a3262a191ad2785329e1b44487640d537a170e29c860858bdf8a08e49cfb0d7a4b20d1a9c6d89033e8b17749abd037bffc8ad2eaf1301d0ec2ff2479c63c848776fecb508c993ca25b3d1a988bf9dcddb9c5b82393b61128562a950009043cf4c8ace90df266310bf70905195f4629ede197b7d60b41d89f21f2fc8b34158eb8796ce5588e49e9e7025cc877a1bc9633bdd80c163edfad5dfdf354c671d5e035c188c6b02188c6935f8ebe696dce3295f9c84f42ff603d3d4c302e7b3ce0aca05b198e1d338281640a2a5d322074abb7b4bbd4abece298d1f2dc0a1001b2e5cdbc86109cebde723cdb34bd1529acbd6c728d9e44f4d2ae95a0018dd17db99fbe991e94aad4d5c884fa0f9b061776446f9778d513bce55120b382090f030274d0e5ec828f2c42befaf09d12b024c33e97803985805a4ea7ef2f9da6ab89c0bc4420a85cba32ba78e083e4c6a85e73f54b65c9382cdc737839f6a63c08015551accc3727e965d93e844d46d0c7bf8bc9dbc19073c0a56c168aebd2022b5b35cdbc832da90cb56cacd078261e2251b58300076f5c8b4ecfc52cb8e236d49948f3121e459605637ce23127e414adc84858975131c94f8a40b3276c8df4b2704d71ed55adeadfe4fc160983218ce2f133c38a8d19ef2813a7af37c9904347d73ab1f4c24a8ca935a4e944f6bebc9fd7f33708f92fab294969d1bfc84dbd64f72ea9b3b701ab3eb4f2bbe46392cad2577b85e024c983752d686ef02d8c16ae45fd4fd72213c7cc318db31dcbc68b3fa8842b5cee8748d4f28ba5c92316d9004887cca587e0f246cceeab21f7a5ecf6176b721fa11b6d0a3aadf20008366807b82bd13936164b3962554261d624343875134c8a88fb021f9d8ef6af521c848f174a037770333ef5b98eb72fa29de0eb440bb44306adc27590ad77169738920b499723e898377cf3291b1455e2bcf215179f0a69d2af4985c948806e522b4121f0cd44c162bcd5af5233d005459e68afdd46f8b65a5aa3e31b4d86f1ee11520862815733db2dd9ce21288642145b09a1cb60552840daa6dd64058f66e3fb706589e7801597fc76cf464c72a9abc26cd88f2b5b4255d6bd4a8cb608891380cb5cefd11a95d120a6db9bd8b55cfeacae027c8d716fe77c738fb4bbf70b9c450426c63ab003db3db1e6dafc58362aaed38bf0d4a77f82f86c6a45d90570efa37b1eae1c3f9810de530e534dfed071b47cb74708f449662c66ae7fbb0a304bf3db7e54943a743f83da738241ee52ec26b2f3ab86e2826a456c414de1281dc50e1271b3bdbd7f9c49b127355cb6d46cbc74aa4e244f80eda1f7393fffd4f618c71965bf4e1552b36477dc33dac9f180fe19da14df176ad26d08fcac6a0de6d4627461471f27c6171b2cb2b99caf0a0bdf870cbffa037e05da42350a501f3237bd24ef3fc74f7084e7f34de82132d1f1368e1fe4cc179b8cdc83ebcd7dcd199b9131c71aa389c526a4bf722dd38754330bc7d23b763f65a46b13c00b2ee90172ffaa4cb6ece72972fff0e85fe9e7ddfd9109d2953ed617ba604f91a9004bc580549e56257868b167d2b94f47a6c4f1d35668c21f0cdac03e92861cc212fed2d3ee9d1b79adeecebd681b9ace8b8d3e19ced74f69c6effac6d8952ead2c08c6e75a7570109ae447cc39719efb9fe3069b07879298f474d9aa0fc7a22f09bd772d220e036dc31e628e9c9ea34e3bef30bec52ee4e0aa6c7b22caaacfb87c4b1bac0e04d325015ce59198b945cc661ccef400f1380235ee7a10c8bfd7b9d2e22651a19fa7e1c893a48ecbd94da047fcfa3ce7c1b7ac0af5c4ff179f77798ccf679f51820dde354e3ac97e53d545d3bc54d04d42a5aeba24f6488db03ee04f7ba0f19e42b6adbda82de451f92f6c46e9a0edeedc2cd78820bc9f95b17884b56ef77a3b8cf5a2beda24712fc515f40c5d651a0865bf6c96446a10e0ef1d586d470d5af53d4b05561051b30d524c49bc4fb2c6eaba270fbcdeb4634bf077ce07fd414ea866973758c98e9119c128a3a14ce131e2a00f10b7c9aec67f5f4ce894ba0c4419a589a68ee5c36909239098f4c36e3e0bfd05d843f638eb6c91297a479c1ccac4949f6dd0ba6195814f44e027abaa3f4cec0b608089b77128c0c3a87790428e5b539af456e4c7fb9a6d9198496c5ef27d3d511d4d321f8952dd04a29c0970beb79e812dd4ab717f3bda540b6f7fa44b963332f116b132ade30f93b599a1bed433a6f0ea51668825251a24cbc54d93384273317d182a1d6bf77c5055e1f650964215387a1f6ead11c42d5942afb8fbb7193d7ec9e00e8254c2bb1a12f00b1787aa3bd4b2a89bd5ca6a04bcce48c9f088b2914c2219c14aa22a1f826fcf0a9cf6ac6e8a1e7d808ba99c491c66776d1db3ea63e3447b8925436ade813dc946b2f7985d919aac9499a20bcfc8449d477f9d1ccdbdbbe8d5f351a970a7cb8ca9151baa6bee95999af13f16aaba1df9763e70eb711b728857eddf209e096b7a8e08a4e56df37b27b11366f25f5620ed24a2119ce4fc865f6b87a657b4ff8e0d5883498536aab264940e3b82015ed6b305b95a55ebc5d78e9ebe5f3c98f90c5413070c52788f8d14c44b340a5c4b97d1f59fb41841a6347444a81cc7426f36b0fed62721c6732c4ce1fd9ce3c27ac590b3a2a85c9547207101de4633f09c56a7d538774e096207d54d6d15ab7c5c382efdafd3c07306702d4a811fe8f923183e826e457f5c4cad9ed7cbf8e6275b1720ae1bae1a08d95ffaca3e8af653bba2116ec9bbcfba13058c2c4797fb1e49e732006b585e69c94f2dcdacd5ed8d34bf1ac99dfa8a2f4183628a025ebb29b1ce4cf965f587912c1136a99521f0611f202f361dccb6406d87bb91c600257015679fde7231fef1326ceabdda5653f010b86ca75859d45aab55c8bc641a0b000d9c4ef9e424bb2635bddc4744ef9a3ff74708885b33fda94eff16b868a3512693d8121faebac5a8155e5fe35d79759a7d4173df874a5a8151744ce7c84d9d1248828c1412ee2a07f6d7d414f3d75362ba986749499d29f92b15b8b051da423fdd8cfca382bc3e483eb8292049fe53d8dadd0ef8c8445ffe2399d91207aeface6fc64603238d4638b4238f077a8f99d767de2a5556222c1bab5081238224d6f5f996140d2135711505e8c654be12014fa4ca8ce327c7da844fc97c643a41b1bedb09da8676f1422dcd50b18bb6d24a4cf32433f55b3922e599239cdc1f1e0490ece84b7d16822fe77fb93f1d504baf1560dd22dbafb9099281855400338c2b5a6d82bf3b6ede740b5bae88b8de6d54601b21ad8e17a37cd38b5177bd9501362a016d4f97812a6e1a5271a690d05d6764fe53ab8e4ea2b503b347961f4b70a38cba6209377939045589877f940e6900470789f00da9c64d7028a5e41dc64ba936970abfe228b0cf9b6ee958b228b664dd0a5ce30dc1d779dd89dbee318ab01544d71b8faf28a31147d4f53488ae5668b4ced8aad12589c5ae089ff28be92559a09b23bf9e40f2d95ea24eaa04c85c56f3b692e5b85230b4a6aff9e23592c0e7aadd876ef7873d2762ff5447afc4ca910f8c2180ceee569707e2c144cf29d708db59f1247b59089f4bc67e7f50e2e2cf2c8ab32ffd0b8619aecde0d0b203b3b388be9a8d282eabb15101c1656ff0e80f6ef03bf83371e407962ccfccbf0c59ef42096ea65af3c4145b930c283d301fd47e0e15fba5cf6f62807b8d9074cb84b4a8f6afe5d55c6caaa05cef2f2bc2f96f3244acdf9da95d327ee0d1f6f005f46ce768c88046a0480841c74bf122d1e0e050cd196c24204ee3699fd14f2b3cd2940d5b287193282497a14b220e29624ee999f51dce968902db10bd947691138dc611ae975e64d1ee8669b9e46b775af01d5da5a20ebca73a1792783187b107957832e3b1f0303240a20e8da5bd379c94ec4a9cc0b46539bf4ad34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
