<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bebc4102052ef37d5f99bbb282907dfc300ff7f541362af44754f7cbbdce1ce0b4e6a20956941787e813f4997ba7b47fb9995053d36db6255d2ede350aae22cc12116ac66f6ace611bd9b6a566a6d922b3d540b65b9bec8b8a1af0876abd4b5d2df30c51058e4e6cd8cd506a8e3ffe1948347e9fa678a3bc8f8121c8998f3937fcc6947d0a5e8d480b5b0a4276fc067a03631b8642eec164c061d152a7f7f727a8356f6f9d6910e84ef9291fadc16191da99a49cd55b6a3178e7e977832f933879e6bba5511dbe7a3a9de3ddcee502a5e871e7f0b807e6f717cc82f1db28e691605506824f35c1a4d3f3a8fa01e3b47c16b547058859f24bac79ad18f49ab87bad2f3d1cc0d7e6cd904e800986ebf618a0275e418b956ba2aa1bf2737d922cd75b2e0f306feb28689cb4cd8aaad33c67665964defe05792e2bce1695df123b0bd2d2e2674d033304ddd8543cae0618df953bcba9619568ec3ba21299ae7bf508c5a7ad9452ac4a607a24c99c35971605dbf9c6356edb3557f544f5224582201cd672838a27740f8acc8cfecf2949dfce9899b44fd9b8eae046c0c2751297b4c81e29a78529327c7e921b44db77d0559be4e41b9601bdd50b5d2abc8719721ccb1ce0b4bb304be7b4a91da00a50b0b332518d578168da7aa10c701030796ccf05d196004a52a5b27430bceb99a610bbf1ae33c459c750ab2d1d9228241cba7a44a523ed38c0c7e64ed2165feccebe7301ddca4567d6ee7a4313a7175b87b45bb4a8518e7211b0188eca21aa2a71c3ba8ecc1cc50cffab341e58433b7ea92b93ee8b9d6393572c68d4a4098fe652716e69738b9bde7e7bf728709bd34a853c653da5c4756746a7b99952b5e586b5ec2b37bc2d77f96e49bd81985ad065fc10f9119441e8783a86be3480bd08382084a7ab0c71db1bb6131fd4f408fddd2895f17e4166a778c71dd22b7296ca7f46faeecd00d4565bc39bbe676e543f978193f06496009b41746396c91544666fd79a101b08bde15babbcb8a85d809797e90219656954a13e9444eec6dba64c6416bfdd8efefc61e2c7d00d0eed1c124957cd54ce346ef6d44373e7eb65f5df117c40b035e47455dc9c61091ce06cd20d8ef9dbcd716b6b415cfd0875df6fcab9e74ea4497852d78a4969cc33c8046bb24cb4e840c09d929be3b66287a27c3842c22e19fedc2e5ba4d6fe2dc679b9d29d035c54925f7bd222946e28169164f350e335cc1c37991ef8018eefe5a7173a3fb1184e085835bdc617d69b0e1d8d3136a6770966069a5de2e6b3c19471ea1b5207d4751f8304d4d042afca1f405dc03ef98ea100bdc768574a0938786d58c7ad2b31b68edd4fd02c78902303d67816cd28be2f7dfd90fd0d8d4ca7adbaefc9ecca7d30e7366012112c8a4339de751cf5a92c08c23b80f4b7192318153c25052b3006ad4fcdd6a0527a581d117ee58dbcc6e827b7abcac7ae0e14cebee8dab01bd4d7a43def269d2f35a663c890210d98a5f5e6d2fb84dee1a909e1f5b5585b2b0a05a877730bc69500447cc9f2af1ccbc35f2ac1ada089063efdcdaf2f4681c6cee13ce655c8b87b3d87fb20e7fb6348a9ffb20471a1409833c4adfd0c8fbaefe888c0053a5ffe1e77c549090ab9d26840a2079163c3359b56a1e5aa502d459d40d2261d7462fe21b2f1a85ed299955e486c9f47c9d6d980cb57d3b5652874778f9e20b643b6fd21a97058eb4270535e27c2da28908add8857d8270dced2b6783b06475fc3f5baeca1b93ae1d144ddfd33c2666a1322383202768f3f6137dbb5f6a4fca18899440a464984935d8a5f51174baf0c23b1b3c668ce2ef230748f0be813322edc5656b0f5b2d38b6293863355d7f144ff02707ceb69b96926784f82ff3de799501e11129be64e18569f4bd72c9801be83818e5f88e4ce76081a1383e6527e892fdb04c3816b0b7c467112cbbb4480845f61ac74d218466bd9a7bf8a1f350df5f5d623fa72f3ca216fabc2504e021d5f8d4971888a1793983388b521172e1b2b0c172f889bc81b017754e9576449b42a4d9ab05a2a9f77905b4e376cb6f314b0123728b909e2962fb5ac5d68f7fcc4c7565beba96d50903c0050384be9ffc8b577490d9c842778b2c65bb4afcc3c9d95428f6a3e5530025e98814d3e48a6ef7a784af52a6aa99ec82d13799abd210b7e6b7c27bb4ed8bdef916bf8abfd1b0ea00febe91fc0e842f96129783341a06538fba4cb14d741946bb671f91e2c3bc4cdef7c1106bcc62a29e544223dcf89c539e342fc38c8a1748bc3886a28fdbce09171b298b7ed55f5d9e7c0f438521174c6ac92acdeed11788e227b0131b212f58c2c7bae09bd854b22bc55188ffe24247fbadb349a2116ebf921be7c28f452b6361dd8d41a9b506522ab9ac54cba14eafcd99a44abd7099952d23228304b07bd0eed7d6c47654a4accdc9a2577d6f25bd26edb984c771390246a4c6954fb7d1230da3ad682c308e6123dfdc073613883c0a7c5a5c978b4ba9e3fbfc84977242b7689171746a7ae36eba24cef59f3660e20abb3eb5f8c6a34ea392efd2f6845e798030551419435392ad79711b0120aad1adc0dc55fa7629aecc37003e52374cb3af16b78bc8c3221b4c2b9593c1080c6e2e08da5b0218c38ee63894a319d57c9a331d11e5d513b0548781ead818b33e124307d5f5cae3adb5370bc7fdfaf8e8bd4544b9fc013fea25158d626764f2063b55b665902ec5402c05bd57886c81d476ee494b0c3fd1522c0b0d21d5591d0f74b1a5de14adfa513d011347a4586d124764102aeac861075b1edcc4e44910972b7adb23454f6db9a62dd3d8e1e05531221a1fcb00c14586646ad755035a83d87a63621d234dbd5effc7fe8c8fb049afa963dd8f564dc6c09be37900df30700424a406cc146e108803d8ab0ac3aa25e0b5f58059522f06127d21deff433a8464c69865b4169f66976733d9bff0a82c29959c2601930d63dd26917d4b152e239b0fd0b8b1c64e2366c15b5cbab4cec906d2304b0b199fa309d33c9d461012d65bd72cf28699eff7d3546e8808cc246ddc33396f17962c43711e75bf2636c7d97b0ba80f94a050a17715c01c85f43d142942aea8add6a86804651fa1b94bd3217bdc03d2ef5164554c8e568037de1096252567cff7f0c8cb25aa0fab6a2f48be1294a361c1af6d37c2d1768fd7c250c836995f18575d5c84d326dc8a899badd6d4704b6e608420da87474cd1662a2feb316a0b85d2cbe466aca4d502373426e09819eb54de4ec5512f4b8d79df2e849a0fa1d256cae8eeef091081a83b69f223c5d9553f38796cc7c8a3678ee170902a33b3621777bb181d7eb91d19978447e689208ad97980e550a8227c2ee346f7de11e98118d0ecb1614128f94c154c7c71f0874d46a7f20a82af2bd00540a24f6afc98c65657db284d6fb39fdfd60171ae82c061e3bcececc653da509cf519613f007f5d60c639a3083b6a6ddf80fb880049e763474eaf5bae91929b19bf1abefb9d3aa25b2859aa42cab09b4e4338467cf6204db81010eb22dd361628b65a7c4b736b87ed2ae4dd34514ed3aa45a120b753971aeee681768a4c9130753b7a852d45e17007c219ce291bac978f645e7306d25393071cbf7da2bad24aff673cbb3cb72009087031cd5d812e5332266160e7c70c87e8fcec711d710827bd509cdaa1fc639f5a80fe22ddda8143f416983f8a30b6194e939b56f3931da14f3ca9246454c312b37a90afc55c96ee0403fcb5d0876660bb02fbcb087811a20a9fe25d8be5fd9ca34bb34deab8ba86f563b8a6cc1bc4342786a7a0da43b7685b5354e3297f88fc0b4b511a1f1fce282385aca0bfb163ed873c444b12d732623b11c611ff8c9714c2105fd2d5f2ebb2177ee493d12f3a4c7ef4b8fef3d558e1b914094c4354e323c9a7febcf7ce3df4ea639d21f3eb86963faab265b246e1579fce30f7cb9bf6c60b1c3623ac4d71f7ea3898d58024c7dfbdc23c818d822d75afb30a8275ba777704c8dd0199d504a8b32463b1b9db2f7dd5cb5a79c23df29f7aae149e7b77d83726b7af1c7b55ace473f1e977a95ca50ca64e716dba70fa9123054c18c7e3a57d1bcec12580090690c10c44f87461d01010dbdc1db7bf85078d0c50b00220507a6702631c20e4fb7cf4e51a5a91a9a23b61f8ca0bfeb5cd3fb58d52ca3e90dd87f4421abf56da14643520125983f580d795dd8b9976a98cc6449b024c20073d0dbac65b531422c02577d4a9b29e0b960916a22623249c5a1d7063c6ec754f63efb7d370fad2d37c1024fc353ac0bd2d51a3b0c673cd87508aaf5ee8827c1f316d978bfdc507c33cb707a6449f8993143d3a608e94c97bcd206ec6bf0de6294d9e6a3b22450e555c0e31e5eeb001bdc0233ca0b4993b8fae34b2e7e63f67e22e8b050e85c15139353da6a3e1b1f61d37af61086284acb7d5a734d9ed4282b7b5ff5398e61469e98996125702bf315b6d176817fd6dd67496d2b0ce28223ab26c1d1906bb46c85102baecef280dbe22fec79dab8e17f1ea8c159882eba1638a93c5eacba8ff1f4178cd6038f9468d1cddad9ddbfbffbed1a43ba9bc76282284fdfe61af93c480d3c33596dacdcaa980c687066cb4208cfd3756b27682abc345907132b8e4e9d3701d9e4fb7565e527e04e265783d1938fa61c07bdf9bf736149e04a2d6f8a676c6979ab053396092b80f0553eb87f36d6e361d5281ead631755eba21a92b5ad5c6f3673490cfc31d876f29ace4d09df582ce4c62e252daf2af4f0b93054197e542dbf5dc46816554150289f0316dba87358ef9fd9602e4a6659ea75bb42160a327f3c09e22aff97d674eb5a238a8b6e51d09206f2f7e3524f10eda2e561dafa94f2855a658cdb14ce41a14d8ed2609ca32f30929e2b65422fdb9ce8f24962981942e7a33224944ad7ab9a51a1407fec9a73927e7d21e93e33928d1c6c84201798e157bd89ab893fb86043ea85e6902531847de3c39fcd9ea5676810ba3b015368370b252a83b7404caf8398613a53a32e17f8cf1255f23b6bed16d60e382c181a023a88eaac101054607c642200bed3bdd123c02af5417a6fa577eb18f2e33edd199aba8b88d051266303b82f3243e15315d8cabb6d237eae26e6fb1cde4adf9cf4dbcd267fa7d1bd736d60662910b73bc81affb8a367dc33fb4a1199f21c729903762a35b6aa32f3c113e4332864066141d4ba4e0773b00107427a43e3d4d627c05f40e37a58333b365a5f44c527a5936bc1c3bcd54c89b5c63f47eb8b15134365066b36684d160a295eb4fc6776f5454160dfaae63933cc9f031c237cfcdb2809eb0c53af22ac0af923776de938ccc17539e4a67390612540fe2a3b9b73ea9f00326506f631f2a2bdfc1de37b912fa6a787ab144bd6f37d7cb862bdb719d5054488aad6e25fdb358f09f35cb17c2caac70b1c3ca4d1008da15a569e9090e44e46fa0935d993adf355b1b0f61e0ca4c648581843dbe37503891d7d8285e2f6845823b942f64f214690cefc024549e92281bb415a67beaf231743a89dad306751db58367ec211c52f8b9dd7faeeb30fb80017067195b70382fb12fbe16d715e23b024c19ecc9522c22b313a5718daf4a8ad4a405a572600175c80a6088bdca696a698c47a18b20341585436d83ecbf9b02e39d9ef6de3c3631b1362883528e90ddc725f4e72a79113173a6acba2868bf6f947d3772950193aa221e3f6aacda944d58b7ff0394cad2f01cb635bb21e6234024b1b8787028df862b461bcf1670b4ce3868278df0406f40b1fd9e9df69843ad3479a105daa5b1763ed1daf5c9972b458074ca097e6232466d5b255b7b694bd480d7cdec046c2a11bff17ef29ab0bfe6377976f947ef70b8fc5a2a0ee1232908b2256d8daf76c8d7df3201bceea20c499bff16d725ebc0adb89bd5d2b1214a2eb46d810369a482b649bf963fe771bbcb5b2fe95fa4fae9663aca7ffeac4c2e09c330398b7bf1d2eff4b2dfab7fdef9763dded81ed21b3b05e93cab899ebd11804d76a95e7c30016f04fc84d6f82a0be271f1ffccb4eaf5b5a515f6a508bebfbdc05f9e2308b80963871c566f7f044a4279af3b311c5863c5fcdc2b71bf87b6f15f7a17b0d446dc3771e2f72f9239488207754b967cb63a9707e2e6ee46a8aa0397b4476bf4df74880d352e2eb2edf616d71a520ed7476abeed200af9612c032fd7b36a079ac758de8629563e33402716c04d88504dc13dbfa1df44e7d09f580fbb439a742d64f8d549ae49312f99cdc0a8b2efe19a5a06d511581721f2309f890f320a59b59d7eed24e3351c7e0dac0b90f053cfd144870d9445056fbd0d0726eb6f33bf9532e3415ae71d49db74f8b00d3cf748535c1481ece49eb77e0312a04b1610dc389354481ed2ba942a30642ae466ae549bd03d5a3719cfa1453b42d60144a4543dadd82ad24b0510ff00f557a4423ced4a232ffe734e89464aec2d1181dcce572d92578b2acbe2f29eb0d4efa208189e885c891d66f4fa2710062d6cce93aae30a569df375241dd21e187805ac8e190d83edba627fbf4acee5279e0973579ddf11c58bcfa2542fdb18db367528d6dda081bb62bba3bdc24bed877ce4adc9696d373a95faf302fa24c833954599b832787df7b247699c5cf1a1417edd88cfa389ed51e989d8582450f205e925c98fe3b420e0b5a7dd8b42248367882c2c836a29d5819321989ae911404686145c37ec84ff0cf5b59a162d34291131cdb823a0d358b9fed4657fd0c615aa9f3d0991eda2f6d5dcd711c40dec20bb4e294fbffdaa46d9bfc4260a73355cffa06632a4597f3f9cd2a54ce543c4a8afca43aa5dd7c6368ad45ffd43bf6ede621574f9fed5b7af361723b3bef0bea18ade420a97151786c52e5d20a674f029cb5ac588c2eb0e1a9ff3bb322615c54926d186df6203815ef08c54b17976bd9892b91b41b7ed419bb713cd0bfa574542794fd6ecffb5c44abd02891f30aab692b48c28f5aeb245623feab7b196aae2165f84e9f958d5c95cc7bfd52c195898bc8e87ab957cc989b1cc619d40e6091f05da31e2a6cab2dcc696932f35f2a70e1756fc9d44ba327e7e262ca9c8f39432ea1b2377f073d876eafd18ee329c2d330d029b4af28e6b385ff278e28f52e05c61c1c05ea777a6a5618719a7cd2bddbec7bb1ee83c18266a3e23957608361110dca44765d2a25a795bc3eb70827eb2531a4f83f696b4cff63bbada5ef85674132f099e7704580b1ecc52c00e6b2622b7c5d82c6c4c947bd1a6343361ef80f360bf30f6d9943fb4e35b1ff39cb903ff0b12b0f52d9886f237b0672e96c877d5479deedfc0eb05658aace72a41cfad814d29087a56c32b23ef731b106fdeb6b89317143f3962385ed412aa9223f6db6235a2339a669092e6c10717dd313cc0dfbf1965ea6a17d49d7c758fc50ac407e8ccd020ab8bdf363335c4aadbcd607eadd19957a447437f89f4d2bf96c829341640ac2462a995a7533181c57c73cacf2a3bd0caea2e726dd810cba092764a75394bfb5f803a90e504a3d45d401cd8189650e01186afa87bb2c84fc44d4f9d97627a77762cc380da70fad69c36e0ce26466489c0eb5af9759012d513d31f26ef9b4668c0e540cf97981782f8d38419fd57683d290252b87f80722067bb13213dd500e245777e793611f402413c3dec5fc8ceb2f4ca4063f05c433d081216fade433758ac66d3a6064403272f47a5470ba5b821954ee7ba804dbcaa24abf7e45d69f96991897f3f664093371c9fd712224fa4e08c68102b0736dac6dbb64d0b88fc4d39b03ab8a06a9ad2ff26037d8d2a9768e59716624bb3d622f72bfcc52462b04bbb4604592ed00a20a03c10e54859f645d192211b9234628c8d2aabaaeeded5aef3cba2eacf72d17cbae9727e86efded0f74a36050cbad65e2de565ac94df1cbb1561a6583da1319efa7050823aafdc96515a53592622e551013a30c4eb52b1617c279998c16416e3148a4b73daf67d177e253261618ff11da04bc86549203209f3d68fb399cdc4c3fcf4bb4358b4f71fae5581ac05efdccaaa4e709501a9058ea989f0f040035f7c761b90c03ffc4e4e535e7ae1c5fafff33350de84543844bd66e2bf8b139b21d20050f28acc5658c27a29c5e4bfad659164984a959861fd26fd99a3113415b2c85e8c36001ee38c6b6f516c753233a08375dfdc21adcafd40776508e1c2446b4987ab66e36a89ba90afedb0a54a5954200a91f288457fe9ba243d3fb3d189b134fe735e8c2ea81546cb2c267c59ebc34bcfd904192e8823a173791afaa1deca8c2494e420272a39092cbef2a5500c2e0d3a0e54f9b451ad3f85e27ae62f13459b705c0c571f3ac58f9110a5e909a413c38607a09484a715e22284de82c34b6da3bffa880ca19a724f79e1f172fe037cd79576c024ace6e9851206df712dc4bc9c208a6e18714b9acddce52ea65fb5c5a049b22ad083d50ba62d71b1bb21701ed8709e72d3d202661a7f4a2408eec920831224cbc91a9939f6cf173105a2a7480f7993f1845ac44092848399dd15aea047fe995a6730dfa8c67372ebb7970c7b2d95bd8fd7812a99a5a0650d191257a81862bce0c6278d0ca7b0530ab0783cfab15c69af5b7569e1918e9fe5d64a5cb7c8602ee05d942b274534f0acc060c97f992b4004844090b95c8146c7e23f8f9f69ecd3280d3ae4cfc3cfcb4fff4a1b4c11c9726426d470f7921f1a24200c4e2f52030dc4a1833dfc10e043fd3fa21b0da45bc2405e95f211982eeb84d3a52174e7aa29adee0972ba851f95a668de898a5049e054bc5135bfc356b580f06776d3bec0a8560a81bd4f1d5416b14beac844162419c903d57e08f984a616df5015ab8bed9948f10ee73efab48ceb82e14654dc4d548a928fa3db2b88b4dd59e815fc02d77fd069d5085134abc221c81903519f164317abc884fa62272d3401d343d08de8f0fb9979c13242b47dfa5940ec3d82dc729fb481474121f7ee4654678c0758d50dd81e6226725c48fc4eb43aa0525961cb5fe71e2d671cd472c02208fc0f42ee6d12bde2c2a6f7ff243cbeb0f5eac3adda9098a10df87f05c2623d4ae4071dcf9cd7cc0190da94695a355b567a276f4a002e36cce2254f233bc4be769a7de08bf78b1e1600d8e76610cc08086f76a7589c9f448c4ced6335070cd3fdd0114e17d828b9238709e9dfb4eb82a1cf205ce9142070017e5077a8f9c282e3d2a0804eb7a4187ae5f7035ad6607f035ae86370998730fe0d3db37e3fac09f52c5b218fe14a55943642691a899ef0073ab03bcffb69538699e19a86a08479b332828a11162b1740449c4cc9d890173c1f34dbff0215dee7c840642b4c327adf6f746ed17dd64ae2abce3fceeecb0ff65f006708b8f57156716cf186bd908e60a341eb88cc04bd7b12828cf6544cb7dd6d058826a780a8ebfdd9972f1697cb0e65eb3f6c8e2d3702fea5ddba7babb7015eced959203b9564daf129abd633020b2ca5d7601706493dd32d32d4f80da469687ee788a7f33cbcb6c1158c500ffe7955db267507ed14cff2c141479ac1b380acf8234d3a7589d51ae18f10dc98851c55da450f7ef11b94e216f7866e48e2dad73641263dd9d805a9c180cab5364e858c3022eae222d587b127aa49b4b9f88c194f9fba078118087f9dcf60225245a285fbe9c451b68b21e4d2e5ba204e0ea293b784fcc10536d35751f435beb8b329d909766bc0c3e36b8b7e484cb9a80a21a5c443f2ff5897b7d147a875ba91e077be439ea237b4a4aba2d4c28cd33cd602f00d284208ac3721ffa87ba9026d66e6a7a9d5875c5257664d1245b51e11d17f95b83e85d65c3b40e2b592f47c6d53fde3fb95c11af82a5ad2953dc5801f1435ae3d07e2450609ea67316e9f5beff75cb60b813b4d37ed8ee315651364aa544ae038582f375cd1e9cd14ecba44924cb76f9ac3248934654b2aaf9d81bc595f9bce9149e8a380fb1366d265e6f7ad4682e9c10fe241ef614376f9706977489c9debc4f335f1e7999b693570af5e230ab7b6b0e5e7b0a78fab43911ed1de9b255f9974143f3f5da304fa6bdd0cac81f795e16bfdafd5c90d6e6b28f1da8d4cec8bd32a535d396002cfbbba56a3f023d1116373051dfe30b422da84f15ef4def8d92d273a244b1fcfba059ca4307dbdd8f5b3596744fb90a521305d00bc3f9d13a60cea17567b6beee2f83d0e72a9de386b5545ca5e5a20a127a44f4dd7fa40eefe077e55ca41687a331394900d34fe0f852eaca152a4a93db1ca8d326dbd1e05718742858db068494e78184f706197315e2f2b4b75b3d410bc76d185dee20341c700a63fe28a27bddf2f3a89c075c4b6885ee35d065404c9db52e1f200eb22d4d189bfcac921d7be881717228f9feefd017ddcbd8f569a064ca617498a8f2550b6883455e47126619458843af77bf43d7458c8d51b6fc4474330e130f2d27f2600203ac4168fd28bcee633c99a0735fed297620ece6f3d577a7af3f434381ea81b353ca7cc6e9f4a5dd20d5cd97a50ca9fbea99eb745fca9716a609ab8ac277749ce860b81ab85095c93f94e046c49e20253e487697bd7195628cf389c11398429a90506d4f9a3b5f338d21cdc59312c58f1fe184cfbcf7f6436ebf0ac51f55f526ce42a748843247ee4c556b3f3e4c36985a7d618b462e7e079810aafcddd41f8fb43d417b68a3c62f53dfee7ac17c03c143d29494e7c9648ee4a488ccd924638be725b7a50c82fdaac77553929b4b3e14cba56d765c17b9cc2848249c4acafdab1161fcc6e9ce5d1d351230a3670765f95650c083c945c8728015b1a688bf3af4d9d4463344ed7ee13251c75365ee8d3350352fb0257684fdc7e1daf85ca79884cade4556e6c27c9ee731f2c9389bea078b4b268d6cba29537dc2fd2810f8a0886fbb8ed5227aa855684c2dda59ecf3eef9d0d1bace2969357b570ab9f0f3d3daa446c4ecfacee1ef81a787aa08852d48c5eb87717766ef261a51f7c4cbace75290accb59b15b523d8e4344892955a183d5fd70411bf2392a45768bf1c8d99cc9861b879d9cccd91281d22584ab1667da7e35b887c81e568d956944c0cab8b1350629e5fd4783a729047d46302bc6d1002eb7301f5fe5ef9d5881e99eb199c1e88e16621bfbccb2bbb188b1afbf977656f16893ea1ac273b1c15cf9844969cb638067fbb6ce1c80dbfb4a94a9c7fbc8b5be5634a44c27b3338b955b731dcc280bbb5ad1593b1451c5f1d516c33eaecf4d26c26fdb018f012a5f6240d2bb915785d9670639ff891594e7051eb6d29c64d3d3914664eea60607c0f681505df8f3c8e1ec06ddec779e60355354e7c54f322377ab5d212c7dacb4ba00405a5834a5e6b18cc8e685571d079d78674cb07a8bd33604f7ec37e317528c8ad5ca63d0005a4c0a6a51dc01e6d7b00775da07a2716e2923e6ae4ebac3a101c32c6feb698dae6387621a0f2e5418f5fd26409a366bf0ef6762746055a942d199dd3692e719c2ac6a79c4bb5511ae24e5a0ec99cd37ab6de2d283d37b984ba802cb2c245c0698fb672d96043a9325a2d3ca757023dc466d9316a55f4c70ff3be2175c3b95d084d8bf91139d659c8aef42bfc836ae2b9bc45b49472463932a457c8efe2fe8ab260e2802b2af7f087990b2ac4b99c0085fecedcc0c27b0e7a9baa6963a1b84f4af6d82806c41104f04c60b4672e0dcdc63e1e14af07629c0303e6d331e42f7015340a86c121beded200141ca1c2668cbcd81d309bc85fe176b241ad9859e93d47818d7e82773c2adfa6d9fd1edb39ca397c9c24876924985ad6a44375bf379956d7794829aa218e6b271a48a7e53afc076b4aed90911398962f68a15ebb7e0ac5d78fa73c74c3b904ca1ab37941986eb62de6445aa9ebb796e0ef0d9c307b56dbddd343473a82040967ba32a2c2aceb9eef6a7e0bebb1f935896686e3194f9ee349fd6aacebec04c403ba10bcaf71c7ffe36e413459d168d51dbcde7e9ad35be44604bb8454803f607be27ca32a554604a101bb51bf8df26fb377d21d1b5381dd4d3418d4fd9cd5ebd3238ccbfbd92b86c0ceaabcdd9b820a11357c5457fe42c35afe2e64f6934c9dd93fa1ff46078901ea6dc156072865ff553ae8b52ec699ba0862864074261daf4eea8f5c3e97b9e277425ae6b082256e9c5acb26822c2c61fe22761f77dff77f0da37eb64b5c1f842d93b4b9d1c392dd17bd35871b3c5168d31e7965dbc9602d11ea9ffe3b7123a515572b81c8931eed3a1d704c52180d7d2b2eccf43cd3b1cc7ff26d7dbe506cc05983ada68969a43a7eb48f35eb151bcb109b5c485fdade93907403116071ea448a447d3703dd22f1abda7df664137d40f2acb0c641d4d2d9b263612c48c5cfb87b323bbfaf9222ab2d0f413cbc1e4665f8e30e9b7c7b7160f9b6471943d29e152978a21c2cb3dc12de19acd94a1adf941fe16f9e89a14c9899888b772056d0f3c13a6b67e59bffb7325521be231f43f1a69a66686b40c925c64700fc3c16787cf6721ec579ca23813f6a751890722fda1ea66274c352a67802558ab257066c4b4590ffddd8aa1a2bba24e51411f9f5f874c499c0a4087b862b51bc9891efdca3d75e5fdd719447e0fe44b8475ce6718ba078cfe1f04daa4905fa10274b08f4bbe3532eea48180ce01744194818c14066e87e08ba2bf613b48f2c1420dec4a0161b023d28432dd0a74e848326f35a0a041b4844222188bd885de82964826a2e498aec920357067a469639ceb1a8447e4fc81a6adcec469d72ad815f34b82f2758e156249b6309edbb9ff72c033b28bd45ca2f39cbb35a0844bd9b3acb52a17cd7334088a4571e35bbda90d4079cd05ef056299d2793d3d81214cdc622404f05ff02611dc77209289d41024b82a1d696800d21f22ccc66d347efd9f5014d106346e6a3293e040738962befcbfc14f4fa073d2d6a89a13279ec39bf1a9e5831083e22874a0c965a34efbb112c999159d2649d745c0526901d67a8aada3289cc5de6fb8c65a42e5c8bb08560d70ab7ac2f685e74ec6b718014be78876bd467ae752a4593640fdba846dcaedcf47aca168a292bc57246c5435390dfb17b00d1055822f256f0db3f51af04e55a9a16589df9e1b2ef438d026b7fc264b0f0e2c9b32745ad5e5b7acb246c2444bd827d6b304fc776f4b5b3a2df6017ccb8d912e7aef7c2af92312a63614fd2e190ab3ecc8c595956c72c99eb8800b9dfe4f0d0f64d0d6cb20756755cdda768c74e1e5d1740e3577cd0ac1f7c6543c987fbbe9f9bd6a097783fdfa567d9c4876f3d8adb7da8b5b61a73521de0bc15fe96d5d3625b05173b6b77ed2b3f339c799b88751b1ca5187ccf2435850d3fb6b0c0f084651c9d9169b7971c676f0b96241ceac6e9e6ca4383aa885ed5c50212a5dfc4f5a6ab865009a72e2cc0f514f8ca8438a7d8163a00638853f5fd9818b60d3d94cb9c92b34b210ffe576543d28b04095bfd7bf33d9b08265acf9abf4527af3538acc8aaac966c8f1e0cf87c0f9dca8e1e49539c38db78875cb6c86d2392037d9df650f625d952f3bdcb35d20b86b1cf61824a526f56123da676e18dd9074d0930418fa8f531f51bd400cbc9f2b55a48e967123f3e31749e3dd40e6bd3ebb37b34d637e464b67fbe72bb6b9c154fd89be3c5ffd2c3a2e0ba8f3d0caddcdb9ad2b29ff0b5fa2c347bcc79d7a282240ff080ab000cc4924573218372d94c5ddde1e2fd017b78dfb76755aee41be266c14ecaa5aad3c79f238098be2cfa10848da43b8d07e7cfd9b9c0c33229b9808639879cec7f4efaaad1a6b49cc841144db9302ebbb71dea797fe52e5e795461922988926a6df26f8969f289b1a46958b35b90c37e74c44540703200aa8a1ce6f9a45147f466f50a146d61a519bd3d58bccb3493f788449fea625ebd409c6da807f79d9fbac892caccb6cc0c26a81c6d2a9738000bd49e45b6b39d3fc932941f944e557e78195ce2721333b0b9d5a0cc6d25af50aa1961f3656e392b2b966b9353d96080af019750cff034d20c8c60c43eb95a79428975d7749b1185bf48b32b8467f65feaf131d6fc29798e2a03a37e1085779530e8905d55db7e9d36689278b67b88654934e34cf324fed131c26ce6cce34da287d83ea69be51337dbdbf493b9c0db6b6990eab9f2600425dbad365e054fce5a72251500addf2280e3f85018bbb048f2990e913dcb14c76173a0e6d153dd5dc736fbfee2ede4236d5a65cc90f5be73f69917b2ec85aeef81c3d8f5ad9b42776c5b1e792c5b9b548aca6ff7bed00adf335f2066f4f052a589f9d8e8cb23f8507a1f98aa05b0dd2ecda0b0e2ac3ee21eef81d494f6cb0dddc12db5d4865a99002c5b0e1e5737a85b6ba4fe5a9d0ba46928eca68c8ec67648925ed9658f2ab617ffd1d7701634b39d5678fbc6af1e085604189559622511428d59e6dc05cfff52282b743e13feee866af2ba8f83f3ba3067c7b3e99f7e1cee47f34e5fc4c713d9a7e82c60f67413f0b71347bfa7afb3add2f85d90ca0cdae0e3ed13f739004d21f7513ae19fe1c5384d4c134f70e01212f9e7783983d416bd53396eb57b8d6391795568b68dab01730274302113c1ad9fd2a26fe1d2d690ff24d48196c0c02bf066f9bfeabb99cfa541edafad4e91f01741deb9bfd5d3deaaaafce582a6b8e99bc2131366d5edc608fd3540e875bb224288a45464c5b98e6f4aa45f5550d6b320e1f6e940c2d9a9d410d8d2940264b1f7807941d5cc83efdcb8ca0e3a27fbbb1556020dc6a218071814296f5861b672392afb93dbb2cca2b88f4f8dfb6d9c705797c1abcbb77b8f3f66a2899bbc421474a009b2d310b1e811faf9f82c584c4c35c90017671e835b88b2eeb26f05dacc3d97cccc198ad2eb47129be3b13dd49cb0ce9fc5185dc29675942e492def7c0bb2d540f131e8723e1697390dd8b1d290df30c3275ccbd34ff0331444126c32e5ced4505d0928a60ec276db3e25fdcf0379cc6867786a0f1fec878ef18080729d51b2adc38fa5f9cab18d1e75eb82b9c434e7ce4775536c66d46b3adba172fe4ce56a099a3c671652b5ea18d48d0fe9ba56aa4a0b9ea3a814518d9e78890d770a158a1eb71917f64320cb578a4744e3541c077d88b779fed3d75b022c863f17471ec27c9b65b6ca9ea6d2906f72e1bb4e0c71e486c5015c20a3cc941a37e185e2bdf6167918c6e59930123a63809a061fd8a4ba44345e94b34e79aec276ba9186987a2bf77631b3dd791044cd9d5038b98fede9a822cb64eb7c0e12939a80c52e5d99c7a03788528d94c3e296fd09259d4452c6555b031383d444c32b923c7c3a20671ebb44e0316abf6bba11491c5e7867cfb87e99156af2437828d2969f59055c308277124b872cb4ce73bc06a8ee954579dcae1f39a7674dab2a337ce20acd529c43a0ba1af139f5cf46fd3fa842327865ce614f7a5cc809a656a61dd40bc00701648626df8fed39c6a2cbc92a1526e16f8ba66cd0dd73601b77d4270062c985348fe6168415196630b631b3fbf20b485cebce5b805bb8bbd93cc785d62341819d969a08ac50024b0666d0127e2ddb09e2a6352688989581df27d6c706e5b2666694a4b31d19503dbc9db74996c5e5a1edfb46477c2d72de8075d24f3c7384807d1e82a8bd19f2c7d25de7a236ebc0355b712d78082bb9cd30ddcb6a448957753ae124aa06685aa3b56ce0ae4a59046743dbf54852ec323351d1ed7c08f34eca72e01b14b6c873fe25242056d819cb1b86b6d446107f297ac0036f1f1b4bfc34b82fe3efd5ea66ab904555c99fda3823cb655d38d9980fd2aee2110414cc1f4ffccfbafe1834763bb33d80b75c8cb2d5b48a31be715758199ab3fac7719d55655fda6978a28ca2388c70f608ef2e6c2b3696759e240759bb295eb756417373ab47ba860668edebba20663111954e2985ff28c5e8fb8f59f2a518cecde3b4bd2d886e19cf89859ef0a4af47b3a765d4e7dfa24fc19490b740ae5d01f15b0945d9aa13eba4a6a326c563b6733733962459baf103e0b9869170c59e7b60ff24bce0c4d3ea25912f6c35d96a70e1d3aaeb1a8fed52440fd7606c94ed102f4c5e3d18dd32f70e47a54a6f3f9e82be7f287433cc6ad3834a1162433850c6c5cdf4493fd7b130d7eada07daed20a6cebd6e5a5c8bffd3bfc1fe7792576db1998d033126f29494402aa75552f3fe9ab8d1fb7bf0ca586881d46ea7c1b41af041755e91a6eaa93b173ca672201af0865f25e682bcd6ffd1c6480fd26067eee6d26e0dabebf2288c9b02dd2a5ca05c704536c927877a0b93df1bc1b1842b2efc81920c54bc615a8cdcad9f27eeeca13acb44c0652836ab721908b94ecab92fad1ef107a8703e188c11e08958b15d2c0b46ec25f9091daec1c6471b1216b0a95b7234aa67ceec7239b36afb1eb976a6c7bf448bb3d2c14bae157901b81aa178b378f13c43ccf62e9773b1c0b7094e7548b7f33eedf5878710372ca838fcffe9b92b2649679d28112dc6b583bafb469822a3b38cdc3167ee4d2ec56dbfe473da219572c8ae4f8ddccad036ad31e94680e9f34441a6326983dae5105f05c664f6147b457d38b1c99076cbbed8b5cf4b43dc59dc2697bed3d97a39b868ed0cb0ae3a3d60e1a5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
