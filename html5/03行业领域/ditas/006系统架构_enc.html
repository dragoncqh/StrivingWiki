<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de8532a9f1ea29b4c0378a7777ff6bb3ea0adeb47e5c5f2a97dc5540f5a2569df5dd0c817f46277ee5ce90009b97a4959c6c3c41b388873d40f7e56cce4f54fa40d7b285030939a36877056d0be96a890166984bd30b0d7b74defdde0ea4ec74c5f79b197af27fdf69b7e5b24b1c7095bc1a7b28d12bb42ee9e63880de164f23ce6f9cf153cf404a01f9cf970f90691b0af19c8ab4409af08ca9d0b597655b85e92e177d867c28c0acab3bf62552dcbb4177de8ee904575543f55ad6171d779b20be8f00474a4a9d8c434b0ba1272a4beb0bb1f461b9e055d2ef13f8bcf3c5edb55255b1aa8a3aa6d591049008af877b78fb5b6f98b0d0e4c21717176a180e9b319c55ed719737cc55c4b020a6bd87ddab37f49d025bace294cc62393e177a3422f437a3fac17dc9aee89ee38f8f85b715e3438b414e5e3be41ae77110b6fd5fd73f09a4852009f6d1b340d502162bcb8b703c7c60c6836b30012dbd66bd22fffe01bb014c13dac6ecac3b2006e49b8dd0336aac41ea9239c28af2144bedb8fb8b9472ba0251ea4f847912064710477f8c906df1d5e59bd8ae71bf521f1635ae348e7a4db3116b3e1185f2d3d2dae63c691b06a7a0cd58dc80a941dc36c3f16b33c2d7d6275104b5955de878036ce92715d61c42e67c89b1057e40444d9cbcd2bab8b6fe4238fe30026c02f5cfc7d52602f893f27ebbd78d3cd8a9c47fc53046d2ee056c9e62edbd437e236d53d3099af696201fda40750f839d9007dbcefd7bc9eadfd469571a2129d4f6ef056ee0834dd01f35bd0d99f15ca35d8bb2b3d1abf05b0bda79b7dec134144d4844e96b913f1a7a41d0e322c652b6f99b395cef253e7dacb93be246b79f7945e4bb5d4f2ef9d07e635ab093ccd28fafcb6762e979a81ba3a1f9899c57455e64d76cf03b2abb197f4131f9972b5eb6f5916087d66413e795e304ff2ff6a3f3235c41aa1037f31b404d3fb2bd974d9c97df636bdb300562bb96f417643eea65fcac5b34d3573f51c69d0d34a82ccb124e85f97b59e9c7f1fcb6980d891a578af26f743914fde8ec056fc7e38117e8cc2bbbff913770fb95fe776a19a070e9c943fc4a38483b1a79b4bcaa0bfacdbaa1a20a2baa040f71b925b3633215fbac5ef1acf43d98dacacd9f93f4098d14839f762c25e4a24832fc5d6e12702a84b2b0d978c699d9efcbcf7a5b3fed6b6d61e29c0f98c25e330d488393793eab6a9c16b9493ff64e3f7ab1734fe62ae86fe2914723781cc690e07aff3818dff8c8cf002cf276aaa4d3399dee95aac14796a7e763c392f2ce244b55e2a6a8cabbe57dbec769a90334017cddc9c1439e350b2baf5854b02369c49ed427e0f53464884de71e7ae180144b89bb6f3c1de8ed3178fd12a78bba797506b2c6fd35c1eb592e403a2673876e92ddd8f1ae436d2e898d35e223830c5eb30f574a464a142cf7f1eb68099d5ba162ab81797274780471517e51af8d99085bc1412561df88b145e3ccba59da56505e8e3e1f44e3a77dd620c6eb2c19c45e92da636431de6e09b55744f266b733b5d303f50d77f000500f85bc97e4901e37983bae3621e860f3fded7f7071d49b1d83b312618d6fd85053c1ffc3496dd211c7abc1a219b518ea288d699134ba15eddd1537e800a4dbd00b2fa79ffdd52b0457f4bcc48bd4734785d4faa05485c91a6fd923c8ec255aae78df40000e047967d60912a4454db5d445c22d1274aee57a5f7ff2181163582be35e98f3f9bd98a22dfdcaf6505b593b13b74be3baa39bdeb3ac9fa3b4f26a2ee962d31c77b7038b12d35ed35fe8c85fda5f0ae647322b7c7c7955641cc06ced2ee7907b48ed03761e6d15d607a5e5161e09a80eb5a6e3fee826c8f2b3247c29c13a49428787b8bb90ab1a4c8aae96beb99e339338616ad419af63583e67ade33a81cc34f40e8b862bb14115029430551d7bb25137d0540a8046dae786b3a7fc8a2c14a35097442df7be83e75638024c70b212ad800b8d2c66fa375c41137bfae1d6d7df09553585345097ff79ad4b78ce353c3c5a25139d3a00937260fead4324b41502e9c4a2b4c2eead8b3f44deb9c057bd04650a0afdbb8d44608607e7e40bc5c036057a047ebff7b63d5af2af33254d89d46497b435547ab07c091d7b08f30ebff50248b1602356850b5d5a104169c3fcef376af51eb225a21d122168c6e316b193b65cb7140b84673681525e9b55e7d620d5c9a9c768b631aea16447e5c1bceea5122ffce75314221c949868afb102f9e1a6b2cc11f2894fdbb5ac0a800692905ba623f3dda87e5a65c2e324d7c08431e32883881cee4fc4d44012627aedb111d915427fa6e42392f34f3c3c87f60d72e2c7dc3f5219cffe7322e1cc7fa45329b1a2f6bf36575d5e1bcdc003cfeb551d117e5a3bd7018a6702b4ad0462e150eb59c9e6f9ec1c89b8f819ed4eb37b3685bcfd2cfa4592436bee852b974ab2c2428227cc6efa3f3206bfe95a0aa0bd338fe144e9ae3de7093d48798438a59a00a691415947b2a2839f50ed1374b770ec129b092785006ddb4840febef629ce976fe861751fb092eef014ac1e44df5fc63157e49cecc910a1027546d7cb42aa5d4602aeb1ef037a7bbf7a5effec24584a61e74be80a0a2e4c65ff7f3e540dfb1bc0c1bd1b87fce5dafd5d16b184f1e5fa3997c942e05d64bfb15b7e10ccca2b30aba53e991c0d80068009e7b0c69d60bd71d6d570a18d918bf0cdfc7341dd6d4264cb8abe07e34e073cdbdceeb5b7fedda313186b69ed6cd3eba80d4252cae7d3fc155e913ec0704b9fa6281aee2e3d033dfadab26ea78b550572bcee29296f468001b9eae702357ab8cf68e9541fa1e83d63094bfd5d51267e4a1da79611989c92abde298644a7651798bb0ef1f97e68401ab4d5d8b038524940aad8c20ea36bc7170daec16d325f9a7596d5e21e6bb784f732d9b42213b2863136297ebfcb0184ba981a06a751de5d53819da6047e4162218d4f2ffc954ae9524b2aefcfd7106720b4180ce462447eb9895ea1f208cc1aa1ab8d601b1a986ac779f2a2291f82c90f3bf6f0baf1084a9eae9266118c8a8b5c9f20548c6f893fcbdb571cf3bca5d7b9b849362900fdc0304d9745020020c02612c6a44f0ccdc4975428fc044ee5c0c8cbf892bf090e0734c1c791ddd300053579d8da66dcce4b8199645ca5f0347d3526e7463086bf554bc0f66fe6cd3b563d82f7a1e81de241ffd1718a9a17a7c63f59e2bf3b2fbae9f171e64949d154a67047a24bb259ec5340ba408056efbdf4883b29e2d6a6e7b76e8e0a5fd51a5580961c3bd9c348b42d83beeffb9d6151aed16ed0a1a11aa23e476e30f5d1edf54c55bc6206c451cdd319cd11d7a7862b194b84f55608650ef600d1636f7c37437e03fa58462b93c2e3486b201b10b12f1f9b3b065bf112fce3bf524189bde71bd8941384ffb682b2283d06777c5205bcb5de293142ace1dd274e620a66051b43f6485c1844ea6d8f971facf452b3c8ea8503edcac96b8a6a67fb4a0625950cccf0dcea5cda7dc088f63a1ad208d49a0e3721fd10113e9ed12227b379e247bb5572380f138a3a5a1624077fd867b97ea4e75dedef2f0548d5cf1d8681e7fee32365d5e8fc4d65931cec7c2fc9b3aeaa314417f1957741c6574e0a2d17e35bd71ccf4a26a47afed24756f2c10788317fb32227532ea53e021c536a20197eb88952a4120a6323c392fd765b8e3c73b24d6bc33e83217d76ac79e4a0803134ffef68108c63aafe01746766f6a5078d1a48c713aec113e37d8a41105de87713d15d222c2d25bf5164eca5abd9d73327b531ca857532f51643a461540146eaa6725c0f8765f1b65dfc570285af9d408eccd7b009261657e4817bcaa966ee42b211bddfa306cb4c48674530b0c95ee788ab218c792f9b1eec5cc5dd1caa97f2c90e315e1d85eae330a0e03226bd7458c5d66c921b662c66c7096d97f724758eff88e81ed4c52a20d2a164dee1b249637b7de6282cc3c6478677d6113b5a8ee92fa22f517f2588c85c193017cc70b122a7b9c6f957374b2fd823eab9703e69027a9caa58f224fcfee2873b999559777f39edac035fc452d4707db8ba2f73156693cc310c80ca66a3ee7fbe6ab2e5cdad0e840794250b782913f46d3d9d8b016b95a07cfffbdeb52f6457081ca49de87c696b141b81f39fe5d91fca7d5f3ad91652918f82e59eb8b43566a5ff8008db8424ad12afd343532f5116a37f11aa6a0975a80e393ba5b66b355f2a83dd24cf3fe5cd98d70c832072cb70c4d9dfae85e4bae7c2c5020e6f71e2481e22d6a6d122dfb17306d3d26e9f114790e344780d675ff641bd61e7a910dc269ef042452a856dd9762a1f77781873c6d767b83ea8bab86d39d4fd3122bdc1035b531f71bcc238ab8be5add171cc7cfebdb4f490d9937fe4c5dd51a9f3d821aba18db77b9e5a1076a319ac91c899ac06896c4552cb87c0888501ab8194437fc1387e23d5bdfcb0363361fc2b3cbc98954a106a55847dd853dd07c01cbdf1717a913d6581fb41d784b5913a59b7399a5e71fda2a43b10c4c24bedca061ce9b24fc65487d6d12e6ea65b4869c160e5defb24c1af20393dfdb456b122b26227b3bf37c214a25073f21eb64830e5184176d3c3505769a776f6703f329612973aa8a29753b2ad02d903451f4ca515fe2ab7ed177293cbee73ef5f612640d41681446f5acfda72090e4dd4fe4d76e218746cee6fe4e5b01817a6ecdd7874c241f73b008c21aca54e39ded88b9a86851d1f822bb6fae951ed1d9406a67d1ea7598ac0668383c071fec809025524482d99674a0eae27a4345cacd499111d8c134c68c2f1cfbf421f81205aebc418c2a02f6d0190f0a38d68a7f9799299cd8c1320700b4b617835a74ef3535aaa272111acea5de7984dfa14ae54370e6b2a9e47a9bc71fd789bfac537ee8da501dda8cbc318dc0177dc6ff10b315e820cdff1748e514eeeef301aaddb8879f86dd6a9de4c5b3a9b25a88621674862f2c956f919fec2cd49ca2c7ea0827b7a0ddfa164170bb42b20556d79774067ebd4357da907d46004160e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
