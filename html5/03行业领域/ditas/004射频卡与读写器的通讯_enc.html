<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"32b452fbdd84eca1ac638d4bf99858676a777e9517d7ea6c61c5b84433288db9193566342b45830f55f1e208bb2d72ca7eb25ef5615bf3396c5a766714e5d21b6b3384ff2dc44cc33251008b2dbd63cece10d320cd9cf4397da6d8fed57e30ba2489cb456678226869f14190bced15a13701ae846bb57981c9516a7d9353f1127abca0f824e64f8c3c07ca9805f7d96b0f1190359cb6f4ae6d9f942395dd2302f4b874a4b71e057ae3cfb62318c9891044175e8dd71558c3747d2253880efb449536e95e6ede5544ba04db135355593b5e09b55ff506a435b5f6feca38615aa54f2deb79144d3aa9f8f3fbce24b2ed40e4743f265127e0e910032f63c6cf2c17cb78bc66400688a93838f4128faba9eac1cda2e86bb5b960a477d6ab08854b19fd47008b6f1421ce9001a720ae0986aa76c99f4a77b98c6070085a20cc276f8ae58ad4faf79cbd8a67b5deb37519e4841ad78ec3cd27e5f700b5dad07f7067c891efc72c3aa10fa5112515c7efa12a8dc166501c8076cf2f3be79123842694b899ed540e8ed1ca17c3c073f48a851da396650d1714c2e10804e04b3fb9eaea6e1457d5f48d73123d09683e469ece7a083e2907fb26362e667b8a7d12e9ef578e96367e780104016d66607f22fef03615af33bd00fb86020469dc8f37062db784b40bff2e42a135f8953a513a6fa723269ec84b702b4fcb72b2fdafe64c6866e7598f7dd7c77a2fe09c46daf8f44ef127682f16aaba55c3b83020792996c0e96cddb0f0d8b970ff6f1434498666d006c1c05b6d9606c642cc8de361babcb1f4ea4736a6e389b0e417809102b668122c0b4e687d55c5874885f419cab4b15e0104d23518e72932b976828a97a29bf5e99124749336971327d1bbc24aa6d9ee0da2fe2973702575fd73be70a9e37142732927f77ee9e0ace2f4a0846503302e91f146d23b704550d6d76cb9ae564efffc578d5dd5916121ba37ff9c15b58e0bce6b5544e84bf70e9dd1dab0235eab859f4c4ef6055640cbdca06de51077a8ee083a6ac1eb034f903c438edf49a23bb62c35b8aa44db823bfe69b2704f8a004bc8c9310bde034730f88aeb063465710140a5d421ce0db2941ab2622e3479c1a21d4e8b217bce236e90df984053890c6ed8a4e1d205aa781055177246125bdffc8babb8e1ae19c103b98344c87a9a075376bd5e87e5a2dfc9e8db2ea961dcf3d63080f6ca9457626989e7e2c32f1200c778c2dc24b817ab813bbd07b0f83109d22aed9459e807d56a0e77685f04adcbad80a126184e2309aeb36c855e067ddb0995ed67fa0df29b827d08fd926cd2ac8dea1616bf0151ec2cf33523d2a749be010f42cfe39c0ae450dba13c3b291cdcd0c9375f200fc2d941b29577ae8766b3075538d59bbab5077188e305f9bbb4f905191af2bf2b2ea4800e2840d281fbe42a13962e2871354a461b398e1b48f10d0a3235293f4705a2d7a7bc6e9fbaf96a130fe5ad088cce11a0de098e304fa5f969c840a2cf5b2941ece1e6f6d1b2daae33543f108373fdf3b7be5d9a2289d1e606a03d7e40ca9453c2d8666db94f39debf365f80601c7e81227bbd6256d34325c6a1a4e03e0289e47f85744e1426b22b15122d64ebf947e730d9e4dbcac942382fde6e0b19499f04b4e80dadef783df3481a94fe677fa7bb97a57f68685559140d706ec04b50167e119f293ae66b2217bd208a42299b47bbfef1b89e9c340172acc40e8647092cbd8b679044072bd752982b9f8668c599b31a1b8343172b7dd0d11659ab101659334f5e5387310e12b2ac45a6bfb692561e2fd759b8f4cb9fb5903cb67df59f4d6b2f9e6bc7fda55dd7601eed9fc409b6536e156edc230fa39e2400f1814bbe9fc2500f3ac61b3db65e5a08cc2fdc59a0b3db3cb681d2a355463f8490992a281748fd423d69337a8e297230e4d7571b4a0c22d051d797bad12f67d4f2a6a2e6339ebed8369eb2a6f62862f1597be867176ff6c2e99b5ba94a161ff60f08f70d50094e42562569f782c60e09a5376d433d6621b4198443b950fbfe8c6605c392cbc365e9a3c3f691191cf3ec16d580e481a16d675cba0afbcb840f563a4638a22100003a41cbd93843246f6aad56505e0ffc5e99b68805605e01783f47a9ca30da6667f903760c14da88329c9b6c6fa3ddf66c25d5f29e3020bded1281a241cceda0765936fca0763b7c10b3312b91603079fcebb4f511dc062744e97d9629952ce73465f7b9f2dc46d5ee63fa7e09790704663ea7162de4b4571c8712207a1e52d86010c51e82a6997e27deacfaa7eb5f103327849df27ba11a9c4fcea3815f5f5d1423014989a9d70f59a32fd84cda9e3298a1b0bb6197a02772fadbfbae75ea8764fcf625390b5364cb119a7a95fd91dc3a92bffc4bf2695aa14806f48d8e3d8834dfbf0795ee22edd96aaafb7b63b11cc244d016c4a263fed43d0b21161af323ee7ade04f755390b84a787e0e941f16b6e6d65276ccc133a52f282518846c11e1819fac229b266a20e792aaea4b4685c553ee13b81a9d6198c5143f2e3fc99999386952ba16d085100d5e86abac12f084e590ce464dc17c4588349cb0163ecd3cde99471a1c78121260cdfa7f9de808f4c94980f9be34a491c67dff1b21765d72a7f629ec3b3564ee360bad2a00c2a964ee3862f3937af40ceba4d3bece8ec16c1ed017a4052099918fd5310b9531fc5acb5387a4ef1bc0d505a7f11fe448afc952550f9aadb58b760848e6026dbe3fc986bb49a9c5613c89d4b6955fc71542ba60bad7c61ef4982c4e79ec6a2407b25098cf2e3b523ebcb454e8aac224ee130bc7c7e58da7bb7be356ed6a712f115da9aa4852c1081857fd5a67f4d8990405664a71d5957486125195bf2155fd74d2cde1e8302bc31abd3904ba1a4f18b0b5031c21378f9d4efdbcc9e6ae7b0ba7488fcb5ae8dd5e1ad6e80fc40844017bbec8e0c12edeae29e06b37cf46f814b30c94c695abdbe46b2540186d6e6671b15b29066092f9cee96e9dd3798f30e34d24a3409cb70882a113842160c41625b8af6f8fec73aff5a659c6a43094daaecf4ace0c9f7c47d2e791cdf863775e4aad61fdb197d60dda22d2428ee3ba296be340d9603bfabc1886e52307f75cde94f6096996cfa139d757218fa390cea89b2fbf75f5c69d4d3ace5c10254355a95710e05a927745b2c9fcf643bf9e40c926dff6b209fe574dde85eb9bb18e462c79869ccf82ed5c8acc9df1587a3f5ac502955ddae921a78b81d2443adc850459a7c7a1ef1e2cfd714c8ccdeeab080f69b9583f266718af9a33189d531c77347f576646d9cb91504d546907f60ca5f71ae76e62fa3159636af8c86595933c65b71367c5b67a551e41f33a7292f0a81ed46132b9c79cf13b5ac665eb3e8dda2e34229d978fd60f98c8cfd27eb8a12d179aa9091ea82df7bb1ec1499df66655208f87b212825fd53ab6b531383fb34a7a063ef76503474efdd4b13d20a4ec51d80d9224ad3a0f7bb1caa2bbafc9b6a39bed47698c0934ff649b86152c2da2ea1d49ac3b46acb2a8a52726421d6f45335161bd56ef3487939d14c6cf96c41463c8c782ea19df20850872f326e18f65877d66e965465c6dbd7f3214a799f0d8972d4f9d69727e7a753ec393c9c79d6317becdb94ba926879b3fc2e2f3ade080c16a28a9f4fc3233d43ae62365011526a5b565ccdba5ef7ef45616ae1b854ff2e96c607e53f8135f86ffc8c42521afaafbb3151d587896c42387c587276487c0a8683f5ab39f6f4c96309c175112fa81d295ef17f388e2985d480ef25122ecf12fdc24c2b0079bde368f85f3e0a2857001d2a2df924377111a84e9844372707a199cb07b135958a22c8989439c4c6e9e13e30a7f534e10005267360cd4135f7ebb14187752ea56b8edd350324fd3e956766009eaef9b4b0ebe442e3dc113910d4bc99e4853eac8986f3117e3925602582af1994fd235f33f98632d86dabd312d262f11b20b77e89920b8e81f952c9080e094cc45cd6fa5d425beddee95c50e351f545427d45c5e06b96891edaeef8632fd1b1362af3c042f10d518c23a2246833fd7cfb1e57b4528da4d935ec4a5177e7ed4c4da25c5cf4e176602b7948e94f8a0ce338103a9ae3dc08d4792b3621ea66bf755aadaa6c3d792ec9c98b3c9ebf27d6fcf938f9e9548d21f64882c6b3a13dad63eb1be349fcbcf1ed0aaaf746363954114bc236ecd02b454f7e82c623b4e93f5d896cc20c69114e57e705a61de845ac29d3994c0ee4b6e72ef333908da0a923d9b155a92f6297133fdcd2772db68b3aebad1818e6b87aed53705c3c64c7cac1fc8d6b20d149fdc6d112d551a71a1ab687985c01045433da531e5c69da75d0974cac8353a13bc21ccc9687364e4cf706dc0f3804871074228bd2cb6de5b7c899b7fc23c9a098d3850b7e6fd2a7e28080992c7485ab5a95f249f7ffb68582148e0eeac550e3941afc444645d17b390df4eb7519d8a4f42ba4491ec1322cda76004841bf0f4ff38e0c07a1ce851bd32866278e65a7fda36b1210183ed40ed8a70f2cfaa5602b8ca990e08a357c30c733bf42850f2b4376fb603d32123a65bca1a61b48e7d6a536f96b5f716b84c596044fe9b0d4bcd340d6d25e4e102199e33cf3a072bad0ea214fd78bfc7404e6dd2a02177cc7ac771843cf4c02a41e162eba84c2ee2e61a441be341e0a9d430503efdd7d3f86fb86aa702169cb1c0b0eb9320c811be62410c2763ddd15b67283b18ae74274882567de4e2bfc00f5668af617a1661dd7b67a9d00d83b697872a85073101fbc229880f87da2d0df922e2a131442effc1cde377461492d1f1f04ee3b1bd07394558ee8fda4352210eea6b1dd4e9c2d0d4ae99f81082cf136fa33fb255aa04037043819fb383f6b084cdcce192cfca06086aa43e59fa6f1c8b9b2ce6c26ac4f35acf6cc17581d8658fdc81c65c7acdc29fdfadf7dbde1f00ea9fc18f29db696cb89d7a390d7611b3d49f0fd639a757e75af4ad092ab06f66dddcd5dedca770cbc73f52f24c27a57ceb8f847f9f9fdf8bf22a3a49bdf52dd466096594520687ef2d25f7623788ec92a6b19b4ec506c201392e3ea45616ef7ae59702a85d15d6ee1235d9b9f90ea8a4163ed5d63066a9da1547b4faa14b35c7d4eca579261eb753d3f1ccbb830f51804c65b787e8266b0a5161693f05a28b4ec00d7530297cb9ba9edb1b5044fe419781df390897d96b523281a846a35150c2d916361b3286f6b342341b6d20b51aff20d857effea4a4d84ca328f3e4d921f2b2c87967600c2cdd574eb7c8d9513dc338e396345d50a8a64998468c9f932d0232ac0ba8329a652dfcd6ed1b18c3b2bb53a30e920f73b839438df4f168eb84dc99afdad256a7af15b921e9603768eae710dc51b404fe55497041723a63dfc7933182ae8dd3536ff820c450bf9b01c6c4bf00f3dcbaf768e543a6a8bd026f732b60d0fa5c8f3c3f52125c395883b27f8c7ce66943dbee4d21e03d46343f27293a6bc64294862d71d11e068322f371cfea020e2bedce72022ff4ecbc5f2dabbe4840b078144d509ed44c225def9bef58f6ceb3c414991cdf7216cbcd24d17dcec23c36a06ed43cfa57b62ef55f62969388e88afe679959a52b6b9ad8383b5f681699e8499cc24a2b3f839397799fc433c4238821921166b946d5dda3c65e7332cb64cf3e6a7bd6de4f7552832964f2372dbbd9e53b4edc7fb12c08e94a9cb1e66d8e47328990eb8d28a6043c3660404274de9c482d74642ad9272dbd6e35a8188096136cb79f4ab0c3b22464c95c110f77273a7c72a99361b0e2b52343a8a5437938ccca74cfad94263c26f97d506592b49c63c0575f40194da3ab2b7c964b1fa9f61f8774a7d19743a3738cb89964267d3bf0936e0d649388de3feb8d01a97346b0be64831e7d641bc3032cb3ba2060f3f851672e576b81ec3f85d6629fec450b19f9534b06bb24e774eb1d14778fbd26bf903205381b0accf7a9f49605aa31938389ea8a6fda2a6e8b086fb94e26aed43e0f16e98e204f427e52275e7b019d0e13bf1fabb007f3f0292e93239a72bc73c612b190c6b54b209039ea77897b68a1126e65acbf542485317dd47a58f7ad60d3fc2f020ad97a9d92068899154c13cc8900c9bb47a5ab2559ffe5349a31a45a1c55791c5b0156185057cef1d30d09beb9239ffaba88eedf1ee392a9779077f09ee807a1aa6b36e443449908a96204e9767d2f58e294efdb8f7a964d2c70fbaf186781769684a16f61f399badb796b28740555388c0a3eb3eea1a0d9e60c91bafd8afec0e7aacc8d249f6f17d7eae80d77b4929c5791656763dbaa6ad2630522b95eaea256869461735f1a18192b66624dc7dbd186b7f5ec9251a28d50c1f71e03a0cd486fb4d2d06041e7c9ff6ed3863a4d234a11bd9c93336d986c916f23827416b0618d76708d7e3e9ce3722cfee49fd3439fc71d6a730e503b71d9c819e818cc8db5f1fb8153d190b30dc0b3a0462f2ed7d73ec1b880f51dfa61beee2ba4a57ace8eae05f7decd0e03f5ae1bfb09ea9282387012e4e77f5295ea925c10f8bf5442fa71c63f303d3177ff613bef51f658b96de00d9d839778d76fcb7c16d072278366b1f415e4c9ef88d94dfb32e8e915f117d6f41a3a8f0409aa07ecd577b28298fdcf1e15e2cdba1d004ed8c6c7f7cee63e66deb81f6a12aff83aa3dae3668a482a5ae62469d242225d3abe8048499b136c551d7fe0aa8bb5a40262e0e41813a80304780111880f886d6d759d36f3145c15b11c628615982d7f06987c4f60f9c5a93fe8e9e6fbd850e7d1b234c486400aee46ff206c30aacba241f2325998dc1fd41df350d94934038773846357f5857cbb4391b10e30901bbb6a95eed5cf5e90c84f639396979e64a78e482a35ce9bb2ebd233ff4bbb5ce57f10ba6d68a98addc2c79dfdc3432bebcff37325dd1da722e55212a2f6e37283d12160dc3b02ebef426f7cef2bb635bb6c7007babd4e4d77b4685a9df9a349c843bffeadc43dcd04dc41d4537e6f3e192e280db7f274971d837b34b6aa7173ab482c74408b2646af14bac2c4e646b248ee3aaf145763422b88781d973e6cd7d243da1cd334aa3fdc32d394a70958c61943f91b3968e08be3c39d6608ba93c4fb0f6e2cd806352d145645869909c40cf87ad5c8af1f10b1c523edb58aa7f09497dd136f5c781d9baa84a6226f255cf400c0bf59816d546554904827159f96a62df7372f86d96d47cd9f1412eba31c256ecb82cf7529d5a604fdfa0354bf555e6eaa87ff5ff59dd5f553b310e81a6877ff22d53d13254bb6fbfdc62f9350d23530acca115833b4ac618cd309aac44d806abdb02f5d91093b23a7af16551c8e2c39dc48ba3e62fb9948291b8fd92de2ce03c3fd72a59a296909e683a28460127366628edd555dec69a37fa98f6bb4eb1e6a8e0fc0417b8c9020bdeb1b9bc83a18b342cd62e26073f4aeb2079003a6f1fcf21f5afd96288e093a50f7769dace0e9e3afbd709b5948e4d16795863da5ddca5ec33b3f7d54ebb2f81295e644eea7ae08d2085259fe8fe7e33b4f661bd857e90f31dc82c046aade060881c940472d903c9f572d0a1a4c9ccff5e1f5e4ef0853f30e1390aa59e3364ea85d3a7ea7c579c1e69292633c46484a26d6527a55441b40423a56b789d658c9a883cffc2abd3e601a1c124102016749fd9c3033c7b7d8e7a3514c99a358c961c8766e9a8af916b6c699d071eb1e8ab16f0d0774db4369cbf0588567bca97aee575a7437c88aa454388201e23c7d44e2ff5a27a5f4c4e15de85e6d7595aa4ba63971c50acc92a1f510abfe67bea192cff0243b3797eb77d7ea763eb3de7fbda8582af61c6a2f407c26c66adfea6cd70a2a429f9e8d56a013892c6997f873f7b856303ac8b2423d88668a74f3c0104c97c84819b7fbfe9e867d2366edd1be52d18f40312c175724fc32972ddd1868626d88d1c1cb0321c974c2af74ef4858b3c67d63386cd2e23ea761143a528f60737d4fb5c6caa7dd3d57f51c12ebfc596f4a0883b7c72d9171222943f9402656395af00906ce3b9173d3bb43edf36c11262348991a9ccb18a776fffaaf30ca047863fedf4caaa7318ceaa4428a1433154ddd69bcd321046fcc3070fee2af525ce33bb45b287ae3b1453f5caf0faf85f98549a817384","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
