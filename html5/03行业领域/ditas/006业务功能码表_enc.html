<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f963483b37898326601ce4dd4cb3f3007d0b089c76f3492486a214dbf5c04bbda4d382ab2ac47615a6fa061b8324aa0c1fdb678cc01aff543e766e43fdf4972962a798a2ee5374456d5a4f522adf52a5737568c9afb5c42d1082e88828f2d6dd1ec05e1d0841da8c5e9346d877321bb844cb93f370ed69454fa506c7ed7a8d371942f945a3f91632787e6f5c0046be0d0490d57a64e5d144a58a7c1a8df55827f5f135085bebaead37416c68336c30631e158fd22c461c5bcaa42302fc8642aa10eaa43d5eb5f2676b8dc471646b694e76669f990a4c13257be681b9d7efe1180709a3d62cf362387bf13381e6356f83b0dd54b1e29b350a7fe7ddf078f83f506aa98dd633de20d5662d30b125fec47e74d7ab62e49b9f5d19457fdc838dd76e457bf5e00cc765d5d679489021a6bca7d595a62111de609dd5ce942a83e778f931b72a4c9482bed6935be0c5467a05f980e5a9c15f5ed0a46d51d4c9c6ab34590314541f3cc27da72e1b6c7ebd65d1d43b62d80efefa76637485933687885e810a7d6fcb005d84664a8f9e063db168c4192f84107073b2af28a79ea9d52cb036899f5cfda420d0a0e842089069dcea4222c916663c5d9a7c6c8bfeae7b0cc2338f7f865cefcb02e0394b5223dd129387a81ee4867fbcee676a633518c714085eec059d8b8b14461a5b4d32d92ec66591341568ec39fe521b1d05eedd813bfce5382693d6fce0f11b3c66afafdcfbb6a84b07c2c2e0d7ad830e62ff3a8c27d939a7a95ce747be1e628d8442dc0c3e669a7c1b545261b1eecfdf848094ffe3943b9da56333a34d52b3a603168a6f5bf733d570ad83cd298d12333e4b0acaffbb827f903e776211d9e1e45c395756114fac0e464bc289330b8a99226ba4bc1488cb5da2b349732def71f12472fc173eee5d6223ec100a10325290b4113a7d5fed1092e0f6a95e2305771ca90003d0ddb565a45d9f519fd936c31e90a2cb92372e12c304dcce052f33f22d7da6d027ee920243e00efa8d92aa20c0ebb809abc7f75cf8f47e414835f90137b4d24c02be6562a56f27a30bea1539f751db1fef856796c1a3c9f4530d0ee638ad4a865ce07c9228e42f1b7d6c45bb674d663d19862125c5c4e438ee0284cc4fd1ad2fa8ab7fcf702c37d6e1057056b8a8e3e95864a77830d07a6efce2cfb784ed835e3c4712e3eec43e6358bbecb0c767b669cb836b2d6a7bf3fb8e67f3e6c03a5d88390f28029e5cac9ed38a37ab25f971e0eb2dd56f56a126af1b8f4c45c2c031153da9cb61dcaae477551df45252d63e4e3b5ee0174ec0f825eebaafd3dcb83b4cfb638b58d4b24887945657f7179bc2201ebc17db5ed7299f44685a1509f299478746d254d0a4ff3d17ac78586b2f6647be1e037857058aa57bd1fd109ca33dd91d6d9f39737469db8d420b6bdff4203cf789714932fe44462ab8f88fb0ecb2ac9c32c94c08360b4860f14044b96dcd9d1daffd01285851c1f17f0bc9ff999b4a47c8b922e7538ca953df90d38016967345ea8626f4bfb5db933beb9dcb5d53b8a13803bdec8505ced730cdf816df0d2a2df0ec55de089d45077f98f5fe2589be18b36ad67475e327e066306ac84787d6302974c696be67b8ff46796c004e40d9405e1d826b44fd0a65d0944e787b3cbc56dc3c36b700012fbca8a92ed99a2aa7ac2f90dd01c4a92453f5c47aed445c7d8f304888a55f55900f2aa75c18335d11373b6ffcaa20210d9626dbf99972c780ab898273dd6d2dbc80f53074946b1134e6f11c962c13cf5759acf2b27d1a3453a9c1929fc5744eb85c0f066b81f325a2c23dec310421b59cacdb38bec75e6bdeac9d336b4d3ff387cb7c00dd832ff43656d92b8472b7613e277830bbf8bbfdafa38e820b40ff386db6b07c24d8698531be793a33affb2ac31bb98cf9b873ffb659f27c8e8883d72bfb21e09f759088f615d8cf186d2c3cb00fc6aa4b3f5b415f4715865b5d9d6a056fc3bc0f06f995b800d4516c940d72b25a068b7cba14b10d682d40be90d5095565012de3b069944f785e034d9ecffa6d492d556609274af11802587a7e62a4a2a9558c6a540c0a70a6eb686296472e0db37dc4cd21e834947c9ca7084ceab17136de98a15f939689707aeadaac30f4f0206f804dae690e7e353daffbb4e75080e676fa449fe27c7dfea6e106d66ebfa89d2a6ff51f962523aab0c90612fb1ee5b6cdfffd616e8308c65a6707bf4f6a23120f6a60225740bcc2f23018f782aab58eee116c7c19b3974f2f17a362ae20775ff82426880a0fa9a567ee206574e084d0472e047f3bcb2bef5a7690928d85f997167e89a824ed555ea43b3a3c81f863d3b3426c5affe620af932fc7f40c9f496bf9a040f14f5d5b60b6ec337149cbc91bcce6b2d5a5a12513d3456518ed5fd9c759139cffbe2514b2e20a00a7d8f033930bd0f526e58f0fa259759d937dd44690b526f917dabde39392a4b80951aa8831d7808e3389a031bcb08da1376549af5c47082f6cfce59f43b7cff24bec1bf71bc5a4cfd7afb71d81b895c5e5af30f20a2e4ec479f055be616bd1f065e024c2f1a617afd2f5e6000b85de502325f91fc5d00e56233db989fdc41d7e048e1262e4f4a560dfc571705093e84e8822dd549aafcfb396a4be9e4aa7349fc6ae7a564c1d24efaccd33a97afe86026df5cea9358a23f6b899a1e829244a9c1b8d1d421b7f7ca33e0b8ffacc9f5b1c1e3a1170f2742029f5f9964dbddb913fd0027bb945008ed6d6efc6881f1f598b772a19e67541c03108cf64aab5d1868dbc043e5bf07034d1aba088570f7d7412f8d8f6f2d86ff813c88b1e420f61be79b007e3b17af6c5f9231b9dfa7b5a1ae4e336fb4208db6ca95c0be3ef9f921d595f200b8c0dadaed64c703e8c07b764512f71466648d642dd9705148c93c7f466a799d03dbfe6513a64355941ada32acb12f11449b9db5437b1e90529dc9f747b8eb14e1fe2773e330703394646f827d2d779dd03c87a20f1662428d948b3bebaf83236484d9f50ce0daae6b6f6a65a190be6fbeee9fe5171dda408c379dcd19a795b568acff35b2b0a3bab8b7b65606fe2d3026103887c78ec5f30adbb8373cb09ec4a1cf5615d159250fe82259b4a6eb55f8d0b727df85206dfce56c5afd4cf748e376c112c75b3ee07facd605de1a78848b21183c718536514007cdac12bd85ac646c6f88e8e3ee0bf8e868abd0a2ac434659fd3db90b531cc9f0be4b063897d1906a77ab65f9ab8d876674261d6f88531be99c339bf9c4d38f740446ccba889a368e114e0eced23c9c6dc8bc619773648d070da15ff4b0cd7ae6770ce5ce3a10b479be57fa7e3bf6ec7dfd6cdb7eb935573e260ec24581e1d6cdbd6645764e4e8d82731ddc06b6ebf461ee77a79715b3ea4706e6ce547b2b2edafe74fb3cb0893cf42adaf9c77dbf3b3ea150d88e41a997d6682bf72cc4da9289f85cf752dd60024cccf17c7cfa4d97a0410a6251d7479f4f33f15fad7b889cddaa88737a1fc929b0dbf8c9a989534f98820937d7b4f2c94f9e120f7190d8610930b63bba788612299461c422334f266181c0f4e29228b12eb886b55f018c3e2f97c149e66cd6e4258f8df6fecfa564d2256cd203166faf034425758203ae7c7310962f92c0b1766e2772c432531e4178fd9665375946b75d6c442013d7b12bc53dd630ccbb21c263c07a763636fae6ffc020f2e7ebd9819dd4d800217c93f4213d93dd941a84f293a2fc4909d7d72fc3680633e089cd22fac6cb664d7c07aec84719c3d4c4f7724e414e005fddd3527ca7210079b5101e275bf311ab44f9578a175509f8af59a6b40d356a71165d5d4f89a7147360d6bd77649cd992d2412ee6a09a55f99149f2d49d2c881cc0196dc4ab6fab2dfd210b63affeb73e11dd38b3ad5fcc60283f1cf1196701165fc8039eb0dd63197a4e06dfe32471eac2cba1b3b1a164fb59c1f5444ffb4805344cf6efa51f7c3f22e1d8580bd41fcbe99b152185419f0501456fc4e90fbb4c9d346730324830cd02dad20c9dc6969f606c15b3699624c1b659e6ac2dc02e5a03208ec02dd9f261a9c484cbc83f046437f29d84b9cf96cffff4b660d6e8a5c7b246489844bf657e59c1f4020b05e9012a1ce6f8e599315563d9f6d63c37f146247cc0fd4b9020aa1721ce76a9ff2472757d15171395e23cbad27712dce27f1e080f821343409a7044abec73d3bdb80045cfbe1c4421fd9dbda18586f4ddc33ffd9c587f26ada864cdfb144ee7e884abc7b1dd9d514f8a08cca1fce5c5d36da955ca248d97583b98dd6c304db3e3e8fddb03a938b021ac9e3cb401eadff696ca7430a99327362d252af6b85fdb787697bf80ecb9dbeeef6a4b66bcb5effab70e3ea9284ece852da0ec909d62c526eaeb1fca1fd35e481605213df939e994805529dd2f0cdd690d7b17ccd858f54d3d50df3dff60bd78b10b271d4ea4282fedd4f0447c5345c6df3468bf8f886efc3f78ac39e658f113381aceb1ab1f38272dbe4eb5b7b12648cec96105770317472c9a77f13e0de3556d9e023e6bcf7253bc86713e39f5a9143980f1b572dac156ea414130cbe21eec7694199f9a28f77c22f07b08bcc6bfb64bd047aa59956c270816c4af51573947cae6424490a8fd9bec783b0aecadf019be73ac9d2d8edc729d622a207a25a7b0968d8a6e9000d534bf1d2c8b891425c1b55410eed6a782b2b4a46dac562327d8ae1086a265ec318c6f48d68dfb77ddb9941578b512f84c8d1e86083463dc9caff0f89b8668318636d54c4c22ca095ca9dc5cba1312f49a013aea05d84e49d50e9864179f5dbeae6cdaa2111cae9764e05bdf1cca299d8f18d1ed0caba0884647d06d446caf022847baa2fa76cd177a3793dcad7e7ff894e5f615ebff1b58b4c8508f0c652f406aeb0e8a81f9d678bd650343bd127acd2d0f1fbef839e212945c9f3d9dcc946435d3818518d84a1b999c6c029a16c2c7d646e2f1841a984d3ae31daced4896d68c19b0dbe702da43f41bec34f2d35bbebadd3fb72bbc9b99da5a9bf8bd45d8052c9d61269506c73185b86ca716c2b4721842b5c0b354e49fc189acdc29d34b14ea88359c8cfd50e056329b6896fbcece1233c421c6aa0b01d5dda1f65f0d837e9474c631b07d7b7792de9784545c3df36519a6204cb94065b8358e6667fa3ad8264dc56e50406b57f25151c509761bc37c56ba0532ada29744ff83ba752d3c11f6bc0eb49c4c596af23c7e1536fe22331e291db08486a4a109c7fff4fb6253475afbbdb804e2d5a5dc5bfaf88545ddd2d1b77162f9d12f8c63ca298adfd6ea560027dc1eb7536cbf702efa022806d95c20ea19d4c39b6c6b5beccc382605ff62d86d561ee67e3c7ad9757f7ca27965b21a7c46b870440eb57f04e2ddd9881f69f32da1b0174b5bd14036635fccb12751b5dfbc03aeb48c282a39c68b64768e67a4eb2051b1baaac1db2109cadafc3afcd26cf887d43d7cffba0a1f85ed763afee7f58f3d36410c69eba091a8f6c55050875c2c688b0b54e44f28066d580300e6f8275792c499605ffda10218ebc6c1065009349aebddd7af83cab5ef9e3bfbcf4cf86bf3cae059c4c8f25e6b1652162cf37776baa6a046e49c07ef2b2ce060b03f9bc326780083feca9d26269dc5aa86ea45fe3c717403005119673708006d30d9d5e8be3fc922dd3dd032b85fffdfcd82f34f145e09ee4008eba45a42726df1251276108395253caf99e9f88c0fe4dd552c17dcfe71bffe802594cb9027be483777998d5ada2e14d9ad2476cc93b2cfc65b13c31e88edfd2a631f2fab5f4da102a47feac3612b9de5df8f872590ecee07b2aea9d95d48cac4e28d7d681cb8cf74206f8f7d0576c90097be0b19365dfd01f385593b6edf7633f7c0473836f80c8b9be7a0f52d5919654a83279b608ecb9b86522983574f41e5a5d925b46fce5b53db34680e2ec805a4bebcb2eef4f2b982aad70e525024c08063a7c7d35b8a95f82afad82e617f113900e1c11a5053ee11c60ba62d53be856ee6d5ee17e08827ecca0cd2bb13c4b865b1c69e4b16238c1d474c029df89870bc44b06d9f171a27635d66d1d1f9c4deab22fe51baa4c4c1fbcfb8ed11493c256ded5bbeca8c49915cd8c54f51361f486c1550da45c4dc362ccdfdf3996846d79f5779adb97de358a41caaa15e952cfac57e5ca77696bed26dc29f07d1873e8ad91eaf8986716b35e70ef386d3866021f684375c7059a484129eb373d3e7a4b7c2f4766da08512b37322ed3d1dbfe07763188cd1bf9a34806b2cae2fbe85474fb91bae3399c38b226cf010015e51eef3b456ea38b60678a998bbbb02ce533af2cc5676ad7bf2e36bb79964d7eacef15542d88a3ae658c80e7b9977d03051a7a68f86a6d56335fc2fe9e7455ef44924a916974fad692e7f1dd05195a2fbabc7b0e62b0202bdfa1923ce88a8af9733ac1f4ebafc61a7a33c97657d05bf6dca93f5b156014fe12b8146ce38c7cf77d6b959e9ba409ba9d315259631d38781b20e254a979db913e17c67d58122c86b8d63e68f490bde6de1c9712ab01960c2e40318e8aff5b00990f4942ffae48894965ffb19e7600dff1dede2dff0fc2adee3d5a4ad5417d5923ca553ddc31059a6569789a3c04dede8ee3aa3898b3a7c63b9d1da3caa5a3e16d54c8a105a1e491b0959a5b32c99b6f7ba76599037654f6d8eb71aec749d36d00a6c143828d35921cdcbe7fa43b31c9d939e1cc50ffdef348809f1744fc2d656f0216e4e6a746dc2a6ec39a3db056d6cb47c4c73be264a6c423178c0f70e8ca44cb44102effbb02cbd0f06902a433f596675d949990b278f182df4837e5cae7d654f5d078452d916192b45ee090997d0414e5c41ccf4b6e4b9f8821bca39bff0e5f148e5ca817f858d829721f4c2976ed58cd886af0b5a6d6ab511cd46e8305aca6242fffb09e0c4055bb02e4068a3848ec085afc5832f67159186bc42f1d258925b8c455141243cb6210c10b14e7c940b983538464fae350896dd7b6db78e0f0c89b7daaf50c3d2c2b15ed9d94a281203e98bdecc0907bf9cff06fb35e25c9a188bfa729e5fa69ec24b9eb7bdc632daf6552cd13d59badc585a810004bd69f755ee5e02a51baa23c770df38f024cc064c77a066d2a52d940cbac534634f2e51f3a4ed6bbcee1dad88d18d0b428eb93ab7d1353ce916ae777def15f52cd842b142d3fe1ee74e505cf1d14c08f56924780833935542c8a9ad73916673245f9ad0fd829c084693c47c5b9ae2b9e1433d2573d37e3bcd3725ca12a16b8cb973dfdc676329a42406ec6af5e8c57c0880817572f7db7fba5943024451eca6d5a55e6a8206a74135b67f26a90f0ebcc1c605541d0975aa5d7998a99bca4365464745c827bf8f048779c246e142bbb6f60021ee93b5f321ef629511d9288086927066aa41b4f7d8bab03347aaaf34a540d92d7b35f4f174a51a75a735354f963947c7db90dd6ba040ee90eeaa5273bccf76a2eb1c19a6551f0e9dd4b5beb4ca3155b159159905c4c4986561b3d077a7dd550e6a8126badfb28741ac676c5cddbeef827afe817111deb162775f74be10bef44a3b2638b04cbc423e9df61ba67b516c58813d70513e53f31bfe12b6e06d5d9738dd19401d82a4f869ef537abe4359f0efffb0a67e96b12edb35d3fcf63dd3426f534ea7813b3a8c973c89644cc6ea9d6503b249e879a71363a2e2d366b86518816a2331483505d1b743a4a56ae06005d968b3002a7587a296e52351cc0c6b1202ce03a3eaf7b822794606b4a0edbbcbf26b29098f2e9ae1ed9ac72f13d4dc7179c9087d5d305f8cbfc8d7ca2936234c3a14f5539c7ba6d7a89eba666c9a4d01fe2932d8cdfbd78db4b78384548e00127669c9570f3f73b885ae3d5a26ecb60330b9e7bf48b5a9f6930a3992b81854f09e54613644b7387e83d47ff2a1c37dbfd704fc94b15a568aa832a240ac9947c28095391d50416e281794ce309c6a24cf92abb3eabb6b802289b1d3cca81eb59f474e5bd0fe20786360d531c240bd6b2d72fbaa7623e4c222ae07cfb2eeca05f4d89cf2f1614528b33b4d0a8c60b7c57f43542292c0d85872babb1a8d23192b677f6fa177da16985cdb25809844f5e70e65e98645534f402f42a3d65e39a2116147381a2f85e6a0117ae72914af0805048a94eedad227c3e80f253f7ac0ea75df02bf09e9433b45dc8d205b8b804987f2c4cb951418cf45bcc19c6629f19d127bf3b87b549a47293b788b0c1b89ca130b42e438ac5f2c3927a27c313e9c9a2fdeae8855b3d84e5913de49ee34d4f198ffd1991aad51eb603329497fdd7d6c12b65080394a03b8779ab892cad068a6c8f3cdd25603d50c540cc22bb71b380a6f0ec8a67c9a0a2b070edd4c8bcf7fe7cfbf7cbbfe66af3961698d8f94d6b2dad1a4acbd1c400828692e3ad486faa9b6d18a77ddd7d468ea49f6efbafdba84c54e896147a70ed2083d1471faed2b7a633d20f5ff55c50a212dd364491ba35768cffb7cbea2817a0d37019198be83204ed3c471437eb2ada5fa65fe3da0bdfd902164fc5d26807fc809fff3cde6d5819685fa66a74b495f97627890d2e4f9d5a80856ee9ead37c5b86bce6d183e5de2825fe98832e35908a22a3b8ffe671f376652f31c377f249dab2bd2673d489267ee0ba5ee4232df49ef4ff681106cd9f4fdbf387e2941a60625795bfed69681fa2845194b5cc939e5d520621b3b72a729b67dd03c33a98e28ed698b5c435256f7c91c0ce35c476820339425ebe3428f88dc4d9d76626a0b1e3ba43975dea675f6b1adc6406911aa648357ce8dce72f1f224ff0b733821400beda81a20466dcc9a5e1db45be31dc1a8ca2298372df45e1fffd7d0c3ceea635da2557d136094b987ebcec54edcae767e65d310c0920ca1c80beedacd96f7417e8a5576e2806832d57ef26240d9f54cd7eaec658b6c0a177164eab272bd3e7f5df2790cbf83e5eef4a6a473c0156190f7e102006598c3aad433c523116f6af6363facd214d0066c47c1350ea2ce06fdcf85d982cff88f06d1af68a38702163bbb1784c6c212a9773efa66976eae478875d5ac05b6e3cfebf1a858de8fe27b31b56c8c399700b538fcceb24399ccbbddd2a218caa89f7d09564634db1df014943c21bc0b70081e6b0fc8074e205a7fba94c68852c5028c3c2e21df8a4ff7df52c8a71a54eba05f69ed9b57cabc9db24c2971895b74746b8847ec985b3d0bb25b12d4403a67d7d8ac62b3b2ea3bd228b8ce4f34b955bcabffc2df9bc71e6af67ecc0f490f28ae2573950c56adde97456691cc6eccb3befddb33f73ceb9a3a99bcbce97b7f5df3f012af09dfd00bccaa0230e4d84f4c0e51d680524be7f1c967c205c42a55a3c4f573c28d860d5902dfba765ca05f6d48e1e53a628786312b0677b2c2e075e94600c876a378e4774b81f3280fa4d27c2d39bc17d8d7af30a42626467e114b3be1b187e445253a280eb0a9dd367792430a039f6c6e90dc61214166f33c2c14c7c57c218727dd9cef213d7398dfd46daa62edf235bf3a36fa289ff12a0f34acf5fc98e15185f054204050e38ed8af61424590cc2dbc8dbc976819a28bb3c475d8712a6710227ed60a34bd063506c67702b6f16ef2a4027d28b91c6cc9018400e75e73bd8bc7bd588e4683d5e2b61d928f024ac93b501c4f620555c0612e99c53d61fa6f1668d521b45389dd50c0b4352f831972cf31049b765ccf85a8e65d1c9fd76400d70b3e5f4854db1fa61eaf4707a9c2d9574a5d654fafe817dfe82bf3a166b78ac10c679bde7abcedc0dabb961ffe03229232836c5408a579d6bb31f5fca80f23fe7ae53b1695c557b6171b67fe762862159388b71814abb4a18302e4a182d9e2fbd6b089179a512b43baa372f04c93999f112ac24c6dddef269ca7a2b51dbc1d244f085bda7762b014969293c26cbdadd13d5dc079ac2c72b0910b9ed7f45c21097b27043695414b9e596a0a56a94ddece6ad840040e1837f222f0ef2fa7bdcf973b85e91607e20de9331b699739130505fc170b36cc03b6ed1668a05d6093e4cc1b95f1f9231e6d07133576811da229a7267e127ff15ec01a2eb91c8ce19f98f116221822d762468a10bb2a542584a31d6018f816c3dcce0f2f8cef740d5d88345173859a975cdd9aa528c28c3543902816d76553402a09c934a642495063cbc1b069f62bf160bcfb1d2c751d14c4cbb13b04093a4f280f0d0613df0c26b7a29553a0c5ddf69819a81aaf649acb3297a6ca3c9ab1339f34ed5a9c3db4807952e37c5665c7a3dd6371b81459c3a3d95b01557bc4940da58ad4fbf272944d0b1281d065953dfc506878659b9214a7deb7463fbbada95c48c5aa67f342f58bd8122c58715b7daf77f2fd2cabc45a0cbbc24e71746925a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
