<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0cbfb959bf5014a237b315e7b04f871ed8e614705ae8047db4141a992d0eae60be1fea6ff93c040f37d7910ec912688497d715b73b080d7733f12247dfd71900d85909ef73392e6a26fb5709c0518b815b87ab3db0a2aa5c9f4d2f78f5d0623ca95d857399172ba533b5f8baa821e7e918a7f58154892c00696bcbbaa2af0d2d6bb1c733c66b9142c1eb882e727e842767792fd8d91f2ff74cc75aecabf5dd52881b794afcd38a28ca4c8baa13188740e95a00bf2a5e805e9a761f05db4291f780263b53e172c7cf3dde5d044a3a8ed0a5c19c60ea7c5ad086c14a002bd401e57a6e41da8fce50111250bcc12cb9a7e7679bfcd2c45d35a880c733530a224929d975dfad10546ad304407abee602507e15f875b5ca27d61e94ebbf7c2e4f3510c89811b287ac42a28c5d1ffe89c505eb725e4b840d79ec4194580438e768197dad68ad4bdc745a6f75688b3a210c7ce10bb5fbaed6bb7dfd029932bd07f357c79f0206b49bf1c55e787108a40bc6910015d2bd366ed7a6c231d82374225be184e87c0817a6ff11b1641b132a6db581b035d3cb266e2404039d43bc494426edfbfce70d51e89800bf081e65a8ffb325c18a56fbc52d463deea7af015b22f6dd8f142f6a01ba38b9e3cec6a4c24f9bc60ef13ea2fb2cf7bf492db0a6a6f8a8641bee31ddb47b661c3eb7045349a724f7d788a55f9b9b0ffcaccdcbe1ebda000e51969397f76d835fc2040b1b38b47e51d284974b842479fd259221b8cb8e5cd6fc509e109fb9ead0407489051eebe0eb1adb517c3840d8be2f7bc0ad6848653201aa5050487bdc4d7c60686c5d8c6c9318dc31d5c9512256de8cb1b93055118ef856eadf8ae1b6e07433c12184add99be0ba90a68846d2358105f23e8fb0db287d54f369410706fe5fcb8614d4632f911bd59d08e7ab30991f36756abfea5ea23d4a05f90f890162c4cafb1eb53a4dba5b45fc3c0db1f8437cb9e7a543ba3260e9f735f49f10c5ec905ec7d2fcade3ad3789b840b8516060182e1d119aff5f281850af7a8179ae49940f486077296c306ce99bc1f674c0fad759e15f2a9259606ee18015c166c4a875860173a4d5b1534bac53de3e3ad2f4b4e46b4e19454977382de4cc384745e2a7cf3c4397de779b5ef7d800a2fa37a633a9a5ecccadabd4356f9aefe2411a90c1b5a3b629ab7ca091bef1d9c0771dd870c19965d00a75089e2bffaae501880d58e46a55ef9931f394554d4251a7c15322553a9c1f19fc669ebf3ebeaf5377699d70ed2f9e74a5528e15cf6fe40ea0cbae9847f0752396f8c82d3fd2d343bd9ba2bd9134f768b80ce18aa3f640eb3dfefd9f67d3e63d466a3bf1e1e2454cfdd8157e90d253800307377c6716bfe957e974f9e3408be20cec129f4209f09d11760ea57e80b342c7b15260606f1d0d541a9e0f7c466f8a222397aadfb03bfd8cd05ab7a94e4601ca745adcfe6a098c9a2ad96cf09241aba4daf4e01e392f6e15599dfdb5ba6b1d828b20f3ea4f60f44f305646487bda27832bab6e6df4f038aac415e34a9b76b5e8b99a35e44d982e53cf688e6aebaf7388a9d3280f67a1dade115f915e13384816f43e09b0e1a9f84b7786219f06db3a1e9b92361046c8d290218b8a3476b9152002ce62d6327bdfe3886f54955dadc2a440b7e43c7664229ad2bba254a1fbaffd9e8674f4880c91cc505d1913265b4de5e9ee3d54ba0e068cb2573dafacb133d7cddd6256a9a76f4a1e82d1973d65e2a195b3de14ed9a442d9180e94741ac3f137b5fdb7ac1b1295dd1313b5ecc3d1d683c6a1708391867afc557e04c052ced66e830622b4feaefadb44d1bf9f5f1e4bbc35b75323865b78f3172e3594fa86cb44f1cf69317da7db4bdd92963939c076852958e63d01d639ceb878fddbbb8d219ea617a847a730dbe4acf3324f85032c6a7d907ebd50f998aeaf79522526b7b512d040db45f56661a7923a50e3c3f827cb94373213d55e8ed8925b79a34d5c235795b72922194ebb3b35521c1ad8eac59dc0641b02d18cca56f7c52cc3ccccf26e000b1743c5d53ae584a55760356c3a62c7d298f6e556fb2d3ef58fd97a6cc9d59e2739142f22bc2d320d56f5c7791c42c175266da5e3680856e3491cfe3aeaca222637527af5bc89aaa2069ba8aa277b65f89f75e1a6d7d4933f7212aac34ff6281da4cffe76b0d4e2a7c7c6de01bc51ccba68f507aae6f524c211421b86a6f2301248f79e43acf9f59049696de78622b0802a3928f0a7f908cf5ed4229f61ec25f646115399a6fbfac0ac7854bab7af63f7cc51bb34315460bb64c3adeb1d565f0d4418f7abee388c93b5f3e1974416032c5256fb8eb0c022bc0d4d914daa4b00e8e41aa80dae270e1b6a3711b4732795c49c94c0fc2bf55ea6913b8e018b6fb0be1dcc4ec40d2d4ce1599e61f8fb42226eba9d5d3ffa336dbda937694c427a93a33c3b4811ad6876147c6847cd6907675317a120e681d1da7ec490cbe0ccd4d4fe0d192c61f9a574d7514344ca8a571c886474e84b034a06bdbf73ba50c3985c72188e0313d3cb27405ed4ba7d96ad51c93bef2b7e8ee277152d91c4dfcac519c4f9bae1426242290fe64d9ca59bc925822d57c7cb13a7e7930b7cc60530c1f03eae9bae32451e35e6907ac43139b66d6432a90d0a041691e9405ce5a76f76add99de960b21641fedf807f3cc9189388c1223924bb1376c16889c6f5f696b4b0507b695391f7c521acf0ca9b77175ac8fe8829c1f9a8ffca19420f333a5c499446fd8e98de16dbfdfae5793ea0be5fb2d46d829f9a5c4c23f99a236dd47eea1411dd4c6ff3e660d2ff87f5e53ed6e591edc7300fe2124bb57142264d465687dfec9a779bdadeeac748f70f1b50d6c968b26f37753cb1f16a1e1ce87c890fbc8bbf71928e8c7a25b279e10a0fb89110c4a7c9848b020bd40e9136d48cf0fe2e50f46b8c4b0c4fee3f080aa63a927f8987a60481dc8ba2ca1e812195d5eb2787079662a9f47fee3c0aa44899cb9c9cf3d554be02ec685516ff05474f74d4d1ef701d038e79bf84cf2f13d29ee88df48d2a7953c10dc7d77f0e2ab55a84d756ce3b4c3498df2a9af5e31095ea6eb03873f7294b930268ebcf59927a2787b66157fd6fdab056d00897773ab3ca76f4763426cc91a50c568ad34f540ace068d5042f72a55a895143ae8ce92177d6104e34443e7d371ba4ba09d01bd2095b4f6b1d6e5f4dc375030d1e273b87a5121b3267882e51e330bf8723e8d0f1e6c17a3e56594fb0fcb1a1270e272413e130ec14b20d441ec0e22854c1984d67bf27e715eb14cff165c8d97dbad6e54d95eb85888775afe402ae193debbffee99a105f7b71c6688bd04cc91418b1e0c90144466b0def4d2dd0859a8c1566937892e35003afa42e18d631482cdc8eef7ed315cd247065544abe5c9e167233d08a198dd91798381931289e474569cf395afb6fe6be7b6c1924088fc7eb218140295a215ded50b4e08d0c235ee2dcb344584ef02339f2ace069d6048f9de05b30a90c3f83481ada88f761c276ec53cbb8f7f712db1d930bab4bda7df67353c5be8281ed6a438c7c01a05789d998c625f5604938ebd87833bae9a84506d0f35fbd099c73831ed077bd16087104c6dd15feeaf40115eb911721de5e710929fd785400eb7fb41693b0660322f433dccae0ff9948117029d71bf0b27d2bdc708f89e66dda7b5047a36496d5a54c05b8be1a20a264ce196bd3fcd235022bd93ae56b05ea59974aa83f5908c94e394b3d3154b8c440ee51da040451f5dc63b7d2af875ea8a322bce6c5df0290d50c958718f4d11e4045a4a735854d85b5882243051384cbd4bedce375f4d7a9c2344a13768abbf7a59eacf84aa3a699753477028fe72bf71fa291a66f411818424d4c5732e307b788540f9259bd1f8b6267e78a928983b66bf151df6671cb157578729f2f9ead5ec1e24d2743e5af49f00a323e408c8315e9b7eb5aff59b29443066fb8eeae9a94eaf200b5b40a5e22f50f1714615a7923eaff8294c40c718a600bbf5857b2fc14167ce006cbd46ae21d69690078d83fbc5fedd73f41c7bbb4d9f980160b869350e6f42ea6a57c54c1ce2d0983269162b83f06de1db05ff490ef81c0440ac01c7c427ec2df43dc1cc4640a3c0e0bcf94eb2ca0420c69bdd9fa1dcc832fc215201feb320fdcfd71e3269d07f42f506e7bf487196d2c7af091cc89be59003bb391f4ecffb6c0b4c236687127a62a7f929ecfc0b34f63eda6f0bc0c4af6b484eb968f3048cc0edff707342431cbadc7f3438524ed7952a10527f9b3e0b6e522718e618a904e50959acfff6cb0e1911de24538a11dbd5bc09c2b26c96a600d320ed4448484f73bce641b78afa11fbfc886f399c676bbb99b2078083c9feb04810f008dd691c288c749ccf190da513dfd892ab3b4670066a20c6cdd637b79f67518b53b6953a4500cb234f67ca2aac6f4ed21736ab193beb38f260e351cc1af506c3ab7a08d427de7d2dc7718e8c6bc17a42970eb48615d6ebfa20b54c543b1fcc6b405fafc3511fa83934490eb59e400e0c96cff9a50aca6def6ba5af1c5cfd9186cb8210f5895aea9df5988b2190a50b44966e603b61b8fe0c2c958f57155b60144d73fe7b1944eff258e8391c82b1769b7f3f408ff246e2572c785b35e792eb4810cd8eb69d3834fb8845822b6b76afd28b2825ad96ac9dac5939166285e3e0a9f49a666693382abef5acd97b60b1c6ae899bebfd3f99a81759c1162564c2e6acd806ee35d2ce2e116b869da853dd868e76d4edead036aab10c64ab0268cb1c35601c58c0112eee6a00547383951f1d9349597722ed155ce518e32abf118ef3fa5dd12f20ab20a32ab89c1c34e48a233c3f6dd0580afcf1a2528ee17db25f344e4c0c3c3a0e6f5db06b803b7cea3c2c29784fb0cd59c7bb76ee2ea4e006a2a100fc5e34d6715d556f21bc4d7f38e128e6bcb409b10965dc4265281730746b3c51be48ad4db0481f5bf721ff0994f348e71d9eb8f0a4b181656d0f6a9ec54a58a3b794620fa59793ca8d18275924b44686ef192886a916908aa10cb098d2a8a2df680f6d8641efc107e6c820f699bd92db95718c297814e5484d5ce1dd8ff6c24ee2b03f5878a43724b80c3c633720b94c4fb23c17c2edfa057d29f1c45469f09b93cbda4ca6d9f0ec644b0fecb1491ffdad11c88186c9997ca202547b7ee1774b234f01a76abca9380c570408b70354a795a030233aa66cdfb3ad3e4ceb677270a42bb73b280c2e9d6687bee79fac1f6d8348be5ffbc07d28f439fcaf9e47fc24180c93458f231b39019c3eadf335a5cc97dd2271cb87283a9a10b58f87902e9705a28b88eb58de5fc0c43492ab367256473137df07fb50b934fcebb94ed2f0258fbab1ccc498e3f08664774a7068f942d705546ff18d4ca09013df64a78f1c0bdcc0c2349bc4b78bd8d4fa675dbccd29045f0cc7e054f6b10e5455f7f207e54c4fc6fc307d0f14eedeec1c5e170666063145ccd1621c621ba9f62e59b835b97aad9217bae4fada3e7a4f6752513a5e1608e1c4793c97bbad926f9bc8ccdd173b983f3a0907a15d90ae28bbeaa7ea714a1b647607d56429f48c0ffbed5d1b62bc6a8907f9f00fb9b99372ad7d25c4676deb11ef3e2e169f47ca0eba57b25703c27f65d2d97b9be7ee3dadd7f92e231faffa2c746687575681e413babae785b4813380595ab74132232f3892a95a7e81f2ec8475dc99c204fe7c51d4968f7cebcb9683f8eaa7249e7111b279a18010d31fd42284098c616b5273f804a5dbcbb394684a4e059ffc15c34b6e943d3b7dc59879b27af47df2db54535ce5ad95b0caa073ea3546928f7f2224f65d9bb6c34382a26ed4da8d629be8510bf45e202f6279ac45cd02ba0eed6f85c2b42581b8efd6bf340a16e133ff9fd59499ddf019465ba35df11dd294c428dea4c7414397fa6b3b7cf648f96711aae63a20e42f58c771ff8d1cfbf3929ef9214559ac6ac0e64997bfb7d99465dd24b04fb5f8c57a61b6e6db4a691677d4c8b10e0a771869c9bc8fe64276bdadb2be050facca964a882258220b21a57a23869018ce6ab1ae48bbfab4fb4355d71e6fea9d841051ffe6e7306cbe66999b93b1eb98303de64db412ac095f99499a7a147d050de578e4dbe10b06df6b8e4342a6730a7ac63a9219caf6e978f0e5c97afaab2456d77a03e9a88a900d4141afb8ec9f98fae82a2754c436c17db9c88deaf36fa38de3081d46cff2584bfbc56a6e2eaf3d7b19a359c23cee5030f0d6343950e4aca2fe571fb4029c87a0e6a9159d1c1b540d7febbf8843272cb75e3b320a56c4cb67aa676b6f5457e7a0a4f2caf2b3de72ff576d3a1fa411acf4034c56da6f1cbcbf1ee5644e3762ef091fae16608af54ee3584f2301cedf0236e47577b89d313ae5369ffe6acabb9b93f3e4b9a25a1feafd36a7689786a0783d86fd5a9bfa955115a93aad835accc047c5b449da0c5ca1f4760f4acc3eb0344f037ae1adc805d61dbc1c4ba4f276ad6f344bc1d189c0465b5e6237dad85fd82825a7cd337cfa7da30c3f7242cfade800d35b63945960715df2142409714fe65b07b8dc0cae05a050e80dcc20364253fd49912969a8d5194f615c19195c4595802a02f74ce62ab544726d01313455b944a7aad2e039cc35bd30fd3d1abf82f04ab8180ea31bc412ba5a76eda795e36c2ea7c10dd8863036192b5aa157dd8d6359ec442f282a268f85f7095c7296048256061f99f614ba661e4c1192d1198e2ae8d36da792fb9713eebaba8a5b08645c9c0dba657f6d33e2979536a9554adbe55fadd51ae1d377cffd6418073f0e99a9437c15419968de62c0b45e19c322861de11b2c6d2ba4fdfb55fa5de1d5ef54266544b610cc039374c20de6761d24641f721ded9d3592418ea0a4eae8d7e5f09022b6be6405bc02accf3d484f7d0ca50e470c1d68fccda285a39d7f5e09fefe8f80ad51970d9aa3c454cf96b119c7ae5ff2fc2b1c3fb1fd87b967a21429f9082307d9dca58080639b3ef75f156dd3204fbc47ebe93f21c8d4d653faf9162191a08979568324aea61473da3818989acfa174caa53be317a6f039265bf212db9e49a910a469e89b40801b2479d156761662de9c4b09e471cd4d548ee722f214c4cc88fd4fb88c01ba043702d17deb3d7f2ab838bf9a771c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
