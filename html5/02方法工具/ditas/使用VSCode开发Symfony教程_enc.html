<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc2cb00eca3d70bf577e4156e55c0620e57fd8e0d114ce1a9a200f810226cabc74566ed21d53c4b838528ee8338b95255c023cc29aac4550ed8f5dfc93e3f41f5bb83d3f1c8d73773bc65348aeae89b9f90383a7a8376cf087b1212cef4a01655fa913c6ae882e9b4873cb86b89ff70a61974c5435b51653284c0b3f272ab91b34bcae88c924aec209e8b1b2b7cce015f01c700680e96fbce7559860131f2beb51f0149237584b5137eb6facbec730cd0e73324292607feca75feccca8efb5b150752635869b2f22dcd91e1fb6ca655ab637e2a7b3360b9b080e70885f94cdcf068533e5131e092b505a863cdfffec953b6c2e9565c3f985373b4c6b5b8508b976287170a5ddb702a2bb21bece18b72b7a256534bb17203573470387aee2622e7e3a57f28c865914bbb2ae1e1a2318b8796923501f783ed785a514fc4b7b33d4d01bc7113540b0c7980cd7f58df23e837d3750d9d1f559f49f8a7d04cabd5963a1448f8c4ef00b94ad29db8db0814bedbdb3088378bc755290052c0d659b534450047d4f849a74263cff1538dab01d67ae816ca323e35c1fc3c9d5a1d5de717044929dc9b38a0206d9ea87e7413ac65e40f184f8105e4cfe89072de858e6c043b343d11279194f6b39eb6d94c31cbc1f3cb44cea097902c5726901fb5a57808221fd2783d8d593ea27b9066a2742e84c71290a19ad7b479aaab9c07c7d084e6d34852622df7598d0a0f3cf9d024a7d2d2462fdee30fa57831d8582af818acf0bfdbe3639e0e0d36289ab3e019053e3702393ef7b3ed86aacaa302d37f8e0fefe17f0d0a8e64b519513d4ed1159b4c893440d655fdcdfcb84829c612e37b20a9190d0609fc2a205003389f52a1bdb8b1404c0a61310452f55c7b764ae47e171a2bf4a90eba0c4a15a3936d6235c1e97f56ac5d79b593662ae7497e9c90ca6136d776104e5b9cb012d2d915ebd05412eae080c279cefcf868061bf4751ae0d593daace0837edd703b9a68835d5eb3256bb5e762b72aff4460d985d75913b60f17427b239462ad24a41bb34a285f54adce176ba162ea2798a78cbce8b498cb07d81090a0da0ebe09a326e8375dc198b3ce998f1cd0206345e11dff9e72484b12f55e273fefd533ec42692adcd10c6c2a51f9faa55ba1e1edf1881347980caf9b192da743152dc98dc107fe3c63e5767fa88ec9002dd144ddd0f1461886b99276b01acf075346274c0ff99eb6f93bdfd82632de640846b29a40478e41ae6caee057c455449c97c0eaec1174d9b23df70b4cdfe492e8dba0c8296b6488bcf11459e7d077661fbef94597c726eca0632171bbf69403ce18ac49b4789961720468a66e87b8b422d29ac95f6dd7ccb45623aa1ed7eee7d637a568cefc12a02e1ddcdf85175b2f085a52cf6d03b69675d3a3297c28f8bb7304282eb10e389843cdb5e42beaca73deeea6ffcd61f74540b233955ad6ae96a61cf9ef532da9e91d6290fc5b2dfab86a9e3be8c99a3c427fc4f6239ec6a03709ff57e326c43e86f01aa18e6295d6135bc874df5a780671ff56e9e8185d240cb79eda17ced04d28b29079c582d4dbc5b9cf8117d27656e313d996d6b7b6c612e1ab183402178b28f46f42ca1d1542c50ebe5af03c842ae8e240b2a5e7457bc34e59af785710a95d662e3ed470b3fbdc3ec24805a9865b829a016227ac50f8b641768438cef024d9f0df393e3bb88e554919a9d67172e9d0107dae97806b4f0b10dc2d6b02fce24ac96ea4832e4cba7f84a1e14a3712eff384210be6572781afc0c60d4e814c1114366fd37158a12bc7453b87dd9ce43562f1332e5cdc6fdf4e964c766641da14826026a77df39748f42ff47e25ed8e2d20b1a2c74778328a4b6831d3dd88cf2feac85ad7b848f607cd070687bc2ee1be441523a2efcc26de81aa9af7e59913878b8aeabc48fe2e87eded25e8719eaa722016b3eadbd084314fbbab69c1ddc59135b26611c029347a58a8e776cbec70629b64283d40c919b4d2f936af24f08bf364cf138d9520231d7aa3f5f8738cd6c760adfe11002b67476bdc91c51be1a1874017117cbcbcc485431d68020604761f47e10826fdac0bdfde082a81ba72fd4172111bcbfd4f537ae77821a8161fae583c9b22a4a309d8fcdab9e41fc24b8d4c138c7593c1fd02f71411ce0f7f32f829914f2ae68b95c806af65709541df0aea897e37a4be20f549dcc03d952591dc46d96de91c793eba06f08f35907f6487aea7100d84d9c38b8bf47c0b90af218875cb6b084768ccbb6fa63a180df89a6eeec653cd646d305d192680224290e2f0f969a192158bcbf79c1fb3f26a76539cffcb4c90c8888b779681a18d96cb0ad2f5a2c3c249727f74b8f59825ec634748d7294ce7585ee759be25a998ad255e2e4690709fdf67165b3211062a7c8c71cbf9c22cf1fe4fc2f547778ae16c4e04a9076e64bd0423faf0802dc74e33ddb0cfda180171f32836187ab77e63fcb48488240dc5242aab164fcf3f7ef9df2e246f6f24fec76a6e9ea2b7897c53762c93939fa2b05c2d4128dc86f406cfa816d0aa3a51ac24e36b004a5f5f7b6168d1c99b4f89b91ea6a781645b45e74ae0e14e2ed8070cb4b266cae6809a42c508fc8501a43151d85d0548f7f26248781162e23d7c51af20e2a150faa96362e3ae07be7902ccc1d963250cffb244d88139d62cea55fa96f23ad43d88ff7eb51a42ebce5ed48035835a8fb485f633e2d9b67647ef57cac0859bad14c0e4e700735dcd35f36c980ff4c09fdb452f3c75ab76d729c53aef8f16ed95d8aba849c902098d8c790c722ca7e71e1d2ae6778421837a931992dca921c78cbaba91bab7a1bd7c8d9a6a63b0f7fad9e0032ad3c8d6b0cef50663ae4fabdf0a0bd872400ddd5c56ad11514129760ed3ab3f6b51e13b22130af8e01e32e06b98a73e8627db6a5e6521838608dda072303bfe5f5789b94ab5d0a7b27e139300f830d39ffe12a09d982246e6ee41705381d938433c8f71b213d7e8e8b2ff343a3c7037a5e03d1217ce997e6d250478e1e66d83566ad316597ff7c899f9ad60983480eb15c437e7bf9e8ab7191c7da849065eabb91f592ec3cf256becddeeb78d829885f9f426fa506a018238ac7f017f18b08f5e81a399167e623d5b56e8b3bac17706700501de9461c02b40dafd8cc6cd61bc62263db6a92efe6af2ffef7d8b7eaa7ec678beb9967506be9c7e08373e346a9157a5031ab07034bed3cb32d0ac76613e7a4b9934042ae2e6a488bf7e0f8f444d7bcd2cb57372d0f0e93561024050a998d263a317619519036b990e341b12770310f0f5674d87eff0d4a9910d035e70e51e93fe77825012fe48b0d9d288ceff47676edf0a7928586419edf1a09714e1da158d9a456973e23201a7fc3d42984d8f8f1a098efeddc1d219ded3f7537c03c17e5d93b09467dcf7632c45f6e7254ae5fad4d5702b8e65636fc6dd79e5f1d8b040a03f1afcede67bfdf2aa755db0d1b1219b5f09c9dae021dadd7fcc071d40d6bf9f4fcca33986b53df395c1770b6d99a73b655ed564600391f722d2b5017d9eea3cf14e75de974d1b19ae476fefeef5c60da3b14fbd65d4ac2e79d7d087ebba8c825339d9655211a7afd35b86b9788f09c2585315ceefb0ddcc28c90e3ca6b5ffdbf7eeea6ea1eeffbd8f84b0d9c793bff120f6b71150ba2b011c390884922c3d2e3b0e14c7f39feb01bfb0d19c82123a59ad50b2111b86dc1fd0d97ec2ba29159117bdf95af9b12b7c9bc01f6e808b1f7218af1f532923a3614a1c4309e0765f064627d93d7ece69918ac4e9e7e7760ac7f1f8c12c8edc80216248b8d51c7a5a9e1fd16eb71cec6f241ff2a72a6cf5e37674720d431ce993566cabe9bfc902e89ce72072464448baef5e7afbc353b5ec5882b5f34e43b466377becdc0cef47478d31110d026e5262301068954bb1711c8d64b8d7d2149ec21b5e74cd1fd1d0d0ba3c9d9b9051707d12eaef0d93395b39f18dfd20387acff44176fbf8e63fe73830b0ad059316d1f72602f7c8d9708c92cc42c239a100e7e5da744c004e7a4edc731d9492c270977cc3a700d315e26b18af9e74b5d55e247d7a690735d5e52eb362e5f8be443a1351273dedad366e3701401243f9784f33506d8131505e736f746d8d8c30b8109eb6927493d3e149f10b8270c0a5c2bdc581e87c92094b140b7f6cd4b45d7228cade75ae1eb38f008bc3dcea76b53e760776dc7cced5149d26a944f8ff68555e83120ca853b2ac2817894df6a352a04e006ce821918e19cfbf0aa6189055a01a55f2dbcf52a05d6da57efe55bd944aa413b50ebe317b410ecc14946126dd1641eec1d01768db453af429786487ff67653850a9be9bc6f5eaf154c32e7b66fe754bd98a352cfb43b544c85a9788a1fc075a56a63b1ad426b859ea46c0b957154e9e61e6b80a0adb33e73072da08aabe7989c25bcbc7ee7114eb408830980c6a68dcefa89d65bea528eb2f47eb1c64b4fb25bff16f26b4e7bb71564ec959f765f36a58540b3a7b8ef72a34d73b846bfa89dc5dc9c6815b0196c2738128ac37e7c9fd63fe040ea6b5e3efc8d0729d1f0d04682a0fb63c2cbc172e0722856ec391b9499e45ba29f05651529c89831caf15395497051733e63be3984383b8dbc681cded9be200b5e4301f49296e209f477ebeb4b9625ad3cd2f3f14e99711d56c7420cc76cdba1d5553e7423225d285feaa8725a459f2919919a39c90130413f07378957833e31b11267b232a1f1d200006b285f03a17e6c1bf41b01ef6150823addd832a8e33f02447e377c33151f8b1d85b09f2ef77c424485b40c82442a94d7e8ee81eb0ef4e35ca1c3b0b271c1a603381fdaf3cd28c2b093d9faa75f6916c0c41b8030f067ea2854222dda8ca59b10f57adf57cab8b9dd7bfe7d3539dd6dc2530c4b21f7929681c9feea25a0cf4ad57e757fb552372984e4da7feb3b514fdc9bf96c0d1245cf5037d2dd3d1520413103a68bd72169cb0b8e3c90a6ddd692fb256615820ff006b1329b65dc4684853b43c7b6a3562dc534607c86d1f9c1a92753d847cd83fc4faeaddbd47d573d8d6b29e8b581bdb8d6c3ff189c2353e47b3be70327b998c117aaed13626d62b4d7247ec6aeff4e80f930c4faf8f90289b4ae9c46e28200d054911c82242d1049209023bb91d095239ceeda5b661c5fbfb46fc07faeb67c35a1fe0dd3c72a5358e69fa26cc648ecb04d4e3e3c67cc716aef2cf96603d73dd28c965b1df436718dffa9ab901132c6cabe5dc2321e46efebc59f901c9dd2ee6a64d1a1ebbab3dc33150ef6dd91af064ef5a25eb2fb7802f0cfa3c3ec4cc825725a2aa79b1fd157b9f456f3df15b32c08867f6ac4b9115c4d74f8e870156021c410b2630a246e052b951717820a118b6c9272ea348595aae056a6e1c4475404e0df45a8f42d173556ce108e05fa03ebacc4638757000dd4575dae8faa51858fab6ed7149b5f14ec5dee915868aa14616734b0bb8559edba3b980bce49c79f76521433c477d4cbe519cd01673d8483df34ce1992b45be3eeedd561205719c59634d6e6738c9c7a425b8972fdfbb68d3df5050603e3b1eccc1deb0e54a6f1ae877c9f3caf037c242837b132009223ee2eb45a3ab0539bc2034a0d1a701381d064db3c27f8627eff62cc8f5caf9a8f7e336721c5a1d186efd81687840345b754774a5bee912394a4415d1cac4f99966a315a97a3b9ea14a0fda252ea689bd5d13aa4d1ccab8cf0f77dc0ea4409e859c093f13289b74a84890f466e0f947f263d28edc4c56040daef00b5deb6e24b02577a5605ae4eadb0cd234abcf24a722e19d1515037d1a39fffce8e88b9b29bb30ccbe30231e932d13595f3df4c262c02cf72761d55b982f776f8349d3055e2a688a0134e535351f58865e4871ccee58c1008ef509a293d69a2fd87ee8c01882b3c79ef198734cd47ca680ed72c47e14363eb5b8207a97903eade881603ea7f9fdc9aac8a1f09f326c10b637cc8e890280b0cc2caa8364a098cb35b1735d98ba6d18f6f6418eb992b398fcbe9948406f6828ca50954022df52c3bc65f6b459679f3c6219a9d64f280a01f3e96effc958377eed6bd4a5d61013aae1a442b1a7fd49bcfaeb3d1073f6cb90151dd566741d708f4ca1f93bb0e7169e8832db5392f47112961974f841439e9f00bc06d09d5372e029af3046f946c5d32c388cacb72c23854aae4ab4bc1b2b10535a01bd2f898b458eb7f9fda7d87b538396fccb75e57f5f955dea47c5bd9174fb442414a10f222c9641ddf9c9fe6956f2b459505d90d316e6d476a3f873bd985bd846ad3abd1c9231938decbce3b671dec0d0ba5ee2fef9c156524dc81e0d2bc31f455a682419a7dc4b46e7ca8fdb7646caef58ee2a76dea523ce550f5bfd40a5a66f0e19aa6c147c337268b6a8b64fd24fdb73f190325cfda4fcc51ffc8c40bc2e17c246c08d6234c653e64e73f040c3c7dea5d75a73349fdea94e550570a0b98d202d4e713c8d1c7ded7ef3b0fed79cfaaf6b0ac1ebc025418ea62a6dc55e75792573d639ea29657418c2ae93b819dde344683b5cdd3235f04455c16d02ba6b22d6a73dbdb9aea1d4469d5ddaf077d40bf6e82aa2f9fd690fc95cf030750f74a47b86d7d6ab0ce907ff400a141ba07c4c2ddd0395eded995ab5cb82a17ac7507848af10bbec5f6c2d10d8e9508a08540c5855b38e5d4eaf1173b0990723d20f2ca7a745cae5521d3fccda0f73da9e5fb7ed837d2af92c21afa795b36b096fed47bb7f760ae540d40226d2261d03f1f8bec9822144c67051f0edc45799de1a5a54508558e665c2fc556651e91fecb7d7bfdf48be3dfdb7e82bdc87a6b8d79a119aa9925f9038bafb68406758b972f8294a56ca8ac663cbf3e15c6358db318dc59159425d8e6c44fad38c113a51b72187821b1406011b594cd3eaf8307b3a56f5100fde4ebbde40fdbb07b28e8fa683d442e853e9ea4830bd98d37f996ff57a9c390eb2b386f7c72b4b1c03e9d2e1dbb2d56d9afc9318a9919d7c890b2910629cb6d75ebaf2b4987e9212a8fddc29b93c645b34f9f93a0b0527d0bde296cb5ba933e1f23a58b94574404fde5036c9454ed3dc540de221c2a54cbb2e329b49decc493f495aea89dd6c2d3460f20bb002dc15f004348a51d62af005a76f39ac19c0d6f1b1e9a980c62c437a429638f45670ddb17bbb96cb5bbf18b79c7613605c02edbd9690d319fbd2e39a6edd04196b597248a1ad8c4aeeb4f45b14ab2103116297641caeb1bccf732d4e94a51f19842bcbf706d916f9f838eecdd99be6cff8ea8a0c3b3fec4dda49fea188836d13cf7238a56b0cd8baea436cde09139571510c0996003c0bb1e61babfcfafacb12427a08eb11331a823398c574e7b2a964efb8b3811911c36e3cb318ffd56fffad50be227adea98662579460b3ae04d97aadc8fe6bbdab24104bc20f051e31446b441935ba39cbc84ad41ceb7e47cf35738a9606903e1a11a12f4f536dc7974533da415b65c369fbf356c363bab8a90ee4f219bd006055e7d355d54da79e02bdfb080a68f88ba0a1f37e9775e335d3227a3ea61b72fd2bee06246512f973ebc85085bcd652890269cc28186135c733d75515a94e5c816832181464e5a08193773ca6231caf6fda1c8819b7160c098e1e4acbef404dd2dc890ebe78bc57696bee23130045fc2f6741b0007f1463af9d95e64331444453b22c9ba7a14938e0cf96e605c1ef558fb3c1991b11e727b7182f6097b7c84683069d81fcad95c27c6fcb05b8d4a7889cf92a3097c43cb80c382cdf317f416ee5bc11e6e7a7623a1f5bdb64df3e1d34aa6f760cb1eec9f4a11eeef183453d750476ed2269e67bee44fae0e9a0b814281731c6bafdc3c1cc2b6353701afcf6ca754b34abeef5f4120d040560833cbc7a02b98d25acc3bde3058675362e90358588a670f193823e1d8a0c58994a1a588b10957792ba128df729435fd1b69fe1279ef10708d391e95f18b1666d32a5ee0a09f13c47d1832d8d0a19d20ca2288a08e912a39db6c15c0bdd5aabc003afa9ee7a1abb23ac43e7f566cc40761990fe95fab9bc6beaf7bfa83100941c3ec11962f7bcea1a8575f192697e85990f1b4cc0772337c9daba184915e8ed41c6fc0a2a968595baa8f40e10578b5c5bd05ee0729041a6a5f1c69f1aad3c8772e409fcf3b0a9b890dcc6ff840ed185fa6f7d8ad9a289a5281718243473d31f40932c76b743553180b1a9be1551a0a6fb94a2674ac2b131597a0dbd9da9f21352ebf1dc1fc06a31f4fc1d6fbfa243ffb61ca7c0b0904951808a5e79230942f8a49eaa5756938b1aa5763cf2a2b25e05c4a957fd3ea6c9696fa679c743c93fb7e19b84e7f7ade58b007d19afd6f5d0bd23d9f62386dd776206c9294d66cfcb2481f1e6a448aada453be4d7de4bffb615926f8416ea9a07a60b588c66dda3f05a3f18aadbcc9f5cd3d1482cf173f0acbc2a5d2f7c46470b20f943a108eb5806fd6916f9393660bb0f3e7c24f6c084bcac24b9898b1bec825eaef80e8c1d015a3be9fa54d1c7bcb6d1bb9b2b888a942e65f1b04a48cee3da6ae4c5dd0f37aef9231bf9b0df1e5c9ef3fb0346e2a151cf5da9d4295a2d60cf0000d40b9d765f48c40a8c570530f0640ed6bac9a15e30f37b832ae8af1a8de86f0d43a735a239210fef7a8ab8c44d2fd15384348e9036a5e7f61a8d0d0c40e8bf73b70538f3bbdab69f44d3127bbe20c013af0c707c598a8a6bb25352758a96784dd8855efdaeb624989a5f042289084e63fac5880d14bae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
