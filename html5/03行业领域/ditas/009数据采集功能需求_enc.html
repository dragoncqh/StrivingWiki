<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12be40fe9e8a003f23aaf6d177f2371a8f75fc518571034c3b6095faa5ac41a6d4d1d84e292d4ab3c663cb9a2f55f5c2043223e37073719b80be48772efeccd07eac376704417a781730c029da08d88b47703391caa2ed873d6c781af200a6cd6bfa6092bb0b6f313f01313462f1170085a13ddd8d890a313b1cd49c1160fee9a7c7e3d4079e4873695e981cf9f946c42792ec6d29983bdd0be808c46e1253fe96605cc6352338641954ced3943376a9303a12d9e183af89ff56dcd1fad8370c350239096fdc231f513ee62dd9a7b13ed42ef60fac7348684e5c0716d275d4c63567da3af901e6c1fc41785ccad611e01ad49f50effba4da2bcfe3cf2a6a978dfe2b88c0b132dcf32df9f9855268233e9574dd31128b79c17b7d677dacc821469194ee9638342ff4ed7726abda04fc112e713bdc9b2ca9d09c6b3b1f59fca97612ebeba93eecc97f0994c6a581f1a949d0d8dbf5db7b86a481f938279a27c44af44aac2013234f5a84874e5ef3d4482aa9cce6cfe66b2717969825dea28e2159c98f21290572ba90da9114af2f8a539dee8a0740dbbf10c80e5b9684ad9661c72e9e7f88308ace9cf1fbd0467d591f8187949049a45c1b834a747b86ba1bc2be9a5e9904ae9690999232b8e35fa419875e168cc9700453ae3af3dd46c623fc218b4b2f4b952ecf9a7fe72f1fb291329cd77af6589811dbdc0d8bcfd735b685573638f029936231fcf8b2b5ae0443f9f2f63b5c04f32c23b16ca90339aaa455c90f641f007eb7905a7c71e7cdadcbbaee2a8237f036d609a6964f58d9057a34e0ceb7d2b995a984f1bf90852342a39e3a926a370f77051851ba08535a32b67756ec7828451b730e6d9e9e01046dc7b3ed63f1189e2bbbb16d5aae010b694569fb701842d9373d227cf4078a062d2bec71742e27d23e4d5b7884fa6bf306282ed381e0c9a761b07fc32421207ebf8a28a1e55ec5c58de72fa1407530915ac5327a72de28d41cb129a91f7b40928a6b19d9adfccc37888512353594aad49a594330479b4f318e8f79f7aa887e552b227dddaecc52f9b32d053e2459e3689e69b89c99f7aa6df84bc6c6dd335133ca423298e7c8c60262664d1e935c99f751ceb4980048caecd305516ca627121a50eb86ee777a4f60db81b5241749a6f95baba64e42f86697c83b1204d0d0b30f91718a4e6ee43880dcfc139429ec490052592ce5e35843bd4f34931bed0fba6757acbda9823ce8735386258abc45ef292086d07b13daf4c273832c295d636094515a1be9a53fd9f6dc2afc782c525295bcce44c267cf7ffdf7c1b55aa03765aebf66c0b9f2baeb4563233ce6f00dadabc7d25d329f7f2ffc62bb8c18c0262bf7bd3e87ee582ccd0017b0fd225a91aa36852b711dd8f7c06cf2b179a06be0081337f1365801a0cfe55854556e082f7eaa11e586fe48c8f2f0c2f5b3e056bfb8a8a5cbc8de328bc434e8b8a4a3e7968f9ffbb0bd2b553d92f95b008210b7142625f6c78acf320f9b02d89da54d31dad51fd93d545a75750d12de3d4a62d855207ac9d42483017288711a7e4c3d2881a27ba20d80a49c5a413f27041ef10b07b10ed5820460e59e5a73a35a8330736c1eadb415ff1a153849f10f4dbfe8953b7d608fa6da084df17990a42a0896a2f12ecb794365359db82f04099bfaf98fac0c3502aee6e0835c85c0f8af53255f908e653de7e1d907d695b714054e06a8b4f3c796fdf4ad335ec1c4eefdb6702e2ec63a5c33b3da69cd32aa974e0cf9c14d889001866aeada840969e505e80dac0be52e9d655c5fc6b487299c97c08656d2cb0b8cfd24dd5bd2b353ca7fb84c67c64d01ba08fb23211a3f31ca7fa0428b18c1f345d0bd758463ab2e9c0bbb87d0dcd3710d82482eafdde5b3d8628534435c8f02823821be4c2d4c6d5ab165ede6620bce77a29280c181370e3be8461926869b711472c08451935727d18a8325389650391f86f6052384c9a31956d86f9e8d0b41803b584d9185f0256e9b4c2534b0b82bc576675fdee720897ad93c449758abc4d2cac1a5b48a4205d196012092fd3707dacd6486978a698bb10397184b1c2299fe85740a9c8604857b26b37eb6a003bf17c2fdea09a460b1bd457c641c854159c2819e16fd846e0f0bb01ec7bdab50b199c9a298c6e3a44e6c9113d3d23cad0378b65198a6b2565eb992bb16551cb51bdf8c6db979e456f8b5cf33f57fc623c57ff8e8b9ea4a695aace5cddf147bc081954de340107082ed0f5ba11ba3bea24971be7ed2ec81a74670c4f70cd3ab675b865ec88401d86187a8fea7dd8b10e3991b76f6bc980582e51c98defba5bd8d3b39b8acfa101988da58676f53dbe4256298048e834d6bcd4549158f1c45629caa37249f41d2c939e6422917bbc0f20a8b861595db31c74022714df82e27762c1c4767962aa4c1b7b787b5fc0cf20600b1f8188ae026359bdd5cf588454064a10dee0f7ad909e54f94a6a679b417139db5dab02486414f8dcd031670b937084eb8d4bd9528735af3fbd53702bf7257ce9a4889f5f4539790faf4f570e5bfe8ca587557e9ce0d92a92de597cbc1c0c074af9be4306148d5671b689d2fe6f5e6a5e4981ba762865b03d63d87aaa8d1f13c2d9e9896416a59a80e4d769d2920936e83dc75f8d4d7787200a9fc2c3d0dc05115b207ca4add1258a73e6152d97e1f88c73be1e7c54883df683094ecfd8b823dceb39f06da49c901e2db0f15bbec9d5a17bb2a79d64d495417a36f3e79a82dfb8263d8a3d9faf7e8ce1392e3b499808ea5ee594e70b37f11f0081a32ea81a354cdcfca0f5010947787ba1752e784385b5c526b7f35e07c1de28422200f9c29d1066392558cd8924c7c4e526dda7d54ac8642c8d0ef656cd766d710c23ae218c38d2164d2547472836996df00ff4b1f32fd8779f0ec4fd8f0f3a31f510fa85d3209b771358c2dbb7eb71d682ebb8ec55b38efb675bfab6f0185cc05467ca766a7f05fec7e5956833c746b30d3ee79ea095c3465a7078adbde7825bf389f54c9c0e2590ddd8f2a32098b7bab582f5a237e2b2974186ff4ac8a7d10fd378982dde142bf6b23f96668cf62eb352c76f310292b260b0da5521162ef26ba91d9db580a5fbb14828cedd2e0a2c557b415249cc2d6e239186dfa4c4eba9a8d31f828016cf1320433bf14c1c286963f05a2f4941a8fc5aef1605e737a4aabb60676fce7ed9e2d757ee2699ffdda4b93c5266fa1148cad237700fa2a619d9d95f038209950e13de64400e797ce807faf238ef8d64c2dedf07c7d5f4ea03202da33261a985d96d993096e6864b618281e6eaa54f5ca247491016c7df2a6cc165038e3029d1e7ad9e9d20ac4ff6130b0a42ed7558b3efb57eea183ad87cb635f5da0d67f9ec6ceb0640ce9e74ef88cfe31a6be698b8b62cf6379f2d17e93f0995dd89290223d06073f390b80cae37c99be32d22d144c176e04c80aeb6119c6c06434291bf976dd88808c98b374ded5aeb25e1eac6628a0ecc9e505234b8f9387f85a16970d91588c9aeca96d97c91b64b28776aca57533cbb8b8ff0e70cc22e0ec08103b919a1c01bc134fe4141c921f03c9fec8fc4c377c692615f0018d05befb4d0cfd902da7e786d0b49cd6a1098bdf60dea6f3b1bfd682914deef7703782d6195d0702f489bf137254a544fce545a5540b4b6554c9bb2bcd02ef98cec9af4d9e0460db9cfa9c408b93e99996efc3bdc2230eb73b406561e763cfb18f1cc97d37f290923fad3c6dc2f680122cf6b6569717a26bc1cad230ec8d375eab8e29b6b3f8734e80bbab393ca021cb79640023d9897b9edbb8fd0e9a5593d6a97e46599ae32fac0e309b003d76eca05fd5a3cc672de6b37f4ed4a806235c0473f78efbd9a189547d7b295a84dd7fe2a3402d9861ffb1a634c63600966694ba6f014aa36c4742b8f1feda56c1b8caa105ef1bb66aad70109aefc000d0aabd632a6e79053bafd9a1387fee3fc33bfb848031703832a4074df540c1eeb546f433d61cf57c7399a57e09909bfc796301e2efe24ee3137505b562fd0dd8017f918078fe3a9dd5c191be435c7f8f58a026eced65ee6ee392c29e46e1f8c2300853d265b6b503499c1454b9ea088d5094117add05c512bd362ee5da883f481a5d4c0d1f2d73b8d09051ed768b28ec97428ec66a230d14add46204ec09e8984122c29af74eca5e3ddf24698a7bc1b61f8825b570652cfd62df9b72a420ebe4bc10d6ef0d2f9ddb8a23a6ec0a4ece5a5ab32b95c124433d59ae39a6c30b33c8e2200697a0330896021d0a907c38efd33539c03e1c34266f757efc6a984c6a2c76e09ad5288b99fdcde0262f5b7d3586c201d2ba5c61b1b629c556054bcd393de5ccf3893cf554492dc21a4f8d6b5afa0c5221b979f3601568850697356e0b2348c8012e8dce717114e7fc1a48f4cc1d058a2d42853547a08c8d29936597f7121f63bed16d83074acaa273364b4f2a6d376b901601d9caa63d1568a42600fcab24f17a6772e31e291fe78b646e6a41ce9abc5a57049015aea8e4f53b10faeafacb00bb3c8a367fa0b9c16bb1edc949dec9091741bb9b5003fcb07f2d231002e4e3f0a328a7fe3ac72737dbb26ccfe339ea37b20c53e400d5557fd4f44364ddd1cad2389d4f6d6f6d9a16d9f392240f68ab5248ae77821cfd5a6613f4f898b9a898867a5e88bce0b1a94c94452533dfa69bb78db6b3b6c8548e30c6b1c0993e372f67f43accfa996ccbdb9cfe3c7f0cb27c636a9b34f1bab3eacbc50e9d0b19f22cc651d9619ac0c86e0976fe659a01d74bae36db18e07ad2c2907221ffc3dfebe871927fbb3cfebd65f0c8902f64859bb83f6fa72a75e18b0d2d641b91afaf622d33c4ab5b20d927f7fa023adcd6d8eb5a7d20603337673ca59c46f1532abeb1e305c277cf1a1e9c6f953449fb086312a2fce237a16da72487877f800b2959b7af042f12804a4c8ec511bd71ef9f35ffbc6ec87cdaf7f12ad9c522882dc3cb45835967529b7ef863afbe5d11a75dea30774bdc5e4297de4de3bca8f7adc6b48e23634b2dd2b6b1d77d638d258a34a536b2300a65dfd7eaec709f6458842bb73916b4ac6fc5c59b3ce18407c3870561139c346060874dc9f504724989c5c2125db62b19bf4fd0ef3e4b54b5d804a7f6fc31128b1e97e58d4b241bfc9a11f185be8e608fb6b8ff48ae2379b816f5e217cf6a6e321a4883f487844e58cc0b4f7efafea6a0d5c26f3d9df0ea94e8f6b17d2e8f979c829bc578a3882b00d3a755ecab6dd3e74e3bcc916db99b3d5d5b64711de8b4a9961a7ee703e83b019b81dc3dc9e1d4de4e2c39d86b5f846d0119fb5728e119cfdbcfa64f87a0458148bfdc4a94d7155a0d6ac35beff558f97a700ae4732f74438f769870e47976dae38f6d4403b412c19393932c235bde3c5f04f5f8a28b01710b937744a44bc7fa3504b2bf076017488417a613fa92bbf59a2489daa466497751d2efece77b8842463e17c5f59a72ff29f4d6a6b5070599cfae7f30f1986fa03d37a17a6eb1681ffd12c3fccb357041ee90d7cc9f28ec40293cf1b0cb961b8bdd9f5b492c05386187df845126babed9a5e4870f2b8cb0789c3d528a55d678ec8751016abfefe22269a9a0649acde05d784720b7839b19e9150bd453612eea741adcf7d0bd0aadc99ddd91370cf71bf51b70d76cb3f61fbb95cdddd89d72a482ef720050698dcd7c02795a383863ef63567b647b6e7645fb7bed4103d5d3ad9440cd37edd6f24fc5b37a60071334966e02661661f82e86d3b273552458d6c3999fca9140a16738d5b6229ca6605437f82a411a87ffa1acb4e5b197431a0599347d572efbb3d87bdee0a91d435a7c78d547c7ceed1772dd647bc95923a95caaab889ea38ce3ecc9993b17686a5733c1780abfbc2c07f39d469e53656a30e43b611a7a7235928f355d52d6997b8f04081e69af65a32206b3934c33848f00b88ac501b8f146ed8bd40e771d7c7e7f552cf478044ead45ef782f95f052823e041a415ca69e77bd747cb0242da127271498a3aabbbd44af31d6484b8ae04f621ed54dc53dda3ddcbe6f97da20a1561048031ccaca6b7f23da488b36d8a5f6013193d261237c4c96550d1357851618be4d586a9d7c0cdc7720d4974670ef02377ec494e1b97b2a13c03f8b706af2a7938ca3588fba20ce2a9bd393b9aa9b7550bdad46c66212aa249a24c0123d073c898af7bb7a99f9689130e70ec55ce918a20ecc3aeb9098f74141a806dedc876202d871d78727c89f4fa4b8b211e121bdfb5c0da25811e3957cdbc920b5ac3ef6128db42f293a5b9e1bbd05717dc5a86f03306b06052197701c827fe49d30525abd806a9d789f6e2d08dff9f17b33b5b6d7317c304751f9faa8bb2d836c883317e40ad037b391d5dfb88b1f12889407e324a789287cddba32dec564abacdc3fda576516cb5b0cdc76cb57470441da2aa0b436ae45fc5799746db7fec12ee170ca32d882d0f27da4a88268f1a7ca39d5c3f8efa4c9a7d7fcd26cc89b2c64c8436086c5242fa0b2a423104945f87966cf6c9c0b9f0217c0890f7042edf6183f3473be8b0aeb4190cbad735825158f6bd89317fac121a5754774b3d213d29565204a7729011f845a0a65a42d8e5867024158fb3eb1c88a5f0815a3978dc1888e211c5c7e6e8dd121a4f6f3b67588d73c8ed7912fb29602ecc16d5eb7ee77bcffdd4e6905a2845f782ca1910e7a24e2daa0165a443fa0d7baae2188dd572596f83657d430faa65aa2dc61a95cef78fd4e0bb974ad6537d79f699aab03e8040d79b575c98c205d94614242a166b064729449f6c6da31ead3ad229b5a5d19c0495c1e0cfb5d3debf2d8a77c680f6dc5a3f372f70711860d98f85335e6be0c2f2fab368ae89e53386108c59f7587cad170a9c84af09bee5c9cb5b690418373939a8346119ee43d278fb2d4ea3c247c61b38068110a5c7909f74cb9a5ffef18c77b0e91bbc4ed928b5fe15e6d1eaeb4b5ad265cea4cee24e0eae91701f6cc72b06ee53ed73477d03659298bd8063e519aaf3fcd984753ed513234c57c37337f82884e7eb10435a8c62281b3471a9f6eeaba8eac81e625aa010d86b42f4cc43e27c265818a5dbfe2f479b64ce508832f9748171481b527b0088bbe43ffd2c28676f3c4d1c9ece69dcbc9732634875ec8ae2a4fdb98d987d4baa59dbf13b50318a183562c3240a3433ad6ec9b85dd07b84c345e30dbac39a5c49c0ef3a2597987a4de124cd0c093cf37274ce55524f8ce8c5045c28636cfee72423912d63e6b67d6b43a4e675bc934d53e755fe94f85dbf6d2dfdde7f4bfa692fcedcccbaec4ed11f039fa421570705d2b3bfa399cd17fcb4e1d3b18bd8f296a5062f920c1f1425d592716aa8fa092431a4d5b941cbae9efd091fb038811bf87d2f82afdcd72ba1c937c5cb6da22ba2ce010cdc18724a4c393327b07ce00506534672d172b7c61bca124b2c57ec0d38bab7daf426aa0fa1a25ace2f3dcde5b62383beb7f39260427af95d81629ef665553bc571692ba8399e72714d48d5137bf165863be7a0c36b3dda76d8b44e8279fea2161850d69186a0f1c7f1c5cb49037c83d955df312fb8830dcfbf3b1317e19e58fe6f7b23989b99ea9f72c1cdd732079c34036cc51015039c3067129aeb157f6bf6ee5b42be94d57656958c43f815be738c1a286d81df7a9411336f916d37e48f5c43531064795efa5a72749ea6b90b98025eb9e8e66d1cbd369819338754126ae7b1e0517de579472f2d69e8e19b275b5f802b71e707e8701e609c8e30901fd3a3cc009111e119a462f2f5880d5af8b331fece8a50a74eabaaaad17b8c20fc020c8195dadce14036964b8c86c7e96ec1deff21d0a7e160773eb95f0736e57a6494d9be79026061a9d55c724275a0669cf73b56f5b7d31547574ed5fa5ab4f69d3b466871594ddf3347e5d17dc4dbf7df3d62860a27a18c20bd9ddc710c700b30309df7934ae5390273324c32c2e303096faf2acc7ff3749a4bbda397357014bb4bd5982700b31864787737cdfa2eb04f2a24935c0a642dbfcd6a012de0fafb3a8f20293474ba946c997ba1b7605b897657b4d081785ea193a34c72a5b8668e517211700f3a9c4ba6a8709cc018266308f089b91107b5d45310c357845f3b059fdc16bbf15b0993855823716ac71ae02bac9c6595e525ade446204ad23617230289adec4b3fb299bc606539d783aacb78be88571257c4465270f9ed6aaaf847b4847a9e3983f95ad0cbdab6dd55d75fde851cb690c1dbc4e9ea34bde0df1df978bce5ee9b5e126ef52e3cafbe026be7a1206f938660404447636f58c74c1196ade0de139877445750b6fb29941db18e6ee4e60b8a6aedac87b0d789b81d5bdbacc74cd98c4f282f57788b15351d822b7ecad3fa67f63aac7a50a1cf5ab21ff67bde6d5701004d5b721bfe413aee39770bcd52321805d3fab818ce244f2c3ebea10b8750192988fbac194f12c948c4ea98bf74e9e31e023aac4d008a40f69b25d25570deef87e12bbecc05294b54c757411375caf55d274f7698ddee71fcb97009a6c69bfed3aec2788b4446731833c0001405a17796f5a60f00aef8b446e03dd49cb3b2316da18f93ac7f19e0b2d506f9de9ce159334d3576f7857f4bfbe4a576fa007ef94fb688a26efde015660886958d8764adfa71d7b3f7b3f4381f0e1806ac7ed5ccb7e1607f9bb476c2f83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
