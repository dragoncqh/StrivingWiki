<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1a7341775ffc8c2384fd9f0ba0f278a883159446f828dff4387ca3bdf65135db67acd6ff4e6321879ca8b762d8a026be5a2ebfdf24ff5863843240b4c7518d785d1e4e83462a52d4c6331392e475edb43d88dec90c0a4213cc9cb1b9c1180b9ea1a4e204400b5e619d61e5938839db18ab275825654cb61638a16932b82761454521a5a519fd64857cabd38c7932abe66aecaccf00145f663616b4984faed332f6e0fb7bfae80992bbde130da61ec3122735c1c228725871dba94d8171d549da37427da17af90f7d4b5953d9ab84ef6d0bbf5bc059fb6b8e38a54635e95150e263105d1240b4f50a95883e3176d7276790735ef4438f478f2ef490d670de2b37132f56a1cb3a4e8170962ac2ecc8f514190eb4dc376487f3c138fdf126541e25849d85729aecc017281f9927b1386accb97a9143cab160143247043962f4a8e209061b97ab3afd2faaa0708eb55904fe9a83324ad882450d428ba3f279f241d19e8c3fddb2dfbe13b18fe87ba9d0f967bc6869cd99919e9b35513632f2e15f66e0896eb6bc9d1de7278262b90af92f066fb6be573e59bb9573f5581337d6e0b656dd39c3c3e9a22a721724555f2c4e7409163cbcb7205c0c4ff20797c1678a5b343863b43697923280ee2e3513e7bd204e809940ca282112e5c18736f33072e82784b845bcb734bd2cbe89bf6740bf1e64e310191b73aeb5d5199dc50e2ff13d5c02759d3db741ad8cd7c4a7c3b78ab078cea0ae6a98b6b8d39cafaa81280df44a0f80ba1da74d1b78d295d5c959b86383cfb8f2aa37e7ba68d7107fc056867c269f6fa85740ecc653188bc03d46b2ccb38c5b2ed1d74db745d6ec2c2158ca37e45a697b974af3e7ca4e50160d545bad589426fb258953828d9b5d82a7780a42ca28d1932ce8be225f87c057cc521b72b262aed8d84d38b753045692331b19087ef382edae3e9b7201070973a961c5c2a3c178fb92dd904b78f9a6b2cd548e8d75e8704ec217271fdaf46df9c5cd460745ed1ed95ae2ac018c3a725e1aedb70afd5f3102370495ad6cc20475a362de561141ad376d871d8823cc30bd49d1b3eebb9264da88fc5b9015a2f105f8e1ed2bdf71133c65d0fca5a24699d2391436ccb3d45847edb04ad856806030c5986af02265fb8c1c16a2b68c7757846cc13945d71368140ff226f2fe6d201fdff7b7415a17a14d6113769a3de29e1f1f449533bd8fd42af62fbfc7a70a48ecd2f729134c81cc0353ea56a3e117ef103e48edccd77dd40fe8a80d8b2950866a78ab37c7247dff658557aada66f90cf33b277e566bbbefbbdd5ca75cc79826f5dde80d42cf5a803b503f36ad170954d944bad574e48acc22237051c476abab5855bd49434164099c57dac9cbb4818fa55d0857f80b95eea4aa4c0e1fd634f2ade7dd21be9c28a4b78a2d654ee6e4f12f03c62aeabb2fdff0dc31e8f8f37e78f4239e7c90a6ff369bdf8cf47e85fd1f96a5c2de4b8999fdb467a40856a3de60851916a33f1c8454c3e93d83179d333ddcd2a2e24b152d10a6daa7cb5a8bdeee7a56dffff603645fcf415519e560b630de1a2d0707e3695ed117b65ddee619d7e498957fb64fd7f2825b87ecb194e7dc1dc73428db250611de609559b3d302ceb1d9507a1ae185b208e22cd7298292c185ceb6914b0e336b06ceab7a2d145d6a0dedf5094bc2de51eb537344ee1d3cada79f4ec4735d7ba3ed25c3bc71253211744552fc279df52b05e144c72eada11bb4854acc490d470427f6b95971ecc5233235997811578d8a87ad11ef3ad74620a7907b9e517af203153d813f66f5890d08e005bceaa1cc4301e512e6f090f4657ee1d7fdb3838959ee0d6fc7f5a8b9c4ae2d9fe171872e5d824b84052743dfce57238e8352a51197976200f7a24e1c7e126389e58341aa122649cb17be0005a24b3352b51a27bdc85730bf779333f1a9ede907ff66d0e8cff98970cc7a08a1fa273f0a26db0cb91d56af0144067e9af233d06e942649d6a102290d3815d622c1b7cb83b2a6c08ae3cbc3739b432988bc2e8a1cc545597651a973127a9f310a8546dc23e915c0ec3df13a801a468f779cd2b590ecbff14023f351cd6a879913135997fa02b91c22144df024f188594af2e46c7870bf359ff2b1789131a493e4d2b9e8af9cfcf712044f3eaa2b3a6ba2d640432c4c93f5b974a2c36626b463a0507abe6cdbedf61f328b8aa7322cf471c64a0fec1b827a996607d2189b1c460674c31ff1257fec59f7978139c479c05af665007b0a292c47a60163008f3184159b2f3c8389a89507d5ae4431cafcfe27d1ce33e5631adc9ef72ed5b930fd45a255231032998a03814b35051585834f6da278ac583b4dadfabfe66512d142ee94aac380a03d9c5f7fbde855ff5b39a9571b3f1021d5ee22430e8b8f5e8a682eebf648743e7545a0fc16fe4d28ab62780896052aa127070bb00fae4d591959f27493fa4f9a3833b1967b6f2e889184c76c55491d2c20b772377cab682757e9a444ca1cfcb249312c87f84ff55c14a32a5a3febe60467df41fca06bd3a37ab5978eb2d73794b57bc6141c54bd24fec2cdedd55c62efce20c6a4b819abe969b3648b22c04e671e13b40cf46f75245bef90032077c87c75e1f4d124c0f3d31846152abdd22bf2e743ca1a5894ca3fba29126ba03936613818f1737485f301a002d3577ab07b1e8d56d423412a21c12cfd3793b367af431f0b69326bd14f63364f5f6a2da3cde11ca3ce04e45509086abbc204c2fdc9257d3daf5379af102a351c945b798e883053fcd7304af5312324badf39df642354a962a76124f7cf5af2a645502274a61dbccdbd62b80fde37869ca837cf604cebfa72c979b27257c469a65f0f70daed9cb8917016beb4cecffbfb692fb990006575d41649908ad90cea59b4d3a16e33a02d16898dc0b4b727b27bf9b964f7e11959e6248ab0f69a65c52a52b24c4ab8380d63a88daf16e9d99cd21477cabeb2b4c9d82d8590cceee0ff0864b300c2fffb072540575c978754b0e119d92eda44b94562fa7ebc06c375d768b818f9af9bea4d5125af872c1d18e865e7b3a5b08c4a10d1841ea7812948420dc605fa8022c9cffcb3027e105986c1d520e6fb5a429249bfc546191e5ec266d8d0acd92ce9246828c0e60893e1f7ba799efb9abbe6c70ff1f8ccf594e6510e0b2c7cc6238fc9abb0d8bc66ab324e29b1efe258b5a8f41486a4747fc3cdeadce92153e221eb459af11240a58a853366fa0c080b224ce8905a645be3b9a6d08ec1ecacfb9b2c65276dcb8d292b35fdd84e13077d53b7bde9e486fb59ed88f1382894213aaf1f3eae6be389ebe2a8d4d94348aa2169fd52a65b0ec08f2cb15ab7815a25fe09cd2a6a26821807271016449af77f55826f6e6f91f4fb1f826e623f6a96df6e8a8a565b919c7f5cf014edb93684c80edcb24aaa25c5a0c4a4138f60219c664d467a0b9db7c766cc38c9525eee23546535edef7f9e0946a2d3e195e528c4fd6cdb8a439914181c6cdc6ad9de928fbe0cbe76ce370ae9245b7124a90acf5c29a2a8dbd6ea74877bf774c1b3210f994e7d7056c04d0151625ae8ee5959c3d62d493153f03269d090fa1a451c01159a408c33b5778035de994438edd09184075e07a9e34a01389634464a98d80642311027910a28dca690657d3d07ff6306c895868d8ef962926853a61a8d2da37848cefbe4c8e15ae97f8ca01bde712af47266007d859151d154d7f6c1e790228288600e35270ec494ff34635f7e9bf00fb9c9256e8f03b93abb41e9b2105e885d0c97248604342d262b39ed0254fcdeb0912f5a8597475512fac58f234d87a007f27ac6e8693c4cdb6cc2a4a0cc271e305961c3d2d6f4b5ec514c99a3947bd4a5fb9ba7964b74a0bc527f3d6dce862f797434b3514964894b9d9e4f1371d37304d282a631e0fc209b1d73b3c9511f91021a3db36914fbec30702e3242331d312b369b540dbd49756dca593cb236bc4aae12a12cc674e18ad5eb1b7603ee59fbf99fc52786bbe800986e4598417ebb97bcba30ded084cd5db80c7f29045aec07acb0e0652173d26e556d04482011ae9dc85cfd3e099ec08dfe54e519ab14487edccad2795fd3258a58bb94f812665b7b1c734e9ea3afcdb0824665f9543501fb23e9a85d9ce034c9f827212c6f21748d738bc37ddbed27fd2f1bb5f4d597dc9cfb4de3b7afdde725f014658fbcc2a02cf76c706b81aced11a5729a84ab1146b7b191385b56030418b9d40d779d17d1e9e86c59bc452d24dead269fc3083695dbaeb01f1d4f1c3e21ec6c7c0dddbd3d13faa48628b5780aeae6650724f6073adba0c1a79e8987b7f7074e1f21dd0b883ae1dceaad4807d3b14daf451e33a57e2ac23fe1eab77e656a406eeec9b2499d67fbfc97989b7e0c3c377f6ab5362dd70ad260b01dedef4c155f7322d3c5ea841cc9f624431dc69b271913698bae5d4d7d9ca7ce8e0ebc4fa1e59a6ed988306614f3c046b6ca3c3f26f78fd2f1b0092783540c985f264ac1c617e00ddec36ba7aea9a91b950149ac122a896126b792abf3d453066df925a3d80e20e6bfd9900d8c1d1fea83f2fe1a24bbe78004a3e43f3237b9a0dce41cb439f20b2b1e47de6050443a1bfe12079be14cd66bf7a000a0ca26d21a8a78f201fc50422888aea4f7802a8b750bf137144a6719c605c68fcb5d26cfb63a18b2a0feebc548c98a8d5de1083b22f5cc8c29198e6b5fb858cdbe33d417a5f26f3ea520b5c10361b56f38fb94c35007afc113de302a8d585f03d06919551d35d6effbccf4f1ff5fc76ad80d4fcdb2654392da5a43806220e03ebfc4ae1c9b696f0e8d7a0ae64d94140c2834d47d035f90f0dffe663fa98b6d2b2dd1a9edb4598ac3aed70f39817c8b9206d0ce292c4969a51adbe3f8b38de6ae1cdd9c704f8792e82923538446a0cfb53fbcbf9d360def190e79a73040834ad017574d2eaab64a08875993a79913861354b671461f8ff923a4fc580408615a0581101a097128adef1a8616e7bd1a4c22f9ed71da379eca25fb04184fcd80c72c93d2386513cbf59587e129381f0d07bc90247fb22ad9d957134be20912585d724be31ae026138da13dc531ce7b72fafc6e595b608114b807fbf216322803e6dd34b9a3649ba7ed220db0f8a1e1f43d63a3e423bcaa4c182234b27f4b1ec0e4a874e664860a150ee519b469e0d3d4bf5d3e6a47f46446dfe2aafbbd5c53f1f5a3676ad010993c1c86db4563b717aa81b035fdc71589c9e12bfc5c364ec03848ce13aa254ae45bdf80cd29061bf1c4c63e7bffdb6035eee47fe729b2c622ac5a9673ff6fc00cfde2477d9d2a70d2b6108872ed15cbbe476a6f201fb69cb2cf6e97e1b1af7e7a24df233bcf65b57edb849b1081e6372432b8469cf586f9c1d2432bab5ea80918dae374963d78ef4151333dfa1b2b4916064737aea95838cd847b00a0877791e911281d7af5587bea8ff61439137ca8b4ea33a698709d0b403ea7d398b3de855d824d3e9aa98b47350b2a0ddee70d1641a322aee9e35c7d1410e7ef13ef07894a3a0f423ce9ccc2e4aa7f36e0d1b39e7c5f10ca4d4bd1a7b1cf6bdbd3d9c7a8ca3ea02fa91a2049e44413fa0b4cf807ee39e1b9a6f14e8bed7b4c1c83e12d5b65bbe1bd031a7a46cd8f280c622792ac99c84930c60faa39cd27b885eda87228467ef4529038908cf5622c038fac4f9c2ba8522ef8cff3fdef49a1dae391e85360b34ac960e93b9e9a51a8262998a3a342a5756b7569fc39b22f030f091110781ad71b2b360c335264f4439198592dd79993176d84506f39206d78d4fc35acb2b1f80b1c0f2cba0b2478dc022c3c7703098c03c405209153fc53ee0bb3b24ce7bd96c8e77fb2e745be85868783422db083cf312dfd418a220aea3278e028be520efd3ca70fb409e6cf699efa92096d137589bd056e26a09097272c498811ac5129251b21528c4cde61845862567542b5b958ec344f036fcd1fdf365b37071880990e7d9b19827851777c98b4a9d6856ef75b2f7dfb4f5f7bbeea3f9cd029e91ec76828beb3bde598e63eb7c49cca848fa8b41d94788a982ba528adc83f56269dd742601f0c7f539ea5d8b905f7c1e85aa858dd4b90b622a5f73ad3c10ad26d52c3010993a162f044a0879bb15ef95357a4badd705e5bf01e5cd4a879334c67a9deffef7acf564fa6c05bc2cfb4da8f93b57c14a0e8896477cb36fe78311859a8602e45d469436de8f8a394b9d52fcf30ec0a73d19405fe17f30a4f06fd96f127df47e84ac2d95e60ad5a59d27b725683d7d7b4c598d84f30ffae9909dabe8cb949f1f51b136b5438b1548c0edcf090a310e5efc2cf95e8787ea71aa8f94d8e6de0e935be87c4e080dd444298edd4796131c01a947411b957d8c059e83d3225da5d9c4f56975d8eba43f654aeb7bcd1f2684a330b7274d97ec3ac65f0aeffab580dee1aa372fb450d7f757f0c1a3c374e4f7464da5571da6e065b56ed1b1fca4a7b0c1451bc158790eeeb7da8def39e01e3e8b7e25e818d07a8c819b5d261d5b61aae5a1349f8448f891dfa62f82cbb14abfd6bd6e9ecb0b9c4e121a0a3ac595c40dc8a4dec80b6b339009085286613ce856ade1a2557982e93c937cdcd465f72e6216e9172b542d94594dbe89051e3519451f355cbb8e1ef42eb4bf205d85ffd2a3fd0fd42073e89bfe122a46605c18eef93a316888a25decce6a5e6fd641414759b885dc0236f307f3eeb732a4f77e2346b54cd847141dc4f2c944f8fc6ca7a434b28a02787d8c6e1609284e9efe4fa11f017dadb9feb65b39aad7d404bc2c7eaa99ac70e6a4d62bf42ea47665afa997ed269cec6bedb892a6e53c2f10cfa633186cc18fbaf5946cf35674d570a543138881a1a0d34d2fab5cc0b9787e414f2790fc81f1c5b59c9259e89440444d9ac6f10782e4b231a72cb6a8c49515ec94003ce1331c9226a0a4f9bcfb134f6c4e53c40f6754dac514d84873af2f82051bea88503c4ca218080a903556722e600e608ee7c574e799b9e1ca8869532a5e2e2e4a77cc6a439a295f168859d8b64197af01fc4e9245c0c9652a56c6fb13308ff6fb83b6463a48cd905c8fae30cbe82f05ea122166a8ca5e2e7acbadb7937894f746601a9a32c5357ded11cedb57a8845bb1ba845665b6b85a35b2504e900d7a088eff332c72dbe5393857c37f532b148f74139650916e29d1ff62b25428b79ba3daae13dac0af25b90984e9955cec86734cf7efa0d25ce5dee21f187804c1ae491eafa4d1ce13126f7e47eb17bd417b4a6bfa9d6b6b7898218b0e53fa74040f4b2f7e3d60c400fe9ab28a09eec19278866b6a38ad440479f0c7d735c99695bd08311a0c573be515c28bf75e310922fdb8d94e638a38fe16fbbba16e2c9f13e950c9b1a29bd9a1199686ab60a187a73b55e8cb55e8903159777473a1a739d4a365308b46e2d719a28244c6be6bb22a28357874bbfcc5068735937b70717ffac09a8b94f788f6f26d5448163968c91a896f3c5360e43b0989b2432559127db7eb853ebc64de819a6ad48939e52f389689155cc0b1bb65bf32f6fdd33784804f54cdd5939791d62dc2d4c744859f96efb5b045e2ba36fad877c24df3041248522d2840a5b1a17f321a06bd796ee38ef9efbaadfe7cf341492c8b8631e445732e4c2db1a33ac8c63eef88f50b38ead1299ef1c6454d93e13161a036438045e27b5647f1993565afa0bb8103081bf314d8010c8c235fa0bb377ba908a7e663f427828a4ca9815ec9c51eb9dfeec53ffb53a14101ee5ecd187302174e3b1e1e73166a1468798da73ca7bfc5c2ef7f9d8557d9907cda51115475d714b98f12c4f551b6348d2cc57a4fd927e749650cc73a4075751b911f73f39bd57847b60e5a73865801fe30e4564c485a8d8870a6935f8a717d70d8fcf542fead3a16f065a258d3d37b345422b28d721167f59f136ec9e615b3b9746b35063b2d07c2d9099c55825c2497182cdd519c0ee40a8d71bb8ebc58fe7bea03aba39e7a7da3d0e8ea6f00bad3f3842713a2533a3eb15ad290f3d781ece7a40c00adb9c694c4aeae939e2304e2ccd32b67568d042aa88fa2f26b48338e08f2b0ba7a13acba290604e6642d018b006a00030e32ad687601aa6b0d7fd11083086a50aba86cd9e4b502c1de3330522cc3ccd830730df34087239c0dd990963d98700a610e426d3c11aa81d21a0ac4a84afa0e8c5bac4516344310da97ded4886ed37c60774d371300668778f103a71b3fef27a61c48459eb72e51b63a2173542048a065b75ee3293ea48f4c23e91b6e950bbd337ecedb51f2b9bb0ebad0b1fa31c75670558af6489a5010a9471ec82163f2776a68b3afdffad92ce5650c79c51077b89cec22586ba2ced887b94e1af50a7a3034b16e40fce667ad2c8e7d509b5be3f12c5aa2f33c8f0a1b3ac9a1770cf97ad1900fddd2b7ea34e94bbf1209b4182a7dcabfe23c6396d77a38c5b69be98479d939e29201bd0ed3dc1b166a88bfcfef3b67c876f7ccd212d2f4e81c87a656b1029aae663499f62ca31e297bf8fa34d6ad9bfd6903fe4c1ca3ae98049c8f49c09f985790ab083e9f11354c381bd1e133372f7396cafbbd8ededa27168dd891b6387bfb18bc7c82118985b4fb45af1677b238eac413decf29d5eaae68305420b188d5a4106f388a7af4ee46388f4ef9a61b8e429a2c6dc3dc91bb0c5fea67012b4bf976a364251c68465fd2e31133372487cabb91539f85ee6fd39522f15996931555ea971f4b1c36a34029f2c9bf906a30462e33a76034610d0a390f9ed631baa1b8d2704f1b57256d52a118906b17dbca220c5a051641c5fc8fc4280cb38200d88bb7a356746727577338f17dfc90abfb86ce4711b45d80306a757b9354f65a849b566101463d04e3226ac0411b073957292f89bd49f85cdf9e917907ba93c541f34e1c33157961a278811632991e2546a5af4f413160199a1cc69d761954107767bdf95d9452203b7189feb06ed2251c887fdc8394d52618370f29cf83a422b299611b2c2e3edc34f8d04694d3c1618a43f26bafb063aa96bc722ec937d55193aec6589d083452667ac938fb440d4554efc1c6fef644eb7608d3f4417defdadf31c40a284b522b2938c89d497cf4a57ddcffc1e5ff2a66f7ac96fcb6ea4e242ef48b7d550c8b7b01c23ae4acf5d2bfab9d30aabf98584dc4766be1d386afb6c00a7d6c7fa27e925989128b49dd89860f35f1dc5980d5cc07854e7b36c2b64b06e34cfc42abb828bccde2d8f3415d791319116b66c2990af541adba80069027a6150fa94094e9c7078c5c32cc777d67dd2a038cc0d7d7dfddcc21c5c8f06f0b34a6b40f2821957668c00c30de52357cf36d0a31e225230dfb0351d5dec4f51a718cca032c1dfda1f311d7534a080a11f10db5730377174682ad69479e92443442147a688ef004530de73e362fae15fe570540abecea6f32f250dd6c784be765efd97a113c848a89ff88822e731d7c6f29aafdf86d33b0949a8d0ae457176841e6301f04786d6ed6c950380c22784e3092e88d4a7061cb10b0f93f099cea55979fea29cfe6ab7ab2560dc6afa20e1267188df06f857d1502209ca72c695199c471563fa34d91596b614282051df1267c6320b842d2321d6698d32129d83cb0f2b41f3104e42cca4784dcbcb8ccc3ddad56a0db67e7fdd7af231b38af0a5cb61109cbb076549189514ea81b9c859c0af9cab20517a34f469fa9e662e0688795c298372bae8d8e9529c7c9597e41acb216a21d14260f95af7dced5363dac207ef823724abb80e749f8f6a2d14203a32adbbc64563c321f40a0e29adeaf5fea198232cff134c5d9ba4c1285b0b37fffffe44a0bc6e412e945ba81c982cddbf7e9417500157154fe281755a432e05796b21eaa438b3d419b056d837cbee3ad08dda6c0723266616606b5a56ebd47fa629410ca23e8071f84375bff9515ccc831a315919d7d7c9608c2f76199396a2657d9fbe011b2582e82d5b44f30eeab08dd5bdbb58eb236ac34a5a26b02955dedc7c5c5e349b3517b523dd17ee33cb6548abc9c2c791fa1395c50a7f4331093537a9d6fc0cc7a361bba778c43513406ba781ede0b5e935d2d7775562d9d99df0e49e74804f0cc754a094ab5fea3289b28d863502eeb6f50051a9af03ea7ba28dc3da6016b8b92bdb46808ff9aa5de6f3d8ac05343ce894218d5ba79b425ef536246b4288a6efe6a893b3c750529f9a57f613bdb4850f37c709f02c897db3697bd86785d65c7b3f45a57e5e2ea7ec0322899b02d2542d7fed8316ffbfc60415ce08410dfc851be4aaaf3f2837849812bf05384b498b64488213c0b5952fbc0770fe0e8ec26ab8c17d3a607b5c86c366ae6a913cb41a9b22c4546d4e4e3c9506bf5f07a5c8cd06605c842186bcc07cc386c5ffa98c0bad323fab8eba54fcaa202b4cbc75b89d13ecef445e7a8b7040c873a05bf35d647c48b66171731c3fe3812474de8b7db7b33c539baaff1239acbc4e28db09c3aaed0b4a0edd1dc2f08c57c3d073b24398d058646c902edf587abd113e06c45488dca1d3723bdd408cac9bfc22abd5c0751288beb866fd5d7edae533a9c626ee4307c0a75847d65f30bbf094667da752d6f639d58b742b358dad11eb06262e17e47986858763c5ea9d601d2acd770ee07c17b1b79734e8693b2af09c95df3a98cda7fada3c02922c802e476f89a916a14846a0943db2493101bcd4f1fd1c1bb4dcda21515249c112d62974e127881d525c7191f0d6ea4df52d29dbc86cc44877bebe7af0194648ab2d9fbac7a86373226c1a48b19e501168375e56b147da054992a6469efe322b1d51ef416653fd1172fd3537489870548b34288c7f03490ca48da16e23d890ca660192aae3eb4438a34d44da70a2774e2b37db727e01bec796d1ea6a770e5fee7290e9b1cc0b289b0d1016792f5129d3e5a901c161af9e85fecc806cf6432e41ac49469c58e92482fac0457f52a0d4b4ff6b1fefbb525472b5ee4daff6440069c56a92719f29eeaf1923c0f77d7d0cd8778f2aa94095374096314cf05806657cbd210841937c3874da7f4e71bbbb25a529d9fb9527f8f71c581d55b1c32934759bb35b8977dde325d1ac3bcd7c3730c0e29c3139e6e8f05306bc21254fc1aa139fb551bf110f9dccdb1d5f675c4da75ada013519d4cae670c039409af8e2df30913478417cbe6fd99d4b8def7bb25ffd639a09b6264eb263a0ae33654cb5ce4ba1052bfac407a0e8544ee0a3b635c3495a9e5560b2be60c51925d3269cd66d05965056fce3840f90b72bfed3ce7a8b3b61d5051d4e9565d0fcf99a8c4bed7869becac238e392a5cf7a7e0c5356227d0cc1dcdff4816329a38b686016d780754ab9f48d7aebaaa589f32e80b9e8d88493b9fb763ffb505506e3b4e614dc3ae417d17d14137285dc0d2369b5b3a6bd029443f4d2085fa32f36d02968eb6a9b65df1d1c924615f614299598ff03e91df99f36707ea63dddf8cfcfc3767135081dd2c993f0b6545aac0c40647d1dd1c25bb803d9fafe2c1e4b9cb5a9f8a1ff695dcd1427a398fcd96eaf2feecb3ffa9f2932b4597c29305e3dc85ba788c59517cefdecf96722738724d31f6a4b54a217cf17e198acb14a9d777e186d6adce318cb21aaf44bf667f76fd96e15a8be6ee5c75d5063213047d0a245d7d8d4d01c84043e83b4056489f8655c84a8b5db66633a6febffb42a76ecf80da4ae540763989870fcaace3661ba415fd5d5ac2659c9d8be6e93c47ae64f39558cc08eaf520995b0d4cdea62c0e88e8f18976c5b9ae1c19878de916d0133ab9bc593de1f78f4b81f7869af96c4a6841e2b61befae6a02a794662c0e77513f6b8536fcd0b53a41982e97b1558d818631b7f84150bd8c333200c1118cb34ab334ecd841fd7a197e19731b7e9bc8329fd2478ec8f9e19cdfe2ed7d10b93f9db8f421f9bda6d258875332d0fe3b0c41a6a9b895a7d33385e8c61d28309c9bfbdc55821aba074f4e73d2504a0a81df5b105f1dba149aec6ba39939419a6aaa1b33c15c815f63db3e5556e5f4a2d8f04f95db73f3142b83546e8abb9499ccc7ba2285de471022bf89a8bd29d0670ca52e54ce3cf732a2ba9f1f1f59fb804972dfa299c17e7ba088b3c4b5929156c7ccd152eecb055c449a0a0ee3306d7e5143812e4f8cc9c7814d02c73fe0836757004ea88be10f7bf255c8966bbea1dced41699f80333b1da558589d0cf9870033d9d55f09c3d55d649af0beb07c6d1206d796bce3ad286e40092d28376bcecbf05691ff9be98040aad37cb42a98d925a4f81d5c770c33a735b2b985e312698d5fa5fe7ff9f08e347d58d0e2ab273e5c8bf3ab25c5c841b8a99897acfda1f428674b18e24af24a6de283487f83641f0820e51ab0f6bed364f79559cb5ff71c7f7850a3284320c15e5ce84492719212f8f0a671acc08744b4326f0371039f7b02180cde2d6a85b97fb44e7a3b6966c77f144e73b1bba9d383435ea0f93bcc8b6afd76169cabc4042399aacae13a3471c23e11dcca142c051788c0c9a1bb47c49a5469f1d7bcece32348bbf43c8f118fd4b26212c943fd18d450dbbc97cb6ece6e1f734f4e527fab795ccddd0e917a0df8a68747da8bf6a9d132567ddb435f992516784bc44ded475a67a9993e35d56e3459f0708f987d2e2413dd05c426286d06c8097bce32d0adaad92e7af1766e3bb28397327168eb93fc81d09340aeee049970636cf2e3dde808a8040422b98a560109237222fbc1e53fc7ecc901d43925299779087a7d624635d5af7f90d30829a883760a85d37099256415e87cd2d9db51f5996696e6b0e004aabb0e5e057c54b17e8132ea5ab7fafbf437ad22030bae4b1a67a71ffb1bc40468903448f21bd77d068de8f57b72a71d6752728d78cb1c381f4a0126e101397aebc37ae31bfad8f5408258cf048e89898cf625ff4b3d289acbad17205b4db94f28038c6b9dd5aef322dcf6364ae18d83be0adb439361a1db9aa2cb0f0ddd1adb7d42f66323178d52c3cd788c2e46e4e61d86556687d50553cdfeb306e7e5474637f2232a9f0b3a90f70894be97ed8889faa139c100489f9469b381ccaff033c9d316db7137d78741026b65f44583dec4a9d29b3f4c890c4f8024c84138edc20c72e972c2142bd7e8acd79c7350a8b2870a921939a90e929eaf54623059b8e66167789b0b147ca9e4c34b983e7f402b1dac51b9ab07735ec0fd9c46b0448db059ef18d56b6e34c82c807d9cdd3fc258da92fefafab67c303e44dcf80a77c7055084df602d7b03425ec8ad4207bc0246a44236c1a949088f8f47de9f467a09b185e222269926ec5eb7159f33eeb838a7ef61f58008591d723b420b2b8761be71c73b55f37f794b66d36a48450e56e8d33b0f28a9b74a6e3016a9ccf0b1a1cbafee42bf23d31fc20e90edfc3dea9fef2b9026402014dd30efe753c7dfcfbb8a4a878b0fd2d9779f147ea2ab518f257454615b4eb887b09d6fca420f5a73540fb0ba3341401dd3b5de5633daaa8c61bcc967e79a155a3b7c3913c54e94a5fe6c85c753","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
