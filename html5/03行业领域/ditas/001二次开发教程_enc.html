<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6c12a0f2e6107ce0a6ac99459e3c19e75f2364bcb7616a54532c9cbaa7477efdcbd92032921c0e236923dff33d95f831d8525c46e50b59c9f20127c6cbad8ecb961772c00de0f8dc59e5f615acfa317455187452105d544f7e4581223c23a7eab030c757f0311fbb4d9a46550468f9381c5feb2fb0d53cba8f465e2628fa35daa3fe98047c54127d03d8367f1ac162ca7c9d1c98008c07f6a9e7ec4bf287db7542fbe46caaa9fded266d9bb13149bdf88a404deb7f8264963fe7a5c2b0fb23284334f026befa8f7a7df8b27c28caabf030dd017cd29b8f802824e77959b3f47848066461ad9c230c8029f953d83e4d50587c21e73d53281094eeae71324866cfef741f1d234f4a553b9dbf7fbdc59c0fc7b5101ff56c2a595ed2037a699aab503627754a9aad60f571a95e9eec6adcc9f6974c4bc5012b8ba153846d0f2702da38ecbb493759aac811d1b26094c018bef3e051f11f045617a5622ab0e1398bae83fb664b03d60bc306198e1b9956757ba624f6a3a14b3af3b3121d12f3d3ee5fa1145d7ec9c835a69b419996540cb5a939c53f2066a3458699a1045ba8f61c4c588d4a4498bdf94856903942410a3f937b11258ff650f598ac249b34d5b40dc71e0c5de24b1a622a8063720859e1774f762c5c83dca684aa8cad33c4dccad9d9fe959ce40ec612f0014f33a211328b1817826f592a7a14daee6a23c3495c3e0266f595086d47233ebd04632d2e54b0f9a8906b792eca6317b65801826878a6708deed153e9dcd73f135d24ad558b0c4fbb709e51bc225fd598b760a94e6718e2d6c19910fa0560d94982c2d198e9570757675d2c7d710f9e64a381decb79579d246fa26d11f79a426d13fd864161ff590140f9535ba9ecae75129b94de165aafefd03194e6a099551ff74c80133227daa91126a16867f286535e5d664f77fe2a6b1aa90d2517c9b4c10ac0d313e568bbac97623cb94eb57de99baabe2a0b65be60ffb678e6faa44b5d167b58b577d7740af9d920e24a1f93b47bade7030503ceca0a20db29defceede09ce29404fa7704579051b31a06344c699b80a8c3c30ab4bf446c09dc5cc4cc6cf0fbb9275928cfc2c65d5d572982bde72c104e4db5f59643f06f544eb9c8f300861a47a57de22a6ee0128d429828af1012891404e901be74bd51a260272f9cb4db719efb168eaf19c69e65719101f70826694cf96817f22778823c76505f0a17478a8d3af0f76326abbc9f4c4cf2ec508904d4f333d546afc0734e42bc91e63c35fd7dd9a7e0385bc788cdfb2acada5ab6d508c87039f7d018ab11cfe0ad1dd4d374553558ef266a7dcdc8432a879ee76c1c6dbfc0ee247cc6fe8f5c25a5ba24bf0da8118215299133ea3ca6174aaa48df48ba7e62d80f5a9605794c2d02aa52213b0362d935c11f383c3dcbbc035295db9f2ea4ef626434b5f5d061ef723fb4b33922c6801e7f559c5c7cf9e428730a53e8c51628751fd4bbe5fd0de8140edefbafdaff34a1df2614957d0950c4bc17c828cedc75c55cb5f67109841cf019c725ee216e373e4f19c2a548f94341630c1703d5261bf18989e2ca5e98073eb4f218fc56bce5d6fb0f62135600b011cbf2bc55dba1cac9ef061611392f214b3aebe1679de418611ef3e805359db12d93a704391dbaf5588a324734d02c937e4c08201da0cf04ce730cd142f8ac71c666b9a749562657e40755cfdeac4beaa0899e5f0d4836af196e2953246cee808d56a8fe1f6effcb61a0c63ebb09a362adac1260fff21ddb5bccfa3c8ba1f2702b44f167ed59c7d5a0423e6cde167197b63cc4e7dbf3cba846f4a8c58b725b00e756f35743f9b929a4d46b77f7656267b3d56df9810c7f142cb2f5fc02601ff423cb1977b92fcd9d245e51e6deaf218dc789ce0955ad65399f39f34a09b5708195362ee3f6e4c5fd671b8c562b9c4acdeae33674b8dd0bf0474331dc3980f2a22e480824978ba921d3685354a637e9747d1c8671d01005913cbc46527e16dd8c2e3d3b683e055291272080e4556009ecc6a24dfadd6a01400e624c074bcb417de7416a0326ba28ed5b0479e3e90db524606ca694bf9d5909e680188941038a519d89f43cba5a0489bb345cfe1e52e9bbb37fefe40cbe88c35c1f8c4b9e4a2a79784c6f5f00ce0a0c5959a10cbd08905f2ba5503be8c7c6efa5f6242cd8c7ce66390193cc73801d6b5afe8a33b8ddb6402ef2755ed5a0155757b30b5477885379053d43b9f8deab5edf06c796b515748f75ecb8d8a4ff77067645e40d1c88698fca5d8ab27d810f49aec355b5b5a9c4df1fdd60957db922f6cde903d63ba582ae65a258cacea32cfb4c8bbc98624be894b9eb943d570704f33debfc5b7646ba8276cfd713fcd7fdd9ec9bb9df393486700b47174cb3234a34f27c0cb1d41d0fce67eca54d52352d1e38ba298dd16b555fa48439533cd20a0a8386039416e143d9dbad5a62d75fc26bc0055e4973af336b83be2671cfdbf134a963372e5fb312f2b5fad68b160c8812b5c4e0dc866a8e6025e16bd41d6d4825cb244751d19badcc7a41106f9a04cc4ab0865821d0df45aaf872d2d6f4da60de44cc3298626840bbb90891d1deaa2d879cd2cb2081367af9134234615e1db8d64c5af82a53b9e81cb97016b7707bd0f2ec2af894a8186625eba7aa5471f696f575594a022b878f765ca236b693e3d33d23435dc04a4695b2f948788e59e67c280981d4af7baa867c3a083fa257d621df339ab0aec3bba1d566999b64bcba7fc14108306df4419b23d16a68caf6d6c88b522c51d271253378d5426330cd6810c632f64bd7881c589177d05dc21d33115a26f8b280b049d8b63657fa5f6075e35e7c36f48b2496169ead8588334b6b58f209eb01f9b7b157dc851c4cc42e118fa6a2bd2c6820d73b6cd0405d70f7c18a20ca1df15c65c97e09fb00ec1489e8ff25e4a719f40824eec10f0158aba88ce284af69311a4901eaacfa98530a7a72ac85a487d3575894cd8863ee4c5cd33c0eb16c38f9388f74eb3aeb9b57c11b22dc50a9e48471b03339206852b84b6a1a8b926b461c7eb0e75e796380ee15947a4ff7ff32dd3977d243ffc4ace8bf9c13c14f1b27b477f408c68a16322fa6e74bf1a6df86fe32cd74ec951ee134c3708e3b5a890582c02f18fe18142addb1e3863e16b9d50ca715ea68dd3e479f7564a45c42437621dccd3b50eeb741e00fa42b624ab46e41e8558cab83a9421c404b25cb261e5d34ca3a693bb587cbdc11438bb745ede937ecbd6b0ed6c78707f94b36e4786994c949b8ec975784ad37d900911c8c9be88f49d16f6b6b06833fff9727ae3fc745fae39af49bdd53a846a52e2ba36796afbf730a4e78ffb0eaa6a8e270becb9fc24a147bb55e7d55446194a064144c1abb0e1f7497862c3c6c397a58c3162c8e6623c250bfcf0d25390600eb8c72e90ab95948ef09e5531428f45b40f0bfe9befaa56828965091e4f314cc2ba17c199fe448082a733368744cf2dcbe9da91c9d88e07a7e714daedff1b2c756b6d466e0224afc179840d807adebbdd0d91f9a25d581d0d55d6ba2bf91169f6f6ff584c71d7faf26059d8dbb6024e7b24e2a83ec92c2022ab8c6c58d4b84d25c8529490018eb22aee5bd044785ea568414a7922e1ec0aba7fcc8d931727f9add630e4589ac6b4f1fb6ea532aa77e85093bd97e8621caeee33cdbf92c039f55a01f8769c8225e133a8a802cf083a6ce944f7b663185abacbf12e0dbc8d78a289fcc25dc4b50713ced9d1e915442e1eadb1c63ed31c2682a8bbc7e711f89403f55cb5eea151beac5058164e0d485c8ef29165a07b5066c59b0bc29e95a31c1ce3a3ea9c4c64e27f303c1839ec259ef73f6f05b717938d86deeb049f570a6ec5970ecf8e88d57ea96f84fb60b1328615de2c9cdd65c9f0bcdef5426250c6f50f6e5dc5d8d242b1fcb6f93877952c16116669270277c6a41503a58effceb3af718e3a6852a8b4cb9b374a97a5ebaaeb3c0b1a0f9bf88d205fdeafae915825369522d983c0e39f813594f920a9793aa8885bbaface5580fb5b24a9eb07a69d40fb72df22282182800cdf28e6d0ab4e619acaff40f143f72abbb6c07a0d7ba9ba0f8123200eb3c4fd79e13dd16f20faf9e0cdca9bd910d51bb01c47bc36c29103e15e7ea17db7d876556f00edbdd9c4e052d9dc1041ac28a67b2da61ac2b58c327684cad2379b40cad020a4a2dec8dc5dc0c76f4cd1deb4e9047ae2561cfd0675e62c55537a41aac1005c750f90803790a3db8db63592a8d44d04d5eb6dd7ea7a84068a34f7553de0bfcd666d10e5551ad213fa9e7d1df75b10aef2da420bad850babad24d23465be1236f51a1a83359addd66dbbd69c10d21bb01110e830f97f787e954c15bc1005bc4c3f809fc89f7543d694b504cf0727b2b76c9fba903b832c297f6d02d2c23b48a12a8b6571e0c7d4551819128d996fe9ca2e1aaba3ca47ea6d3a57b9fafee48dc0ca4cdafb38eca7eec3c2ca4db2a2cec4d310717da18edc462224234ef2229e086757c2c4e30c8fdf4f4e266cba2bbbaf28297d1e23cc4887e2cd10fdc5459378353c1cc4760691896ed2bdc52f3fc1d617e3089c936adc37a3196ef0c9335d8fa1e9f489c6a34f2cfdc24ca1e93ec7982e1c4f9de3962203dcdbe788e977b92b8c5c9460d77c6f45344f9b0439d20be90be00cf05167d424d33a88b74ff8d30e9dac7c7c90f09f6f94491b11ab62bbfb8219ad3801f18870eddb470846b7934627fff8af79a14369ed8c719cd037cde1c8e88eca5939f3dd689f86367c30d7fc7a5e12e02b4e8b1f4427d887bdb651885d7f8a57ead6c0bf9ca25dcd637f73116c0e74bd91ac74429caa3bee685ffc22eaef1ad7ff96c2a3b0f06e2994736a6a7eaa4487b3cfa50f355bb5f993b0f62a2bf95331f9ab20ee67e825d1d84e5bb5e247e7dfa1b25c714a464220744d5f6a634aaf722bf69c742bd1cb8412d8d5cea9aa6190d61bc1f9e6a9e57e454b505e11b6be7de2c4701779afaa08c41a17d0c29b95111470eeb6e464a101cae53de597cc7b4993da3437f0060b16f47eecec8edb1c125c7450108db9ef03bdda16ae6f99c64a5babac76fa8e3b9882c99dbae66c4563575ec6185e8107bb96c6c03bab9a686783dd66ced6e218dda3501be25899f9a6a1f40f6291d59d5f61fb106525698aeb9829bba23b1f99e3baa848fa2a17b45f1cef9c812226d5649cd22a2e38644ae0f2bacea226c8a6da57374f3d409e5e145a189b6fca90a6f40e6c9e80948b9f8faea045d5660149d8b954ef284179fc42cd6feba276d99c3e1ed96f35d0d7c2cabe4621ddcb5aed1fbb06fa1d140cb5cc95e7f6592c8817ab70d49beece77acf7df9b62e2cd0c6d70f71dc6192a41d1313508868057d8900336f066667656aa14ec3353832d45031d44caf9043759fd6674bb423cdb7b3eaaed97bcf38fa72a83d22f30076bbfcfdb03f5577cca26bf431de240bf03afa3d2bd4f4f88f2e05a11a98162018e0f02587a297379fa923447c3b194f67daad6bf485bd481f53b75c1b6c3d2e9b7085cf94534d2edb4e21b8af9d19b3f9ab242082dc1a9d7efe0942a7b2f23827e07db016c85c30082947bc5446fb695f7766322e8d97ba1ced9af124ca21afe291e6bdc1c7198845c4849da6886f273eb0864d737cab3286b0d94c630e70de64544da03730d5c4bce4e526ac914459b93ddf43cb8808b216da336f7ac036ff4bd85b0f4ad13010f5aaf06e7565ce84c2bbbfa9f438d765ba71937d9b69763ca4b7abd128bc5d6cbb995880124486e2a27d32e3931df3ea870663f7a3cda2c0dd18726e24fc913dc228fe072f3ef5941bddb37ecb6b52ba234e3cfa377308516d7b161882421a9deb9c90ac712d8002bec8cda508f8a3b1b5b5bd018bc9e2f822ef2ec9f5e83251e81d045f95a3382652a2494bb2c6077dda758e7b083805d0bc291548dc8b919b1366591217b4f96f708f2da6fac59b1977022cf1370a97b551b4cf9a1a4eb6fc86d904fca8b4464ae91b7600d9fde60ed3eeda00e525cde2746fa17095c0e1cacd112b2548dde948a23886d1a5453cdb81c28877ab41be058857edaa5402a2836b4d473646a7fe2bbc1d5694f78c1ae2bd3d92ef0212c4fcf07bef329d638fdd50b525e2696eda68141f9861278eba2a76188ed2f3812a69c81559ff7ac1d17fd59531b38e7f85d3d8b17e21b9956489dde71b6495ac0e240c62fa3930af3d30bef2c55b6aab5bd8fc0ea6decfa768344de6592e6e2bcb4fddb084689babbb4fe435661853f0b40492e1f4c684757b8a716f5d5032ba0e3422c824d30fe1d79a2b7586c0e3542703ed3512314c4780881a497b043f6f7a0d96fc50d55d4bb2ca2bbc659fdfcfbbafe27da42c6868f92176de56bd1fa19a4d6b3a4c0234ab75bbbe0b1bd78d616ca85e5c7d6d9bfb6ebf6c151b9361350657c831671c1d910ec22c9124220f8b8f4bd476abdcb9e8817133724ec0c64a1bebce8e1e2d4100e92fce3ea86746af951fd17f189a22aff9476aa8062d515a01c6176fcb7116c44776ccf4a6ea75425c6b1dc056f63d17cb4a725737dc5896ec36c890e3985a134bb24a2ed98165e6408f5b43606f7b25989ed5025ca12e511bb6334c2abb58e3cdcdc1466598f98e196fdb3716b6402855205ef0d350320a31287e87372286d3d42c84b6bfccce90c890c54a20cdb9c8eefcc2a32298d3c4b42d4dd59c56f1d0b3122306d9a5af00bfc5153fca2bd7f3f643401824f8e23950aa1ff2fa71b989878cc7cd1922580e16c2ff14bbb12cbbcdb65c32dcdb9b84c2fb08ef20855ed8808baa6708582e5d997b10d3ca980a3fb85ae8241a06d6b798ad6d92094e7fd1803a055a62f80c324d86bc8281b07ea347c20a6c740a48b995999125f1b47baa7d5c389afdb9d3e7489884ef7b77663bbbd51570df160b09c656b2a675b4130c619be6e08fcb05cf7007f3a124780b2a137618cb34bd0249bfe4166d934cbc15e38a22fbfedbc71bd7c6e43c678d4d5027326e9520f4ec6b139e94ba6d1c9b90dee034f0be4b3b114249b83b9fb69ba6c6656598427f60ea917928884f79656b9cf240854aa913a0dce9a154f41f3e483b33cc165ece3178f4182218370ce75d622c7912585ec5672fe60aea3162f080c30e1b0185d8722b0d8a46f05c317e5c5c52c6edf1ec6083c6e75f06700c4e81b0df6caa0d0ee7e27f3d2e083537cc7dc890d783c9ee703c15871a9d419e298ddc390bcfa36b046aab6d86352be768e8e99341b953a3c4a34929b18bc8f2d0d26ad147ccd2d5a1a2ef92a1bdcf9808b139da8e51457fe0bb20f9334ed9227e1e0097e27ab12cd6eec134497e9357ec65bb1158617d9f9b5d327b457ece8594fa52db5bc866189dac7c8d8c76df04d595c766bb07361587793e6ead60f5fc3f936a717119fb33957a53f8c0c2719bb9fa1971a6750c3be564c3362cfaaf132b6a8cece330362085660e3cf103f27ffca8e97c5d40ff5de4240de73a74dd5075f525899344edefccba185a9249595c7aa6f3b938f810e2a3416737af6e0ad00cd6b675cba9c9da3898c7b6ff2b70972a1a03cca612fca66184ecc74b9ae6b4156b6996d53df07d7d8e7bf0c8ad6e482470c0ca638071754a167b2d99b4701c9a00dff4a6a9a9633c77ceee6d349fee3d11d4177914ec283593ac262cfb1289a02d3d9c1180818a428c9d4b5a49117ec78b57d61802877b1583b53313cdf6687d52e5781c2b63101fa8f6218a2dcde1b108802de7e9c4dcc26d20f081b137bebccaa6c169af8c2d2e70f664e449a081c34e556682a680535b8c0e13c6d7b68b0c83540fa3ae3f75834361d4472aea454125b9bb60d1e275c1c2b4b412e2e6986ce27be479b2a7b37143617c09893ed93b6e7a6e888ff99ec50b457af9f550592c8203aad94860affaa8e231ab957e9554bdeff79451c961773d61024181eafe865d59f1549fa42e7d7a187a98dae50578568eb46d730c1ac870d19c9e5f3f7780dbb01b02b17cb351c3cb1ae62299ac81420738ec24ddb3ec9c988550ab4348b60a7d52abb68f66299946521259ca229badeb64d188f37f8caaf2306de42c4cd12294352a1df732cf377999f75c1686a76b70697cfbd2dcd774d15dbdf7562f53bef919a6670f00497a4406ecac12966350d324ab97dd73c9a05266417f9b495202fecbbb42c68626cf2b939f768f0de6e27477e365ff1b815ae4e9485670e581790f511b53f9e4f5c4c75bbd525e4b68a6d0568737c788a99d9a70f07840e4f01978b1ec3838e0d57d64381d36b40e6c877a2a360ce8ea28f26b126373610d77a52a813a96a79046160021204e686b4bb5be69dafbec43346e96ee77e4ba365b6831f61e8944f4f7588e6f1f8f9bd60e59d73ef0421c52be44d5357ef372c2d1f39609ca757b1cfe1bbe48e184cc1bfe438c3120daabf2b14b17f632d13a274ce36818c3752f1bdabd4672ec359ca0979f7b69e936889ac59944152489212ca12425308604fe42cf77d9fb7dc60f9d8b770ba9b0ea6a5e8c11bd1cdb6640512db61cb71eabf0594006b47736113584101b1fe1e9636b952440d9142eec2b0e791703f6476c0c94ac571a020ff657d4255e45b42589bfcc08b604e5555135beb6c077616ae0f5d55635e4e09e1a2c7aae0d46725740f7f304c181a00a95b7331d363b1de10147ef2d2684f84cfee229017ed7b1931e6f11f86b9dfdde1c83172305e8ded6fc98b9c24ad4a7479366a431c4fe876e6c33620b7319659c3966bca3c277e1efece93c9db7c87ef0ea6600677680da78a2afdf1b5a5ebd5ebda3f602d8d899cdaff3f99d26dc12b3afe98b29181a0d2a64dc90caaea0e6317a1dd93469994114eb83439741a9d1524b213e897b0504c3014796c8cb0f1d681a715001d8b2431a8c0dfa27eea6fb13b0d8c81e39872319591bc5df29ae1f83d680b0690dcfafd59e90cbd507e4c60efd79df229868b3df8716b260ea33780e2297e13c0fbf9f0eb1c964c4a05fdfcd5a099702e7a76a0829dd8eba2886c8d2cce6559a7bc09123dabaeb525f1b2c526aa8fd183e1f52018bb01171142e2d20f4d41ca9ea1cffba3345f3f91dcc6c2a52464c873ea2029957f6eea7500d396e7d2817658f4c5e2a26a9b4fde513fdb5fdc12c45469bda06d9b1f4637c32e8811511f9ddcbed8ded391c8281a5a9e500421cfcacecfd77fb00e80c330e1f7718089cc6b725c7134fd729e3934444d1a574c7af0fe4f3d185cc4d157ad732e2eaffd60beb6fb3739a1c539233f6f94773a58e52c5552e5cc6dfa921f36494429d7de90db77a3c4dff31f80458959ca6a1f463aa9f077f852535133046820bd41dcf29da2188890d042e4a6e42bfc8e8d1bdacd85c7536c009816895c7740229a68589d874d5c511d2eecff122fe9738b2bc2326cfd558067ca3f2e7e398f0269450ac078c94bf368919f6c336061d75d7921c6bbb2b92745359d48e4584f9ec46ca0ddae29cdbfc8149aa3da7ed616ff0d13865f4f0570945922b6139a07e080dfc5d25fe596ada02374dc70a380130a66b3af1ebd08f528546214859d088cea97398e10190bba7aa55c309d386a903286f08122431a3512c6f55c303247ae378b74013bcd5d30482f39827b097c65d45e86ed95f22165655eac2068ad667eaec76778678015fc36455a4b2cd45427af996087ffd623a2b051a639dd461fd68b7332f960e95e341099342f5a3166f9ab8cc65e721a2c9c94345360733f424944ae09401706d4ecf16ee920b211d16d5cfbb8babf38e65e502da170a47b9d02a9144dcbf02702db8238856722ae1be5938635ee91cb09df834b4b0cfddaf26d4e3758a8effeef5daebdfa3a7747be24cc10d23182ecd28f5ab81f535b927516281c254a2e521710d515b5a2398ef7d4b4179bf072f349810300dd990f85156e11cff29a55d8d399e751791f5b374e1174ee91072bdb59185a61b957521c879336fbca831edf5d2848d49933b2235a73a34ae072e361f2e2103153e5c14b4b2c811e1ff991dea47b44e7488c8150480c531a423346aa18e3370b49fce2bd021dd80331315d787e0d70bbc4e9556f83ab2f17f33effae8809684fa1f4c0a9df628e38dbb7fc0978f405276b462100df1192620ae60c8c0dda99802a7cae946659beca196f7752590a2a3a3b696f647dc047c7ead3cce53e677da06bb18cff799ba1e187450efeb33ba38f55273eee2aa15ec83b212a792fa19ed553d594edc597ab4f524c020a9f4e265df8bdc2e0cdbfbad09e70637853cecce7040104e9598c061360720422dd6d42060353b64d899c8d6c8dd60f834834c11bd5388eeaf1c8f8159141a2ef6a1e1a06c75af2447b8add72b5826306c579d23b0eb6b751239319e0fd35686efa624af5b1b14be1eb8120cf78f8b54d895fcb0a08eaed076ac30ed1703d1ff0172721b47a6dda963e0b13d740c7c57a7915819b240a89e2258a39d6c9ec7fd29fbe99fca6d7a51d9fab78dce6792d0785a0b8647e4741caf27ba803bb012d35eeb92153842383d916791aa219f988f1756f4a67694960e1acc2ff85a925575651f46d5546c6b1d66f78be84266f661f4643c68639f271731c207138fe16a6066d58b20f3f32945c925621636a587d0fbff23e82eb7fe0b01ad09779e47d9e33e9d4edd42ce37ef4785912aceb92dc2379b58d774bf00b416e6ca93ecde7dee74abd5f2ddf5fd69a71d7069c709cf7fa9cd709463ab82191383398d5ed6203dc977ea262bc68577a125a77291970db3705d2c2bb6b758669799d3d082ccb8afcc58eeb01ab0b344e3023aed40b50a3e0b11e6476b9da2935402f1841d5f97aa12a717613916b1cb1ef59f4c914272ed7b46de0d325daff241916466db6303df4b7a9d550f8103c62cb3f02d12b9a5ff799f27f125a652d142d6dda5f48613c20515800f19baff265d467cec867e3a70c237d30b54165921ef0df4214e4855276dcb6f3c37461315398acc7c152715aa20fbe15d9839ea7a8777d48d94d98ba6a7d69660b6440f85646ac4f7c4af4f5acf20afb5e74ec1e2eaf6b6f7e809a3277c0cd019d4e3da3922e716a4567998eaf9dee79924381f333665fb50f228a876d9110f1bcdc7f2533e46f818d134be41847b9301250af3f43a6e208bd05f8df375ede0ff7c16b8f86989b2d5e8a30465555f88aa29f55db68556e77033693d1d35b2bf040cf06f4368e7b29c3f0e6832028468bed8cefa88045ce85e379ba3776a5253a722a84016932294319f0141dd469aa3128ca096ac3ada98b741d55f409a02107baacf1ae698ce9d1e4693403a5e1e0fa132d43e44f80203fda27587f5790ac9863781c519272162a67e19be818d7da04e4b048b927eb9076082391f9911e73eb87f07f52d9c1ea6a7adf3352631f02de547d34376fc7d146a4bff19b0afa0fd973dc8cc060089994ae8acdc5b8627ef4acc40ba02317dc8ee391a4cd5f1f5a0bfaf0eeed1e415095b3e8698a68cb0289240c41879a8e9ed56f6974df65377eb0b67696088d2cd9ab8ecef206d5baceb0e5b0b020964a0e4a40d47e8195f744ad64f64d81dab5d3fda0b9d1934d290cb28db659a6abff4d72d43be2c2bf4dfd45072462792fc09236c848ca3842059f6e20ba8811840491297d66b04245e4450991b987e1128778675980a388237172d1b5d801c35a3ccc1bfc3ae6214d789b3dedc28ccd8d736cd2a56c4bb9b6603dc8593556f6fc134d13c75a0e7e51b8b6d6297a5de0afeda86fa9d447c55cf6923aeb1d164b9e0fe60955775fc893a50db489be047132e0b33a10a0bc9e061f0baa8e2b5755f920189c2686b111e7cd7796233da312f609a931ab8d8d6e0d7d2720a2ac120fafe30a558c0d4558380499a9530c8b836107c0ebf8cc4bf692883134d896723f2ca5cd95c76e4a3d3e06579a3965b01ceae90cca315da90971d04dde461adf91f2fbff4f292e16210989d0970b626d2127084c261169b81d8b58ee8fd184e4e839a0cc06ba998072f821fa1ff5c47ab1f267aab5bebabe46ddf6e090473ed7fba306393c974352c668c836285512031cf65092f8056e45f84e023931149d78c100331246fe13281a5e651c6eb6c6e0a119ac280d8846c3a528e06fba228312232fcbb3cb6fe0706d5a00253fe577cb28e2aed5a175188c911886bed62f44ff94fe3da511037d88f7167162cf4e1464cb837b359df9902175baa972193a8f11d91fe3f3ce09d6a485aca059d0eb32a5b54bb08e56c3e64c95c24753cd7bffa270435fde6e167af3aee402e1d2a72d2de018b8ebbd96249396e8ce223909ec3308948c930c2424955187e5ce2941dbf24eb0d4b1213a401a99f3d04c84e169891fcbe36072e1bca06b137702eec79404175491f87c4d1cdfa527cdd6f0231e12a1d37141975adc7bf0d7e254d503f7224479cc33fc2705b5b321d112046d5bd60b2b6124287e46d03d320a59c9eb2c0138e9ad2ff305b9e4cfc7f95194753e4178601051f3af0c1eefbf16f43c8ef1b8ffa6692aac528708f7edf82165e21a305c70ab1f6885a5374c776dcc0ffba1201876142f25442458da226ecd89206747ca4744562f02011aa90ea5d2223f5cb9bd6ada1e748a17d0035b1830fa307bb588ed0e8b14a0b337a427623f59d38ee9f04f13a559e2198d111ca657d17601842f85589252435ceab500928a2ccc0676f973500438d9fdaa5b4c03d4e8eec2a6cf73589e33f606b0d825ac4407ad5d48a15f7eb4415b68692bae54defdb20705767507d22fb836af9430c0556ca37764a41cc1c2f7ed1cd4a2713e81bf34022c04c5f308ad88d07e1672bdabd5bc11959fc06dadec47eac682b23ccc4d6a359356c27546728aeab757c70ebe721d5c769dea95ca4d37860e5bb117c4913253c0ffe8177143373cab40075f71e056d006c838ea9019cf38f0382bd120b953b29ed23aeff0924fb20031bdc9c65a04318b2159cf6621d7222fa966caed8788128149109e7b43f9f939dcf82ebb8722ee7fb835eabaa28bc533d47ae20fe6b52b33c350642d8897c6534707b537171bd6e8f66b6a80c5f93c3c6602b548133499ae61f91b33a5d71aa74f06579c94862efce086b3d01df84603019adb8ff2fcfa3f439d534022258c03f1944d829b2a1f6ba9f83971d2a517691adce8d6b64eaf901395d58a8e96164b5febdadd4ceda4f2e3d1bd2921cce0291321a267a3e5de4d6611c8290d53b377f08d63ab98f3c2d6d779d1ee1a3fdaba2551e3ff33ec396a28536f76e11cf928722b74b8e7c0072ce14d1ceda187b6f1cec29a5e08ed19d73253352c70a75fa400503af0e21c40447389b01359676736dd906fef4acbcd35d056c6fe388a4b99f5335c998199da1e717a21000a50d89dec28ae36148e413f45c0807c6a5f1f810039b952d6ad2a422d8ddd420e3ca8238e4bb20adc8d0af41e08c04ef737941a19f09bde5e7ff2f4b70c7cb0ede6985f11ea7e0424afedcb21c2d37e8f3498a16a01bc7dd2fb88d5cdb9791fbd8ffab583cff8bcd87dd89fd983cc82a2dfec2fe06acbe0d2bc405ece4cbee6ad2e9cc9105bb404c66f48bd2052dca26101b87d42f36f7abf2e740a2d5734673ce423ecad7537790618cd5e2fbab8e86fb03551d617f0a1dce3dcbedcf35de4009c571460bfc0ae19c6141d195a9cb2c0f733ae4698366ac827317b51142cbccb2ad18112f21b512f11352d90978ba4065b62744a4c93a05fe53ce63d64bbc6f67c3b0323ebb517a9830301b2dac7136cf206e01a56b4f80bb51466da4790ab6598135f8d936a9c6896b8d19252d03d6afa490681e98fd9c08454e61a68f2532765579cb7db684e4450be87abd912eea6f6b9be1db1111a0c51659bba471dd2705bd782389559e9cb4de593ee6b5c4d670b913ed8eba0dcb92188617bf5d4108d563e8ca0e7b2cbe16866e80834e27bb586183d325be2ae8b68cff924853c85031829c506756878c026281f17b7169c29dc9c095fe876ac59a878fdaff078caa666cb3f3a5c08af4392594814bc6e8c6a2251daeded8779ed7a8d6dea889c008a6d1e5eda4cff4cd18abafda9197d9a3d9a424a992286ce6c105f1c6c85cb5ad93bfab1f817a21e2c39a24ea2d446a68d1e4ffa786565dbed9df2232b2cf010bc20160681d18e37ae5de91343d8cf6007e83e485c7a2b414fe17dda1f9f2918f24f9aaa17359138dc8c4a8a56859318ba9e5ee2e5750f043b2fc94ff9a07d162dd4c464ff729ef01ffcbef51949137b860f2d935524610f64b418d14ce169c3e69e175e90ea0244515ac273568680edfe2d767dba362567b5f04d58e98526c3611d91bfcc8f98fcb3b1ebd1dab555d53b2cb3fadbebc889c39a840b4966f0d50afa2215697b68be0b45724e03dd10efab1ac845a171c8519d30a0e49c9c4c6f115e3945e4aa323ccc2851b2d34b2f343175111369b15cead84c18e1d6ec0636a8dcb346ae757d494d0eee553f159004a9f7f83e6e7d3a02ba2ba4764a2c2ad00ea1bdfa9e34eb2f93560c1418032564bb563be8d1c112e6bf03d9a23067d1f60d060e370b5c93aa36122728cdb7f7756cd78b8d8b2ecc96c16ce6effca6137f53f1ffd6c9f0a754f01e3e6c12450a0f49d04e47d8a2a2593717edec4a7e28a5df1486be6aefb9dedf092975385ee3b193056d9030a592295c58582548583689147eb0b99e91107506508e956bf5b95367f636cbfb041fd32bb5f20a04b97e435330a2c206b68206a4b2d89051a56bc3bdbfb32cfd9776d2164f0fd7e60232c19be0d2e31f9a88a33c6dec050c90871d5db132a7c1f65e3be44393aa7d652929b2ce3ffc7e5fb12d2dca53520c606bd8a997691a70738286c278b0102f00c5f2af5a1c7d50a076fd6c722f28dec2b92b50927c02da258da3942cf2228f8519d6a873043dce184e874480fee319e7b3f2f23d2b101d2255d7a3f54d9bd9df9867350921694d0ae3e92c3020fefc85dbac9f1ad9feb7f7f88f58fe87a05cd6a8b513a891c721fb0db15d6c85bac12f087fce6ea4afe92cc4cac0219e6f58993e5f61076b90149428e41dcc1a3d472ed3dd4dbad0c36bf69ab47eab6a51b6705f108dbc800a84bc85a06c05629321b1cd7a89e99d97669b1385383d2591343b22760af7efc752a26413959e6428335dbc20d52631cc2a18feab8d01be46cd4962a826dd7362d48afc21b9adfa0d7888f91770f74ca022fdc3309457d568a6f93ff57d93d62bece1a2ceb1779bb06177bcb876abd5bb0b70729a44edd8b800a5cc784e5ac3ed8a9b9a1397db6e7011a776948625782b4da0f20853ed963a9359de938df9e6ef36909054b9ba72107695119bf0276e28335806afef35c9b64e34fd14fccb6fbb4cb10165508d08ffa7cc30ade64d505403dec594c9542a64994d9cbb2aa1054f3ec824a463f54a2a368f3c1422a3616c3f5dc1d7911bec8e5859ced2f40fc66cf50c3f0fc7ddcf9e49f3c9a82d32352f50006b4ee07499c986587e0fb46448d52310cc73eb56bdd567bef5ac3cce6171c3ac775e4c6ef8da8f4cb37ec40c8e397191b39f2810e44a46abd6c7d0dbd7a6785cca4bcfc7a276ecca20896ebdcde87f3d03f3e4c1624c80d812f2821cb4c5bc3706d2e6f52f45fa39a6dbbf31d84bbf71d0304d66dfacb1b86ac2fa4c4cafeab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
