<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c8cd68b55180728e879ba105fe6185037908497e9135cb5ddfb685c5f576bcbe2ed0be3d6947b569f698410bd6753b35b20589c4a8948d58f5dce05e96c4743e7c088639c3a4ae046c3476d660138aeed5adf502b69b2f35163bc0af9fed6ee123b9f466ab2025497c712962df6ed15a835fbcd113d1f2a6a79e857aa2503e7fc05fa1137a4c1e1ed949315a1cb636bc27edf979b818e2e87d38f862bae3333ac0b3aa7a4ef755b63fe94b5984b61b9f7ec60325d406cc2d24317d380b9000e095ffb8ba482d6cb65f87ae6123afc97f593206a81c5c6bffac81d6caeec83f0feb491767515923b71ae6a770e912fdf8af47c4f255f06a6e515822b026a72bf3e2d83fc4b4ac34fd7e2d9005e6a40c3475ef03de23f3c140f3101a5eb79c1cd5c3b281213591cfdce1f6f198c6d13e0499c422d1b2e879b544fc379e2de0211726359985ae77a57f95bd456da92bbbc73461bd7dd7b0fdab7cd29360fba988c31f522a8664fd66b3083b27549f3d8aaa904b429bddd8702d95b9a1ae08e28cf3adbd993dda4ca411bea437db63f8b7ea9e384fc49445ae50b44ab9a2e0f9f07f4e789892cdafccd563935efb81724068f9f87786aa48e02c674a693871f13ae2dfbd025ef031a3a06f3c4f8c508f52c803cec00b9d67de091a99ce07802ebaa2094334c9faaa2b1cefa44f37b563e9d7efc36398112ef7671363b21be236db24ed01115a668d9b856298a98f17dde97454acf3b9fec9830e0c0e0d90b0ff8d24059a6c406ba1ee9d66d7823595cf806276d465b5cde09bc0b2c9b7cb38d75f6afb7c2c02d3b1c530e42ba1a7e9095957e4ddd7987726219426c1018cd90f7fa877ed36296bb7af8374b669c65b29d84435c07ff27384c647f6a402ecb63ef0d99719467e8c19acd4516964383dea2028e0c65d62dc069112e2366ec1608c6911f65e4692a0f59eedd23085ec5665b0f4f923bc602ea781b07ccc5f5116c2847c645e0ee02f6c2de43aa440c40d1bc0011e8bb30ba7fcf84aad64279fd16b3e2398b73de3c4ae806ffe06da1ae80cd9eef6ca6cd24514facb44fe06c4ab4d2cb802b0580babf4c2279b4581fa25e382e365a6f18e3b031f51bc5e375c7a9db79270c1a11dc75f6f6db384668f66b2b071631c0bb678bf958a31874cd7bfdc17fc5981e2bd06c6fa43eb27d32e8d03d9efb0d6f33fee90713696540a241ec8c1703ec7c050ef9b28032666e60fde9b8a8433801e5dc1874f08def214fde8ea19bded0a4cd6fcb591a747f834d2f1e1d9f06987fd12a3b5e25a187ff844766468b2d5105cc89c7feebb7cb9577ea37a7b45c1d0e03072a6796a98c480014c9ee662862793f3aafad24cc7ce8e917fec84b9141f8f233ee3740dd16f6e17d06f1e85a43969d8c0f0bfaa57dce712c04b62e911896c4acefe16fb7e62bff4d8041f91b11e5595d5770149dc0bfe8ce86029ed351acf2c1871cb87494c890b3f41c39a1c18c0f6c2983d6518c17759a854e8966a75256cae1fae185d5f684d2fc071067828ff8407ac7d7a7b3b48edb8794a243e9039e79c815716afc4da304534f44b2a580c13619e37ee041a7de02e38fe0eaae70458db7cc7a3a6d082b68eff2880dca90326fab56a90fb19664ee26195bd495d25d5fe837baa530c1fbc489812a771ed1b3d09b6e50874678dd7fc64806d1d2690940c69b901b3eb7620730db68e8eb51a42aa03e821f5d7a188243300ef43c35e788f5a117f8ce5d9d67bdbf37822d5d643bc787a88ef0443bb528b42848882914f42833db1fbadc61586f0a6144d2d1633ca4d297433c31f1c2b9bd9e7ec046df9ae2536391f517380ada16f409a6bc5b4b0edaf7322a2ca6ad19eab91bb4573d8b6e58922dc9561a02746c7e2ca9a9fb48aa1f7d236c09a9a784eb747aaf7313b7766cb2744058dc3c80771ea58fc7ccbd243ae199a2770e8fd696b4e9bf296a68ebb076c5ba6843bd91fc9a3bd4692e31bbc877813cde9c4d0e3a485fbcd1907d41a10a16675ab3be7e1f40b693c3e3f51ac33e9eac524f21e197a4f12b9215c21445e38889170058b65d0bce52aa7ca8350d54e091060401c15fe0f1d24217a02bdd85a688548508093489bc6b7f93b5a612baaae3264c4f4dc05901801d301cbdb6b3a4c864c610318fccd35f7bb86330170742d4a28dd80276fe46b2af1c82e68cc7a28e03d616d530907f068e004e58049326a75e4d8fd9eb9c0a3da377ce39c65d692eac21acebdc873321c5b0401ffc87f6c893efe57469f15d900781303ac015e3f755547257c9f07c44f6573ad0343d0654ed8163ed3a6451efd3e3f7ce7c768e564fa1c54780e91f04892eeda6817c7aacb12d3e36442966b615b8a7c054b3a508dbf373d6f343598561dfa4813c79c9ef612bc135653181debb68b54a878aa351558742420fae6dadf6dfcc70b5720aa2de121ffb48bf5730f34165a4ee80e2c9cae39e586eb238096f51ed1402ca0824f197a354d1276e63a66ee99d6cc3fc42713d74995e59dfafb43853eed0cc3ed762f2dcfdc063662ae50efc712a816a2b7d4f15c1ad4680d70c40a429912bc49875d24e6fd930ddbe0a39d91dfb9b33ab403a960ffe3334682094632c54d529b19af30ca03ad706df5586e580b4e550640f4c1bcf848e87d4fc4a48c786918be01b2baf8b1a4dac4e483488493bc8fd0f057bb99c4d03ca425d4d465e3d4e12d909176c7b41bfb96c275e6cc04b8116c6595cfe9e63ea7a82b645830092f8da3e3d39b240b3e7b8d5ba070478f28dd5003fd65aefa1eea67ba66722a3272b341d1e7a60c3668f6eb34055bad9924ae29eab863cbdadac332f2b4fe40de79c9da3cbaf359fd31d405147475e89ba9d2396e4179b2ae19a7ce06c7ab795473ad22200a272b5ac4f668fce5baba5824941cc40ff890f7a81e0d4318358a6d6853a0ecb987a2a5a353f7a1609fdca7f22829c530b7698a16fff73df3515e97b24e2e925d28918c43dbb4f7e232ef73728de66c2b7538ff6014d069be355492211a2158f3a64feedd61a9ca0a8f7dcda5a986f02323ac004741260b6f036889f6f9858a4831e787b664e5e60b25e73c7c948d4201abc5e9cb3247254cb10a0f809a5b77df13826cf41c1882d23b3d3cc92c33549cfde98b8e971ff3c4ccc5c7d2d51cc75b13044e3814002cc767765aa2f7ad6f73453ed02dc23c55fb4241baa00ad5c8134256a52c5ad9198de480da23e7a266c15bc41a4570c2d04731f36e65edc76a48ffc59fd7cdf6d2d5ba343aec1f4ae2365c606b68fb2f63b5c49a92f0504b22ab1ce947ee9a0d633bbd80dd1a5e330d3d986465e2005ec1e478483529a9840766452cc283d2b049bea145ca52101a9592a522ebfdaf5341c4b0175b580b8cf1980e034b770a3b17063229e76ca9b3b47f3513c24ad043fca1f37065dedfc4706e11e1666f8b12096fba920f1a0983fc38a15bf3f54dc167356eba9acd49c5f17297f02b798d8390769974c27421f50c21f36ba1d20ef9f1b17347d0bb31d4def29e995cdc4847d916d3b8a0b815e8fbd69ae0ccfc86be6830a23e7f20ca744a8d2b8c32a80880b4b9387688bafe00510fd3eaf790cac2b298e7edaa8673a7051a10feab2b36cafa92190de73860c69f5ae8b111036627fb9ebd2b3a64fad838a8c97296ee53ebd25928204bdff9c1581485a01f952590585d80f1b7e9e5069390c264050cdd399c21e6843beda2ba8672466e0f5aa0de9319a6ecb4067b613231dfa8d1240d2d8211ada65b0256ec875b6886ac065b45ca74e4a177bcb7e42d4c194d9fb42bc918dd77f37fdfe5da229371b03c5140071bd3800452da862293f5fcf9509d90659b557ea8a314e3a699a4195c657503af2c8250f7d9e267d0e04a0189c721e6f2182a527bdd675b39187a2cf72a3ee4316b5a8dfb450a31d86c2d3e36b532b547fe2f8e3b27b8d58c73024429edacab192a370c318de79b003a035d69e67dde9dd74b77161a407eed40eeda4a831290e88d21bd534110eb91acdb9a7e0ea405584613f6e0cc30ef5a3f379fcd47031bce44847ee67192e80fa7ce6dbd947171f37e299cc0f33bcba9f3ea77d05146ead606f870a10654698e18e423255d99bba87d06c1984754cd21cc522be095ace2bf4c03b846b88a2687157487b4620d55e375a85d2eec1e78d5dc6b2f9e7f2360a52336cb5e03db66ce395c6b4d64a2698d2d5236eee7333c5cbfd96374d3eb2bcc6b69b821dcff01853912d3ec083156cf4f819c6c37d77c02a54af6297838ad32f9ac4d64cb41c883cb6acbb6b4f4bd6e5b0663a62b459a648c3ee56caf0937ecba5f57a278eeddd0038c3dcbb940a08116c0b070cf7a0e6caed498da93ae1814d8dd151da87e829d260ecfffd87aa64e8d66deee36b6e37b533fef9e0e9e9f708c9b955b3b0035d8f10127d592e1d9e0774020aae795452ae5e89c41241740b4c04d9f86044d9a9e85d3443b7feb0465441d2b46dd41db9f628bb92f93ccd7562c186cd45465cbcde905d2dbfa40c517cbe8bb0163bfdd1ea4acf384b0b6dcea532620823cd79c1b8fc8e2dfed654796c4e0a839c1f5e9b1e31b85c4f88ac9033292862896fa2a44423668c54fb59618157576ef5e83509aced3ee2d5ef9a5916e693b9ef6bee78a98d58d3cbcf82d931cbf5f3d0b1aaa5ed72365c5d49011802b0f5af1120aeaa7abc090af5eb5da96ec4502c8974b7d7d78c60c3faee24e638cb4d289dd005becdf74d7301e0d8804bfea5c4391e46cee15182d30b99662a4a9879798e77dbe59578848c807d20b0d136c7e8851a91b4db0b8a05f1024cafd1dfd337a8ba90877ed1449b5d68ab2ee45ab56541b9bba7e56833ad37b5e6f6e2cff1a55e03d572cd6236e89793759d4e3dafd8da9f513e9f4cb9de6acb6f8e6eb5978ae4629108edc9a40f32511411956d873f5122a6e55c76502d10b2ff2e1e9053eac54ac3a6ef1c5b7497c6833f3434e918b50a72591f19f85f516b35280d98790723dcf7d39fe936c0299266ce81c0a7aa7d67eb158c161a1e87c136ce7d605fbfc19b9f2b1270aef5ed5aea1e988617b8352f8f60c6064f2ab302093749efee4269166be9dd6ce4fdeaa5764435fbb6540d104d76abe34de9b4dc387a9941af7ce5816d9c372509e78fb37e044c1d3524057a1806098ec1e1e7f8b3a2ec41dacc8105e46cddda5b8883af5a6833ec53020967cce4528c492d32e30fcdc45fa86edaaef8d34011763b1d4157a95e6fd70762ecba10e1d60b6a4a1429c2a7ba9a26f12148f3d63faa5d15bf38b94fde382ed9cf34997b00000a3a574bb99c798095c2aabbd883fd4e7f5d01be3fff616800caf2a12eb0e419a1bf09ce6b5b5e60deb23d1ca8fb6cc6b9b601005c9a02d43fbbe4852c7ec71ed27e6b67939aeec9c36c5244c67363cf2df0bb4665e5ddd396cb8925d3af020ae97fed316d2d0999fdaac59a53316cac40ee3591990f688d2d88a524be71954b1690c3dcd3d972b29f690e6287e392be8185a8868c6c24d94003fe457c4392ddb75c73237cb365e83bec5ab4637cd9b2fc51d215d21512a01ca5bce0fa04445d1280f00cb16996b1d2ce10e892069dd8f4a9714bc44a0004c74f03fb5b3f59f98502c45a5bb2f866b5da03a13a8e95096a842ae04c439ce8fd2b266cafc529a401b01d3624f81adcab979ce093677173b197caf6e575d04d41dfc748619099b61bc7d1c765ef99939cfecc82900e1d5645aa418ebd39790b23c2c4725628ab91cd1efd3a8a75f1dc8943330751bfe27eeb0b69b15403daf3fb4159d5aaf0cf6e1761dba5d959b2e4ba17eeb017282e291d15c4b9fdd951d9793038b6fd03b772ad19378695857cacc1f46c6921adc7ae27e63b73d04a9c869bd101cc0f228029f507cfe542cfc149ec9a4e8a76d0f74ecdaf8f9b57ffe7c5ee67b9a056d41a51cc8e4fcc1cd342a2b75a6b1bb690062b15d2b7e60ba529cb9e820b2f200160493265c5557e913cef0c657f3518569e1d36d97dbc6ed3da09a2697df96b372989a71433fd542acf66bd7aa5056651dfb408fab7c7c7213f52eef6045f2f5ef549581f7ed3da5e78681c371b86a362b9d943d96ae943f15db0f6bfc39b4195de8a1683dbae7c30e7b2c6a8e41fc2912d7b6179e2d719e13a7b74865f1e7ddf2cf873cfd44c0048c1eaf2bd002472a4be13da10b19e9da5016b746b90b1792071279cabfbddb087027c19ff6ac95319d853911fb11eca2420d16421865a9d8b3766479c9440710500fa1de4cb62f6d7dafbf8e11b637a3af4c9e8d0f32632cb762fdf3e1e51048cd16e182f75cf1dd6de22b97ae0f4afe4f2954035e0424e794ff552772bd98b1e87efdb91da52e3fc124724557c1e3dd6ac1b9376f1d2fdea5fb7eec13fa9a10fab4130eedd8c8af2e6eed7b0884910bcc3477181e9d6c2cc06b888f40a4d5ba6557d61888715a5d165d616103f8ba92bfb7b9713f361b1f30a87abec5b19b3cc2dfea4ea881a0c7724726d35f555bc62d2d98188046f9e3a144faada3b12a2f19193ec1e40965f2f4c7292bfd6a3bfbabfb917b5e9c5941d56a1c11d9d71bdcfca17a110cdc9c720d91581e23ed61bab17d88c0e0d92da98a65cf2b31515aaf93c38741b2eea5ea85c6c23ccd9c98184e6083b41ea1614fab603109f0416fc8c494cc1c739f1455c293e7ebff75e764ac02f8db71207135667bc646eee34fa67397a0e0cdcbcdf9e8c29dffb7b6d45e55b8e78d82a7e06b35e524ff90bc1bbb41213b9f004260aaea4e10998f2a3d038a97ad1cf49debed2843c524611dd533bfb877a39dd9b7bab543913f39ef33c24d130c300865bf24ed525a916fdd65b11fbe47e650cb40f9f28a46f4ae6e5477f24cc3e4e6e48a83617fd9b233f3d53ee22b366f4abeae77cd7a0459d094fa7b78b4a0d571135bf4d1a24ccfcffb0cb4f292b8c3151037fc0c112d3f528bb2e4b151fadb3af86d85fc176b43e2f0ed73b98a1bd6745ee94d158eeaf793b3a9754584cb6ca5918be2f533b114bb463a518daa3a600a245fd83adeb4962b2150a855229dfc98049381b8675e71995a15d45f1fd8a6f752a2f87bbc5e03737686da30aa79a67dbccf0bd21daa43dd03c70572dbd751e140b3431e1ce68d65037a5daece5505b615e4361a3b7cdf99f4f971cfb17d1e847a9a65d300b74893ac2ec1faf1519a90394c65e5d41026c0285f9d3cb21d111e84a656886bef146f6e1da4c2df0a8266b44da3ebbb6844e9e597af590446cf7ff7d7065ea8a9a07d49a6587aa67e47c49b8a8ca0c00b6c986ebbf7c4f1bdfe50ebbca25764f66a4a45b3064a73ce1ba34eb720d43ac03d39466a92c5be0a734b1f45db62c2f8277b62ef2716c6160c277ea15d42b7c3dc1e3b8d9c19487808711017dae53dccafde5689a842adc4d947224e3cf8b669e067e704d8b156c75f50febda3c1e39daa3c1e8a350e24a6506c6dcb580b15ff0e373e0fb46ad31d2c3af08c6ece7534cfe9c5d1f8199430dc5fbfbd89f196b2ae14b060fd36fe059d02f5b9234eba702ff9d7dedc542cfe3d146bbe65bf55226a3f861ab92f9383db59efbf950f0061595ea7a8d415c95bc9bb5856e1266a5978aab7ea4fdcb6d423104eaa56e7226178094e8f1058499bfb28d18cdb9b60ab8e6d6f481dae49b6e8be00604d60481c81f76831bb8023c4bd3b9545422e0828dd46ade02d9f6ee60c588d234c7e87e0f2a9b10fa19ef0365a329f47f2b616201dd36af9f1fda2eb6a6e44c7c60c13ca0853269dfc63c8ea1443f5a5d7827b9ba4ec1bb9628aeca994466d071bef2d94d9ec002964117ffc95b6e02abb10f222a2f66da23241801b7bb9c86836e1e4554ded38f99bfcc4fca1c21805e5e353faae236a1b88c754703dbeafb0cc0e0e73d093266767e2e1dc20544cf2c5b0d89c613634f169071b3218013234580c193ff08a2fd442906b220f1f08878de639708a75bd024b9ac56ea42e4ae3ef86d44e1bf3bdd9ab13a2fca7930190a1ec786243db5ff8e09cc46d2ba867f002fbf5c363c85e48099926fb4d72b79df19bbda28dadee24d53feea324c2231684ce13b4cafdad4b73ac095a6fcf1f8f07d53678d6bed97e14a492a210e160ebc63071b76db2fbe42dfc6d7ff33e5d0c5e21e901418cb03677822c1a07088235c7bcd8cfecf7b344b92c9c35e5168e94c128095eabc13b8d166ba576d64b20c7d298b8fae7fec857d67e954af2217eb0fc77bbc592f65841f115d7d422c6b00f072e7851d874abb581cfd1916c63f4f5dc410334420b0186ebb53b95668a26c640b496e82dfe3ba2c82802cc034b73cfffc0fcb979f65e35e6497b575d3f610eb76a2b04866f252cc986c68c600c8bc22699966c125a6fafe9421dc37d09362f0f4be16ad6f2e7ccdb6d1ade5cd343e35baf5b59562d6c266755dfdd1fd110f20058769d5c0612cc02883ff4d3a1159113747bc50407e2fc1692e24f4f0370fee8e40a2a5b663b58f1a64079310095b0f5c8c693bb26586afb320ff984333b4f1d708556fa1caaeb4b5e96202c689c7cdea1b6ce3cf5752dafeb31a9e90d42c90d7b99ac225e52a5e78facbd2c9332c51d86995294110473b016ab2508fc07d68c8d0b59a37d1de85979fc30edf24990a0b093f173b4617c94aadad7d5407970c50f647f51f5a676b9e2b659a240ec6695f188b22e5b1c843fe133433324523529cd563d5194fc1ed9e57c8ef262c688063c39f01527555f5977d8a77f317117f09372aab631e2f38f851341bd21f6977b6e6533640ae56900c2b4d72766109a1ffa709cade893aa770619480f3b934f461a3520ccfbbe9768e283665ab4cf1f1310a7fa38f1d07ac9f9a8ff713e18c44a5722d6709101a1a215747edea152b8bbb8e33c2a27232d2b5091392742a6cad3b4df2942fa472db765a03853c119055bdf2455f523b314a54aeccfc2a2c336fcc946b9296bf50d69c223c272d268245521952a38fa193f00abbcbe11a3c1f7b2859c20fe1ffed8f70c7c7e316a21845ffc5dac2b819dcf8f6e3b34ae7bbdf2a33e779524dc228c4debc986e8afc937e80eb6cf409b0e06dfb553df23046b5943df8f8372dde40db8015c6a66636990af048d59f20ba645bbea19909f537f4121ce1874977c473a32f18ffe788bec8e2f159c52cc5c06bb4b632f52403a0cf1aaffd5c9381d0e4fb3c09df862a5552eb00d2cb70c37c818a915e483495975f1d1eb553c61cde385d5d6c57c2518b78c5eb6fdf55f5bf6493a787b44dacd166af0cdc4c187afa9ff8eaf64e8f627226a65bb0c55ff9e34c6bb9dc1c1a7f08057e1dbfa90a4b981812417944cba332f1c231b80b6bc78e680c79a1782b6d522bc12700ec33af389efed5101c32bc7999924d1dcfbc3a736198ab89da5412eb5c90ee1ad09562d579f8fffa7b791b79280e098ef788537ac197f35d880e12b995137e0b26cbc530d15a6a3afc809fbf596d8605becf24c07a3fa5f75d0357ecad874ebdfc7e33675456d2f5c6119745df99cc5b94d2498602596efb5761d3ef60c4c2659a20843de9b6bc8c7db658ac56d6226d26673796016ffae71af679a88b4b896987f7b551848c5a18ee68c7534de23d47cc592d79539f150a687113ab9735784ff49185c057ddeef540d6182139b21093e4f00344118e2b41968f0e080d4c2d00a4f9575c9e37609e50ce65363b45f58a3595d4fcf4b3eef62be38eeb3969c4a434aa519ecb0c3dae514dd9fefd389affc1cef0dc01cf8c5232db46e4631a4fbe6bcb1575c11cd1d61b0c833273b347de3aa76f4a482736d29a981c18742e39f064bb6aa400772c394f26b77dc37d5c3fae2e7cc46cc06cdf7677245ff9d737a91858bc92f196afb3976c36a9b5a2ff7aadfcd3c80a8db799cac9dcd35b18766002d2d230d1cd7ac1fcf2d17868ce4418cb95ad92e51f63272e5cd1556ab152483acaddb7f0517f00c74739c12fe2ac8197078967ecba6e6b5cf384d8818b387683a9fc6e0f994a6a44480eaa66fcdee23aaec98f0d3a53c458e6b0f9ba948aa7f811a3cf2a4e34e179a51a81a7fceecacdf7ea32e7c601d05e5ac6970365715f77bc8336804176127d2339faab0832e1386949dcce3d6dc54d369698f1ead28c9733f76d4469d135bcaf7261c4e3c52f1411b54d6949773958028d3de0c17fba564f49468ea0729616fa17afe657b5109978881f2e920c78d48927f8e0c2563fd5f0d9d5c27507b00a53326acacd59e95cb5a296c299ca91e8f68df48675dca549dee9ddcf7199890aa01a2d3ca2bbc54e1f379d0557cb8da4a33ac354eaf88876d8c5638477b0524e2d0cbe940471e5ca0ed0aef80e6733329efdf5a126b7b16c96888b8e5636c892e2f0ba71185dd4a979bc6b354f46958e140320ce17f7f715ddcc691b09d65f2f728fac15c0270d57d8475d8599b21b1e9cbc8592248fd0c0dcfc648f476c590b59f6880caedfd2386e2adc6df49f46cb458869c014109c50277c0b7102942bb4603a8231cd29ba756f092273f538859f0cf5b54f9d4fa3471565fa7fd07c209721c500a5161b4071531c195c38479ca8fbe37cafaec9512f076ae5fef22fc07a8f69e0a6929ce7a77f3a42173cd980fa6b8d8373b87c529a5d515ffd6675368bfb613e274dd3df753413bf881038c9daadf200cdccc28b82875b153a5b9309658f894d793576d2d5329f1aa34af4d873fe633996f81975ff7aa518cdb9fdbcedf0769a8b1ba489fdb3fdea9e8a20f2cf6240e7b3bc38b067be390c13d2fb9c7783a2842cc0633c4d60cda8dad659055525080b2c6b9769febb6f51bd1e89ae2bf466731e8906f85195557229eeca77d1b428734f739537af9ef435dc8d15f3186baf18f3c11c90b29ed0707bdd8b0ccb48ea2011cb8577dff383580c741f907175db941a101e6f19732cd2064eaced2dd7becf3eea5cd97298560614f7284036bb5b2f5a62162c4079741e7dd920f42d8c298906bcf51d78336c822b545ed54d8fc99778ad5ae4e33721ca39fb4f5ed2692f87cce2a40bdff7d2ac55a10f49d824300e17629bbe4450114667a30488ca78c6d73c46a81a89aa64a0572b7dd790b68ef434ec3b705cf4d7e3678bd1f8a323cb8b146f6b4f5e8bae014cbf0b1c2f4d7bdb5abbdc57f412097d047945192b9170e0be08551f6e5bd9c4a14c9c039dd3f6d3690f6cef5c08d8dc398d6dd6a7c32c7f7967111c097d9bf78525b58ea6360f24b8d9b2d4bc27339fe6a3f3d30061b8b3397d2d6d1e93af1b5763e5ccddc1850cd157549a6698b70ad551b40f1c9ac590ad7443658a0092984eb02ade6e74238aefc497ea473c5bf65901fc55762c6e6a75a27506202e23e979fdc14ecc3b0e9119df8f17f631f0ddba3a191b838ed03755ae074f493a9553911cb15ff0045532a57e8303b437da0e32d353e5340f78e3c80d3fd3e4fe38aaec7fd382920b5421c7c8bbb3489befc760ab9c034fab4681e8f45f590b700eb2f005cc1f3358b947da2f0f26f163a8b4d4a467c4abca90a9f1e3b46894e9a8dc84b28712c64b25b68979640c03f9b0db2360815b1a7cc38066098ed169f2f90985df54de0e02f210549e531b319a270fd1754ad0c4e18bf135062470b0763204b15e6a49b700a0030a8c4a89279fe79180566f19908d3ddaf33b4cfd4eba3c8994d679a77d0d8febfe78796b86b953712947b0bfcd22cd2aa5bacb8914792672926544ddb5eefcc11b6772da7c10c86ded92f56b7b65322b832d1f2276dfac16f9ae7ea1a59efa2660340cd4605f4b4afa30c704d6acaf596d860406102484242388d9b329d3398699b48dc19cd20384ec81a06d9881b17f6e5e5a0a038b167766f8a5a70b19aa70896d721df74951988a06f19a73f3b61305032dbe91a8d18ffede601d02b9cdc5dab3b013fb83251d5380030870c49db53d663dde348925d2ed15b77ea44fd297b4114947ad248839c95d4b2267d6eaa892a23b5958ddc3a557f7b006739b8d863a191b699a1c091119d37008a3b08178da0a6c882dd08feb6c0dc5327a9fc4fc63702e933a0a8bc2e309af266aae7dd4c5e9b3046ba8d5257a24520189688e81dad76be2cfd337532db1ba754ec93fcf57048b88517607a4546bcaf7a15fb3eb1636fa0a715b2e52ccc1c7b276bceceaa902ecb9e836c9d1499b9d2db2704a367bd423146d9c7e2b32a107a7c207250962b89dc1c57a70b1808199cef35038d592181dab1c8ccef9a19f8714da531ea36c267261243651a764f93258d866c800273a6041050a9f27495a063644524989fc809829ca53f4daa6ec25d4ef5a24b45d81c2863e51bb8bd97b268297952bc2a250720b6b5a01e8cf6c382e172aa7c843949503a937b5c521b23ef4effaf18ef9ea07137e21760e6bc2206fc2e1c52e7a8fc3bd53cd39db0437653bf033f2e39333007f5e69bde14187bb8617c957e220ca46fe41db1d983f4faa9d6f7af8a25b2a34887bad4ad2fc330bdeb4d32e24d5ac46f63bfec17dedf8395c92e3e7cbc858af7c4327116627","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
