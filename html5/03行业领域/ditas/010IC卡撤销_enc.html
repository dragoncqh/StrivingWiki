<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"44e9ac2cd1a28959516dc0696571c0ebaf137cd02efeace144e4e2b8d5d8aeedf334a844d937aaf20c17c6caf66600256b327fbd467e789d51f06f23f2602fadb11c0e560a97cd16477692d4768f00ece7433a1d99d34b926af610a9438f364c2166aa2ce01ae7db9cb992aad385b5e2fbc8534e1f538b770333a986d72058f704af6eca205f716d3bc6c885b30fda83a7c79598bfbdbed49022fd136917445596dd1bd0e03f7761227ca55b079e559355ff7d9ca521dba324130ac232a7878066e4227ccc9545141883a9e71f9a6c604e0a0deea170f9dc9472d0d09aebab3056a026755244a1fff2b0efab4dcc3a4b32a1f00c9d60f05b3fe9aa9037623c90f9d8b6f7feab173074b8de608ac44feea64c6dc989c4d707befda386b113dd1a13ccd5c0a0d0fc7b60d22cfd4558c96c6b1be5e00ff1403b8734201583e41b51dd73e05d94a2cbbd9c75de17c0edd571831e6d82e2cf0023aa9de0f6e3eeaab2cdd36c466bb30b81d4b98425e2d9dd44bbbc4d59c81b4eb3b1b3c79fcbf5ff9a9985e9be38a36daaf9e4bbc92bc769438ec3c3940fb3b03105640521fe7b846eef86b91db1e0e4e7bbc14c8364ec127047c404cd562ab77c1b86bc32788e02c86a9dd16c84d01ea337b72802c5476fdf0a66ef03120214d4c977451fc63f2abf42cc087f0b6c27712994e07658e14260d19a443fa6e24ce64c02a7e5ae175c90d057fa2265498cdbf2d04bae4a59a3785814f1701684ff5ec92a540e3c96e09c3712bb6989526bcb717b69adbf4227ee22ba4e1cb3de276c63ff6f19e4dd87dbc29b0f0b76c4f84503a8f85adf16d01a8df257e32ed66ba3e06650246fea7a628d27133b4dc87aa65807aad52181d6ea8ac9cae2b97ff5df9e425161e83a4a2697793ff3144e996a2a6daeffe6e3e918c93b3bbaad2a4ccb248bdac5f812c5f3f71b91d4486d206889a14fe125645b25e653594d106b4949178da3135009604222185e5b5bc1d38a288c470d15b8eae99fa34a061231374339fcca41656b65b907aa62dec329da9f6ad310781d4cd37972d16fc95c4a3150fff703d268fa1de43cae5d4c3c323b59b550f4f71fdf365c62ca734bf517a239de7d165b4dd59472affa263a03f29cd7d3c08d73f976b0f4901fbd312bbf4e2ce7f808437aa2cf697549770841492a77680f21ead2b3d0e755e85141cf6f199d3ffa260347af935eea0cbaba4c8187b87cb9e2d4cf5fac570c5f31433898cc7bca09629e279b352ee9e0b8d2e5f2ea94552a470378ade95b4be45f75bf8bb81ddeae593f57fafe54a257c8f46fc30cea6019ed7c7fff80ac627079c09f42165be75eec308e27cf5d1a24217140f75b7a70d9cbde85126da7130b02da26a5bc9b5bde853e07b2d944aa2dd7c132631b3ce83d73f4f61f40f5335646c1fce2c424e0af5433c691739298f92036d28477e132c2c34baf17ef018b55a62916d1237e5236d388003079c34fda279021f13be7cb41bf165d81285d67843c1d718df36bdf6dc20a559e24c2e8d62291550b73e5ccc1131aa67b569f8d4d66c297f685e1edeccc5327ba80e92b8353ce55cf2487f0c26019fdb3b6ab84c01807c4b479f73bce3b5d4f73f276188c990061d221cd99d2bfcb5f6986c6b9d74081c533c40cbccac733920dc82e6421d94e3141e59cda9364b94adf553bcfe349e81b3a6c6f47dacc1c1e98d519f6c301d2dff117661695593b0220fadfbcc5a13ead5fd8cd9fe66f6df5140d26b6b55ccac0cfc1b36d6ff74d2a9fb5418bfd1883c60d7bb3c76787ee14eb7ff796f5fcf3873f2ebccdfb0ee99d2f6c8a50f76a94ef98cb75d4af36fb1238f0b2d8ec998a19c65b610759c52d0216ab5abe1aaf17821d30202190076301145bff9a007f31f4fde02bd87b946c1b7be8aabe58ae2f17a45d2ae6402432d1cad563ec57f710153ec7b0aaa27a46d445f17b299d379206dbc2e80850fc83d0ee3c192c751fda3e203921d0b60b9ff85729969c03469ba0b3d2139c06cb3bfcbc6111015832a43ea8d829fe4a92ec837c709788b028b1621536bfd3a319d6ba8663eafe15d914043ec1cac114cf5c727606c26cfbcdbb12fbbc591c1f2da1ce8c26ee181e93df903593132675db5baa7993b1170df77265488af0529cda00236726b13294b80bb8f553bfe8297f292e4a402665e3876aed4c8b9f37055d5cd2d8bb837a65355243d39d444f53f9794b531d70f3ea1e0559c56ee143e4e8909737d679fa762928ef816766691814118bf4f0657a1a61a4cca4ede000f4caf308fb51001fc96d1eb9302cb156d47aebb2ddf979c98a027516fe8fc649adad0acf90d1a612f8dcf94a0a09f25aaa9537eb1c282cba7a433e271f10c34e6341206b8b64832c9505a01458898dbde2e6c076a0cba6e48765e856ba21e030899dd6c457ad4b85072ab369e9770b9a95faae6367cd801ae55383e21e1f016bfb6f217296d2dcf5772f1bb2ba4aaf7153f9fe4ebd9ec9c3afcb871e017050d3634bc51dd29b1e4dc92f1f6e3ca10f773eea761556701b8ec5db81cd5d7c4a26f16514f560f379c210ae5e5987ffc2992a4c2263ae2bbab4dd4973da63c4ab3d0f0f0954c289e80826225cff77e3972a74f412bf84e92ed37e79aa087e4e0386a30a5d0ec48028a5cd39d4a4ada1e050adae411e1b1b3a551ee1e4af293e146f0adeb9a079a52bfd73bc47d4e7387891f85263c2ea289dfcb6b469c81eaec18cdcefa4c00a91a50a242615276f770eca52afe7e9b0517f8204c6143311669a2286b2034b7e8360c56a91662529285e7769fd7308546e81884091d0d79095d15c052c4e102c03c742a652db20f19e31370cd1bfda8186c1a9f35de60c8e7a6e3db754ce0477836cf51e974b646b9a6f511a8e05bb5ddcee7bde14fda084c4da30adc9abe7ae617445e95ecd8653d9351b0b4c87c54d7263c014e420d27fc2239e3a5c9b806deea59e68bb7a73d06add5ae85d7dd771846def592ec8a3f698f143a678c6d9d1acda4130f5f7a13e8a37f1b20e3bbf55f96483e196dccdb2b1d50eeecf4388cf977fab45a083be712c3bbe4a1e82b677531077d814eae0f941a0dabd6df761cd0847dd9808cc28f80549744e9f6bfc179ccd87f7fee108dca58067156a237b4032fc5c20a825c121ba260d2d0978b9f6b6b74fd0603b0e0ac1b449ab5f8015f3dfdee6be1956b4c74bd0cc2ef663b6a50b63f88a5bb0fb4d0d4ceeef716a1d805f67a8e50bece99b2e2359362fe6fe285ab73bfd5abdd71be8b5f2ce9bfbbf2e811b6b7ba3ebf9943ca79f9156724815ead4f21da73a0965cc19ee84f121bf865cfeecee89823418159e17f4916a8ed322fcc9dd3125b0189e7647a06a0e66e3f77a2e044388899d88a52d8589813116a780f6ab3909ef70c12606695e273704dc04cd629e63d2c0c76581e0ab9374b3e184bb4755a3b4fbaa283248d2458744a87e5997de7825b241d3c369a1aa812bd873045164d6d3981a3428b2ec1b5636e0b41ef0709f792835d950172e7d4a5bded54e93266d6eaada0be45bb02d7a108bd6e78827c4921d718618d6c1caaec0777510f164d76de2e2d827e3aa0762270c403bec574be5373185f1126cbf1fb825bd3c8b1555a42613be7c2b842e200b7ce5dcfb4ed6186a84056d632c3e64ec2e428fcd0b2f341f4d5d5fe42809a61f9d0c667dbddd63ed8d253191552fc2ebcf5e77cb744b067323d8bfe5fa015d4a6046097c16c0de0281b578333c51432b11d4299d613ffa7d75ab75281c6ecddeeae2b5fa45ccc2091b7bd0d38ac4dfa1012a4f6bf88e1d306f32c46070e0c775c7661bd0e976a28b104d1055677de45f7e70b95faa759a9209b4914ec5a613749152fec43c7fee2991f08038889bb3ec0132297bdfc4ee7af0cc6015b791a17ff4acf9a5e41c2558e364342a2ab4e6bb2bdc57c0745733cf67da32ad66d385067a769ca046efbd3443d53686a5ab89f0bb5a24a3011591628c8e7e832b502d5fb563c3e2e0e687e0d2bc0c95662e469529cf0781cd20ba572046b3d77788d68da407966005fd2b645a2c2ebb27387163ae80e0e426b31520c5e4448af726e277a76f5f77a1b5c4654a70d805318b083e2e6f5fc18a939bca6124c04f3915940881c84382a3310f72938c30291e7029b78f04519a01b3ef507cf8d2f31d9105aa7df884c46a1553f225b7780f1b9721b8b302badfd05a4c7ad7e48ef3b9c277606f4ec2b7613ee0607e65d06663b599b6048006b751e30b65b4aa0521085fefb9a8577a95f368b3150c1bbd3607b67444ae736b8259f2a7555eb9c2fba87c25591e78e1e86d053acb0f4105e5ca2aa1e6d2576bb00b1448799efb86709094a49421c522db70519a9e8deeb7530f6dbc45c8eef2837635734452dee14ed91cb9fb41bffd76fb4f41445fa9a94146a0f140ea8eb9f4e3ead9b681608d5e933c18e59923bb2e41cac0018af99d3634c145e92c7b6586d7518bf9aeef93c9fd6a5ca406e55e8c165f29cd4eba9475dfafd61e6459ab48c72e227d6e5a2492382e72f9b3cfb49d080bdd27d4b3804f312ef6fc81893a97c6dfd55b8d2afbae772a9bdd1342b23a872bcd1060e6f345f21df7114b1416cb2c966a4a0ad2cf82bb6df63551358692c4bfcdd1dc48b274e1e7a6869bded8b7993b3f872e4beda589380a082fb3081a199d822ac5391836eba469800d84ced757e17232ad41ee8c1b024c57ad3898339f42cfbe368dcfb27f9614a1361508754a77b08da01e08d6782999d81305aa687469031d927e68ead5d752634fd3e302ebb368b7df9935cd6da98f7c31ce0347b13d285cbaee57364abc0df9c865e11e67f2cd72e8f3c0fbe65190999e87ea90f5e07bf1a9e6fd39d0227cb362b357fa7b726cf78de1a176468e6ce2ebc594d3e83b81b3db3305e73ceb1de52d1559da1111f22e4d1a11dfa9fa70e481ef12f2976ae2c261fbc9d64876a92dff38d754121c9c64e5a7cf1c7c97ebc0d8dc1db571972b64150faf3b0c21773afe2e5aa19fc68e9ad5257129c4f65107d8c4bb832c7a57eff773478c9832f27c62a9aec72e121dfa1e62807b0dd75720415f2e5e4f9148d6f294cfbf0fc056f3f5ff4f566457ad3d4bcf0920c37fdf27c9d2a713b7bedadb1bd878facd3d607a20ba5609f47426cc689caeb475261c6fcb3d623c2dda8d57d76f86423e0936f527465e20a0339fb0baf3f126e0734074ac5af2337c50cc8b095ec42e31c6bc61a20e560ac6b6c8d7cf7adc88ac0a85685b0a604e63c575f388624c89057bd6de6604caf2ff478cf8036bd769b7ddd66903ea4bc1a396d21801edff71d4fcdfbb5f45e996d55a07b2e66a7f863213eb78c85f842f8d080c2ff42ce5fafb212780d2337e88ccfeb4658e2c30669b01141e91e392f9d3d97283c2c94b8aa9e325d19e23003d5de4ff4f5a461389cb22b02d8a3be2bab9f6a4aa939024353322bbf83c7bd5115c52ea457878f2662f373796925f53463286886ca816deb9d865e1857611be527fe2570135544fe4532dcbf5311a151490f148f66f9a5803375312c77da48fc4cdaa248a7c0872f0b0456e4274441a0fbbbd724f1d0fc3201696d3b2461d65e5b9f6f52cf56704283808058b6da86e9b7dba8d06f87f24a0bb7515d1609b40b7e3bc426e2d6e1de24de4d9a59bdc31288d3182bff1d8acb9fa46c4cbe3f82272d70852c7581bcea44eac3fb9ad924f16d852eb4678141151caa4e3802b5c2e67820429e16f8e820619b43eb0c82e7249b6c8e271260c5b16ff239085256278677cd90e04f44c68d9493783d753c890b3f3f880f2dfc506f0eb63640a0b29524d330977dbd2c76062323f4e087cd345c269b9501e50249ee7845c1b7c62ad88d98694bd42d3180dca679e5a0fc03ea692d22513b0def85a3a225080e3fe51c500de8d918dfbdf7b48584960b5f3a631cd62b0be4b0c3edfc3177759ac77262a269058e23a359adb0214c7109aaf7c418fb481999e5d70675e6443c212f5e137a587b92ae28cbaedc82a34e0677d98fd0da2dc9033d3cb3a73b3863aef0c1378ad9fa6ebfe0d7d9870303cc737220e5eacaa1fb40bd7b6eea43d6af15feaa26e3ef9c36ec964a716171ca13e37d835618987b52229829dc806aab712331b2923204f367747304eea876c5fab33dab414754bf6262b1edc4602faece22f20b16ca6547d32db1514f63c41526f0fe4d67344cdead912f2d0ba27e0bfc8f7874b31d44424bb6398571358dbd7f5e63d8c6abcbe4f96c516b931ac5933d9384a493df5e591293962bcfbab9ba6608a600e91c72f3db139dd05f7626e4fcd089e6cfaaa0cf4364ce8b006fdd07273812661a47240655178d0b7c99292b52b7ac9e3c740501bf3c5046f382699c7697873238d3ac8781fe17e6e2937926d0c25ae90d3218db285bd458963cac6392f1405de45ba736e16121c8a757d53a2ac956453176e108f6d011180ad6ba8ec784e920e6abf463bc88f8644360e03422f38a98aa72494a3343bc1cad2c0359a8740b2e8af274a7dc3b035704f0c6e47883c38e1374bbc0616a503f717e86636f3eda2f9e8a8927f3afc430a9a686554064f1956cd660593839568a51bc275d25bf6c793b54d95a7ea6c4a72534121e9af20115057a61f3c71a1da5fc1767cbefe5e247d18df361aebeccf679368c9453f151f0af0bc3f0c4059bec5f138241c0f533e42c1b7885ab1ec16678f3423a63493232d91c9048322533f664fb135821bf9ce9993e2695fcc4dde4b3fec7f85ee2c90bdc8627b3694bb9d578ed5945d355ca6fa577f0dfc17f86d0428ae87f4a82e9188813d7449c91837a23be203c13f1e7dad05a2002022de91effa3c9fa3a7fa42205880e0dc52e716061fd09e36b05b18f3727ce2230524f7d83ceb5006b6de8dc1745008f64e2f08ff8bed5ed9ea5e393d4710605ccd648c39154d8532769447400d2e94ab09c4039a10599468c5e271ccc4c36e2a2f0791d72ec1e8bfdd8fdbb72db2dc343e69c675627119f9d3b68e22a01087bd99fd35f7619d5dafd6856351a9e631cdab9312650181a538162e1a68079d4c20a7f0048e448cc3f066b92f69844c00e982153c37bfa9725fbcd577f418715269847143d83d395cb9e711cb60ec79c9397f9e5b351f9c4219f3e761d34f30ba9aa68790028840ae55b511f7be26c4813ed5a7748b2549ddb40bda7779771fb72dc5bd22ab34f5505274cd868b0a7abec1708732bbc90ad623c5fbd31ab01f3a5aef3a4a9e2c5b7cdeef5342affdebfad2f63184c3e76c283112927ca541dd7d89ba4610cfeb3e6f55cfdf1cf394e396ed4161bf940f044841db3f8b53af30b775858e9f16c37870a78755cd208d682539b73244bdbb7d9c7db997f13fd220d7689b0eb0008bf7a64c1972a5c80b7c9d231adc8346c4b0c39005cf39e64d598a51f5880b31a7eb6dbd1508384e4375c24046bfde7e1014f54239d6e3b59f8856d7883f9f298cac71caf44bd881058b0f184d1e11b0f3b28acfc229046cbbd93553e5ac36f221b57a049899998146ffb04e5534109d8efaf6ef02344f3b141c47efbc95d329f8fc78d8a385d75c6d89285a409b46c5470c48910f3b9cd8fa8a11f19ff0c4f7164fa48e4b0193a856ebc358b8a88cd07098cb088ef37223d90a8c536990610ac5f88788ce209b20caf22aa9d22f85e82236e906d7c401a2f5af8d24b36960c8aa88545ab7c33d087a1e8bfac95b9f8a025ce84c227102d2fcea69bd253c65f469a88ad2a3952226fe11c4f1aa2162f24c32ac77e77e3023deb736ef9f1730dcb092a911d5577937d790cb7fd2649f17d5b320a64fbef4d369548e8dca68e5cb72654dad5a8d0b29955cdbbe9179276535777d963c965f36576d153e02222aa63d69b2f3cb6c3c63e17aef65044b7b10a0a6f29a43028ba7226b61032de05b647ce30bc6f25a13adb908d158beb8e2f5201a392565b74c2389b9ed8ea3fd09ea262da079b04356d2d545dd9f1ddcc32927a129cf1eb2eb76f8a600e618383cd7f1c77a05f64d43b96db5a3119c59d692a4899f6f3f4f00cf063fe06b73407e8a0aaa378f232e6f0b745a6c87152d9bc5f8ae81aa2c62b51273d70c663cd6fa1157591c5b47c73fb63cd99b933a354e2ff4a9cb6c1c5f08b26cdb239efd83d01d5b72f012f15a98fdd008baf67a51e6aadd65c0ba1ae3432309c87b3a4bd77f34366b8579bc6cd703d3097fbc4c39cc5fbead3e559026634c871869242b74f7dd7c4ad032e449c8a149b52cb7f428cd5b7f373979dfdee2929129808bed6854afbe7de23f38c090d959cfa123561eef665e5851b2bdbc9dd24c1d500169cca76aae9e46301535aaa456e7535726684be66d31376a1d96d889dbb3f461990bb41b3cfa0b51d4ffb5826177ac78bdb0ae6548e986ce00e1e2914dd618b5ced6d99401be2876569239e5fae08b0c3709ea21d1dc94ad5f1a8c437ffa3d82a0994d8151ab37fe9394c5a80880b5ba4377a6b3d39a122fae9844c118d3a3c2d2e6615972f203a78530eaae7fc4f739dc079c48b1caba5415ca5f496b5f56ddc9026cf956537ad256e452c1431a9b88f155b1cffe511debefeb350fbde82dc5ddb12bfb5a1258281d7c379ce8c0d837b5f5b3943a3a100df4437ae0408db724dfaa75301526b73ee69c380a3a3f76c02ad6701ee7e23e5a82b182fe6ce90bd38a92d6bfba6205ce7bc0438ce09330de60af135be944e34c6f8759cc50db5189f50896c13e0cfa8ef054956d33c8826e5739582e434966dd6fe8e85ffc28efb914129d87950a16e2f154f8897716bd48d6cf09d0ca0b1bc98a399921de53c90f0b39cc18e4381cf365eb854c66e99f87ce5e2c585cd0b597de3fdb5ce1fe73a57b2c2aa4f47578a8c32079eb3368d8ac33e71a404186497e885b142d056b0c28e6d7ab2154db362881c8af5c4abd56f24d5ead714884b9fb9ec199c884e28c6be01b4297352fc6dc4f24f171956d3dcbdda6fb2b21e507a263f6f0ad449b36a159d86276906f2ccb4b35cf21f31f0095e62dbb25fc9f9954268581ff8cf513f993c89acc48cbf7c352c3c8c419eb1b999f385c86aef1cf59f882b83ba1c51784bdf923c08cb28f9176428f011f9610432087f9e3f0cd5823cb95da0f314b49710155d68c3eb60192be01b9be74fef8465136dae99e59c3efc17fb291ccdae2d55825d85f031c8cb875b6facbf80f48129bb85133d33fcd7a41faf65933a71e9f65d6e82d0ff6023b81d4711a95d5e3d1099d4f1f8fec0774dacf6232ba4c1c9ef1e544d5469aebc31a5ac0a26e3d3383da1ecfa13c6d0768d8b16d5064a0d832723c8c4788a209f86fca083900ffa999e84545d02b804828dd556f9519c42f58bbcedd15b7fd46943972f1fea67d8898a70a93ecec52d6fa78a63c9c098121b0ab28ac068b33200a267496851d9e696c95876bc00c8ca46b786e2432c5d227d897af645a3312d28254808ec67a7c89a619d8696e651148348f2a84a99aa36a09bea49c5fc622c4390c6e42290f830bbe4f5b6a0613fdcebf557cfc33d8a8ad9571dc0b8efed922a9ba98465e14015fd3c0e3f2039d738d98386565ff1fdeb6cda5128c6d9ba212cf31811acbf69918a154a0b864555c17470f2035b65750269d9ef4695ba231cf44650735abb14edaf8e64c5f4c3541e8356c94ec36b6d0a2b6c114294f06f31d079a240a9d59972a1e6c2de05ecaae95bfa7878b421901b4b0c741f5b5607a6dd067921b99d17c7fe4d8c9da112fa92f28c78e9ae889bda5cf6f27a154a32d8239257cab3fde8b167a196d0b7514f2a0fee10c5a5e61338eb52ce712701b67091a066272529ec466674e36a1d531633a2f38b1439fc86855285150f9b7a69228cadc01141d02d5dd0b231cb15fd019d38ec8a36f98eafb8aca84d4181e691f864497c504c7ae56ebbbc9d4a5dacc80bca66201fa1b2dea60ef46b7d17f8081db0a39b5c71e98a8db1809bf383c4c58a517bf33585a2b868b0e20126de6295a52462ae753f8ee9f78eeea9073b0c106c9d98cc41d045403a7782ede08887b3bad6cbe932f1c45885e080884dceda0341d460b7816c252c13a4155493f3635fe9e3edef55b3ff013584280b003e0835eb6397bb119ad04dedf35ed0f4d780f092ab32db69ea2bbf19b8fcc0af03c4b962b8ef6c59a8841856dab2ec9fa50e2afc3f34a29108d32b03ea230b4076d564d4ba00adb6a76dbd9c49f7b68b7a8b8d170e23ab7ce25b6a269e8a575842c41ccb24ccdaa9e82e52ea3b4913b895c74032dec7522d25b72752a1d323c04a29ab6e0c3408d4cf5aef28cd9911b5fdba75a04cac320f720b13da89f909efb09ef7c57ed1101b3d8274dbaa33ced1fedb8c6fb59c2b763d2f19bed7a10c0d1f09577e7281569c7e1fc86de091dde23c944bd3cbe3a46171544f5ffa138060f96f6b9a83629c467c1c5bfc572ed48327f3ac40909928415dd8022f7c443a38ddf96cd124ae787c18c3e3d3e4fb525bb21d2d88d932b2a0bd83a774f7836db8e16b06394f2f4e501825c8a98d2fa926a7436d6fa8542cd44095618ebfac4e40cf4871d0d74b287d4c62720e2eb426fb7ff85e72a5b7474bfd311a6a7435c8c85c4b93fea9c93db61aa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
