<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae5bab1803af5a9b6a00ab5bc63b4062878e50764e1a5dd59c8ccd1ee4a5d9125dd29e73c712e49ba5cf251208f320cfc8adbdba855961abf734c71880ea2eec83ffeb728f03725804578c0713c76489c829dc61c0af55651eca0f1a0a18e88a64cfa302fdd2a07274f06540adebcdb6556bc46056849a0c2cc9b3f772964ee9bff0d53d944578955d934953f1bac6ec105d3c3977cfdc7d5baf627b29e95eb7f571bd35a1489f032513d44c9e48c7e4f9c30f2048fe65abdc844b562050aee008b3448740f1e4044cabd3cbf79d7a123e71d1cfa4912ebbe706a8015bd99c15a717ba90121c762c5ecb8f1e7caf0996a106581fd06fd087db95a565814cdf312c80f84241a2ccb881760e52efb23f22e850154310e2db4993f2c2d21cf3aa05a6222ddcbc589916d3c46a796827dc5078fe2649d4b50391990347f8bfa3d872c8f931444dd8b7d10af97533eea4e2c6559484467ab110dcb5b7bb59fe819ead04d2135ec6a48d021ae00f407090af7fba86984d6e8f250b1d4c263a17b19ab1cd97b517d94b477acf1131f53264cf31e5081a4de9cd393ccf9f37cc83304d6cca912dd31c109dc03451157ff0f073a387c0c732ce652ac5b724abe8622b1ab4c7b4c988bb1c2683437fc71ba7ddfa9f0a41bab5eb2c4e89c1a97df3707bf22c5ec82269f641384eafe194ed2a294c09ef005e6e47dd183a0bddd954aca0db8255435dc3746b7da0583757d6b9b16a9d42efe9c1c58701e01dcde96718f859d14bba42ae88d3c0ec9049ffa5c6210046bcf461767053e272cd1c949921ddeaf470c47771f0034ac6e07b804613caa0d2c3e11ee22f775983a30ac9e277aa468130312a96687036343a49ffdcf8d382f9886f08cd95955b92f9cd5d405e3b8531bc885c169f26a0cdd45a1da9c7b5c972fe2c2c4b038be9b31a193bf5daca60e0409af7520ad30785d4ff1de6bdf0e66e2e5af088d8ae426f86631073082ef7bbc4004665a941be98e8bd682db6abd20f82ea1414fa71f3ca5ec9b2449dc366ab821be832f46501aa342cf38938bf548b4c3b03867e215b3ab801a7558016b661b96e63713baecc867d910aad82397283b9892a78ee7b45102a7488257671cdceb576d9576ba378e8fb4c9c8a2e92ac3e2ad096fc4e4beb82bb10055c793145b5b092b4b34e66d161df0c09863fffd9327f2a941a4b5dfa216271d348f20e0878c54e0e9cf2ee6fda34e2573dd75da5071d16617a556bf6239d04527db1102df5ad8b99fa61eb9b648165231551dcd068609a441a96aed4ad7072ad9ea3d771c7a2e273c298505c18825182d7467096b586d6fbc84dfa12cafe2cd2424412b22e37a98e525cdb6f1b85e93f947d9a14f51978b96ea2ca9e56ee23a7dcd8b803d79273f9b28c3d71d55718153c7e5f5b60e11be0538206f912afc42c3cb882138c91af1b101e7bd69f40b0f63f705f0ef132d73a5d4afd792d58ae11ecb0a269acc61d904cdfa00b8b80f109d4d634ac37720efda8cb3b918ec33c988690c029c7797417c9a318214fc08c6c79e71418c08f62837154a42d1c79d96f47ca0fb795e368e58f7b95cdc1aed3b64244008db89fe03430984112644eb4d8ebf121149171e90f65e0cf994f2753578ccae08822e7ec730de98bbd2836fe69e639e0770f585eba1b8697e0b352bc0fc7a0287764ad68ea84b54f9f496e2f8212fd034c608d4dcf62fa2ecad53ff2f4c0d973664829d2d5a9981ffce339fe208e8c44017e40d8bf5d7782ebdbd893bcd52dfc3ca96a9817514ded36bd2e04df732e9915c782b85ae09e7b936a905731b60635224639e5167c7e67d02e83df3b7483b6fc0d19691b9ec9a05f25f0a19cea62ed268003db0d42b7b9798c8032128182d97ba167b3267cd6975145bb9f8fe6a590ca2e4c6b6f4f964c1fcddc19d0659e6cacf4ea9d8fa5537f2f7126b1e97025ebf01a182d99ef7266fde8050522de6823ca33a04a3e8c0008404449b7a0f8f1f9c3d5e1838a19377290efb73f2b1caa9ec13489d7cde8b463f4b878733b0b1fbd721f2ae83ab8a8913606af7d7a9c729b78bb16adac0177a24233df2709d17c387b820ba5667865ec3762eaac3f6e0fb2c0067a69dda794f73876e88d2f716ff2a26a98cceaf0be0f3a755d6f51fbd5332eebff81aa955eb30472f1e3a522c9da4b253d590f9ad033db6666fe5b6f5c5f5a7728b6b0ed56f59a319ac184356a1c843445e037348019038144f0bfaaeef81e56eb4f6b8fe913f70ef56ddea1a3dee449c0504e7550442a240ca006b5c698a5bfd15ac2691634c6e6fad2f6367c2a3667407be9664c6d978ba9e959c992eb9178cc2cce11f8abb117073eaf6ae500bacd31ec82cd3d52b296263de704f24d21cf9d74e712a66893e5244e86dc1d286ae7a3a7a415114d80d8a8c5dbc3c7337254fc179ca863b93cea59cf4cc4f7a5c26b7cd86ce2f1461f8ebd7ee7285551194e15d3252ef6def6405f86a2a7c3e880572dbd99dfa8029636416504de4a05ea0edef74757747d6fa57f3745578e09b8c58676a7e2b9628d649d1c96de87919ee11abd255feefb9c357ef3e4adbaf391b9c218e72bd223f5aead935ca8fa83f162eab48f1ba0a30a875b077243c30ad3cac6de4a912f880b42f8c73b08dd9449a51568c11d2233bfdce4f5cda4415d0c88a1db08db3d1da3489bba782b973e7d8db5deab7884d639d9f8513f61b695acaee6d1c9e0cfd9491356e0012b6edbe44cee54443e870d68a2f58fd5b8bd2e9d66aecf12d0ff47c5642c4cf3db8bf6793cfacb83b5a0cec40c8ce05c609c0182e58bcbeefcd1b9a8eff1ea577a4b998f42ba63a2b835ffe1d8bb69d1caf8396aba0d0410c24a426461e1f583cb8dc2665ccbe2bf8f476b7dd87cdc7882d5c7fbec4ed79082837d6e8e67dbab6109e879f67b9b7de6588edefafb2c0626098ad87a82164e2120ecb6e6b724b7d452cf46d692595599352d4e74ff9f4ba4acf01438ab4252a6e3fc6b0838d953074653aa2fe467ccb6ee3b5f4bf1f456174cb908eb33b54431024695569fb41ff874a2c5a89f26bf52f7705d854bcc85aa3011671af2c5e41e7679d785f811530c816f1233b707375a3f1d6cacfe9cdb11a786aee9e316911f69688722542d563a8b3479397b83178124c85a5eaada4d47bad4bf6a76e85438069adb2f7ddf7e0b46d3c148ddc870d94c93b4ea053c90dd5105ccd0818c35c8d9f30bad2dea8abbc4f4ea51c033fc6712ac6480855d044071021134f0e8866d8954767c4021f17a4899fddebaf118723fc8dcb44376c2182e0d7a07bd9fdc83957ce0c2368ca415401ef269ea116547d0e53169a19952931159fe10b805d656615c394760775b94ee7b2f5e64a07438cba76d61bf2f8222dfd538683106c6b1a35768ef236cd6f1d544212d8d1223caec369b34ef7029eb65838836e876e9e9291cce4b12ce8f54cd1ea89bdf071728e52d73b91a22d379f7ce4277ee44df0ce4a3d102ee22675cd66ffca7445307fec7200d7c38383844c1bc0d2daaa334d73cfa93c0572eb03d4b09de177bf3d4d6c674b70c2b77c5244aa6d36b269bea6a1a6c5611a67ceb21794e8bdf4d92c46556e35d8d4f3edbbdbeecf32d5168ce85668bc511e0db446403cfdfdc617564901d84cb29779e60a4bd7288709e9780ad8825034273c473ac58ebeaae9d105c67e72dad3d14b93d6ed9f703510b17b4a806ed12ba34c9874d3d7ca9366eff85312839d72023e586d1a85ba89031eefe9ffcdad48a76cd0334810335450f165bc1f4eb5aacf4484ffe5281c72da3a64219ef1724854cb0fecd853742763a9ef6285b4e1fb0a38f849fb4fb6b15a2349526bab18a4ebed3695e42e0fd26d3fbae7be0845f2a827ae8287161c22f515460a05d19a8e24f894df58b5f6aa80fea981f5b835a44086ce73755bbb0bd8371e600c624c402eb4dc72a10d69758224d6450dda26e6b029808d589a195c7a8e7a1bcb9c7de84f4f88a0031e5a8fa427915c020b3456d2c1adef67ccba5b56024521cdad8395efb67ef7b64de6e3006630f388ee89ff6815115ea532afae37aeb4073b28828d5c69b88cf63590ccb075498f3dc4d63d4b8e84b775675abcb8b06b4d594335bacaa8c5783f5b255e9c7bcf419548c3ab1031e30e4a51d4896ee524bc210c32292281802b998d575eabbefe80092d1217a96ad68c40c0f1af89a83ca4be853594ace8b06400316dd6819116254a7eeefb930c3fb7e476ee2f9bde65c477749936a28440c82fe6bdce707a9dc40a31f6569d572359827c1cdb4a8a1fd13c827a08d17149f40cfbb4f1dc32e9fafb0bdca5a8d4369737460f0a153a54ceb281f4808eee35233a1d14da0f64209a07591acfbbb310713cdbc7275f32f2e5ae52a95d645e94a40f20e7052df05591eecbdb988df6529e1e8db19ac0e938c6f75f2fff77e217c6dab98922b274276fa854d92ec523cd5f166d3311f1b18434236d62ef04d5847170aff0b9b23c1067a4b594460057beafe860c30f4cb17e7e651c2ed9ee4251dfe1e5200284f374cb9e05dba2d7372ae571d7288f36736dee1c187d188bed6806af3fa28d48186b394c07c6c04c73e7639abc785f82164989726be32f8bdf814a009e27708443ead0578400c8bebd8e439b4e7d074292c2838c925a680927b86c2384f752764bfa145e73670bcb9231bdd17c1abb883373b85ec8e73a2f06478b638b70c99add9f03744314c69ab43f0c53ade4bb5d8eb801b5ecd52dc14caf0c56d7514d61101ece920c6c5c3a339089826d34cbb1361c19f9de79122102d833e648e4a5ebddbd0c2f114f96f639d0e5529b1ab97b196f56b52495bf7c97820009b1bc2e68c7a36d3e7fcd02e8609187d99bffbb65312b9708dc50cf36d033872cb447322a3648e7990495cba79b179818b114361a1030568f53f0d1cc83f82f8e44ef5b0f5b519bd28d4f227c85add792f89280e71e75f9aefa07463a205a222878448499d607c3fa4a8a887ec6558d97e7172a0d7b3e6bc495757dc78ec30d37f9537920fba82abbc0f9ecfecf91babf97a0e90dd717e59930b606c5598551a85cbe0f4fc61a8720f11e4daeef49401675128c06533933746759d80a457365fed053e967a9e377928abefff3a06781ea4962beefcb47f5a6275c11d91043abb5f4f4c2c0d3d405680f4be286dde0ebbee89447f82c57e8523514b38a045ebee2339a48aab675c75c3efaa5d07fe3df8758c3ae183f7e1c8a0149a416925b7629c923c170c498c9a1283c4d9c786244af6147cf82f84ffb8623c7f0506fb5a65a5a6194cf361a243f8a3cd70fcd5e6558eb8d736806093ab7a1190731abffcee1bfcf8c11cf13856a63b374cce675e1137f0e80002dd17cf9664601685d158ec96235af48be0dd0f2a506b0b5bdd10294db31aaefcb817974c37cd6ae373aedd510da7c6250a635161f9d6bb14f824bceeb74cd6588b295f36fa5d84f70f39c0862035d68b8b87cbd88dec0f2fdffb45672ab67ead53619fa7147085c6860d10637a8c7af4cd6e0d7b99f00aeacb9311d437d028c965c77137342388c26dee47057a2ce0e7e037f6b5c9960359266608855fa9d5f9b88e81a7a784174838c0d4645e562acdbdb2e5fec623f909ad578a8d02776ba263ca9237872477cb2ee2acbe3d0305d503d55be06c7b511184f35220774cc06144302fe0d15ea0cb80497ca4647b23f6c7b07c96f225ecd1c13fca8e7713f9a198b557f2d5c1b0d5b67fd3f30f1baa1e10606b99e6c00581f6ecddd307000c6ff585552ddf32dc4a60fecbd4d8f0506564bd0878528e27497e149ef12678c13c1adc3b9ebd29e6b6768011e02ad8b73761146f1b41483a767a7188d6e4372b47a4264cd1f4e95d9b2027a0483533fdfcdd5b0cf811e6f15a521a118f1f5ce6c17a7b20842d934251ceae49c1657093b0050725db5304646041824740fd6f4366b57451d3b23b28143ddafec65e066342a02c0e776b16137bae77cf4ab0321c4defd02f80c111252dbe8d0bfaaf12d137f86657207e3212bc8993057f938ef112ae8ff0eb1e69e9585df945b2c8343158115128aaf34de1e9644f998371f522e80487a764a458349a98090e7ef44e28aa98ad1b1201a63eb3fe7326cf54f9e67ba5c164088b91b8c0d53181d01e40b0ca784c5222527136fe43978b4b7e9e3e40c1148bbe2c2c3cfcfcbb91b25c672f94bd81ec0dcb53af08c0d2f53f374488185ac50bdac33edf3ddb2b7891703676003d95ce29b0abcfd8697e6eb34c93e7651ee0be060456a9a397389748a455c383532985a36c697632e08c9a588fc2b115f7d921ef16b6810d52972a2d88ba722e27e44df6f7c8c844c59c77e75887911740976211cbc421e0c4fcbe8d00688fd79b5be941acf12c480022300b1b3da7ccd2ce16372ffb32e01f0275ef58056d8914716feb37832381481413da30e4434d8c4bacf3f89158a1a9f39296cf16f39484dcab1b6e9170439dfca184fc5d20ec6a142f4da4b0465b2d0cadf71236d35d02ebb51282f7f7205dac577decdc4b588c620e22fcac719bfa6fcb28001bf1141dff39660da1097ac7b8776c1f5d08c4e1ea08a650950ba7d0aa4f7f5c78a806bec3e21f8d6b314219cdc990e687c33fe85f41ad49f519223a0bca617cc38706d320f05e0ff55f2fe6e406b85aad320f6124541e7784584525735f370c9683a106356986d3ca923258e5987db85dce7b90ec2af9cc944f8c8b7166c87e4f5d608b83e95cbcaa3a5f2a0179640ffc27206e236d444dce0a336e5e6e13d38c035dab96a7aca7a589df4640da6b0abda7243ed667da4df2490b218dfbb402400cac0628e038070783d695161395d22f869de1a551600e2e748f0b2e0f46cc646fea0f6a93717a4c8b29d605afe8699bff970ce3cf2d9e3d44149825766b9f389f50c11c873ab2bd1bee41ecdf87d190485cad0639dfa6fe8b01ebed97e97c723b9d2eb3da1b49dcb78336b4bd70f7952e50e975d7c0eba6e18d3dfdb2eef9f02fdc21a9b9d4d3a6fde790e173b525180866bea9f7474fe100a55e4fddcb578dfbc7c4eac46bfbdea9e05317e23b92ced5d422fb661ffc25af89fb2c24d9edb175518da00e662c3c9f0c0e3c8e068421ebb5706492bfa94122dbb35efe29b1219cc008ede03a92a07fdbae89f02894f4101a14595f371363f73f0c107f4797a6e2e2cd2ee154cfc38706caab625b361122305ba17e306ed6a140e18d635ca7300729028702208ba018f8d6a233261fd2cade9da36cb546adfffc5a2e12a09760ff740030f17dfa4d7beff47ba4a392185bfb60d8d33ae111eede64fd74ddce0ba076e8d9ef551d85f3d585055aad8d6130bada2fa4ccd1c754216645c8e6e8429a49920192977c336dcf41a403926a3f5b23afddaf82832f7537f6ad22916be811c526de8ce8fb31cc683d2ba1550acb5723ad6441486cdca2034e969a49bc55babc73ee116244d29f54b26ad055a76e9a5bf7e3d8d2e8209485ed0d7074c8052081811f6b5e5a0df4a60e54e5ceccde13745cb152e1af70edb34375593e3b9eecb3b23b96614a009cb3d7b84726ba9f3a9a230d26d1e7f793143a464c43f9a93122b353f3b4eaf6291016fb5f7fadf1b66b04c4367191ed8abc83dd0de8ff8fe06867504e9bcd622fef52ef746c0f5f62ea0dc219b8390b73711b702e14c553edcedf0e191fbb8f8baebda59bffb9f2f5ef7e4a01f861288c777c0580e4732b31127b4de6f82a037a2f00f92b30441947a9570c1991d89a2f5c0ec61748b4b3d6706879932c0759c58dac5488553cfa9256205b8dfe2a70dda78a80d57f568747fda7e1e421eac764580f6759bca18493a249f4082d20e6c09cca10aeb929413992041228be1ee981ac690094badb6cfc819f3ef74149339822fb4ca8126d474fcaa99440b7c42c0a580892b4a40d5ae6b6c9e38c49982b174487cd30361372cca2eed91f76debf81d5506b0401e394019496b872527b0af340284cd9545df738f3663f31d5a6885f17f411a527de060c746aa5455e14dff86429f6931520d6dfe369aaf1e5090619263e8e0923e9888175bd95d0ecccbd182ded5b07aeb8bb93341ce35f123af348775d213168b031d15545256edeeb277ea0416c135cae0a6fe56ec18428e4b04eedc95c35d3d9944cba56f048a7dabdfec6d365ccd3cbb4ce00e4e412d4c1c361fa1a9cc6539d13a8cb332a5aaebe906ad0ca2b5cdb92ab1844014e291bc1ff5f86a12cf9cbd461e8e0aff6c03a85de323eddae8c24c712c72dc9c142740c141c3759e142189d625c57d1d6788ea32d830072024c76d2cd3eebb639d64b1cc24f3b3c2f0fd9bf2e48","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
