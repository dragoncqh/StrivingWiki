<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"240b1ff127c258b07081e041b9cf72fb2538979c377483fab0217e7c1f21e7d08389975bc23eee56c808718683fde9fa4a80c122d5843ecc4f4cb454b368f16b368fbd23467050b1998f10bac5ffd9afe57cd09599a7d3470842fa8e98fd93ee24f2ff1d538c9710486c8fbcd23e8179117c7f10fa5f182f1b6e39b276aac96f316ff474e4a0bd3f96e8a9220099720232d35cbadec62d20319707d4542c1031da4b2c365860102894e85f71a6cbaf1d2d43e749612c37b7c0a2b7b00dbb2b0b9aa4b7876379e8d8bf1a783758b4124f3054b66c6d0a2181cc8d21b990b47e89116343ec946a4c6d6de8430b66b7b9035e6774166f5c4e3f8e8713fe2594d5c048128824bd0e94737bb24966acc236c335d9ef3a9491b74ab8f98df2bcc058265795c6ef506bf4dc9ba1a14c3052a07f6ff1db1f2a2f4bd2f28ff20572562013eb7ef15f6290cd5bd302f15f3a40ac552377f1b01ed0206e77921d87ad7f8caaf304747c7c000bed8fe590379e246c94944c40cc2c200cd85147ae9eff6c11e94e82a3079795249985c84c5bbb1ee08b37e308b785cc0c50782d7f709bcc3673ef632c34c1cf7fc9285827f79e9842518f6ed11410290afb8151602a1d496fb8ce0d3356d65c9cb88d0d3a8619ababa38ead19ab15910ac3dfff023da94f1ff2dee17029c5d623ec0c3c52a8c809fe993d324ac8c726761200742cc7d14cf08a3e145e6f963e292d1c23eba8b6e92e1ff5d92338d0832f4f39b9e1e54153e8f35a493e296581f8e7c8cc79a79ff01995f5a989ca515cac864b8d068e2ba05227acbff9a40858d3dcc338ab2f0c71b214a11a2f15573a131220d89462f848639b9be15e0ec25014b949b7859dbdb3aea8b84ffd212751742ed37846f3bc6aacfe101e4e00bbd6797569e226be5ecd5bd5edc0ba3e4202e61d4bf6303c73bf94042858c48e32c34bfa0d34d64d64d2161cec7045c885d1d2aa0b62af075ead99fe58561d1b17a5d032f41f856c37e52e2a3efa1ea3c5baebbae3998df3036bbf0679b7f0a7e696a094497969e998b403b75fb835f0dbfa0d2dce99d1facd67f0e7a25a98baecf6a3c7ff7e35c5c2cbb2281f0ee289400fa58431ff5fc56feb431768a234431c600815b40e3f9c8910b5312a5cf441a60607da00cd306a9bf8e9674e468fc6fe29fb41947537f7701ffc8641b10e506ff996685a30cb26073d3258301ef9aeb86b942820feb6ea5ed9b6a5d9c67a15c1ed9eb480fd458f5d186c4a96ade75cee2e6bf4e141f30b2bde893690d28663ba83f48fc233d468ce9f2208c209b39957e53ae42d608350ee594c87cb04de4445d3960483b4b2a80cb9a26a4cf34f1922030a2b88df9ba37e92f8bf115758a8e9ef8b08077547a522b25bbac91e928c2e3aa38e88040353029cdeff71525f434e0453a4a39c0464f8fc2e70c6a83c42952d52bafa16c263a993cd8ec784ee023be1211a2ba8e68e5292d0f6342f4c02b769f469a1ba0ffbccf2bf5a268b0e5d36c4c9b2919d128c4c9f30dd98fce513841deca41a3ea35d141e8997da8e37c31da2d9b3f06f8c2f85e249a23c5f1736567a37f6367a1737ba3c060078c8ca0a9a8d98ca6e05981bd7886731c87a6b7971c4f3493b3cfcab411a8836224df3eeb377b8984cf9f665c51ae6c891823f0326679fce0cbf2ddbc8baeb847fabc08fe41d17562f97ecd897f8e900b15c27733449d909c0b32d6b22c63c598fd813a62e0dc37b0e165dbbcc7f53637cc022879a7e37507e017943ce9413280d4534d8ed1b34d429d454664cbb3207ab673ba824a6183c04ca91efab1440ce125c3bfac9816d29b3d036582e13ee6b6c008bc625ea6769bcddaec080b907d12b8ef1aab201f96f2813b7e6a4369721ce53ec20c70a6b64699412c6475ec5b9fe8a81dc0bf2e29c1b94d1288e4ac03bb6442588c1bea05f6273c91accf3174be27e4b4456404625f7f77bfc988eadc37a41967497f87cb30c0d2dfda49da50286b858b9a2339bff8a7418931f1875002470a428866888f3da77a2646e33f24b48c255ba8316374a59c5e9b935cee54ada87be025c8816081fd327942a4d4a688b27d7e00ba5b87bd87b86a144f8b3f5037be8381b1bfb6bd58e4e9a21e92d432203d4d1dbaa1be7f63abd1b09ff7e8e8628cdf2af0682f0e952f4d947ea444945acd996522cf9b1265e1822084bd6944f64bd7d64ca285dce38b2e7ab306d585f3b175a2ca921fc78d5539151cb78d73bc90f88b5bd7e08422690d92cc7f4c902bb6f80eec27323026c9936b890b19a471df57e5eb2e2abba3fc0c2d7f81daff5a7c807eee782e0bb7e3ab810551eafef0590286787d7ade5d8bfe3c6208f5cd9c4d1b0031d27517d12589890f55735f6842a7f459111a4562be38c485c4accf2448a9986444b4bb174226e53b1f69361c59fbb5751bb82e9eef9d1ff18bf188ff9e38953373bc37ce4496ff7773c4dff7d3d9eba2eaa7c741e986e9d093fa9eeb03fa224ba8b555ac3c9dfcb7b3ae13b619247e34c315e5e2ad5f174b2dbadbca63b8e76c7db37d28ada759f2a2b030b71480b7aeb71cbe120003276051df300274dc4abca9fc843885ca0327876e3ab2a3b40c2b52d18a7f0edbc2d40d9a2f8574512740a0009b4b66f9360b192bd9e1847a072e1c926f913919af4aa46239c0300e9d06cbb3c07e83980e6d670a7b93d570b81768eeedddba1ffb72a732bef44b233233f18d7ac3054c0974952561cb0313a9902a8d199d1c41e2f2eb6ab2682213fafc7011473645ac4c21876428d42d2edc6c06face3811209732f35443b8cbf2d936b8e4727fe78845d927283eac0e14922c3e731650b49414a56db2b23099a0a9f15bc8870377e424f082223c15aef727a618bece1383873227af988924e227c9aa100261d59ff6125c9ed0a0ebae7120aca40a77b5ef7d7b7544fe9c983468f5765c24402cca40e3de608a4bed7c7db6662af1257bcfe1628a09e03c1a778cea0d07e3cf7351fe7f686739000d635d6515564bf958ca84fa8912d9386be8a66befe13ef3963f386fc4a17657e9bd0aac9bf1a0331f4c03000ff8ed61764d09870bcd6a3048868c38c483b3447b7fb48aa9314effd0128b4a5c93dac39a8933e90a00a678e2de03e2ecbfb34c03643f3e87d66308ea20fc496aac5580860936e1eb275b276fe1bf4042c38e6cd7cd8e457dc65e4bd372ded2b5e2373a6d7589cb766730db7caa92f2780faca52ed75cd1643fac677accc9e1f9a0794251b04eb78ded42821ebd22676a293a60a52ad29090d5f477ef0caea039a66011933e411ac16e4dea6e795e84934e5e1f56a0942e9d7be79dc6683c82ec05e90c20ed404b124bf6704496d150d33e418d2d0ba7460ce5df4eed8a7f2d8d035addb833fa59c3a886f31870570b6b920c04054445be4cdc605f759bcedf9e5208ba20d2878260ee077a1a1c2d7731f7ede9f6f00502dfdb006090d04dd642296cb07adc41291f2bcda3aed5403c4a9cf30292a985640d702aef060edf43decb6d55598c206f3662e4bfc789eeac8835bcff0ad075aafc217cc82fd298ec35a9aa16814ef3c27a8c56800ecffcbd07a99c11701c020bffe81bd233cac7231959ac03afa184a0f21679e05d17aeece0cbf64f86dd04f45edcd25d932b607da688af4ed956749a0433bcded61b486a28376095a3ce8931b7203ba7e26413a8fb4d0dd8636fc3ef1670bbe4b4fce3bf19899d57d5997c4be50f7f985ffc3cbaa823a3fde2209d7d6d55f8dd24c02fa68ec2fc228ebb3e0c1e5a1149e9fa3682e939bd1dbed6c43bdf0ba6930290b6b64a45b75bee1388e5cfd2766ba38e3d4768bca740f40e4a09437182bb6c4078a99f578287feaf68d359cd1bcc5304b46c7017e1c2128b2d2642d9a95176b9d9bb89bac44e2b3157a4ecc2dabb025b27068c1fa969e2abc0670787c11b930a8bbc48dfd8ce218329a05fd396317ffc42aa0f0d7599252f1a6bb0b3334065659e06b4104a3796fb3c3bb94d1864cc1cc30b976117968b6ca49f62797f1a13559106233d8ad89a22863a0f7a3727ee1b7035ea52c17bc3fd32d95c1b3409f9d6fd19f7c7e23a04a3e687382229a12adaea8cf3154e8810d4104701cf0caae48a54ff64a5165ec6258c030b2f33e27387f287b934b6d6cdcc82e1e056993e4c7bdea5a52d60db4081f4443c7f8f449d542d72a51c6f749292e82b6bca759874ce980b66a3b01230cfc7d4065ffa8565dd3ea809829cfed487b63a42e9830862d94ab05aaccfd01eb443c720fc84c56658a6eb185212f442f0ca536bd3661c0d787a197a14a8dc20e111009451408c0479a685549e87ab06bd3c6d47ac0019dfa8bc7c64d81111115825f2a7827d655d2920b4b16c6759e14e5b0e75183a4782a81d7ceb80ab4ac185f29b5dfa4cfbbc9d12552addb78e3f8bcf09c6e995c01b843a964684492212b11bf6ebb55fe018e8e0a0139ba18e4e373d200978095e47b1070a870ef59650907cd4ffc3668eeb4f6e41113714654ec3493a3f59bda38fc282358721ad2b37fea54cbb9f335c0d46c81957e1932fe82a0f5bd8c6291fe73ff5cb3814a4c607bc5765205eff23fac6a5a90166dc8b49198663384525ed20d29611c163f6289e715faedbc7e3f0c691c2b3f61a357b38be4e4978ff78e67a8252f3f9319778e1a58acbe969a7534b211c2b704d03478fc9da3aa9abc342bb661563519ee7f87ad37d2d13581eea2d873198465a14f44adee64dc4e5d6b2fce95c5265871bc7400df33a22a0b0931100a042d0c35f05ef098d2dcd38e1779b125e5c220b8cc6e879346259cce8e4caa0a26aaef2e0c647d7bcbb16a42b322d71c8f69dd7976e7f4824be8ee90bdc78b496611c52c55ababb731a816589ee03af170e610985cfa256453ceb923c5805b388e525c65f479ddf99ba7a7c2a2c3aa0fca847de5afaf0de09c437bcc16fe3107c7103c501db9c1602628011c98a880df26410e96688eeba3d4a12c39b4e049cfb6274a1a71fd8f70c8ab73ef24a8eb52ab406a06eb7cb5a7ff1773114d6ca2eeb3ab4f8326d707de8c4bbfa3b8e0db621e02fc12b11e7b8ee5e09604ef25e8d909a7a08f7cb1f02122a577092c8b9e20713ef97324615779f5c3c0705ade46350e1df7eead55cb0e4b1450d29b263ef6af3e684eae8c15af67792c02a2aee48f21f6b58c4ce71ce27b4d28defbe79f15d8f83a131df045a018920e46e30ab4c3bddc519915cd93f0f271e89145495562e0670d3483fe657fdeb9427e3871d091c2cc55b2a23f635d0e4d3c657446c4e03e81812b9dcd26b5f5b5f1e6c80c9f5e79ae70e6627582bfd40097ba2a5e594cd8d5067149690a003c3ce57395bc8f3d53f3798c4572db20723a5c50c3b3f3922712356054b80e78ede3d143ead58e25ad3aa4840664b681de675902bb07dcaba926ad4547fcd049b7e4e255be1d99f46ef2f425ed19798aac2d63894d04fe1b35dc1d3401065a0cdc5d2d204c536a5d500a9d08fc6b966c81c36ca946168cad712e5c6527e2cde15f93935593cea6a278934c9c0611e68266ddb4b28dbbe58e5713396092a515cb9a6b441393e28c7c1b3c10be1d6322bc03d5370c4caf22d58cdfd78bfa1c806ca321c7da4772fddea55ff25fb617bb445959504734305000314934fcedc8b774905bcae69275dd106bb42f36a6b8391bff3c9b26b16cd6b96cbb2d35b1dc76bbdf6e83821f6b6d5c01204f752fc326b040ab27aea313eb55c421e5c3856779655d171f0de20a84434db2f6d9c6c51c81fa268c8c4d4652f72461de48edb604782ef7339f41b0d623a0f59c9384b785b370377b4a050babd2f9b02acfc54461973c151f03cbf896e608774baaa59ce5ba0ad16b4f122ce4c4543217094102014dfbd6cd11091f10eb8b88767b3aed486349e5903fe49bbc720c53676d92eb2f089dda0acae69677ac8db17aac8416a7171859959d36c55e15c595efcb61855e2f1910be581f5a56ec67d727fb2fafed1ead13497f7ce0448c396d808af14cab074fe8e6effd646276e40bffe2b719e1b9a1e244bc5ffa1566d40a6efaf9631e81a497b64c5d1cd698345b1b8759e13f6b82ceb90786a8da89ac3271703e5e1d734ea9f1d90dccbd23d8de89a747015af152277047a78ed8df2087a7291888fd45676e5e1b6219bf4edb88d0be01925039d217a47768dffc28c8ff81b79b4dd614d7378d10ac2370da7db849e1eecf223404a898c5e0e7be79c4bdb3c98be93b75c54a1828ed350237f13dae1fd893d268d2f92117879745439cb4deda986019becdaa7de424a4906356442c0443de95e98cabdbec1bdfa3f69304fdc1763095f394b6060d0fabefcb9c91c4c8b908c81de64c4ff0c97b3fa80124f53a6f15fe581d512a9fc971d273a2af3554f70c80ddcb6021c70a5ba7c4b9e5fcd04d3a2c58e2d119c29e815a5a93acbb201a38ddbae6a863e2b3bc151350056d34d34d3cd08b9e0707a58f485ec3eb657153001cfd1b30fc33a58d85d22f2a96e6f419a5bfe86d6656bf8fa212b206b40dd3ce51a7f967ecfa40d55f92a5e3fe86f7813de2af384d807a0332b66cb8e86b92cadb1b3313d507f47d3b5355c989dbb904fcac347ac3a7d75650ba9118e7b02f3fa552e1cc1abdf9975b3e4434e6059dfd1617ee627be53fbeb9e8ca50b3c77e00137b171582ce7b328e2cb0363215f04102f301e463db423a86790ce3118c25842d91546afaf0d68257fd450c122e9cf570fa38899081feab7a8de45fe33e6b6a495e2f3ad0749258f7afc2745bb682c2907993ab50c7f8eba65dfc573a9b491db759924639b0973efe420e5cdcb5e0dc020f2b09b57990405b1a5e5a3f9fb50c93763a1fd4faf7466ae4152e6431a146dd141c63cf34450107a0e201266adf35e7989e44ee4a853ecdaf357198b2dbd16ffa48c729131ffa3000bcb585d8466f7716fd9907bda94e2ffe1cd68c68deca0a2c38de0453e1ea91b1241a2c3015ea0c51d24b6f8695fb5ace9052f8dca8df41b7bea493b0af95e47efe4c4e72a712833f793150d926c2e33b5fd23c3e806b53c481d24b6c9095145c39af6ed524006a3f1c1433d20801d446e56c2ed2974720a238a2575592610a20086bfe0121b2cb75ea7d3c3fcb04f7eee7a7e4e8c318bbe85de9aa49d2cb462649b4c2ab660360800efb0ebdd8c603e9bdb91cfc73632fff96b7fe56ac83403ab6821df02af785fcd12ac5a51d21970e50b35902eb42d4704bf83b53d72925e03c304c1f9cc674b3e17ce75fcfc0277a1b231ae92ef427121d15684d7a1e44773d9a9cca38a8a88ae22697d436843f49bceacc307ed1d7e939e6ce34dcbe5c8751652e9d2dcdf088c4e7a312dbe9bec687d458e3e48316f10acb64a5e001dbfde060b6420bd036c2bf0fc790a73feb34c00a3f9985086536ae061d917ca8c64fae47303a4609827bccaee42537e44bcda338a309180b794aed2e3aa4bd45b704c3e7f20e540f0d1db1047623336a84aef46f5fbe37b88fa0a822887894a9b133b0598d877d7b2c0e9d3e81cc11cbfbf32456e53125ffa07978632c9f0153003e5c15548b3865e2c61e014dcf727fadbca2f5cae9357bcc88346852a9d8730d5e593809598779609063a6609829cb7b84e1460fe25d7a75133f543404398807e4d51724b15292e34a05abc58b49731c76a8393a9199a8209e5c0ee4c1d4071aed289cb77bf4e1482a491cd1e189f2f832e5be7f6b4dd69fa565b60962d76f1fa94caeeb1f108d1fd677c4aa215bd0e153e57fe30dac2adebaf063268aeac24aa44f275614f72760d7613457def0725c8b384eed6b5cdcd97ae114db7c2651a499fff0dac2ea8b3c9759003d6d22fa7d02bdcaffbe77a5c10a4e13c6b98a9c60948f65023e749f5fc3fc29a3dcd2da64fc28f4ecbfc75c2cb32ccc9444711f3b439eb9343033472f1896806c246a71f0fd09c7b3fe6e6976d6a3bbe25e424acb001323672ab2166dcb2d8d68a6bc60e3098645c822b2b580ccb6ff5b66e1b3ab981d2fab652a586de5aed26ca996673a9a87781f642d7b4bba1d268396fec35dd0cab6c419165dde3d5c45191e5965e47034ba50e757b46deaaa94fd32436b492ad4b69665b7e5699e5b310c1077571cad53422ffaa0c6243a8c8094045016233b2f4765f823201d04b53784ccdd1a4797cc034629b690e080ecd75f5490fe10f7e20b1c77e39f463c7e0eb9f5802ca19fa83c7a50a903adfc9419164a8a37282b449e025d9916015f75cf7947af52580787192eefa479b871bb9212f9df71f59fd265dfee27128da63990e8a144e8a6bd26326c20228bfe2d5d9651b03ea3a86efa7d89915d876bf1bb6ecbc72529f745b65de9c8cbae35019151909eeb49952ac6a4ff9b72cf1345944a10e71730eb719f15864a809f3f3011a1b4773433e31d29a513c8c061d8350d0fdbd3141218e5d46e104a3f2dc308e1def7d42f34d9f6afbdd6adcd6b2ede7019062967db9588a95ed7f9346d2bb6c4506f250885cf10779e201e45b335037390f91761ec6e9d8b2a79060ed77f5009960449e91ea9d9042be461467ee02961762e6d867c70be5bf18cd6d610329486799defd27177b5b7aaba22b17f97c921b351b6112a13db0220c987dfb64a5f84380a0af6af9ab4ae19f78bc07699e72ff63aa1ed34714c995c0c37c1c64231628ea5b318b88554f2e2f591fd7395627cbbdc8cc2452105c7d3960d33aed5d0159ffbaf02cabc99022d2cac6be45d62dcfede4fa3700b43fd7be3dbb7b8db51a1f5e0fb666448572590b614c8120b3f426aceb18b9597451d3dee655534120600b6b8be37dfd186051583052c1310136e6f105d58aff4c76f2bb51404c425b6016ea084569c9bb7ae129b37928b671a237ca47bcb18403ef4fbd5c13fd7f82f8925ea5f08173d2954829f3b4e4326b869b903b26a13447e31294ef5aac233ba28044964e3569898313e94befc5a6e71fbd214a63de6de6c55c90240846860491ce418557d5b5063f2457ab4c3aea5e4c5b395a974eed9895e39b09427a9f28d788ce7606fd80f1f517a66a73279950f98e6e735220c4abc132a69a944bd3eb2791eca405f2fe8415231733aaaab0140d970a110134042b243a029eddc23955518fc3875da6ae61137c545c124d326a25fbcb8229948f3d62f0f212cef57202ce5ac8162b4eb11827814c2a7982b4af9d9ee33f575cdda6f195354b560d07d386246659f68ef42cfaa537e2bc4d9bc99b4059a5954c23313bfa8e8ffd1e0589a24b3b371b9976c68aca96dd8c8f787b94969394743e88b7bcdc5b2d17a7d4d35895fd26151026f9672e6fda1e6f7a17713aa7561c397b33fd848b6930bd610ce0cf68652e7ae79950e86e0965626cc0dbe7824d55d65150cb82bcb0e87c9b51afcac9bb0df6b160fbf97bd88b4ee44b4b8f9283eaa63db3c1f9ac8705ee05faa5122d322076a9539ee6c67a7d48f28a37715809422937c5008f61f74ae82ec6a0db8870e5b47b31e1ea372e623a1a6ec66c2ddb2a5c11a29f112260c0702801236ffeae2b580f927e85666d4cb8810458b7f75cc7f71cb9def6f29c8a099f59f315a5a7ba36f0ea8d19d61f9f2f68f58459bd5bf0dd7d4b912cdd9de62bb1f98cce0e4926624cd207a2ffa0807459994e501985c082a14c3a309923e624c0e10b352aa1f1fc3b26302fd115ebf91b20c6f3dd9e947898d6be7a7234b701bb496c24c6ab99b645175062ad6f49ca027a135c099f6496c5c95ca8ca9b053aff1d3b73bc2482874cb1413daa3fa697e7cf51d3808299d2658e77b9f02c03473e9452d5a6c61da7690996a2172fdf607a107a29cd6ebcb271c287db5181b54743801fa5aac634e00a269a5bb3269f10c606a40ae944f6a9e95ef85a0f61a3c99307c6471ca61185596f8ce7903678101f4352de4bb2e6647ddc58b64912a6113b70454444e16c5cd26e49e600677b4927ae6916a99e780132b22a3d8693ae9b9d5fedef1a6bb9b894ae2177ea0744ec8a2115e9bd8b367165ab8d614732aae515dfe46fc94d8fc45889831636cf59a82103d6ef766c3068031f3d64f4b05f727ae79a2ba4e46f4f248848750be453e69611795f1d193f406ab794b6c699949a7157a7bd11aba216b8fdba9710a86bf7df1721d68204ae423d51d56c76142e26b6f7a0118468326eacf4e05442aea1b1658c930dd13cb37b2529409c41545cf5ceb42bfd18bdd43a151385c8d915028a86e10d1a21dca8e231dcbd124e2b12ce8407687c4c31ff755b095ae454102c98a5cd8f179c61ff0027aa722547a54ba57ffc7b5dd702a7620ddc1027db99acbfd53d876a3300cf1d69c5984048ef939","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
