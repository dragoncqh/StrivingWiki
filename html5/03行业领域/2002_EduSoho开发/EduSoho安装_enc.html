<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cafb03e0b7c85f3f6d36c93a83c916d5f4cbb70f2d653259515b545d2c2183b3d55f57475f3e74a89318111e7f63b9e8e70fe529c20d57d940dc5a6c0ff7c171dea5a44510c0f248d4c0e174ca3f4ce61e6cf3d5dfcc0119722fa83bcb7a27376231735156e57a17030125cc637a3d4f730bfb3062c3b9e72d76784a7f67873eae5884863721d5bd0d2ac3da12ff921dce960fe324a5dbb5a7bb7255b69b27e8bedff91b0f81f9d977aec7e5439703819dc402e3e1287b8ef38e249fcd52b66bdf1c5059cc1f6fd600fb17d427e800e54c9fa4013694787ba7795703c819d7625d38cb833f64b4553d7854410cff60adb92667755ff35fa1ea11620c9906c9d10f4c7890eebb7782de42bb7d8cde66b8a415c20e466fa592e4a603b6f25588eb1a67e916a4a5fbfd96bd42ef4f8b39443d309b3f19c6bc7226bab639e9e17604d01ffa56d87536c9f16af55fa62081f916021e6146ad5e56d449aed0f07921d0ae37445689be50e4f0c4e3ae3fb12e0610f405d0fa62b8ed104f6b87a6fb272e8eba1bc2900f9ec745b0f481266190e1025a66a4f757ac21d5694607daef466309f264a6aaeaae97667c8304695ad8cfea74a025748767fbac3879efef2f4995c80b2dc1e5ebd95221af22925888d9f531fb815e47040c96836ee8013e7172fba2f5590656fcc6ce2fc48ad69450c3917115aacb3a4db1953fe0da36622581428ea4708899ff0edcc3a7550bbf7cd9f21e050057b53a3a31b05b78104f4d2d999d504c93610b315aab610b2f56743b36d71499864c9b8813bd43690a320bb4df6902908e7221dc6087a1af713f6bf4c36800ca85c820b70c913634b78cd87cee35b0361187ae0242f6e161508d5ef6727fbf7985d1dabd9bbd3ddb8f61d29883996b23fd7b8d2e55c2aededf60e5e715f0be5f88795bd8bc277e30dedcbc8867147a2ff28e809f63ecbb4bc0ed65d0c8820e558a9a4c2d6bd40358afc6fb58d4f08eb5974e7bc2b208561fcdf6259f730c60d2cd40ee21ce696d859bb8843c58c2000f4d9ca38caff4dccc77c37797fb0279063f2ac1631490ae52f01880f5054ab540cd14b00f5f81647eb58c72054726ee2866c10bd9b430b442590cfc3fbb858e71568cc573b7fcfc8baf273acc7f4d8a2eea811717c2b524fdafdfc377ddc742d12f40f2a9c34b64511b103ba04069862ecb4e670f2e4c974f85effe84a71ddac5e4281749db7e463ed53a25563de1ebdae3ca5e3746ab3ce480d87e737423184619760944d485a76071897b41e3bb18782c662441dfc6580b35cd62e8e7dc42e1ae473723d3322205f33833baea385e97925b6f5598d1dfe2faae24d58badab6033351b1b84035ef8b790ba02a67b8e5afc03cc6eb3d6283bf84672bfee4f49c70a8f22148a05672dd4f0008e8847ff3e63be72fa83cac230cf6e77951d87a7a855bf5edab9124d33345139366101de3454948eaf5507bf9ea01b4ea4d304d9d6a8032959b80bb345c897d1eb615f00038d6c8c741b3e6fabb87da3372cfde6508da424bebc1df097a948df8c9ee2f7194693a4588b14b19d268a2755dfe53d1187f7bdde99f1b69e29e646f3f806404dcc2d9ffb2bdbd53db2afee11067a16ae0d82c56f34be70c4a476d9a3eebbcc8d8945805a2225c6d49c604df1eb3f581497932bc446826e20f98f1335853aa57ed4463f209a9585dd64313f518c0ed3f4e69ab09016e1dd2535e7e7f26dc6d88a06bea0a3c3e58e94122ca795ed7400a35687b75e933a0e2e15212ead81d4934aec300f8115329e9e055228c39b5463958bfd5557ac8e2b24b5a7f4f637bbc9b49dd4f69cfd1371d7ffbf2986709b0dfa96586a3c57c2fbf7b22ae1525af98a7daac7d2f027a131c4ce1ba8e70d240fe3f4616712e5e620698afd5df367d779fd2b60292af59a116058512997d9dccfc75367a2554c9f9f81586fbe7a6fe9d3361265b2b12b2fa9949b4b8db5a62cbf316446adb5389e55af146dd0dd74913c48f1a3d219dd2d9b25b735c046582916d1dc6c314d5e783367d06cf8c75e73733c2cec86a489b4d4da76c8f87024125fc08bffe83cf72143c587d548dc1b5f1e1b84c49fd36d814f55229f4d8acd8c7e868d17ed45454636687283320e79554adea8128e61b16b9513c5bfb23a07f28d998b385e4d5d574ffe767c7da5cb677943ed821ed9b0aac1b3a992447a08c13aa8ce614498291f1d1d3604173af3b2964bc822a90d5273b36d6a4b8f5bc4e244a7023f02055b3ee6bb498e629b3b90e7bc10f552708a49f84f04138eef5249d59956b58544e973f57f13a28a5c247fd31df49d47eb1a13ec9793854fac3299f60acf0037da137192bb89ffc5a7657551b3088e413ed0237397faaedec83a0ad44967e13af67fe58fdab54b7b6d706fa1799e951af14508a4a73fb507a36c544252130e680f9cefcddf556137074724a1414a08db2be782020095892631302e440cfc7c441b42325acbc4df8099a969c91ed7657cc18b5388448b58a9d3c99c84e9e2376ec6d271e50a7a65c2172cbc52f95e5d1faad80fbde72f763fd3a42f16e0acd9c7595bc134ef4f6eb76eb2489a750c2e9167b6c23956d85ff8b689a13e0aec5c07d7b3dd1c97771f4f5f9e1fbca1cbc7a4f650ce38fc618e5c7d9bece5a21383d4d7922d8958fa1fa70d88549de6de433c7015ca0da92abc29673bb1ccd08385d147d7e5262ac1858a3d1e42db229f660c9089c7279b24a2a362b02a584d5ca04d61dad518c0938f4fe2c8cbec7065c87efc45e67822c73aac78e694aaf742e09bb774545033a2f44b0de6f470dc4375c5c7d75f0f81add3f15e51b14bd9b9ed556e5417a80cf78b1ec9fdbd4045d65330fe154e6bb11bc1bd3bde7540bf8fd41f99481015c99ec066caabd0ad1c0189e4ddff1d4c45a3823c20374efa5305105d09c8d469f480b82eabd799a29b21124dc14d05610603cb5c8d300f666c03525d7a1a9ada172159cf98be46af80f9597d86e6e82bfd23f0379424f4fe8599ac4ee58526d07102fa0928f7463013dd3d653a8eefd8869e935f471a9818d5bd80c175f1b48459074152c346e438e8ef4f0ece2404d1b3ea3747268eff830b5621f40f9465557104e660e0f053e9121153f495386b72b614db4af57e641d56732d1bd0f9569c55e4dc3dcac269d183f40b2b48333a45c30203903f7c22916c2547fdccc45c2549384b4bd9b82d69733116ad132ab19629dcb7f042a229500a08ca46c0ea303c2014142eaac464856ed1f41adb2f7251235aaacf6850116ac745de992c38da5a11d4966dd6c94bc8b74507dac57eac87a4c8f3024a32606df156d99a981d41cad37a04ab3a47111d2fe7445eba876455b1ed4bf897712d49dd46cb3be720cf51634bf71575ffc79c0d5ba85860417b210e48a2e5e2775da4d33f2913e1c53312b3bfd01ce1cfebdf3984060c55bcef9f87d4e9edee189b9f09f03965bc772662c304c4b8a6a737029177e1272665bc2f035833dbf636440e6c77d927b6f89c219cdfefa7ddbd04ef1698200afb7bcfd231635950b270418c2e5f55f8204b27dac4e254cf79d205ecd70457163e6bda5d194f061a148a516cd6e7fb532a368cf15ca752f0f095f79ae90e50dbd9d687803d5c4eeeb5b07c171b6483f7393407773f2bd4622d7a54d721ce5ef490e56371686979d16b8e9b79adbd875d55df48d19aaa7d87140a6efefcea491a3a4a30a9b74b361766949a19677e16be347893f15e18e9b8384e9436801264f1c26c13b1aef2d196ff98bdf0bb26d48f987a24e54fc13a26a0b5445a27525d11460e843b932dd7c6e260c5320457c5fdcb587a63525250fd39173dcb6bace03c8448f688d1e2296dce5a026c87141f152e32c486257eb310bc2e6513970853337ce5d198a5e2a563094329ec1df7b1044a0a3bfa8f4fc6bb48a3753ac217393474aa1cac015104dcbceac8e1139d76f8fbff5e0e47f87c10362cdc6cb70dab1bb8c301b8f79d73d3127ff156063ae8d62937c49e682aac81d9494855e80c253cdda7dfd10ac2e9300178e3c16094148376dff746fe801cf7f3382b87bb0f810673ffee168bb7495c17f282d9c4fd947ff4c67efb1ff9eb514bd67a1b6ea5fd65d888931093e07721a1164834a75fa98082dc4edd4a8e9424791f3c30c79092583dc8b0ef35700cd54f96eb5f3d234050e7ee608023ee99275db4def262faa42c9fedf900ec9844c3ac4708230e5614a794dd62ab7bd1ad4e71baf62494f07a4d224e4bf8bd30c9581977cab228d95a3337cb00ff59a4a8292eb9dd9ad5db70f9189c4771891a8e371440e29e9e7a8867bd01753558fa5a382631b8209a5473b4cf12f5ff243c19b631f2de0517ecdd6f38bca811575a057a3765f809fe05845fa82eaaec356d90f7bf092ff269142e555be4bfc40c58d8ea6bbd959888d4566b48930a14c8518ba6f71b30000b6f2e4908f37dd0a907c5e80a68bab9015649ef8da1c2f86ea2720b4c89bf2398be6b8f27d4be14c7990d5f5fbaac03f2ef0959502d4c9a86fa1c80339d1889d55854325dc6bcc87abe275feed1dd4703f2080267c8d1ae9647ee672831d2e9c2fae6a8f764a530e141bd9057116b8b549a9daa9570dd8e0332d7cbd58ac10dd5626a43ca8cf446425194d54f2780ebc96e1f72e7bed0e793ce78a8d2fe7628de059cbcae0d31808df9de98e6e765cff45bb827d8ad4be50ca1b551e3f67d3c0a3ed233f2c514c2ec6369bb79a39aea075d92965869036721ff1d9ef6923c57ce877d7f4d83fe738c75099a0332e3b421f89511382d317acea1612854131fe76c3eb7c1f0e84400e1a36b01b93aa397a7ed7ebcda00f4d6a8cd103cc9943fcd6a147f86f95f9c045d3623a34d25ba7530c455e31fa1612cca19f96866fec5d2bde1b500029efe53ee2b0efa3b77b170e27bf956afb45181095595f9103924bb06a25b74769ee3460ea7f84a1ab23448b3c05881826e489f1ea4bc3baaf775d87c20961c44d4084dbcf1f4e69f3a3a85437cbf6171fb3d4379830754b96c3d3037abf6a4287ebf8858e9ccbae673080bf8cd9f5133b8d1f6de98510a9aad5a030cf8867ab2f3c6636b41a0d4f09d3e8ceffeb2c1815fa88a347ca2f266a53045bf0db5a84b25279184f2383be8802d67bac31673419b42c05fabf7ce0c1c141ff44e056e36a39ffa4bd61dda1c55d060c1445dac634cf371dd606db4471bf096c97d1bc33678fc8fea9605fe840594278fdaf6ab57df96430a58f017a746b33c3f02273f997792e8dcb904f3fc56f62cbd6b9bc10f20b19152b396d8eac0041048a163a05dd4d64d61a323cf1d5c1750ec7a6ac63694e77007fa8a5446477d4f8f65bbca975b1b7711f55b689c61b297021fd33bfab083e0a90f358b1ac3117596228af4c3daef7831ac9dd153225b5fd42ee6c310ad198bb5a5d2f69e10339b323ae81d9c5cc29d31de83e5971f03b7163a83a48bc4729e2ecd3597cc86a50075c706e11d24f52bbb9fe353ecc8554390550737624cb01b6bebb573b872ea853b496f3b9ad12857cfa5056a5aef0f51f93e07dacc8e8bbfddb65e7ef33923bad1a3e2ad080ca10401163cf3a63e6be86eb2a26987a88e8a5920735aff42f00ab8880b8b512539ab24dfa35f7340efa32814242cad38db2fd2806d5f703e858027e084461d63af9d014de5ad3e3d7b674457e20ec78545a749a6a51271d95812ecc247e3a2f4e51fbdaaab9ead6ccda067b9e54baf70ee3e056da9e187200e0bda4e00777ea5ca19c09c2af500a4286af577734adebc254a7464060dc1a3f843680128fc7449218b766c7bd26f212100ce786433768d0d02c9b6c1047bd8c538a9398120882924033885e645ecdd874227475947cc98b6af3888baaed6967995068069571439213850c879cf415e9f24e8dd668842ea8d1047f50bb12db9c8f3087b28a2aaafbb51ebbc7c34437a930bc140ef1968f00c09abb49ea4bb1d5830d7a11ec5e676d9737d198fdc07fac06c862d5045f7bf0caeda9bd22ca2230f7e2ee64fb081ea642ab1f7ad94dfedadedb649f499035d330d4f72e4d77ea5184dd3d59922cd641df8bca6c72aaea077b6bdc5ba97c1679f7f51de20f10fc6933a4bc796457dcaaf91bc5e6d263c75c4c2c4548b40d07be6c6c3b05a0f18523eaa075ed7c9f43f51eb1735b3551bdc1d3b675da6582dcfc3e97b5b9de4b854df7ed28d0cf0ffc717ce2ed6438ff4a7e4bac6bb88f61fd35777806bf012417bd3808efdcd11d087864e1b3f3853f9823889e6c0949093718073b5110517d3565b6098a32a278811d2798cb4f0afcf2843c52133b0dd087946e1c3ec8272bd8892857c89a78fc4eec4e5324efbd812070cfbef4d6525abe7d33805ad931b8573bcfe1670829127a1bc50a79d51e56de0f3ee3a5c5d06d303e9b4e1594a2bfaf815a4eaa6692ecd4a1025d1944bf47f067de09ffb9621bca62d5da1f793a1db6518cdf67e1034a6ce085bbe7dfa813020c4a0dca4354a1c0e812477aff8815f4742bbad878d39cde3223ee6a046a14379209423ccb8d4864be7bfe7695c4f446a1528ef46542fd40aac1b0c72dad8f59299c528f91b4eecf3d28156e51a5b1da6a21e2297325797e3f8396db8de27e64bf1b4a808dd83d38dc50e540ed3fd3afbea72f35710aeee9f79866290c30bb31f5fecaff63cec3b316a0dc987097cf5ecbcda48640c96f70adf74948172f8d915c8cafe1e4cbe8881eca5cd923d09b489b4bf1d16168348d2172b35a3f8203ffad5b163b194507a45c29a5ca3bdd25923762e6e59e8ec20e07aeb9295f35fffa6b84b86b720105e8da00d70e50aa89bbca88f0cc7404fa872e31b95b60b5d1c747aaa27e9416fb76781d36954d862bf42e90b6f22ee0f4b05af26023f725992f977abad90bd4ade091c4f47b7d9cbd1b4584896e2fab9cd521f45ecf413d98c6a1de5fd07d96823f9bf0cf193348ac9ddf2f61ea3426f70a35470c3aa2b2ac07b942a86c4a087bdd821e613c75dd9124a1188b44822032d9ce3542c5d139f7b839cfd5c80d8d17f10f26c17034df335ed90d02c4bf105e18ebc0419f1d0e65445b492b31b764e92a6c61aed6368c2606e6fc1ad1bd53aebbbf34bed3b7baefbe4680c4209c8b9ae1f21cc2033140503898e6cc045b35835cccd5708d1805a1c7813db4de0680f223dfd9980dbd8934556bb25a8f4191b365060d8f4f85a3b9392f44379725cce7a7431c5e39d50b0fd11d1dcb1dfcfb04d98ef45d2759d7ee46bccb023f05bb55b56e8112eb7c02da7c496bb728ab7135ca04e773221e57ba6e01c2b192ef056b0e0eeef8bc408d280adc43cff1c1f72088fa0bec35952479c9696ebc6d55336fe3dab12cc4ec959f501efcf584ef52c363fa4d7232f011a074a5f2a21dda61414689daed805667fc55e14fc16ed37a4983442944522ef54fddc9b6c9a6884618c1a836240e8c190548093da7c0ac106607b312db978f53f267759ed1e6cba54095ba394d05bf8c0d8a2f04588d53858d40df568138ef45051711be8414485c9991c6e381a9a2319806d7f09f9ab779847ddc33e80acc66104365cc3386deca91ab7902527b55159528cb97d769a7add56144b0d33a87bcc38075d482b1b8d28c9e6be3a63a77520bb77fe84067c7124fb8f3e557fa395917ff7dd99acc8e00833f81dc5fab2361480c85fc378fe083d4453215a678b1fb46db0e8fcf110dcd51daafc093c5585eecd459aa12268280ce764e927cf8346b730281dc065181589a4ad314ee44b9ac1394a679bf7b4576c4319006f9cb3089ab7bfc33b4e59cb397aa977f1e3c0215f3b710318956fc5b144907be78285c64524dad1addc8c62ca17607f9de18cc51cd60363c7606bafbbc2666cbe3f1c52d18e868ee3c288b6e76517e16c100dd40edb268ea258510842ec8df60c1a187ee3931e4e239451ffd0d6e482dc44fb92c61bcb050d570b7d25963264996c4a43255dc85454eca359ec9b3898ae00a216ad6bafe668bb90e5eb53ee33f1b057e044ec7d9bb7fdfe253ea67fd3e2641f4c43b354c71e3da75ee67594c694bf825e61aaa8c41d90a2ed80dedc321ebd43544139895eb71340118edc36c336eecf244f704da9661ee2141d030e60e2c5ade2aa3f9aef9db78c34baadf5d92b334a96f5438567fd939288c72ad122f2661bc90c0659f3e917d32a017e2d50a583314dfe188faf76515a2c97b83a16c8d4343e6c15886745c019591d500aa63640485e1414a147d15d7a533ed792e138bc9ed3ea1754a52c0c92268f870a14f794ce0a9c058a59ea01d9e4b83bf4806ddc27256a95bdb1d079bbbe51b2b5847bb8f0fbe52bf3aec3b23557cca95132284f853580ad488e468a546b8050d30f5b9d7b8bd09fd6eeb653de871c08789a07fc9412a87416e151c0168c7b8c44e7fcc1bd962745973967f953761cf741e7f752e5a78566b4ed4c90d139851744cbbcb38c19bae90b7836137d7993b0e70f93dfdd9fd0f37159835f5f37c0d8d1d818991980f844ae0d4bf10394cc34cbe3e6d1c33679685aa07891477abdf570bb8284e99282716e89e5ac9aa3862628f610b630cf3003c05db5c16f647cceb7b179a11b24485016161cbf585e0be4bae5970e187c6e96265f7d5da8a2661aa9e782ffe0ed7e5bacb2076c004639989579bd0a9ca43b2d64a195f743e8b5e6a20ecdc8361e4f93851d5c45d76c5adf17bd6c645ce0ead7a0d24e0f7ac7e4810e05929cf620d2ea98e94dfadeccf226719303e7f09525be28c4a54dca21bceb3af8517540113d6ebb158e8cfa0d230214f06e2f4f8af4a7aa805c4db72669bf42b105a2d9785ffa10610670f9cddb2b083b42869035c73e53be9fdb88c06c16a3b8ffb6217f46730186ba086561ca6cb8ac1ddb13ccd7aa5fcf26d2b6652fad00d3ebde473fad457ac1c64c204c68ecbbb9c501eb4b8bb067aad1760b1379931ad563ed5b543d5ad36a7ea3612c093d03cbbe82dfd742cd8b63525e8aa78353be1297197af28c488ebdf84b0bfc84c3c700e455274027cf8f093288366102ec3a09f50e52ac1808bd12dc61b6d66803fec795840777d3a120371fa1621f0a2d10d8e00797f637ea15e4aa357ece0b28bf952203bf607d8d3652020b3d35c06bcc9e9c68ccf0fa0ffe79bdb5f2f9849b3fc414b3da18142bb167746d4ed68c89ed2f56829125fd62a0510540821a7f984d61ca79c4a6f2c193c8e7b819be6574013f43e5a4da918bca4e7e6d35e7ab3e61d9a48f307774c6701a71f3862a5db74559ccf8fe1ff0d5697991d7191fccaf40adfb9a52a68fe5e6e3e2ee30103f6fadebf8ec78e70b3613697b56d9ac33a646bd5c401a7058cb92eab5dfc1aacab422638349ad66d09d74d0f6e1bf0977fad988240823767d8bc8d54ae08e2b7cc501b246a3bda5b9fa01f1694b7e65940b2bb564b56ae01340e33a2585e811b5b7c0e6d497ec00ab2eeae3100887b062743d21fd65912d30e51aac586d3da98a42dfafa7bbc9985aa0efcc98677fa6c5032ed2a92ecb22dcb47e0885d8ff935b73012dd7906136474b9491bc94b147962c01a6d33080ffae2f34a93bbc356aff9a1167467a8e249903466a1e6d7473fc7c213d9aa083b1e18e18322550461b03ced100403ade3cbc7f355ce410f2e5a14ae86b29263bd58b08feaf59031b90a11117841edd82351415f0f7f3eb21eec6bcd466a060d89f2c6a07b0b90aacd7651b7322b5880f3c5097e4ca173fd745e6ab547181d27c28a380a5447daad2364162ebc90c01cfc683b0d2c2554455ac849cfee59e307d679243214dbb4785a190b9e0769ca662bded5c441044595e16bfb5e3a67a923740f342ee4db21e845583e22bef9cd710431275d7ecd94be72667a5d9d59adadfa67b55a7e823ddd06a18ee92c012adc3a4b7baf2689929c8223e04274356e1bf2d0e34bd0a0cf249aad704361aae8e1a7fd3cf1e575bf7e2d5bf31833561f6be25023d0a7cc1db2c11f8a86c791245838564a481141fa31a44ca476658885e7dfae7d9d1f3676f3f3d4666d1a9b00488bb2178b5bf39416595120a1fde2234d2ba503f43fb573ce3322d90771967b26688f282dfa65d35e25f36618bc3b15c7b1f27ed04517501a3cd739a6bc5c4a9772df5a64ea02e51d5ff4cb7a6dcfd87b49150a5d21ce49485c56b70f1e05722ec3e00fa38ec590f1f8783cc1c816d928d846a29c0df9cad1e702c16f32e0b2e4f17f9289e7ad85ad82cdc0bafe22d5f586c5439ca2597f31965b154e13335cf4f7e81d33b5464f6ffff0e36eb029145350040b7f714d412e72eb984b6d1fb9925629c1ac121f5314a81d17050c5e1e59a0a7871d4f0e8870a36187759bf606e12cb61865723b23be85c16b8a07cc5c85a03cf733cedfbd4f6407b7b42badb82b34d26c8818fef146284737508e5df2623fa7a4335bb66d0088fd93dab864c3cac2f05fe8fadaf001453d271426d5c0128c964d2a3d6f5b1973ec52f6f31749457e41124119acdd571a86a8e0a29abaa542c103e48273b3b88622b683657cbec792d4de9598d62923823bdf80635badb2be5835a717da274ea8f045a2044af7f240525726bf81c88a4f26a38b80a8a1d0ce69b2833e090e30629fd3c3dba175e58777939fd3b0db448a604a108d10c7df2261695366ed041045b6565da613732ba7d05474ec43738c21529ff043d96a6730ef63b95b648a4af99b5fd0eb2dcf459aea162d82673facb923041aff0500db9e6248ad1822514c8062678ebe10fa06ce7bdbd17e4a4b95585e0fceae61549025cf7c65212b2257f12de666d31aca32a0a09c36cd6fbf9e33e8cfa8f99594030b6be2de602c8bd11eb982360dd7f0244b203e5c1211fb63285c20de304ba84a64847208f162eb81ea27ea42181e4b356cdab2a636666f5782884e53352f4a5b9d716192364436f3cb708e121febc8306dd648ea10238121458c7a85a8f1885e08df80658f9d2dfc020d060940ae68cb8d79916e3215d1ff8dc52dccfb9326086fb24ae0d5904b8405b514feb48868858a6233a7cf775fc1557ba7eaae29d9a1935c264018c161241c2549e2166eb621d7a8de4746d6c3a5920e14a908d97ad6983695c438a3d634720c1af05430c1287320021277da043127a1d1b2a0655046d1e3a5e816395be7f62228a7f9bc70cecba8e76e379b17b6ee366fe7272fa9eafcb78a566427f9d67700b6276c79669741a1547dba3b77e9badb66275d88caa27fd85d9bdaa2506c759c6cc07ecd4a506b9fe4bc5722be9da5ed98b7f2e68afe4537a7b959e15ccd8dc0f3a160ea6d4880ebad17463c538c92da94d660cf7480a52a99db5829a6f89792081898580eeabbada091e3a21775a1acf316b297d25f456f4ffe2867db6a09c363598d10ccf6ce593057b6937d8a892b2199533ea3901378f4bfc9340372865e577b0fad40032db2dc7105f1d6ecbacb229d3224eb4e4a5a34504c3d87dd79933ea23af60a72a23287541","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
