<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"79d263f3b3dc18cded51f987275a63da9efcc600fc8a1022e82f86415aa37abd7da3c56b8bd771570e13b032a8a61c049494b29c8010a40e6c0f5bd554defc80062e51dfba16e0581114e2b92116a10b0d3469f63922fc5ea43769aff049dc995ea477f40a75b97879cfb9df1c3c4ead6ca1c48565f3e1d1156d7d45629a14e1eff2e4d3f46e609261a5f987ae21ad57ea3fd3fda9efd696dde2298717988911a7563208f2c150668fb9dcb4fc4baaa2ea1eace20b5a122ee5a5c04532d05264150ff392bb898843260bb33afb9e83050b2292c801778e8dfd82db82794e9471cade499a882fc4d809f469c0e3f94c060186e863e890862d482d31ba84937ff32d20583d7b8144cda42e51b8eaae9f808f59cb2a7cb5302ab215dba8114099bfe372fed461f5cb741fab24df9f3981d9642aee7bc0e73e68e4f38f813a1866b30842e58639d3324975e08ed1fb66b4ad4ff25e42e79f628f0f940db52ad8622d5c3be5ab9fce98588068a07df54b7987a98ea46d43157ae3b3c17dec68d78dc836eb2709e8448ed68e0b426cc796b243599295c6dc24850f5d1f10299b5f810cb2b71839a8564a3808834c054e16f3f3675bebbc32b258f50bb42f8cf05b8f582706b0c1175ddf326709c4c5f0c2410a449d15dde854a10c81224607a9560ccedfb884536b3b89f9dd3ea79de192a94c33f9c318ceb3b0295898b8cb97d821d938b6868a436a5256fe292bed3b7e189f1f93b4f8fc4801df1ea455bae083e13c0db1d846687b217cb1141b835d1e3fdfeb7c4ecb4ed1f17632149af84cb5e1dc330f14b95d5de0edd5fc91cea8a80ebfac890a94edd37fa4a123ed2b6e67302fc42305df3862c5cff89cc918ef58c0267612dbd789831ee8a4487ead2e7c4182effea9da934185f9a6f5f035e7f1a42ea453bc1d3c90b00a2aa06e0c8b3b62809de5a0d32513cb6d82fdbb6afc3e5b37e48b1db0183fb87591bfa1890a1c187974703de48e3e89f7bff593bf72451ca870ae1a5d181aa11960c87639c268cfc83465ef06f996a92985f06f7942fc2bbde65e83bb156deddc073d9355fc1824212c4eb03eb73ade3adcadb364dfaf7620dc08a0ee6bbb131831f83a1aa499f68d52d4a3c62d74edbdc6dcdcba1ae5966d78789ccf8acbc440f439ff4f5a415afadcf59fc538e599a29eeed014987046a3f17b2c2d4139f8c850ef0ab6893ed1e3966b77c882ff057f386b6c3669fac64603b2e989eeee1e3b6afbf62cbcc821b79e689a87962fa9e26857fe19479a277eeaa23f2f0127836496cce89f0e353195fc495c146b9426dbde9f99e64cd0ad2e02c3df87bfad1bd6eed84b61a03e058d97d5900c61218f8fc72a1c9d6b1b8d6f0ab002b4486b2fad8e4675527b2af2e31556325592a312fe90eb5f7d84c644f5cb6d6d5dd3fae70ac3426f08a01d8312b05677ec8bc743551866208a04ceaae9a9a6730dd1b9767e1870c4b65fb5e4488183b7b9af799333992e7566def40cbdae732d4a5e280d63bb4cce138a7834e88dfe0e534335b72e0e154d762553214af3960c79de2971335c64e1ae0be43abed8c2ec1ba9e763f31bd16382fc82ec6b511ef8c8985cc056bd89b24b9f44e03dc6e4c79928b9f7c069ce7b4440600ecf2d9841f3fea377aebdd42aa30e713cdcc0fbd75c87eb47de857c0301875e7f70ef8d9cf1e9c71b7888d41332c45a7253d0e96fe00fa9c02287f23942728379a11837792f7325ea32512cf2de4e35b21aa74a6d26ec49674aab2a32d6aa53abac389ad78fc6e398708f90f86de7719deeaa5040fde99e63a3ce11e53923ee141bc54a29c5011494fafd573575d88ca931883917cf3220cf3e135f78ffaa8f4c7e77e7b3f9886ecfe8ba6dfcc97f4d631e40d8e60254378da38a679839c785dc5abe99d05e1705e84db644f64980d97f95e310dd143e2203495eac912136a74a748aa4a9f8e2418559fa3d5c8051df14e08f48fb759a2ab63f3c21aecfd7bce5b235c0a36be99d3e5e6994df2a765f4d269efc0e155573427a0005322dbbc33ec869ce1b81ba2eb01594432c8d7353d2e4cc8e1c274a1fef61680a801c12f870139db08b1ccb734a2c27ecf2eac196d94ef2ec15b9ef5e857d5203f11dab0768fe70d2d55ec3ba702661039204a7687f7df82ea46301bb6f94ccf1c973db6f4372c3c77dd9fc1305369fe797409b7a9d0371cae11cbd4d582ddf00240cab98356a214c3518ca3606d74f90855241ecb54d17e581144f0787deb3c8ab09488b07cace3d61f7ac8a092641e5ebee4b9a6ce1c9e003d37127f24e0434911d4391ccf36e9f70507efdd276242cf590bd2a8bcdfde924f7da8be1b4a8d2704b6e338d4fcc7bf5c278efba96194143ebd0c236d0bc44b01027e172adefe1954b0b526dacdaec8193b5e564c8cb2139702e20e9ec54f9d97668a317092feac9f070e80d9a12dc3062b194f2db0d5f8362c7ea76d7e0431e42d64814ec8a29dcab549a735200ed3cb4dd55fdaa7655efe6b2d89e171e1ee6fe9f7166a828d531ca3d93d1c045e10029523ce5428d37076cfaf7e0bc98f424c1e0e2306b503c2cd49015a83816b321474ef44d880af49e6835edc00fb128eaade41a5111fa9cbd50001841a9dd881d23369867fb77545b54d2bcfd229e23e7b0d021f2bfdcb091f719b9c0fa6e12ad9a304a4a72fb616be6f68351ed7b5df3a7631c72326c2b93bb5b327673017ff8912c74653eb3507c0848759b5f3779f7af0af4bf1a3b2dceab6eb02f7a494e67d4584745836960ea762e28f06dd8016c7ecf3ba171b838e20218e9232d4cc02b9c5cd0d6302273112a1946dbc7fb14392aa67d1e51341335073c0ebd6355c61822a711ade1897d4eff5b0c3624e7fd2e5780ca3604b34f0a38b9e6cc361a30b618d3fd5553e77ee59da3adec099694d997bae966ca0a18040f646b6c8f2bf746964d914ff31c742157df13a8c84aae965afdc8f798cb17facd59175e6d21a9e92240aabc6384ff35d574e8f61259f03bd1a2782552d888ff7468f5ecfc2193a6cdff93ee4e0bc1f8927846c6537b42982b4f26e0dadb44230397d02608fa75abb4b44c140999edb2b10d50d3330f975acae4f892eb131ac44088a876f20344a8c7d136985a5e0e404f6b2daa3287f0893c2448cb671bc15fb09eaf5f28cabbe6764da8522202ca662175e77b0e2570dfa377360f3a762362f618809d373aeb2f04c91686a8545975213a73d3a2293fd5c1a0713b9876a3caf092f6d431bd34f59ff41bdfa3550f15c948648481d954facb8fcb8bd90086480981d6923d680ae7dc3e38828b381df4c2741764199782387cac7fd32e1ad912f5433952cd2b34f5dcf6c4966661093f76c37317f120cc83baf35980a357bfd67ecb5943e628f1bd93a6a90bc4e0102675162136154dac5ad0501259238a53a7332c064565ef5f7a9d84902fbf1713db7d65cbe86756655f0116b5ad6f3978526e801454aea3bcc9ddfe6ab622f013499adcd114692710191d2e1a96f348458eef65a91cf9f3f1743ee8f0bd591ad5252a549292156e6d416b3db20dc635cab144068d8088d6da157845dd7788f83d7c4c7655464988eb011a5f8803f37e07bb9f08b354bea3d156e42377ed027ebe64991a8a1be18dd76f0493f89e50e0a510ce0d56aaf243e9bbe7880824f422f6ca978fbaea89a2fff6b34ea03ef4605c45e199f2511b4df8508194cbba7572f9e73dd5b8933676372cc92b033b4d7d7f92a93ccb47e1128c733521dc2d545d3dd74cde7fc0a35806f9fbbf239dc3a686dc42005a07c0e909e7b98dd00b26db39cf025127dfa895274f17e3e5003af1ec6fb68158d7d50eeb66d838b66fa940ec6ced80b2d3de626ea03e996d936ed7d7b5a97f9627b481c87da256ff11e4e619809664b9c3204faded3a539239467c41b7cff43e73e67a77a1a9b9f02c8b010190beacc9d13c3a6e2a810772fcf5b0f9847399f748349dda674e59de4a96b431f049b084b0901fd2a41dd4bf1425c5bdd7bb07898868d22a6e759eb95616b78acae04e192e4e5e13bb710539dfd96a6a425a6d2cd03b0096caead5140c114ae8f32dee901341af9c855c1903cf9c75ce34c5205cbb649c7a9505d98359f057830f91be72102f02c0e30155db19b5aafa7cb86d646867ae05ddcaca62b00562bc6a60348d503279311ce58e3216a8cb83e3a26efd37906889755e47bb01b0045361657829f5989867a885788d4a24a33e94f598f9f76796821faec83c3b4a1932c47af1ad1281ae8b6a4770a66c8fcd44d312b7761ee6df2c9498c8741421376a95fbd148ac679c1e9cfb32f379267c72d8337d7d0ec9b75e09e56962ef3165d707da6305cc62bc65bfe7f07ec31da262a1eb060363957cc6cd4ca4a971058221100e4b8a404c1bdd889f654344187cacfb9b8829cf3407eb604a25a54a885d81b2e68f8711609a28342ffa56ee757565c65e551b32c3e2950f43d87223b5c089fc389d1525b11292d796c37065656e50b6e8c6ed8fbe62c0ee4e5e28beb91e2196ee6ec599575ebebb28f983458fe72840b5ffe390ecaf4352e2979ea84bae66e8e13b12346328f7d6ce36cd431ca304b997b30a99440f1b4acc84413e30eeb031a0f04624abf5cd9c9ce6fbfd43d91535afb8a1269a556df017e8d69dbb3039dc6028e15c5b85776c1205fbd1c661a1c96b43d62b26980fb68e6e2ef7f3757e6726478ebf8e0527a225b3c326bf282258e37817f513bfd2cb6e0c92b1543d0a06b73d9786aaecedc85d8d5386b26c6b0b708d31abd88e74fa86881e37e011a354991b261cdc3432c4e55c97c7a51fad5a23e1c13ba46b354d8177a080d5fce09644b7202175cee2f492cdb4c09e6ce7344a0d9c0b367f2ac7f358b4ec8732450c049229371b0ca8807e6380f5cfe06034e87b503b681f00a8b010b47810dbeb65b8fbfc848326c33258b5384069f788369877dc97fad358234990ead6ba53fc33b1587215356102a246279f9b889f7626143c5736c869b155eff3baa147ee53ffe662167e5a31470f3744d415ae81fa37362e9a448f3430899216983b44ea8b7b06dcc9b7ebbe77d8fad9f8fab51eff3b61cb95682446bd9f1c71935001255fd250f6dfe11a1c48551e893f14ac0f3b6704a16475b68f796298924204d338fe691ee604a0e66a0a334f1b9098ae110410ce8f12d1a5c50ae9812d93d082e61dcfd2feb69f2ea8442b2af84d8dd7cefad845c039f2f8b772a16d9c059245fcc20d3c8c6a6a25afe45a6db317bdb170aa088c587d24b02b6b96b9806317a3fec915a46d66c670ce993c2c77daf5e041342b58180d491184a2cb30524d0915b32923e2776229d386b50a2f57955dab578c19a36d51592b531542e97c43b167347c031e563d1a21aea2e44afed0ee0b3473c6e53362814fcd33d69a5967eaf9ea755402b91d22ff65f973d5eca40cae0bf5e1654de552fcefc6f6bde3677fe984b6f2d91cdb1edce3f376da1bbbafd87f6a322a1a80e4bfe2a3a59813a4421808d309f92ad5cecdcfbcb60806e8d5ece506ef8248180b776ab157d0839073deeb8fb608a8cf37cce97b5df7483fb12ca2aba21c32814f736714f1d7e4c4fd34e2a0cbe8a37360fd054a138c4aa3dec5bc01956a0631360e658e6062bdce96aa7aed67cdf0bf201d6f37635bbeae478e59d0dc1f0656af143f52146b02e5a9827949ce39f46a7a925a9fd163d62515a20cea3b47bd739ce750aa1b3d2efb3ca10ffa9fef4e12da0706bdee794c1b951540f159d4a7de20c5694df8b366c7dd5735f2cc9e2b8026aeb243b2a3f934a56acbe8142102eb98ee1f0bdfb1ee59fa4421b0747ff0827b35d6d7045dc022492f88f08146391f3b01961917d863418fc28a4b4fbbd35207e4b71f8aea17d6582cf61c0ba17afc492263e2e6619cdcc1054b8d5acd00845d919a2a83e8b6d86092f16cd934d401e0e199d3647bcf8f3244992fd88f540c6dc622a2b34b106e356a4dad8bf09ecc0ea2ade738a44eff9b1c349158583a8b9d80bbe20494bbef793f47ec4eefde13dbe4e4e05050cfe388e5e7081aee25f73242c72330c999accbeba77a7fccc17017d589d53c6a4bdae5140055dc434a19605fb14cec91563b317ecec73f90a4e92509d4455119e207e809a4696dda6e687a48e4ad01086c951a19537a03a5163f50481d505a36e5b0db979a9440c0d88550ca5ec7d5b48bc5e6601a15112aaf243fdcb91423c7158711fdd4b30677a6e7b3abd84827ff4a68187ebc1abbccd119a6c6e2cd3f600aecec1f222e3e56b549a0fcad8b2634086a0e9d7b46af62e5ce82d119f8033e90d28f59d3dc4dfb3f5ad11c1d05bb872b125e124b21bab50c012d29f27bbada29ffbd18235f9395ff7399d956d4932aced2677b96686fa5e193840b1cd51a2baf8931b84b3a2319e9748a43466dca8d00dc2d16f67bdec899c976a90da7383e6f404715f67079f7ed8cf0b00782b0c432425005808dacb20ed82a94f8625830f3b09a965bd3e8154dc2dd4425d40b32c483d9883d64501b3edd994bf5dd7e5c8331d79057ff26055cedddcea8f80c712882ff5794858236f5e2ad1d4fb731de712a4892948ba196ecea2fdf672ab9fd49f803800191ffded106ae9448c479f3b03fbff64bd2144730d3beb5cfdbe612a73668bf422b0030165a90b6f68ad4b4e7789ea0f8b2420278743ffac3f4e8bb50d85bd1d0ed0b60e80d3f98c5228ac077bd9e699f19cff2f52a1c5f2f24e5006b731f2930217609aafb752a9431c46e0a2dcf0574dc0fbd2656121af12db4486258d2ccde85c4a61a3f4905adcc792d4c63ccb1ab2a0636571a1bf1f9f817aab6429433dd5c3dd0c99a0302e5d3ee2fcf75a4adfe00ab8fd718efbbbe49c1c123d3dbc035ac1cbfaa6c38d8ec52c22a0dfc2a0967cad6dce9f58cf5060917c91624e07549cc702da877c09c451dbdf665f1f2601e33d0478793cf604b7348f7ebbb4a0af0b5afcb6acfaae6a142f33d7e86e5483d450dba041ac73f37b79b38ccf6785cf54e653a33ebe8ccc2025b67ea93b7dba3ef30363617278dabe9338bbe059080f493440f5ea603fe5d8fcfdbc83d107b47e5e47d0cdeaf57eda72eec19e5fb7b43902fb9ccf73a61ba89a8fbcb482a0332fff66544b0832c52d6f1545609cd9ec7686412f226cd503bb6c3310f1ea31f671c0df94a0740d6e64de95a28af9b9de8d23cd984d0e132e54481ecf081b24960bcbafe8172a4fe99d2ae474c31bae217404e0776ad77e2d9aff9fc9ba6d9cdd120b409333a016d896180c4017ab8e29c0a3f911c5ba64a345633abe59c1e40705ab2102b7adaa57b6159cf0c46dabc1e9c8241629c41010d413b9108a6376813df533c51a6087db76fef0abf0681ac7061d145e8c9849c95c131da97fad241d97a4297834412a5ad3c3ae9ce39d6a4bb2d26e9a7b9986d867692f93a99e126bee4a2f3139e8d9374146c8d0612dd8aeb51d5eae16903986a9d05b06a2bad987b2b6b6b3ac08c6c7a021b3e770db8e585b99db152933b18950e3c0220ac6cf7f3d54bb89ccfc7fd2e010719d67629c1ad0a200328862a3acafac1574c929ba039b58143191a3e705346138f766eab65187823671f99b3a207a58b43438ede9b4b779d062428eff5a88ec48d3b313fb530f26b834de95f62ca6f098eafbae34f5844dd5392e90601ae8bf8567219d9351b0e1ad3110f2224e6af44df8698c6dcbea91100154f7218e53c4824f5fcbb4866adba912d881b21f7d0be4e6bcc4bb1047b2f25d662d35d86a83ac9f7af9688d7ea388ebb9051727a50855e295df2cd5c52e19d07454d66f9b7d83c6183ec0df313e0bae109943c2996b2391d9f4eaf72bbe13a3ee7904633cd8805558c50c70cd10a50494a566c906bf7c8c1caf7c4b680dde2decd4fc570d4e0b0ab66fefc8d3a6accd40c74eec8a92022b28e99b49ca25e31808aa367009ce739c97fe83e46fa5f4944e91295d2f68b6b2cdb5bf311fb5a0d7237e8b2115e057738b18e4206817ff4aaccd4a7811be10ee34b29ed00bb30ff125476f09b56d1b04cfca449d4c8fe35733ab69fc7fe30d6c8e71eb085451ca885bc75a08998ac8f59bca7b8e67db24d2999835f72b617a7c254a1aa13771e9331b8f8b09a07c8b81888befb1b284d5e9e9a446ffb45dccc83e3b45d7138344f98011d409f917b389bbd82c63111300cb7ec922b29f85d5c95a546bf9e9e6faf16dffeeb27d27e490f9e76e71aba6c479b441481ba99fc6dea3ae5c50a2db11d930ffd03812326df92b56f3f58d16d0d7ff0b11eea99a8dee353f8ee7af179a88acfaeb3e4827857faccc39978b5597a7339269b89ade1a376f673ff2b103406c6275e09fb5a5b06f6b65997864abdf34d4dcde6a7e9719bce3c95ec4d62f33097d55894a759168ffb9f76e7c55c74e7cef821a344a985aaa15b1e625c68bc89dec8fba4db160d79a67eea777fe9cc63e5f95f6818f0d34a54b8cf61b80d6c62e5c92614c7fccd9676e34382f55c6ce14114b21979c4c1eba20a3f22fde7934c84ca24e6308d71cc442081d97dbcfe5d15cb16410446fcc32db47ad91ac9f137aaa704e4182c66286d83e81eaef89798f95d798301aa1ccedc696790bd3e22671577d7d7577b4fd75577e1dd940313499533118ad7c85c79965d702b719ad632a332c06b4d4fbcfeda0553cdc7f00bc1aa33c64bda3df2e26bb6da0ac3d8b41b8339db34112ebd1a281db6ee93ff0ad3f1a314c7145fc3a10bc36991d57a0b9ad67becab4744744fc1edc75d0b8ba95fa800bfbcf7a47c0806d95a3ef6c46c22954d32c98cc237acb7817de830f191d855e6dae1430b02ade60e93944544524e5f47329079433c5d6ce79a56c4b257ee27d4c0c125c4a1b1ff148b2b67fd02cef0127109e8900476159ea2a538477b94bc7a1c8361e7729c0f6af3709ced14a2d344fa95362b81ec54ec545216107d2303c0d6484f7ac695f8a5b8b726a66da321c8ad5d1dd373afd9ff2eed1a1428165a8769ad9180b68ae89ad3ba105f86dba4d459b2b61ee1c81e7f71a9a3d5ce516b7964287ca1a70d265be16a50b2c607c99ce6bfb26342c2e5d6bf8a58b35c79c55c23f7276712117506d689f7527734b0f70bdbcc2cede68aeef3f8e58b01ff9d505f425dad1fd4a691fe26040aebc0a32ba97a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
