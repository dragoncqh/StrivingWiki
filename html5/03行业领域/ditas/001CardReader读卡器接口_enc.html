<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b1ed0d3e569d271aa00ac0088c0e0a936df289140868e768ce3bd96a3c46aab9ae58d52926ee66304ae036e6f4c7af462bc3f95b189684fce4365bef4c4e2180e17a05ad9e169c3b090563cb777e9cc6acb53cb8c3c4589c71be52504582c816cacc9d401a4ff6662b59e83cbf092cb5c118ee4b11b4b09bafb07af6dffbc5f72104745060b16d3eb373dac9708cf4a4cd7a4a54001be58707b570ecc4929e0452223b9feea66a655d519841c9025a7763f99948c1c754abc3af79483ec0b3bd86133742ff73cb03309be04d040bb98b18f678e28af8c197f13ce4b1394cb40abc35821c252bf8eaf16b3e8be301e5313706ac65fb2ffa14b69578b903c0a469ca2ffd9b6dd15c848af87fe7f2fa4e2e9c8aac49690c272ec1cce39144f15accfa96bf684fd503427fc999af0f14331fc1e9eedccc90da834a0b1f575c53fe0116566ead497a7f4642d8e7ca856af80a9ec7b74d72ef13515a7794088a5bf603c2c5339dd96e1365e37b893c1e72ad35a0602edfa86a6789f36e7c6a0db43e22d6f0e86ff46d55ee1938522cf82008a7d6e44dd33ad2f8905202e632b661d3756a5c6f8b6bc2519b81f87f6821d1b050b432a568e71474c8e615ef9346d96c2c218f6d581e8fcf491057378ab13341e6b02b5c93b8f9b010f355e061c91008d7f9f67518129935986007291cf8efc59e67205021a728bcbf91a89effdb8848342fad55da788ed5d93c6b56c5f97c20db52d32e8dd4e31113accfd33299721625358378426937c9c999c8406985e5ed768ae484dbd3ef53ca63c2bfd3974735a7d2681cb22d273025e0c729be147b6773f18d4b69699842de1868489a8578d46d6244857fd2661733ffcf888e12b8e69baf1fccd34cf5a83fba71943d439edea71ba26be9df4dd6f8360e6ac5a5e92332415ba5ed73d2f34fc55571ab1a81e8f73621bd548a98ed17577e17273ade2595ea621e96cbceb440ba0a76d1457ee1c3ae86cf3e30d6390aa42326443d95d2cce4479e08d9808cafcd0a9342e51d52e9a668e5db780797978454d5adcdca3570f0f97a588e24fe5aa8d9ea0c28cb8ea0da011cb132a0434a154f7b454f7e9b9bc23fdadd55248770faba8e861fcaa6aa24d564a69b7c5f589644ed6ca9f7923d02fc192d60bd045a7f81a21e8524cc6dbba866316c5d03ac43745f59f54979b65318f423a098eb635c9d479daa53657d1f9665d3577b2f213a57ca1d239d47739cfa681ae26b4a964adc56b08d307eba5539c9a1b554d739f901bb0ea35989397a7540a4530ed6827359654e8d8b1252e45bc2307e659ae0ec486c6475ed725cdb68a8e78f228c38685544371dd361cd23aedebb7124a4c3325bd56815f03cd3c74fe95b01117862e0459eae3f0bded8d61dd757492b87d793ae15add69a3922a0447b97d1c2b5e7bfeb5a3e01427af551a63b6fe416c277e45231a9dfd8992378390382edc34e540e23fc7cb54d1af881a6ea2acb39bed558d17936c1683085faedf9810df978e192440c13a2649cb1aa508938dfc5e16d947a9404de09495bede2cb129dd370911424eaeac4b022c24c05c267bd1576c548681daa0601547ff28a9642189d0bf5428626e473d4128deff611b3a1e2bcd06b026bb19e850a82cbebbaa9a768457619743a5c7061b6bec5aeaef668c22ec0f03d08388f7f354a2cb66be5da43cece7cb900b67f9681e5a68ca0969d3875a19c58eaece92a38c10cd08ec0d96619c0eba25e0b999e85dc79456d14f79a321ea06bbbedde553dae7b51e2ab3e87b6a47f49bc9f9f55e8bd9ac16b9bdbe5870a69b71c0726d3ed5029a6a8a8ff384033967563d78db692bed2eea0515fb3d449d0a7d912bbf5fdf46b9b651728eadcc997e358ff1da7b73b1776718b7b29348edf14c79818a47aaf6eb139ebb6b541fc8ecebc29c16580ac1c941f71537243c24cd04b894b8314a5f0177f58c121b598d1df53a2aaf09b555f5a972969dd850b78de67a50bc06e8b6e7c1f0293235d8c6501a94bf1786093252b2696fc7943a2f9e0f0388b086e1280df997a6952ecbe75919b3bcacf131039739ee94a8eebbee3c65c92595077a8f071fb2be960314b924992233856de0f5dce86916aea0a44a119183a1976882ed86eac718c0f6f900926504978c049c5d212671bb48adc952beda39a922f7d684f0eab6b18bf33bbfd536623466ae5217838d9230d8c97a04e9f91e79a88be8cf9479865ada6c95e89d9fb1f8fdc896cae4a626258b15de06dc882eddd7030bca6e9242168577b3778aa01e59fb5177cab7aea43d57599af73a27e20d9742464061b19da5571df50fdce6e15288cf13d897332c58c5adf6aec98bf17146c1b8d08f51f660ede685cda763fe7acccb81f91682ae6f762490bf2f9641fbb5b37b74954286ecbc5e4db13c6ce74a4d4e52d8b6be0235dcee8feac0c349cbae288100ede79529e5d7bb7c2e630aa49a316e1be98f096f6d996d9c503f71865ab143cbb71efb7a52a7872479374b16f205344c60b3c0a720a8c0d3e2e344da18113178bc6b88f033f48467378082d0e8753d115188b44f96a6bd2fdf4cea5688959f3d36b6c34b36c8376f833e6a36363d5be1ef8ff37b86f64fda44ec3278132fc60ccf5432592ceda0baae93f6a617c6037e9464097767332d48045c6bedb794ec0a69e404403b462393325b8d965b1405b8a9030dfef53d092722944c2149212d6df4620f7a1aa7aab2fa99c40bf6974deb0b5c4d9097fbbe12933cf5c224638f81c4e3210ebc78ef22bec826e1842367f32a55acac2a511724a4c1c7fa913b4a889462cd57e87e1d8bd277e8d147841c13b4b53cb469ca941a6776c143cf48171cae44a19070100427d926cb0df714cee8f316ef782dbf3954d1beb82e2c82c1706732b431caeb6bee16f9958598c078a38de0eff534e8bb903aee3a19dd3304e043227fa800442cf7aa7629e326629ff23aeb4f822d7e4810f84792603134b761c6e28f900f3260c0e780d4adb92281486a02152098d52c255bf946e5292a877a2a325e8e7b75cf5584764047da9a5497687e72eb85dbc53fa5b758eaafff34a3afcf0ef824b82c71b43b6c261af553b15a06b06aac1e5c193089d70226eb01d90f6099e3c4339d920fb5b9dfd42cb937d5c227c0bb1e43cbea9174f177c1d6862571d01f63f9f309c3e0e05179070a1d4af127f44e5c9eda4338331e7071824ba5e8e5c4a6a7d0191eb90d078a3f2e319603710dac366bb976632084a9fab3ea7b0c35525966e8450de96294b012c78c7e748eb6b44161426d822f3c02d057a5c636e0e1762de20d464fe985ce994353d92e8b34c88925c8e34ca8f61e98d851f3dddb8cfe0cfd1231e1e53b768636a64de6087d0a251abe9630a5248c91c4982c207be2000bd05aba9a62618ac9bc196df51d512b5b63c0216d76c2e1e787095c16b7b1ccaaa4cda65d0ada5f53fe81726e1b8bf889a0b478db246ab0e06c08a8179c3b3215d56fcebbf61ec4f0ff39b80ea9c32a12075fe8a2926d09b454bc5881b5128ee8f73ae357cae0401ed9b43dd9c5c4a843d01d775e6c714b79a841f9a6d98bb7dea50c7a43b091edbe5ade7ece3735820d6f9388dca049fcf423e8b5ee2c1ba6b175a3ce543167dfb216b05209e625e895882541119c74a37aea170fe2582e79b7902fa9cd1d391b8c0085ce79d906871dbc8e76bb0cb9e93ed8b3d40370263b137f5ab7231f560fd5eadd6dde510e5e914d8e3d1a0ace2042f31316117056cd2883b4866db5f71a1b485442c9a026c40bb8693cd4561e5d34b911270b9b3fd0428826656954333b1e97ad39d375481ae9eb0295597c2d2d4b6f7a48da6148173bf378a209714706aeb14201bd743bbe75475b8a0e10e364da916f4d993e3bcbbf5b2a5347449d92201e4723d045af6093f89f00f6c12dfd053a2f29d8fa7e0c39a76e43844406c8d18261d86b68c80ac888d7fd8c69935cf143ac7edf87fbae9e26006f9ddc4172f97b0f4a38c52cde306ecc09c4a30d954e5c3a0e0369df3c5a920c079f73251e6a9bd7bdb644377a8374e62994df6446318a2313ee65f36e0f9673dc74d38d5750dedfbbf8869716fd2ef27c361effac0030201c4b9094b23cc17de0c456be75a9b8406fb8eef7136b8877b79ee6e1a1b0dfc45672d2aa496ce393fd0a813d1dae5764a6b75edb9c18071581ff53914e4c438da6fceda93f47920e4cbd6285ac4090f0136d6148aa51b57643d99f32b9c28e13f1839566da1d9af50811e08724c0466c54318f71cf802661adb439a43a491fb05dc05e39abee9107c837a085a94f803b77a50893f75568955cc6dbf734f7f0178be1b54e2f36b7b69902abaf4657d96bb7e5f5b04179ad52f3b1fd32f00fa28ea8721684e2e7bdb79c7a434d56ae8b6ae1294c30ef8432dc2d47b496d1d9d2b64f12c25de940321617bc865ab85c9ad274d78d4d3bea29c1420bfbd3f6e9688f1b0fd8e8b9fe9f3cb911e7d7e504a6805fb2170806076e0eb114da5fa34d63d7c8f6111a393d291133216878ae3518bf955ce25b615f89b54e94064d0e6eddb0b804efdedf311ace4e9df7434f72bb1e862498e9333d1d381993fb9622781dd71a8252fba73a948d03ffd1d04f351276b2c98206455d03dcce024848ed27a1b3f4bc6b200646278abc031cf9ca1ad641d76061fb3dc912a89ef6fc53715b35eac1b2d7098f8bfe218f6636ad97726b2397c9f525f13e2ea2e07db62a1c652171087e9ec2b9a91224d1ba74a62f36190a858681fd59c37c02c3784f57003d0863f63f7973eca3d4a7c4fc19930fdb6f679c413e8e30b60835fcf5ce0e031d6bbfdd65e161d596350d699bd750ede35e4fb9bb7306c35a6f1729e2be21456e046935beb992993244af29044d30a6703a624ebf316a359dea825f1bcd8edf7f42287e011f78306a4358893914239be6aea9573a5dfda91df3f79cb98ee8491f0592ff1be6ffa906fb16c0822b43ee3ff290abab12e561548f6f6a269e3edb23e40bbb703950f0503c2bd01203e4ee2da23e2ba116ffddfa6d9307712e298060162fdaca557380590e5038af83d9a5624a959f1156c28bb3ec7273b5743a2ed880e7a10365426ac423dcfe4d89b9af0437167e9ceebb00d9831971412645d45e5a89478264d8e2340d75b88c2b656c83bacebf5b12962ffbe498eb6374121829102458105ad7ccc6519e87dd76f8977237289bdeaec95145ce8cd2aa1328aa66c7f5379bb7d24914dd58313ba2e93a207ae1f523ec1ab71b51cd6e575b270bdadabd8781f35625ea3903c151f29783620cad4a34c196fd637ee7ebba63f4d697f486e65b59c4e0b5d1656ad6bac3556370099d47175632a7351d22ea22cd35ef854c1d4615c2c1a97106425a9e584fb22cc4ed24f8b48179abfde3de3820ed6d1e09fe72b50da964fd6d022a4e6c95ebaa39d56feac305aa617a386d006ae359a75b15dd208455f0c3559a63e6f669d88a9f7986e5f971ac337dac76f887cfe26fa284af2b0f6f16300405a4c6358791182b6316413722d9ae59e041f856c9d611e7aaeba3012c46afaf803803bc1fe586dfa0b47ffda297d83d9e4aa1df20886ebec58c32ce531a820aa71854a915c1910b185fff77c86be569f9f79a423a8938599f6fdf9ed8a57e9d23d4bb573453b4a26d3604a5e5a8891155851c15c5936f8e6d49c06566851dd0efd8f60368f00bab3b878575f5353a1269aad85fb5306cb43c6e3d3ac1e730d3365853c06d20c0498ba5771a6642d57364f453ac3ccc34b8c367827c03587793bc6231620b961147b4a85fea61f58a2af865a0091a147c972f2b2dac06ba7cb58e2a4b92c943739ab1a1cc791d454995f2fe42ee239d30f2a7f917a8914dcb358e73da958f76fed18d51779e3052d4bf9691658e5229915c324e146f068dd2dae5a1f91f3d66e846f3891bc0e212ba71459c6d639f67667a062bb6f4821f9764100f29e453fe353d62221162d53d9c6da2bdfd4e09e70fc244a34dbe59bcbb08ce52864bd2c5cd4af7de3d55964aafcfb256909caf99b93183c76075a56ce91358fc776591934ff5783e8c8e7aff48dc1d168c1ac4a9e927b48ba52676a94db15570f7ff63dfe0b4aded5965201cddaba9109d2d0eb827bf0c91a81d7c39d8e7dbaefa49fe6923ac1b4b545cfb3f1c897de53807af2c97fe254975d71f586f884059f714c46cc9725a2c3df6dc803edc92b59760e1dda660d7392e2634e3ad871dc0d598bf894b607253664cb7189ccf99eb2089bc3a6a8b6dbb72bfffe4dfd96b7b0938f136e5d064c69c31b87d703dfae105d101fa3ded1af20a4c4758b0da2397757385f411ddc6ff210af1b4485a00a7a649f2e57bb0c5920667a406f76ce696069c4c8388ccfe5c00fdf6e5823aeb412ead4da14ca9bb1d46302235cfca63214c99d53afe4cedc0d3f2ab393987a8f342b90462746dd76cabd06d63fbc111d1d26d5164223380c584514638bfcf5925215790ba48456f01a42d8c1261cf5e56469ef4f8aad4dc90a04b227368f6857dbc7b17867da5861ba942b205339353380d7ee2496d8e36b8108aebf9aa2fbe299b38a62eed2647d71d6bf2711ee316f60acbe556b935f17e1072196a5da9b0f58c2ca9cc83189ae3d6a33fe4de8330718efb9e8392522d51f237e70affa7b85f316b3b139e289e71a526234b5f528b102d55afdddceb709e6c505289fa0374f5062948e723c7869287d3979fb0cfbdda8feb8c47b51645c16ca836897581a62ace0b71311492a625814756cbd2c98415cda22ef4af826430925e8a8a324477d8093793b4a7f05ab68b104d8b547d109a8c9d930e230fc8151a83291905843fa9134942d4aa45dcc8baddddaca1776954fbbbc2ae8a13a5d72c62d2ba94307b9e229820a1c0fd9a8ed0410d2050d4099a4347835f36ad5da772fb4e09e371090bbdd6b81c53e1715566479d4be726746edcbea1817df78658fb3326ebefcd405b822599857fc26df173551826f51af068d486fbdbe698389893f9df3af2844f9f303fae164db818d17ffd488fc13e3a5ba6cebd90ac6b5bd65e2518742ba52931f193c691f84e288d816b89fe16e1860a0ddeece656e62d74fb4e3d19d554ba22f7f2e01717b7a6e74f67fdcb34b0fd20a7234c2127250d5c5e423615bec5872c351d3927c56debeacb6a25151812c7fc18994ac8494b85673f1f08a1f9e2bb6aeb4423e9dafdab14dfafc86ea44993ff8686ff9e0caf1f37848835128449062a9a4159223e507e5ad2e068606e3bf75afc8767272bed4120e03ef4cb60fd27f4915f91d5c17fc195c3c5a6f6013b021d78de7e2e4f06f7ced34dd879288eb5a120e7920f4d2a00a686068aea7e718eb3b033492b9d0370a480851184b5669d49611edcd3c62f582ee245ce324f02394d10b01fbec4e549bf0455c6f348ffa021722c8b075db2029a9eff9a572f0a400256eec992fc87a996fc0fb7e4482b9fd3dfac10824ac3785defb855aadffb1f8af236651bc93d8c212b16495e4942f5c8db3fede96a3a6e3d3732db68ad811f7b85e1d8d7e18839ce35adecd0968c7e052d4414fb86a7427a98ad5877c7244b7d1578cec67b10b74ea72c209dbaf2ddeb8cf3a6f710ea81571657f48f483d82910998ad79471ce955349a7eb502c431084317453bbc05d119df16cc2a59982ea8f515aeb9b0d12e57747ee3c5fdbfc5e68b618f7f8b9350bdbced078806dc50a19e9326f97a15b101ed407e70b36ed35a09243f3166a0172bde3379f04a55734c184b26e67b9e830e2283038221990bcf77adc7e51b99860d369a024d05994c14472d4d10c02c7274ec9c7c8e70140eb646a779f8bb490525cf47cc85a643f16b09bbf3256a7615f7a0edd7a83d9aa018f85ce8d8a4be5475db84c3894cfb3a6625fdbae333cbc9d59d058e24295e5e09b44f780e77f659b0d733788168f947754d4868e96b17f7737f7af8d714e4a83cdb35390bfbe519ef1572b2ecc0af2129b1185de4287eb861bf3029352379b87bf49c04beb2e4c5660aa85cce00f5413be08b4ca6acfbc117c5c0b9a9e13507ce14088acb5da1e444bfa5cd507ee0e159fb8089ffbf811765ef2bcc1ab217b39f24bfe87c30fd3aacb92051a9925d456fb1b28d8e31dcfc0ad3cffc0c53e2603e033feab6807eafdb932a195cc22c444beca239c436bbfcc1f6b11aa1b2dd99c994e457df61d12de4e24f1d803234b7ab266d8da062a84e6f98d077432f1b12147d447581487800f7c0d88650b84b64ccdddaaf2a8e8f95b5e85b0a5b225130858f4a065dcf6bd9bbe31fb67deb401dae8d59c3ad832adbff596f28800b378962eb1f4f7c025cce93fc1596f8900d5a3ed9ae14bb34b42aff152b846cd1cf6a791cc471f7c7af273330282bb7a41ecac0a4f7ebac18d8475db483145ac4649becc6b6df21329e75d957eb8e36f79d627d4f084e41ef6c1933afa223b01fc56610f3806a7462ee889d6f13c3b0d29ec69c4672d6f6c8a7b77d9c0a3095b83951238259374de88d6455952c0f4a8b654cb804b7ca7daa3621e7a6bc0a5dde71a1c7b43e302d26f42b2c97215a316caf29baf1f1aa92838564153360b8e055699b9b602e46169e9c43124570ee1fc79953abbc8df3502939e76396631d4ae76fb75f0df7de71b0d4adeaebddbcdd2b88342165dc181ddec5987eca1d339975397189ba75af557138447e428a872322a5b4ce7a43cfc5319b00a5e232369d38f3c4c9c92f65ab382709218906b562606ac7c7130e9023bcf04db51b50bd2b7f67ec3e7a04a9b5534a66ed9c6633e99f5887d6225637ffd95095a1474e4a90a5f71f66c06d4c5c6f984204b87b5ca3c6e4c778346972c7242fe986f58557d9861850bc4d43f5eae2386ffb6eb8fd8c67dabb2606bc3cdc9e99bb45511dd8fe948100be3d1dc9edd970af27656a538ed24ac977d9e70428c734979dc5555cc3d1052b13ebe08279aa56a87d2778bf7e8fcb030de50e2fcfbf8a8552de03bd7bafd044267b7ec9badc2a44d84f7dd8a1468b9aef0cf93e975fe2bc0799ff8c50737e1b629646d064e321864a7c33dc00c80dd310e955b3875de6d8be6835416b98dbcb0b1193e5f10db21c7e2ab6266b05315b3c7878213acd83dec20fa553c79ba5596425e6df20d24dcf1d25e3d3183684c6cb825f38c05e46b3fe58539726f3f01d746e93d1cf1e090779e36e8223db74cddf88af2a772a77692cb2726b4a865fe8c0444cc56b739e838ca91f1c561cdee851c9f521a7b7d96887ca2f5b9b4c76909e2af8fc4dc4ae9ba7b9881fb572612e706d88e177eb8516753af97753cff866cd9486b77afccdee51974c0be66ec0a1878abb5d1fe70ad7890ca6e15981ef938a404c8c7d6e92f7ada9b8be5a6f471b21c4b0324296948bbb1b73457c8375ad68728f3ebbf1cbee2d66e94ec5c7c6a0a90c836ccf2db357a357df0249465efe36d38887436eea21bf64d5c2c8ff60012493e967e3d8266b92a2f661f1420d628554bc8ecf3606cf57c99c909181b8820504cd25739dea903675989c4e655f8389f3788ece10f1eb9932b7ff874d2721a254239819c7043dee37d0bfc2095c7f28a29c4894f389d701bf972c62eefe7d7e8fb71b8a432755afab9970e3f26bd7dbf76c5ca9657397f7afbd2a343ec092c00ac5fada3dc2d2e73738ef098aac954c15eb21d50b08af93165c1b1fac23c136cc5d1f207b13ab9a9b43861b6130fe825bf1f676a77448e65308cd6b8781010e61fccd9348d6c4577c4b34388099de0df16a16654d4ae063937b8c22a8305c5ccffee9adf5f91916da5b78b8dc11c50ebbcda8bf35253ed0d247bb86c72952e3f9607df1e01e7c0df52f69de4281021cdbf18a3c760fc4f1343f11548ac7d8606f3a0eebfe2819087f4175c546e23677edb614e7131d61e2c7d14434907fa6dbdeff7eeb76f282e666d3e94574ecd895b6cdaae86fb128210b9f11a9d0f144f9349515d389e16d706c93072a76824191db7c9cc841b88c51a32023af4fcae3648d5839589307b7f52087d6b71c3f343cc8811cacb4cc65912498dadf4dd613a657a6393afe89a0aaf436d0df5519a21fcb08d16c9888eb9d0ec8ec94009f52fa4ff1c7fef279b3956ce017d9dc59350d9d44862331a515130b3da69edad42b3db966cbc42caa6890465663abaf3e3a9412dcf468500aad16e3bdb930a91aecc4cdc79a70a4a99a3b865a307276e7bdbd83b708724423cb071214db16b5989f8b6bc5c56c226995e4007069e1fc6895f0ee2962b28dc847c5f7d418fe93ebac59bbe4c9a84bbb302b8a26e1cb7e10a163cc1b6ad23444e2fb8b41dac69752b652a7895613b4e0304b2bff0bfd047db1bad500cf8f7079a95661ee433fbd7b40d2348e293ad4ed6a07ff8db6e3b67d29c389a80ac1f516b0178058ed70433b89005480230c29928cc1b034e64132580b8f58bdd7c8d02ef86328e42465be22b785ba8c302483d69eb7165962a9377eac3dd6c9ad69e6d7bb32ea148236d445570553821899ccd482293a5d07e3a7a408975e9291052cb31dd4b7fb149d78d693c3ff49d341d549807b930988ad319e967ec4ea12f70b270770f88596b8d738792c2c5ff82228049cb666011088a0c89d2b9d0fc02aa79f95154d570a0489f218eb23f0528dac18f71555502e7082d53b5c67910940680c4511ffb5029411393f7ae0096bee199cd09272582ee386313bd584efe4fb336d184fb01eb9481fd47e12873155d6148b0796ed03d87f5d6f9b23c926cf5ff419afcebc976d4a9aa20a0e3cc0d23fb7e71cfdde5494a839aab4ecbb34681312be0b4a02428cb67fc47938283cda8a45f0e84892e1efa6628d4f8453d32e33d65274d8393621eacb0e4eb9a16fe776aebe938c6829e92ade87187e24f7dafd50fd2c79261d4385c2962af5bccb3024b2b7b99d8be31422bf030642693222c4dc402b54355945a3fa2e87b8028d4a4670af0c14fea73989f66fd5965f97402fcec76ef27f9b0f982dbeb7012ff30fbcb363b3096b4f6e1cb5d5894d51983ebba1330aae0f19b2502fd91f504bf02a952e4afdb60f5fb02df31a01b7e7b94fc6b23b360041d11f759a7f6f0af02a731f039abc2d101276ebab5fd2323f769134c61a25a1244693ec4a247abc3b1c05d0c819123be0056b309f3d101364cc79e8523f54cc2092c2c87526714d436e935f57594ecf828cb6dc1f107de678d9479a4a9d5c2c3365d409284e498886796fbff81f116ba7af13be518066459b61cd5e57cc1a76add28788ecb5efdd8a3437c9a90093b2cd8dad74211e32370501e6f93f8dbfe4dd8187f5e37d2660417aee37bf3899889597066f894ed822b365368d76a7b842cc0d14b737cf252628ca9cf300a98df0316212f7fb612db4a6b798986eceafbee549239c884d718d562367826d40ef975170649a5aac160eb223ddc80ffb497804b2782914d5e2a61ffec46a39d57eea0e2e8c08ada4f5f4719200d3e943e40301e0c3657821fa1bfe15c6ce6fe201fb631ca8048a0011297c4144ed9d1ac8941602eda292f85cc68e91e8468de7d389aa21a634ac5f64a23eeec831b8d8bc19776e2d484436e029e580510b17a22824643597026e697bfe5beed882da06b15d97e80fe5a1f38345afe09b586669a76c528d7353fda60bdd68975200a310d4fd9bf5cd68aa06cf50c882501cbae5aba70cae4a3a53ef11d57514072b6ad2a05a6475e812760f99f1f6a62de021e59e30e86d59f3b4289dda6eb2237fdb4acd6ea10f592d0a5c345048ac96ad7cf471f46643804032808c535c50cec87bd21394341c9a2ae2b49fe84b88c725eb9d6b2fc2a2c20ddde4c866561be1a4b4ec4c01823b02531c58dd3441dff607f574e4f8cfbeb6a6162c47bc381e0ef249a762b1b50d140abbb42b2125ac9e6d423551eef3e06cef11c2cac7cb7ff978a86bcb3836c02a814b3c98a6be236b20fefc9f80119f25d396fad50e25cba8d50fb6c55b7218d930a76072e8a4de1f063f6c4cb39ae926233096124154b79f16c3d04c279bd5df8c17a4b183c0c5b70580d74ff1b7fd7c1485406436957b78f01f66d23119c91a4ac66e7921f86eb4fcc633bc83f1d6ad25c62b08020b2b9c35f435300b3de1d4bf1e316f10e3526c6808535e6a3eef743f8d24f559e384e3f2724a5dd18f07c1f77e8d0607440c7ff067cdb1cbe3fd831a0e2f32a9742981862c33de4b8960480fe62c876c25e55f984bbd1010c22d0566bc947b44fbede32f5e72821dc8065478578ec9ed2ef2743294cfcd2340fabc888b133802f5fbcb2b61db8ee2c331d9264aa1ce7df96820c79da6c51d9f526d54b93f72bd638760ca9c521e79c1166796003d341d4e260f71e5c2dc17f2d11f76b56f8dd722dd03c186d011760d216ad68917bb2aefd2cb2451a5f5ec8172d25cdc3bc3360289fb9dd2361b655a6746255e74752f993cbbae68fd7ae04c567c939f15315659f64a7e9118e2a5c5667b718000dc0861a1dae67b401145d6478fbda98668fdc5ce67b4cb544a8fda9046a460d1262d4d47de5d5cb4f6210254da00fe11574a82c3b7883a54558fe9059b18c705676a65c8d1a9e4bf900a79de91363e97d92de76db4904c40ffb9bdaa753e46ebbd2e91c862a821a6cacc0f5abaa09efd2c5290c6454716b37c03d33f2257ca5336cfeded0e1943a84f0fea1a359c195a4460839f417bbf74d73981ea77689e0e32ff73ff7e82d9701689e7026de8ba8ac848b707f49a97860f37f87ed8d7a29ec409cfb9df2f2000e2e984c9cbf614f23b2ce16128ddbe9e77a7fc05b980d43b91a51a0906b506720a0026f36e076ba9d45f8affde9d05bb626b42beddbea319669ff5b834dfc94eabb1ab7255e3338c47df63b4091e18e2f080bfbdd09394841c3b796c0da6f559a99bf385b1da89bc291847f584a7bd401f3a3728363b31758c1b232dd7bd362d5d2521d763b0c3544f89dfb27367eae2a4c71e94f344067a3b8c1efe2cf2c42bf6a466c5a5d28533645ab358715b3f60ad4360e9de9595e09d153da0ba69ca582fb256ffd49b53503cf6a19a4f9aef22972dca178b53c048396112df68df4268be766b2c3760313b89aa1e293a8c7f9e87ab585173916d46d7439c66acd663d625e38e698ea0c9ed74c1afb9ece7fe33658fbdd38402fdb9565642e9582998b7453caa087529274fbbdbeac7ab6d9efcab4c7d18bc4813949bf6669b761b72ce96ee6cf2a0fb469efb969ec0a58e069889e664a197166b9ef07671de9e253282d460073b19a77433c19f6eb99224d5be143771b186ad8bd12f9e7658920d7d4e721de3dd78fd7cdc385ff946e3fec571e41a1c2e3029afc6569bf0ead39fb0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
