<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6f538b19f302d06947aaccfd3fd5fa1e8924bcbb8520bf8f7433de7eef8bc4ce08fcfa0e370a8de88e0fb8793792f558c33c93e86e1bbbc7552ee30afad719661b8a937218a2642300b1bd95414a101b612abeb6d30c18b901ced42cfc5367a63c948fe8c29b6408b98c02cc9647f9833420fdab2af8bc35a352fafd692f565568c9619660cd48258baac277914130ccceec77eff12f8ea75a5a54893f45d35b03e949bab68c9d6c1a6b161293ee46414599f5263ef7b66f907fe45f1a64636c92730e60e45725999268987d73546a7372e864365bba5570509e00656a8d77d4cf2359ea2a04beef5fd9313a339d6d438218bd91e4b51aabb06f5252134ee3b4c1650798f86bfa4631e01cdf442e29cdfd5808e15e67e426c57e5afa2999c1d2563bcc61ad2750cc726ed49d8853972a00e955a47c6104819a27a39e441af3352721ebe5b30a2c2d69d943cce4704dd00370eb153c5dcceda80ddb5d6e25839be2833c958ca53c9c7c5e99719439aa959f478e15b1019c63f6a0297204d8d21acd0b531a3a606fe8f3b7f3946c9c5808a137d9ed3affd57abee93b70959477500490b10e5f1130a77e0609cd11829653dd1fe4f0f1f67bdf6aa099cbbb409473c183276c84db761cc124a726e8709d5576fd58715b2d48de35f347b405a54f55c9ec8e4107acd58c9b9afbd7cfc6bc29d9055c6698bef94df22a99f3ede1185cfa32e3cf41c75189b2e97dc6cab6eea56bd2d5126271bae55ae6aef5704273e61c8c7e2d8fda8303080c932bb5bd2ef86f6bcdac21161ae081539209d77e489b7cd7f4de9dc4ada19ce3e387bbcbedb1fc5aa592cefc008b8e2a3911ab1e1989ff775ddef0b0ed7a3a7f61f304d05752d19d9a22c75c21250b0bd3554eed6cf2e5ec53ed8d91bcd50acdf5e6c1b5933d239111867ca5ab05f8accc1aaa0b7882b80da29e17cd01dcdc7d74dc3d6206757732044a2c3a346520944a73475db6e049ce079b7cda9d576ee494284fcbc781affd71519552e318a79b6da4437d2d8598a4f103d259508b351786516464b350da0d547fc21917c3d535be20113e23d956c99b4157198bd007afe9ed1436005158b718082311034f92cc42c2e2714516c71e39053d15061f0648bbc23257b79de34eeb39d339945e86eb2aac35289edf626140185457cf81fcabfec8eaa52bc7660cc1e52777850ac070f1de635c6589b5c6b637ccd3612e3758d00b307c3c466fc0291a7e8c95d45eeeae095a042ee5ee11e1612017e5c0ea19f35e4204f82b4562fa257a503a682b1190656f0d524176cec40db99c897b130cb2890cb3e6faa09023f4940a3f2c80d8a58945ed5efa284243040d25141486545d81840537eaf2cd8cd36eff449245686f75ce252be869b78291e23bd356c0b0c11a7cebac73888b0a450b2f7961a6f64eb33dc51d0d8924e22d9f7ffb1a93c43b637cd71b786370e0a681e33a71b5c768685dfd8c3c8a9b9b2d44f9e3f5ca9dccdc0557d53a47ed397d579e5ad96c3dfff811d8eb9f3d35f8740cdbf4cdd5526a380c93d0ed39f5d6f08b38d213a2b13833a81e083dfa738efb8e75cfedafae255f5d3c7e84545961fd5d84dadb6e3d12f7dca8f4bc08b2beb59ddba4a94ef5ea860b6d27bb81b7a5434463bcc716a31f337c62f3c1665f60dffdcb1955fc9607c0ba3d5878b106dfa2a8341ced1f073ac3daa7079c01004b7fdc868b4115abe08c74e06419d7ce679ee001456fbac481812cff36bd3f7d4140df362d955f47a65f9a44f90617c1414774e21a7eab83e035232309653dfccae7a23592cccc64d21e0c6af3b0e5cd32420de9a0a3094c83b9b62af16a9bee4125e922f66cfa6f19184fea18ac54b9b2375a3c89ab92d6004d1516c3492bea84f97424b29ef67b275069a46ee4a3005f2ce0453692e81005184b3dffbc4674e77e0834c67153d3eb5cd0e36ec915a81164130f4f8d6651a16c86ecdd804f4b24d197ee6e74c8905144a722068df8a8675c111c9309c5911c47dd5e477a18b699289626d9cbc1ea7059fea85b3aa9f0edb6bbc2a8c2bc651c9c56c9348758dd1df56fbb0d2076d9d8f670d437be2ed657b9dbc1cf695a4bf318d03669e025ad24898ee458264b76e49135a6d9bbb678a47f04aa63cb53139e855525b50805af9a74f462961f3da4cb2bede13a8d2909f075bd3f9e53e7ac03a05df72646689ac702621cbeb76cf770dce19ad6f0011f72e8ab0fdb738670582c0168e92356dda533518f81c781a02eaad8fc8b5487441fd616d690da938b4d2c16da8760cccdc5429086858b27c6d85c860d4d9eb67ce2a40f755a91b215ee7ec1d194a2b93aeee73b6b49f74cc4a6fc9e4a22bd389198448d2e6fc5f64e0b5f8c086f14cd4cc892a2bd0f8d4e70c880926f7e3df70abf1a34dc17a237fe19411b91999f6817f22c303e25f0e369ab48770033c95039e276936db15856e804d40c997a78bd1899f2ba5e37910a325542718647a32965044127c557d4664871732293bc81efb6fb3806fdd8ae9d1d721d4ecf17388a918d43d482a8b34d4f9122e68aec4832aed9bb71641742f986d1eae9a0182f27f244f8772abcbd1c02522bdb09b503d28ceba90a99a8dba4fdba4588c61f88213244162e4922f0b11e243e945850291264bc4fa2d82e812d0206529cb9648354983cfc1a2ddbcd80c1e322fc4c86581e6a62ad6679d7ba0ff5cf65c012df4663cbf1b81c60f089cdd7dfdfe463caf9ba7b2fd2356112f018a2c261ea57dcf36bb56530056dc889723a632984b28ad2a850a85c0a0f57bf8fe7d8f2d471c2b85d15818b083647c38c01aea9ded4ebf6a1ebbd487223d7f4ab82710ab7310ebcc72bfe3ffc00d9570e6b85bba2a7c063072caf76e213abaf3d5e658f1d924e14b2c3f5561cca9e41015dfca17427d83d37e2f1921d862d962879f54812b126e0c91b847ab4733995ac1773d64de8877e1add57fd1d68f091de09d5870db35c89053533d95a3f5d7e37b526baf0871a70f614aefca7f841dc85e8f7aa0356dbd996d9c7be3bcd4c567af49eca99bfd44d776cf77faeb0b3bc462693ab2b4aa42b023c467303a44e52a45435c5bf497a7f995b0b7b71322a5a0ddf44bea9941001c96c79a82be8d86b5b2ef3534ece91668053a0de7b5b2897309a7a920c0c15cffd064fac9e6bdcae3234fd41f10bf610939ec412fdc75e68344361d85b146a62a9f6c8393cd068d3d93eee65a5c12b06190e711dec7e2640cc80b78a59a05240243fc47e29e5c7a5e09a18f7020229d03714b8fd31f4abb0ec8a2f23189cfc566dd7da2d0b49e431c06787b8f1be19e81cce2a3bafee0c9aeeb31da0280b41edd30aa2553262574f76908ade92f1a6960d18f4aacb10d74c9289341a92436ff876928115c5b9a3e195e1c645f66dbff9656322c31e8faad419f65196d4582f4f8940c936e8216ecf7ebd3770bf49c0c1bb97834e5a3c3e26f0e0cb56cc53914741305250ff341826c581d2720dfe4dc0e1e013d9da293bf1c161fa2498d79f4373426c2dca1ace4aee598503028bdb395168b5f3109bdedfbb8c62084479d4fb0420a864a38a7809fac4383bbc3b8788fa15688daef1cf6e7973c8d739f5d5d56c48ccb0222bb4abebb6a14a7ffd70c056693b609cfdc45b649f028fafb7d15c3b1736030e78e82c2bab0a07faa97294e203bf5aeb1f173f2d03ef8c5b755d5c785cc62309c66cb6978c1b088a0ba6ee22a4a32a9bb4d91ae1395e5143935b110e2c2a776a66f1b926a19ca0999b7b088e2034288e4cfc91a987921e054e7f4ee0b20a63eedd36b97511880dfc20bc333154029a772134e179cab17f937f2c5eb6a7fa177df73d0764aaf083f8d3e42a02a1f30fda930117ef6174d2bcb47143223c43943873d9dd560f882723423e52d4263db99243325f255586ef94d091ba42258affc8630581ae65c7a75d9cff00e4b21a680748e0d8d965c4da25b951bedc0f889ce27046bc8c245536e649ce4f23c6b47fd9015eba7fe022beb4fa1760066c790e4937097fb4827a9e1c77c79fe6f85902b34c1b354eefe758cbbecee2aff8d925f41658b52fe7af01a151ab43f91fc747ad4b77c3ba90c52ca3c024f3b2cc812d48f0006fc70ad68ee9c9bcbdb59d957f5ee81b3327e52b49e0a9e8481c981402f8776313f62c37f7a9f1b1e4ed5a75ffbe0f9be3eba9801943611c97e4caed2dff8c1b10f2870357783072c5c398334382eccd862fabccba3f1f5715f84d86f91c32c2ddbf69943c8b91658f52431d71e5d4ba617365f0b7529149f2fd13ec818e786279a58698eecd6a516b8eeb510e72d7db5704c6673f1ea7d4f8b3fe6da01b2478524b9da04eb6866829d0600b9a32fd47d76789d6840a74cdb945a69a2f2ceb72b092d6c5162e4b16aa668990fecd9f733b1e1b3939d7e7067859f2a102eeef87d2745f9e353599d61e9f38e12b80c9466f6629c9d5ab089ad3ddf4bcb8c77f94216a2e173b0ce158950fba2f4d50cef960db15987720c4bc77aca00dde105b6fda1c79d6ffb03365c7521e807d60286972d1d55822dabfd84137b74d93ad54f5815169836d50a2ab33e8151edec73dc10748416c81b9298f4e3ffc472a566e5436e92a2153928a087255ee1454b67a18ac2ded9ce6d1465019f1a57f594041199eb1c0d858e9386660418608ec69d78db8b8b1ab0b5d26832e716e062afab4a29256764c2d2fa1f122d3f9922985455a3f2d748936e6c62871ab90f679efdedf8f722f83e39fbab0dc8212c6b066c875aca0f51cad8ff3ff9b4897e19e7822c67c49109c83b615ce03045e0b77f603075812d9e9ce0cfa0c1929c9830818db65fb29f4edac98c25abcfcc6ace652e703b72a4170fffd824d9f030f6dc42440085909ec848b873b0958c00396d1f85710c3fb4b3ce6b7f994e3cb6db516b0af342757a933a8902a37301780e300f1860837c60f17d28a57dcdb2cf5a5d8f1d23e49f156964b99517da33c1807bc73f2cafd257d3d776786c948eaedf61720b39b5907ad99ce8f699120c87f242c8f1630bcd370df56ed748297f560f972347ae7e32d3eac4aefebfadf27af1861a36008184ae55fd81efcdb9d00f7998a6f3db82ddc413d92fc3a887bc6ae919f3318a35ecdc9b810bca73c15b27f8a3029f35c5fea02a63582171c1461ca450ad2d1615008029556bd83597c1b803ff15360701eaa0b0a9f281c9222a71e9ff44610f2f85bb30408ca6d7ec0368561c281c78d33c4ed9a8ae18e1af272cb08d647b1c5a363bc9ca14c3ce812164a5c62c95c45f81c058f664557a38f9dc366d3589c8ff7f8de0cc3f3e733daecc5a71841be7b39311fed32790f792aacefb71348fb6f4c25f911e44a005dcfcb8a42c0e012de39686e1ca6578f0bd04b2bc1c37bcfefac48475be2ab9259c5202a377ae5c53a320519b798e975b4884c2f3f6538a674749b53427fdee64c6ae00f4a6f2a1a49182c72bc66c48b9fa016640f595b8d75069d9a53d6573daea4acd773680273f7a0df01359f6e79df29e5f4cf1c7820d309f708aba1d4011cb7a54d57c879fa9c9a7bcab8bd7dbdbbf54d23ffc8576dcfc222216048b934e211d0645f3d2ea231ab399e85cf85599c3a9f11b763be69ad196778d9ba4065ee08960c65263d1cd6f227c208016b6dac03251f4cad86ed4c3d714e34632533c7d711e0b7c9c2b093e1f5603baf5d53d4ae563b69203b3836620ab7ee8c06fc7d353d79c6de6a7956175463b5a0dc1f35f9e7d373640eabb9058ac8ec74e001ccb1c2b7fe0ef3253061dee87d2a34b383863e8d4730481e29d9c133c3539cada8611685171e966d8c87eaef97825bd8291c5e63ebc20244ec6fc9eb68e5b288d8203eab648907ff59813692574d3c8551ae59deead5e4512883e4b359bd1b2670b7b3779f6714c68c708db1a48117a563f16171e09c01d66878e7f57f2b5f1dca6f59d4b282820031060ae5091ff26cf955b6d3e5bea24163d9d52c79528b00292ff180c75749193101babb674a5dc9ead0386583cf67764393047a4d8785d1f50cc40c952c6958bf78cadb8db60f62c414ab662e48b28b079633eae23f57f2e9bcf6ff8bbe52109fffabaa7018a31a03652a7b8da74ab4977baf01fb8c590d263af0dc5fef3be92a25188c3583155eaedd7c28a4ba32ee4b50f308edc4085f008527b38846841db141acfb0d9850f058f253a972f42117815bace60dadea8acc93f23f598e8c9add68f64e251eebe2e3ee0ec8273fa190f4a86ec6a36a101d9fb4c4c4bbda068e7ad4f8f8737cc836d189d30fac1372c0f5123a928f75a70eca4b83c5ead056260b0df3499cc585b1b48045bca1082e1362e119098932b929823eb21a2adde06a0bf1e284c36849d4ee81924e7df86d6cbfa1fb1612d525fc9ad7a8e394c306c7e2ed5f5f36ed7ae098bd2fa78fc0f10ee577948fd245598283e0fec5c37c9a099dacc0fbc1f8dbfc4a553f949b0ca2d9b8818cdb231d71036fb809b790215cfec0b81154ab779b93ea235eb170b37b688b2b3660ef89f47edcbe7cb700c4e5532f48a6be932f205c64f7745f73767b3dc176e52843c55de0e19345fd3cfba5556041433caea1d4b1fad1ed1fb3f42aeffb27d578df9c13bfd0e379e577ff7911bd6efeb7f8aadbe62ce415c0c6dcae0a7ec3be831187c979501deaeeefb4dbc3b106f71cb97b71c9b86e53bd01f084284d853a0a8669796184b3e410ebc55a2f1dcd9ef064e4b4c3a45914168caac411920e940a0644577945e9a1a9e08e453391d9a1acd4a1fbbac958b856556c023975b433059041c3415f053ebaa04ceda86badb8974fb46ef1e5dcb8635f4f563fc3aaf1db6f7832e4950420c1e8d4811ddac7cca9727327cdfc9ca00f98890e6bf7c27f0b494230f5ae0d6d3016de57985e01e21bb30898b76ff4447dc0b275f3732f24d53ae5f9bcd9f406ce36ed3461a8340b4ba09f55cb197c47be36ebfb9f098193813d20530a8b40166c4eff28c8a4f22c64436eae3c5cb551eb3811ee381a4f5b6627aa9f0760ad2e9fc69b99e0fc1ef414e61aae594b8e390f94644588cf2094fe89c3a0829597584b5313d99951e26e4d687c3b0af2315c0234e4786288f68499275f780c5854cf3e7252ba11eaf5a43c14e03a87737e2f3a5474e714c7b2ffdb9318c607832527802a0febeb4c433c38db2d39a8d334bc5355bbc0490e5850d66365fbfcf08ea2a6bafcac176fa1bc31b89e64b30915e758c2779b594fede0d4b9adf6f95566d592a4a657767086dcc67b31f719df29ebe293cbe46356368fbd3706f485bf6a5b8f370f32bbb71c6859f9182612d23a87d9a2cd0124ca07aeb707f6c584819a11a2cf176b3b072aec53d028622e815304efdea20d9f03f60115e10c48050f4f4a9aa8fa3322e5b74cb906be99c4f8cf0067ce7012f058d4bd4a55feaae30ac77e74f7aafffa1d0875e4c02b4dc7ba7c11804e422fe99f17d1abcdae815941d53a9212ee48dae3f16b2882d7fe209d7bb7fdf0c2822704464b7892629574a2abddace669c53fcf385b4165221c772ea2bd4bd3c02b130d7e130cbe49754d9c3ab72aab48806db0ad8413f9daf806fd602509d01985630cf1b389afb5ce23b2c51e58d5d75c157c48defffe1af573e96800ae8d2ac6176976a9b77fb92f30c150b1f552b05af735d05f5e9439a0ef995f25f182a6331910686a7f37de6c017a5f8b2473d0ddf7212425bd1b70ea05739b6c0411255c38ee800dc0497d76497f992924b05b0a6f5e84f4af727a67bfb1268b0c720433307c654c9f66653c633ee729ee663e9b0ff6f6f0f3d711f955f358963aa4f225dc9319951764a47c1fa3bde5b050c3a16a364b6f825ad6e56c431773e01e4f4a06d15a8e83776e5df3818e178d3bcccbe901f67d7c3ede87742d9c79335359057fea067348b98f9adfcb32dc90b745dcd105e97c2aba05527d81df92e4e8f883568b63b11e46d2cb81138446d1f64b99913797153c30c9fea35e010dc9f5ea03c8dc0e81a71c21ac0cbdf014f8c1a01fb4b86e5dcdad15c9366c18510e60fe535116c2d7d9667033aa24d6adfaf1df1dbce16e43c9dcb70a7c20fb11428ef0399f91629fce3403fc07fb498cf645616f61d95bbdc1849c281f0511d3b5295d03c5ace06b4fbc9523ffbc43b07e5fc9d414467e3a04d7bdd8e55b6bc660e07530c1b2266425b77bd3abe9644abafcd3f69755977f8a80b287f4e739def985756d50dc77349a1a97447db890ff335314456fff823c8473d68ab7cc98a657ce8cddb2613f4752cb224b2a9c787ddd1e91ca6378aa93278386a2393fb0904a71b482b25b7cf80a12d4e7d7b5b174c9d0a86b4e2cc953423cf69d75e5fc4cbb58734d1b1ae0d382ebaf11eec81d270f81b733f98b741d8b637553e1ea3347c94bef28c2f30ca72d997799da51b5ad2f720bec4d569e10cc11115e79559b14bc295897ed5b3fc4200fd098c2d5559c7ae68283492b411dafd16438be1b5d6afad5609af43aabadbdf93259484539d88b1944bb3e7b844224c1d8cfbd57f08c37dbac454d3aea74391a3c8c17ae12fb5cca1bee5f6ee7d0d2f602d1e6a9847e7fe430138be51ccdd920df8c69043879c95dafc795dfc062ed38e69f1338c4da43a83397213655633daf7994bc44b83a44645ce6bd6058a598862d78c6ddb362a1ee8e843a56a5da02f907e168e573c2efab852b275c63c700df1ad94b718fd306a2a24f6d0dbb49e1e8ae74e7a01f7a2fac354c47bc02757f99f23f4087c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
