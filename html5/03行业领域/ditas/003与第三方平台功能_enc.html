<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b18b94515846ed651fbffd9b2a49e78fe196151dee6ca13fd5c432b0e66663f35da066ab1928e956fae8422ca2c6d8f95f3f9f29a2d12c1abccd0d7ab6b4d7023f56093fc39d10e5bee2fb98b6577ed7a7e5fe6c304362e7487e5bd82ce965bb4dc80d358da0595da5086b0f6373357bc1d394c58484be7bf84820407957d84912257774d75a995dd6c29a8b16d7e8087232ed82f6c04186ef217a2e0d8adcf6adedfb60eb80a8cfcd9812b58b51e8f3f9aba697fb2caaeb8bfa0fcf1adfe7b06e5f6e4004f0beab7a1a9afd770c3d511444f5947b081170b42408a51272e54476390564ab98fb01dcd1de25ba8348a9f2f9371511644fe00f01b51827c4576486c34196c1223881c52fffe7d930fa9639b57c84d26df1c89eee13f8930e50acfee15dbe4933aa6f0832086208d7bd0ef73cde0140e6b00e4b1665421440d7283e1fbd9385835dc73a15d027fcaf7b75095cb97be7734e6f99e5ac7e02a57ab730fe98397595ba6d701c657076cd69afb3e3541cf790dc1dde8c4110b0178308466bb034aaf50e70897682f2a94dfcb735b4904d9b916c393705b0880cbc7aacd55e0393439094350c161da90d3433274d833d1fc6ea03feef5d3acbbf3f4541785084029bd6aa9005cddf8247d3e7a73d0404d28853aa88a491c13b446705f93687572e42e47e542dac99f6cfc1f4f99a58fb59d07f04a107cfd63daba17f220a10f1b904fc0725afeeecf1586443bb9855a44af1115b5c0c2e5c146cfd62dce9ddecf0d6a2767f2d2152defe76b93d7b2a28fe8407b6a767ef09bae78a7ee5bccce914d8f0ec5385a13d46489b9412e478ac41a9cd3f58aae319ff9d9f69060226b15a3f2a0e047583aa7a0100be54eaa17c190028f519127cdec51bc2043d173d3ac5bc5ee0e16e3ef5a917aff779ac3eae1501de7a8922d05705f5fd932689e9f98d82adef7e5faca8e23f5c4860ff9fdf74dc5fd1c066439da915019f7052f752718847b7bb0c46541d1b6597e9995781c457ec5309663228cd78dbbf70de56c8ddecf8d7411e64d56c7bed16ef690901913f47b39bd10e0424f16c1d37eee19aa86d6bf72d18717dde625a10cee791cd86d6afad83d09ed7ee3cf666977288462278310305f7993d6f5b9ebc70e22a1ee0cae330927585dd455516cd8f01cb56c210b382b6cacc8d01ffe760390b7417c43b567e5e3158b8b09c85aeffab9d7e640528798d68ed83d67124d8b42017a70e5d3cc6e378a717d174d7ddacb6eac57b9a65e2c7819f5e06881f1265c0deba66206faba96f435266686db2fa681df862f7f95624a8497d0c8b2e7f249897b2cbd053ac5dc179d500d4656e0ab755ad3ca6e91a6f12150646d741160b4bac1d58bed42aaf7a55fa96aa51c9f17383899f68a3e50104431bcff86db1f1a2ef2bdb5fd087773e1d9a2c67cd9a92e040461a269b86c2528b2b64b32613d96c38b21428532cf503cc39fe700185bc57ec98a3c294d4ee2a2d19423f161a6d9a6564aa7e6af12646884bcdc525e263f699c2e030a2991b3bc8382a46509f2304327f760511e954d8d854ae146e7ec6e5efadae6c0fbead81f44cf9b5057df7c395d9f3b964a39cbaf09f3048c01548c6b99d6c75cac53aaf76cfa7f8ac1113d0a4d2ada54c2e2f57891176b8319b0929d68b8d6ca3e1f4fc7e7fccb1145842cbea9f819246a96adb053af938aad82cf695e5d94476d936f098cd7c0af98e811002a131983780c5cdf310ee68b9df005342fd73ef4a1df08cefb9c903b76d8ebf11cad1a5397808274e3d5f0d6d29f5200cc46df35a06cf6090a111bcdc1f9f66ee343c50b240a0b61d64c21b5b30ed2d3a42e8376c6152ca99d2ce87ae3431f310c449e82e1a5c54220ff0ecc8e4eb4e66f3acabd0c0f4072aee12e77abd364c65e00e8097b63d75bf6580d83b915880c8faac08244d60c8888fdf7540b0e535d776f35bb4dce3d35e8f495f8d4b15136f50f4e8986ae1db4e57b4c5d998f14e960ed9c4af00e9d00bfac9930b4d47aac8e75d3332ea91aeff9a57a3832124b6f76de6b482eae7a19cdb1a132e907e21712111023bb538a81440c6227bddd283b32b2f5391d1cae832f8f603265e1a67f776b6d6325cea03bd908f216e03068abb3e86224cfa666e4c790b08791c2c92c5eb0b623266c2660f7c77b9a3b1a762e8d33276be54d97bc19dbb2ad260383748b09f9cfefe3b367459ef7f55c370f935f239cad16eaceb5a5bbbd4422daae14835308db28de6960a668983e79b320bdf58fa89cf30ed35757b5144d905c59b72ad5199a22d55ff3340f54a7d0b98b2dfcf2b1e65823a39acc167b729b68c5f4ffcaf70e211daf3ad9e74900cde99e51cdfb1b623f673bd1d327a89ff5c9a503635a6f8987085f96f9694e78e51bf91d4db945b30bda4dc4dde64d9c525e8823d0e045950996419b8cc7ab3fa40424a0e90b9addf51806581773fc2a45f0efd06d912f1984eb65a88f4340e42314052c9868464edf36dc30644abdc4a93d425789f8289e8ec75bd25ace25fce00373c9618d5303cfe3612d73a751947dc5b8fe8c68fa16cf9295a41d97da65cbe74d1811021c0ef99a376e2c999a93267f38d196fc8604b6b42c805492127cb0ebb86304f6232c0c894fdc79c6a163e8742f6524f541511ac1f4c5fb92765676499525993951191318feda85d5a6ff84fda6a6e8514286dd9ee1967f9ec22ff20df0bbe6bee94c1cfcf480bfe8650796f397fd46daed50229489771611c07aa6fd2492b99b3fe3ea94ede61208196e50aec85a4e92f6d56f5bdb40109dd3fa75069d6a706172f306f847ec763b87de4176691571f498e25e36441e27b8ce52473c353f714629b2a8a4c420ffd4b34c6a098232278aab7a3e58fcb357db6cde91371216b445f644ca2c031ee2379292bb4d239e09e60b8bcf870c35e556d94af723d5aab55dacbe3348e3c4ca561eb3d6bc165c30dc4a36901206cb7376484a525ffe73294d1973b38057c19cc519202b826c91399e6fddab13bb1d803af81416cc5f56e8fba20907a3dbc57d0c83494573b7d2e7c3e4a5975cd30b37385c83a8ef3a34328d79a11fa67317485d2d40dd1f41ae856ba81759d7780065ca11c9c03a188cae03313054f3c9f772bf8200a9d00edba080519318ae2e115236d0a55b7d50fe022704d7677e73c6ecef2919fbdade2de1672b123c54f236051aa4fa05e44a47431876ebfe04171f5d5e3f9f5d4cb20081a6f2699be7632036dbee85ee8c1bc3f6955ff2e656e2ff4975c0c7370697da66c490e802af1dd6c312e399cbdfb6dcefa98e0b6003c037ee9a53221dd08fbe36ae2a10c2f2aaa32ba7b05c399be800e3817cf085f220a373e13195618e8c90474dbbc87b6bae9080cf1e7f8d50492e1760df2b3dd75071bd048570d0a482f0376067f027018a570139765b625e17a8553c6b466670aca6aba8c4f1e624c23f2aae118cf69c47d9cc2850d90de5b739298021d385e066513dc0301adc77fcdc28921aa433504a5e3962111a0964534c42f62650cccb29aa815b9a862916bdeb5193e39239a61a4da39bac1c3ca07c437e4534e4e9a45407ba9898300cf96733945e49452225ec87642c6f815fd571c75defb2b88adf551a9e1911ca37aa54decd6951c63acebd48056a6f19fe1de08d8b111ae2048bec1d73d19089a874c7ccccc3fb368248f6c16c54f5e41d513bef129a071c7cde216ef035f24cb39d4402009a85e2b5fc5800fcc2f06b6e32b0fb960ff289508bb259523049f3c3475ed070b91580904727d284f0046d0b48c6bc5fc1594636db93bb775ab7de978fd0a435e6d489f48de1f935b641c6365868158a15ae8559d3d3e63b865c5d6ede87ad497b8d695672eb33b0dda49342cb756171198a3868bbdece918222325ff0d2d7c1c46402b620536d777c70fa665778afbd1340a5a60b17edfd7f3a3303d607604ed08011f322376c6bd01e32052f0cb689310cff059a59119d95876524c3e7a64ae6b23e7adcd98d00c4b197cee7567bf5f948ba3601085abbfeda26cd5a503e736f396b613ce7a74612017606e66bdd4bfc6f75f5e5166a22bb9a01d10855995c74d60ed39a22cdce16276ef0b40e5ef3eb8368884b0a9b1070be580cbb26a58cfaae898d287d4c92311421dd6e05916c3ca1105ae6a3173e61d014f65fe1c8747742d139eb93dc47ddef33c8b4928934d07a39e566f29005882b297b6da1576e074464af0aee0dc114a6c7dca68f709cdf1d89d6a016ba9fb3fba2845db4f0e385218deddf09ecbcf0f5ea71705fed359988605dc9a47fe192a530c4f1a14f5ef99bdefd5b118a3a0b6f713c33966caabfe6fd1374fd10b6b8c80abcca3fc64d6ce54800acd2e5fd02313bf7e2f3c75ac1c2979ca171a79d08e2dbf18d6415990454da73192770120e7e695ee7f8a7306dddec6174bb25d98bfbc54fe55d1af3fee10d67cd25d72c9060455955145c35c08e5a33b498794b4b0c340b426c7d990967fde4dedef6de633853de643e6db6ad4d440af2ab457e68896e968ed4c407726d365d36dfec435da745eb293d0679a407e55614729668305fa06ef3cbbd7074f37a3fbbdb333751c0d6197726fb87ba0a648e3e46ccfe929907eec1eeb903d4745026ad71b3c56e3a43bfc840137213862248f89412166608e9b3a50412d977e68cc16ed0e9a316e30ad142806945de62a42bbba9f6362b328568acd4aae9dd75b5e444ff209b3b63081c8c0c35b4247b539dadfaa1460c2ad32cc5922941b4a435b37e20af7ce5a942c1c2dd93bf8d847c02436f40d2e63fe36a200a94a6ee99de129f13fb5c8551be7d82a4028105682aec4cc9fda48531337b86c1d26ad3314fd04f49bb1324c915376825e44ee843948162b28f362220e851c0e943a7ead500a5106d277b8f8516c9a0c782b2c2d1cdc422083d96dba4121e3b8b9fce88eb6c59b2094dcec0a5834c0aa012c58035188fdb7f16623dc0b7c32d98a7a558cfbb60e9fd27462612f1bfbe0478b7b404461bade3903e866200733161fb6ad7a19eda4c8460d2c04f9f9409fd67bee83ceec715cdcbb513a0d340486f993f80ec686b604dd8b8063422cf52e3cb47038120a1dc9d1d070d17303d262ee921856385b080ec299d47ca874e14de9a35fed7196167e0177e032012a301ec864fd62b41cf8548b18ef4be67950b955be781e785fef36f5cf42ec39e59ccba21ac2a8cd9cd8e20129d12653c0a37a613e2364e09f5ae6d2196ae7658b8bf0956e48e61b282e3e426cd2cd87703f6d84e227a4bc3baf67245982b4da56656fe9ebb7b24dfb8b059915b8143ccbbcd419a40f14d96f77df68d13d93486c272262c11eef97280e7b0090d2ece014919b34f9990cce743e7fad015249eb7241c646db8946396b09183002f440815936d1246752c15fe6c5cd844a1b89403f01994e475cd287ff34fad2a16629c43f28cad445c36db7da191889a9cfa91c6c855b950d5959e8edcd290a002ee81bb130d946631e5818f5bbce93fe402dd722afde604b988fd9e8c74426cac16b00692c9a2ce789895f423593f4e41f19d8dd55a18809edcc650e563ddf3d902a7d7220c6ec292e609fbc587cb9f613e8d7a185388bbafbe3dc6a1a5802055302a996d55f63518625ee6d795aa508427dbc3cbee6d1b677b6653fb9512f5f7acb4fd2c6e5e6a2373769ebcc5a60b8feeda7b2925c8dadb6d7ebae5b6907bc232e080df3179fe1fa866a2bea92caa4fc067812e6d5480ea3d6f3e05349165c2a4200e9f792c20123f14cb3b765d8c5edcda8f8ef29f993bac2df4eb75e88c5c273227374b71039d9bb0628b9cc1e8289344877633ec4c70ab15b667aa9c7cb9013775ded8f7a89a4c7894d24026e034a8b35bc1173a4b2788de9fa89d0c580d99ee704b560ff48358b7fd334c9f4ed5983957b107d3f7cf088ace9ca807b7f8cd453bc0fd8de9bc7e31d8f6919e828d0a8f3367b710a0160c32fc2c270c6493354a4cd48fd659331c6978d2a963ca8354a355278adef60547690c0f9a50c837dfe1173e8be57c89750dac534f0f6f64338a56153add67a105c25cd896191d31e921276406094fae8c889a42e1324e0d15ac7bdad0cb22773fa6d2c110cbe1c6a770091da6101b8b7f2847d5317aa833a30b18294f5949491a481b6a127b661ac9a53704a719a57693c229a9d18715114dcb4a9b39992eb30f84f49d8249ad0d795f6a7a90316acc2f3f17f8706fe14d4bb0a3eea609f39c6bc267c131bc99b6a38e3c882abe6f1888a7b825930aa40f1cdf3faf3b0782a935714e5141a01663e8a70b3ab8b084354a7887e67598de878ebd04ca23fc3072d9d2c2d18ae0931bd461aac0102a988331082830138abe65447727d1e2de042012762b2160c4c0a78ebf5441de87b4e14ef6353fb097dc1c38e08be6296914e2e4c251ffeb4930036383065ebe84550449b02bd7e9516708ae1fd0de03788f08ab5026dd86fb9d787678412edf5a0c8db0741b00286c60a21e252e145f1b2384cb40071b0375e5b25d80407e82f1973f76837686af38ab84f6e6192d0edcafd8d65a6c4ce0d51688d59913d3d48a88b0c40ed250a0ef6bd330122416d3b27b298c1bc1ff8f7345f4d8cc040e19eeb5d017e084a91eb2b96c01886245b4c30f5321656734b08b1bf527b051932d2cfa20dcdb7c6cec89415480fb40750ff9ba1fb8b91dcf9fce63f2ea88df36831905721ed852ed4e18fc58fb5170fdd9bfccedb3ca95187311a3d1a16a411e523bc9b3293bf7b44f70eab2ee24edaf9b66c9e9db03465bfdb2ab512bf921fbbc96c0abfa3ee4d1019cbb148602fb08b09c45e7a64761a79b255612fa4b143cc75961a37d2395b96e09518b9914289935dbd9f4803104f13bc3a2e8f61ac02891cf99877fa050364ecd31c6f0564c86c504fa69fff295c6b66d1cd3d874235bad5dee24e75a6decca09c13d135fb51024890f551d287ad5209fd02d41572fb3a236c0315963b2586eae076fac092a2f58d45b1fd0394d76a1c8e7711a788c57fdb6d0ff376077bdf84161b92b35b0ed6461a9cb8e1970a821f433ed32721149885dea7eff87d35e2e147bec8646271a978dd2f365ac9797d9fa1379bc65b3737a26970cc830ad05354c2616894cbb52c4bfa2b5e5eabda5e8bb778965a187cf208111e155ca09dec09ce11deed8ec61f3650072f5127525d8df443b0af64ad75d22fbc42b5003ec722ac7cd2d87b4d06f1660b7f7f1fd56a9f2a158e3b0719b98c93d2256f04dd7de219b45ff6d732fac3abc753a52a0a4d01f69c7cdeeaa916a5c5ce9c6103ca8e8b85475ae37bd3d3648faccc3ccc0656ec614be9ca05a5cf9531f50e3dde171cb50e7459f041deb15ef666d1d541466de49f12369922d280602df01d1826e0065d243a7fc0c06d7ec8d0c151fb39292ef649a0c8ff495966479485c30968fc10532edc5e56bf08cf7dc023f0c1656aa95c91de507d7ed1137edcb017e39df0adad75ee2dc36fe486601928987b0d121fdcfde41d2589cd952fe17dd8a0e043d937798d674b720544468ff5504f7521c05129b712360c7e4236f28d8990869bb336551a5437eea60ae5eb6bbcc62aa964794510b9e5ce90bfa1aaabd13c9c06e22a19becb2f10e8fad2918d2029ccaa6d0eea44e979ac000babdf47180c7f1dd21963a2c992d8f00ea53371dc72ac60935d5e9abf657349d7ac7628067e48916d75d533f330f51f34bb66f91a2ef3e54cf3836c9e4710ca0e5021a765a1a1b19341745d7990da9c6981beaa64a6faaac112e60e7a85b501c59aa945818309b6784a584f5df173e57899e0b1fccb98cbc3ca82d0fadce80c295a8a4ea959de88758035aecadc785b63da8b6125eadc62822c106a1e7f520c9fc595d25beb6e3ed1b586151c2025395b774d3bc2264763db331da202c006a4ef31fe94767d20e906a972b55a335cf08cc21640cb8b1a6b987933eb19281bc02e39b722571fcb4f93e48cde4e0ac9404a2b81e0488ccfea2c7485987898ad92cb5ac069b6466b87b89aa668480f44d34fb9fb877f4573fb926e05b23cee3b5820af24883b26dc94f3c77341c6b0fdb363393bfa8bbf6b8bfaf2a6eaa92a70800ca1e707e48b75f43f4022a0ad5346a1fc860209038561def4a91bbb679cec77d3edde083be8d3221b11eac3e67c6f53d2616e0ef6b4e8c219534673639d8f9cdf66f34cedeecb79994f0f1e9a6cfd31befd9fcf39986a4c8b0bd6069d63b3fd502a2b0bfeca6768953a8366fe1f88a0815f3109e1737def35ef5a0b02d54ac6b9fd42201d548812d58a6507382b0bbe402fea3b78b36e2d16e72d343aaa20592051ae1f616b7a429bc931143f3ed937acea668678a659e17390f579f95e84d5524600cea29bbc10b79c0ea5422bff568d0b5b7df91ee19eff11fd857765851deee6206c93a017d3fdb69cfb122dddca9ce67fa23f0c0f88bf251ffc34b0bffe83633a18d5f4ad245c8a73b32eb18e716d3fe6e3b79d6686b9eb88debb3fb57f364d4e20c2ac7b2ddaaa99603f5822a543e5ad4ecf38a60996f79864a78be38c12763414907d69ad0d0481cb0d334fa303aa35dd61e12aa3b3c8d3d3596539f50ebd2d34c8201eee9be7812baceb27093ca97330b1eeffe9c7d7fffc4a134d69a2b03a774c41974fbb226a3d399ea9264c327af326744f7ed8ecec6ce36de8a7bf5c8d4cd4764593c15635a98e8540e4ffa45103f90c607a01951fb56b097cf6329cae77cca20864f7643eeda93d6d3862948dd87396fbe0c895e86d7b925417076fd31a1cd6c5a47ce662fed65334c963c8c9e2a849428583f4dacdae22f7ffc784411f1f8c4ceaa450dc041eeaa36e684c05496cdfdb007fce019bfe91cb7e03eaed407599c3c99a5705392cfaf201e9351ba3d3d6d673d822de20f59bdffab76f9f85e4a62156347182dce5672764a13cb0172bd0f6906594ab4a5f28682f3e0fdf55c152dc5791319c73adb4bb4d850e3e93a7c3b5a52cbab4791462ec7dddbba6bd52fade2a29cd7b9a36ceb4bde9383dcdf38c212751bf2400171aa4caaa558188ab90d3e93743156a420e3724600d575f00ecca06d38440e998172a84ccf38e5cc06fa6a81d6b55ba8b491e83ffa94570cf63c55bcf8c7c2c3a973a2e5c740063c684be6240f512cfbd80132c4c7b24d7fe85a3604717071a2c65e8f704bb3440fcd3378e55a17ce710c81cabcd648fa41989c42186259673d7268b483a0a03522e84b808a4062a8b589a88bf1fe270af4239267e1d21c1f4c861d20d7e3adf288e1730124c847f39e90bf4ec77544220331c4234f5c1002a816e15c1556a95132d48ba38fdf21f17807c0c61389e99eda7445c1f04220396c5328885a4bffcd097196e23c8871321f272ab8112e6de4b03d3b63ec8533d6c0cb46bc0ef7a6d18f906562cfde9383fd6336f4b8b46c2693c89cf908eeeaeb778bcee97d2006be956d1e2080929615d4c7a07d1a2047e7b878d1b569f2eed2f3ac90a6d9f1c04c2f1c2dffd974697e0f1bd21000f24f40f53cd137969576c474131590cca2f96e072b127353dfdd21157c774fdd564990a32f7ae8f7df7dc25a5a8ed48dd3fc37364a9f3b5d4543d93e72a7fc70138f2f1cfbb51d428629b364fe658c4f16dd94962dfcae7cfc43263158465dea8c8d8976b38b9332ab6ca7d774a7c8b47cf325ade6cdf711c4876ea488a3c3a65d3819d0a1a04799a56263ce09d51539ef7f3f79e017f51cda6c97655b305e11e4d1c82874f81e431f67eeedfc683bbbe3f14f549fcd2fcc24cdf9867d0957641df18c775278edf66818ccc0f8c8301a23d6a8f8ef0d333d72e9b0e23be151874e3190cb576e10ea8ca1d8c24179f452eadcc5d2412fcbbab353a5046362964bc389037bdafd4ee574f69e4c2ef7313bf81eb0ac0a4caf5450fcd2ef86c40b5962046a00cb73c803a1a11ef417a9bbaf9706f42d59f26b3926993e297217b7e2c89ac8fcf0c8bd12cd3d35d750b44861b49948008ebb31c0b52f1082fc49b03b606f5fd77daced0ab1d5788fc6460d5476f8fc111f5d2ccbdf1f297d8f2c9cab87421e857fc4294a2b44d223d829ce69419159fb27abfe7d6ddd819e8ec29bc1da69430479802dafca9b05fdfe646f3e8ea075e585f1e559e0d68779538ae53814e49e6bc0453b720b3223a6270a5798052f3c3320e3890593916eaa96cac14690b5d966218c6109b819f63458a932756905e2cfb8b815e58156ba9f46f5bd240ade9a02f9e530deefba33d6d57deffdc89b7f7e20b5e3b51597911ab900a6dda4fbe23b95e4985f7a8ab947e4e6ee799c23aead59eae9ffbeef251e1bc6cd0586fc279f638f3950638307fc259b78f6cb56ab5d5a66af8d5db4e62fcb5a5fb667d1b5e229fe67e54aa087a1f75753bd05f30745b59dce8b4875f40a420b7d4f180e6cf1e1c211e2ea3587ac4d905e8c45e72a07812028fbfe7e335b27c676df78792484fb3c80ff093ab8d594b75b7fcded9bade2078774a0b32b1cf79d2a86bbde33b5d69f9d1042001d38a518d2ff2c1d7c05221cb38b24654e87e872294192d2b09d4e63cbaebfcb991dc629677751ef2d46ea0ff37315d571998d34201e55dfc45b0fdd18f031aad1f735c0d0ba5153aa8b0eaf8fc8cabe4282ac2478b3130bdfb2ddf09c86a52fb2a262797381dafe4dfd426de2c975714e159ee32dd5e4c82bbcb0b09d549e3272e1e333c521de4ec09cd66dd85d6841b24e8c9fb6ca8c4f29bb3e130e15300447c5cd97aa57696a32fff8594b2ad9a88e40f08589f84e61a7c716ab515ecb867bf32cf8b21f50fe301416671a48cfbe100190dbf28a25e64fcdcd415941497019b99bfddf45dbd0938da2b469a81c756315e52693e880bfcdce682f6f8644f35549ada3293e56d0d8bfd8ac5e1a592981eba34b7df8c1b7cad8715f8e2d1a1067d8d4a5090ecb444e7bd2875c7f2afbb09a21fbdbf83c8204ae8db71b4758546689fbd5608d8028904f4e696d2154776a2da4259a069b2859dbace2547ca1063ab6b476c7dadd984cf5ccbde1b46a48d39e02bdad1dec272739e507475baa649b14c4b02d0be513bc5e816022a258fcacf1d39a0d92a1ecee90a0695b81f9953ff986230866f1dedd4e2f24df2e38b80b5ac9af3e6ebb3a61034d013d62c6b9ab15847e223388e316fb5896d13298b6dd2c56b5d7250b9d08b7d316bcdfc66768133958955d7bea72a812a4c901469c4f89c83ae7c8f2ef30034a00103664721fc5e02475f0373fdbf5ed7cf590bf94eead2e6540354b3d5da06275465709b3e41ffe408aa1685cd5b9949ab1f6949716446d41d9cae3592bf1c41c967f85a023a508361b5a8588f93fb02d9d411ed9e0b758c90309221d72e3f4d02b329ae33be3cdbe69e291923e4324fff1b934a112deef0e87cad2ea0784d5e93cd68b2e63536bf0fb0b86e7b6c339ffe6e7ef715e256263f5be97567048389a5c7b75cffa6641a7a7762a1d2b6d0350fb6acacf6f3669a572361dc716a1981d2818e1ece3d2505177330c672afae11b0b9e37b68202c5690b33be3a570259d7d9062f4e58dab3dbd45d9b63fd9aaf419deddad9153fb04c59da5f8a05fdf9405ce069d102e12233ecc384872e7ff80920805526cfb17de1e2d58b60fc99d577075474949c4945622c7d86cb9f0efe58d35121bb942ef1aa7bc95bbad0d8443a461cb51c1f90115c54d4e97b5a5a93fe97a66d4d8bafda5d4edff7b97ecf48b794534d6b295824d24bf71b035d73c5897472c30fd428e01843c60858048a0774258895d01cd00e20e5e1cff34998b321bf607238b9a1e7c1f249a6231c8081c3f42b2bb46197fa22927684e1d0f18fd825a8ba2721299d518529063b3ae9dfffc94df1db91ef6faf8cfa3b7e9df871778d86a53e845f10c1037d49f2beb845dc8d6aa43304c78dec4e6d7da658adff0f3dabceb870ef4c880e76f1e9f8c73b31668fe1f3e333b2f7e461acc2c1718963be0760bcdac0d5a1281adb4a564e05ae76bc5194d1a6dfa8175569de8dd966f66354df634d1d87cc12ee756d8c0bc47c26a74449cf415d35b3d06d2cea9ef61b7612669e39ea58f1f46847d90363f1c85686d7b67eede93ae268e620fc2dc2af70806b174db0f3a61b929d44a91cdb1769a70ce5f4e89e2e13f3c499f59d46512472df3f197aa1ec065ea3dbd03895a5ae217a0216be5a94fbdae9b78ac4446700edcd1faf2c97e743dffdd0a87715a27dd9a32dfac39fc3299d89d37b9f915f60435c2023bce2c3794c3ac62368c68db8d60a9e81cc5e9dba8f4d1a1a0000eb43d8823669fe80d901fae4bd2197823bb2af8c7337f34305652e78c7047d50df221b516f8001bd515292d8ed020c2c8a5da8139bc4a018b14b17410b0dd6899e7066b0c6ec14bdf96aed89fe3c9bccdd03f283731396d011cf17bc3d859c34ad501dd6883821dd3e9acba3d46df6dfe903b8ebdc79221d1c00685ac78f2e311042fd272ddf9e174e4d21bf30cd3d65f1819be6ef89c3fdba1aa91002c7c9b11df88f0ca2d5d8b3aa40d9eaa403bf5a078257356e835a5ce0cbacb467970e2d0cb50b3655e5be237ace9eb3e967f7c840bc100e35da9c19272f11ddccb625f29450db4ab5350ed6989ff74daa4e3db4a9772798482c33eb0b39411802d2c84b5cbac03146cd3229123a7c2702abe430e4ab7d4458e3500f6c1473b515a99ee4733b1ea9e4aa163426a4cd3c7668dcb4b22ef877439bcd5afd1ebb9b5d0a45618f54e8e83b44837709eebae65fc3f2b1a4f2e9d15e2e339629c39eacea3bcb474f71a9cfef2cb6758864f6e20d567acb44eb08bcac9b2b040c8b4bbbae56624a95470b92acf627dc52871ceedee5a5173be4f852043e92a7a211ea2ee1b58f8df8276dc0abb81d899d7b1ce3b07ecd19d318f2acdd063744e1269aaaeac5305c6e29f8ab214024b9d04aeb176c07c54b5ea75dd520baab3726b6e08c41c4ba05f3ca20a9f54a8fd20869b18c0aab9119c5428abd18f6e73c3595de0d2e2929c3a764f4c46c270e5d744213d3a710c28b21850d2cab26bd93b158a4012597a868c45a374741eec8f6d5f02234611f4e25a91cebafd24c2931bb2fd528f598597ad88741b88fe014c884cd2dce49e19bbe523581bc395cd94fc0a3f3682634463f94ed664704a622c8424d2ef9086f4af81329f6dea97071177b92d6bcd84042c6c4b7a0b4aa3646651985e5e307fad068847e30aa54ab781de718344844a78678a680edf03beca3a33f670d4dd63bfcbc82ff193004e670adfb5a72deaeb63058dfca2e7c343416b8f79b16ab3482b498484c942a64d731306054ee74db47e69151f7f91d9baf31d8b73e05bd0f392684d0850662c5b83879f225bcfa66216c75b28988608380575a31b2ae7ade853a20f3a1c3b694721457c67d03bf2a79388e41dc8d41acf99ac6f05f341d5aaeccea70bdbe6c8a93891ceade5d96c86758f3710afb54497d758e397359156afc38028806b8edfdaa5d5f5c423bf27829a89240464897a7ebe86554546b2b202b7e761eecdba831d9cec4257c50fcbf8ced1e88e57cad86b36f6f26f8990b23389d2ce32be5aff60394fa549bdd5a755a0e2145938ab2b541e7094bfa43637667e7dd87f37fd695a442bfd8d278105ea411b0a0edccee04a65b6f694391d8fd6705f297f823bb4ae337d3b2d81fd9c2905c98a5a50fa8b7f59ef6b5b460f197958e3d940c93f125d771263e2320d467f76f2a4664877156f949b418a1eb34ce9f41fc983ca0751a2b15ba973facbda6b5fa70ca4d17a239577d550fd850a248de4a35f3fca5cdfa238a38e583651ae152372a356add4b7341c5b447db83ce528e6803a4fed47b0108a41f3c629da6e2f269c249532e1857df8435c4b9eba557ff3bf8126585601db64e64f001c1f91705cfb399e923f985c024d981eb32aece2cc06fc5b8794cf144bf74fc1b4b971c59bd2c72f4da0448f1ead93bbb571ed997a6b033d341be91b3426efbcbfa5a382e9bec6bade8b6bfd30740a412e936ea50cf52939be4f09be4b7c4d35c71c12fc3a9e1346d48fcd72ba8104cc7b4012a0e8788924583327dd3dd1d2cd6b9aaae7dd6cdc36e58fdfd8db49cafa48f7c44e8dd90c930f91c39202cbb1e313685d31cf87953285573a9c9decb8f3fa9f33516023a13b97548e6c063b05c1ceab5b116e9ef425cbb15b497ca3948c8ca41ec329dc0d2bdf860d16e844b3d3620bc97290c80e5404c107769ab784ad6cc129689baedc5f0233fa26070562b1c8cbce3b53ff9e40ec28a37fa593be1007cc274bfe37961606cff9d564a818f49b1554c7d85931ac153d21cc1d306af6f137a5a8d8c2a4f3d43a1b20237b427919cd32b37d7c1221157071252b5d37d3086833e74241d7c1451a0ce961dec5a1268e576e2cde567b198df9f2d2fe67120b6582477d618f98bf475b4c5f3048b48956b2e0566d71e5f930dcfd79111243c81b17be67acde1644aa8abf40de011c7511de8a72a4c02c068c99562465f6548e2cdae5cda49421f483123eb867420562bf9cde31a088387f71bae077f7e2f03406a28498622dade1f79ad7b89dbc4b82fc74df7f1f2aace24d81f6abac77aee000e25e6cf9cb347048ddc17b8c26188e0f2f4c7a184c4d911895dbcb1f24f9d7c96ccee1c90137aa7eb21f7149bc38566c486aca343cbe87d9bb7d2a0d25f3397d5a1a6bc046212f448ee52dd47594d0d76b079033d537625be3acb7f41e1b92f8aaa7411c35184852edf852a0761a54de024d8a0a1fbd113548e1a53d653e6a5be617cd731cde6c615915f83d169d400f4f1939fb9500a914a0217595c3c2416222327f851354d40a6a18ff5594cc31dc6c95c1be3b8c634076e76c18175b55b3d71888d6fcdfa361b3aaf70bb07054c88683cfd5b99659ee7c6f372630ebce0f0fd34a00036d4b6400e53345833fd2a7c2f76a6081f7c469019612d953730c082704a5c62cf38997fb3ef402940d797660d55a7794b75292514e933d309ebbefbbfdaf081d8371bca0438446798f510eae0dd22bc47c1fa07b3556d4cc78e60f9222f295514a73bdb59762d5fb688a6017c22b07eda0da4e5eb47861edebfe3971e8801d2d2ff537016266cd5b6a5a95e4d6611c0d650eedc5f161b9e482977cc662261af3c0b9782269f2c7f2d5865baf16b98f4dba086d010efb7fb5cf195db4bf88301f9638229d9f7ced6e12222761ccafd1c55633a68709b2eedce6c6c64c9f194b7e3ee51fe98e3fb9d58664394816c50fcf2bee1c5198f46a25334334318d0906ee4a602be7166848f7431c0747a5ceedf9342a1d54170463139e6fd0db2d3599fe13f77d674b7d3a262969d2145f4eddf449425ea6e7446584ba5f912a21269022cdb67b242973a4d9443f8224988449c88ba8093727d24a24e522c2fcda57cdbeab5925a3cff54f494757316d53d22e3b04ac292911e6d50fa571c8a2a5fc79f78c6a73dcb5a384ce938a95b704448b6e0b70b31c9e0d0d5c59cc5aa5799a2bec764e9887b07a7a7d65da8a966a5847135097fc2d18dfcfbfb8e0f271ed21aba0cf6d0e3693c906dd2701c97b148d2b036a53493aa7b0589884c03e6a04d2166b55f71586250dfa60892fa4cee1788e13f74e7007d0e65c75f7e6e7bc8300d7e4ed253f5cb18c382a809aef67f286b107c462094c9b7aa69c3b1b9c0e9cd1f7a5919bf52b9904e47d8a84852c78832577af63fef57a96850938529650f3648d560ea53b0308258b5250553ab3b9917c295cc99c77ba8f04eedf0b632c06f470e332bb6a3f4108d6d826b442508a1f16362e6077e9df647feb0b96460e07ce2e255cb690fdbe4a0d95f8c1a2e17b963079bb625064573cf5d4f24a24176e7bd8b2ae2cc10efc4022e3564814f75327b380d13904b88baa2180bca2f113e60ef5503862fd6b0f1760e29482b9c21d6fb7a283e704dddcc8fdc647d49b6be309cd6c6b48ddbdc448a7eecc6d568fcbe5cacf9bab641215834cbad0829dcb4df6554d03460713c2dab7d37afb3c82ca74d3ca3e7351023d761af744a15ebafe995d89af0935608b42ce96d65e13f4a8c5996a5bfa29179c0e11a47e080634a08cbc0a0ed8306d51d4480cdccc653b0da6fd100b9ba1f4dbb68953fa5e75ab8b8e50d943e5eab0c3cdba3fe43daedd967001cdde7833bc62176aec5e19c19236629f08107b4eb5693288f4183377eda01715f346222d41a90f05a13d6b110e2ed0effd701bc83c353e22ab3ca848845902110393c19109cb1cf5ecbb8bb00b536277614808a99f26338b7a4d46132cdb8297cb15ed223970c566bf43d97b2f9fa9596fbb45a6e95ff2bd64d8da7b4d558f52ab895766cd7b1474f6e2ec34ae4b7e0b861b1ec07d78f725978298cf726a6ed686c0be7c12a30f6db322cf42f8070cd43651f15d0e6a752b1c33ae3d167ed9ddf189bfa5fbcec5d4086dc1fde90d25b4b17b0b1906331fdaeafd34f97c9eedb3361c13a01ca7afc0e865d16b85697209df75fef471128eff30c9e1bcb42fd43bd15364478c917e19180f359ae8997e0a98007a0a640959d036d190ff40062292637cc1917ab435adffef5c0fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
