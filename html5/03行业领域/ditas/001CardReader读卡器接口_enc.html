<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90057be0e18f89cebf428d5abf88ed3a986e62bff3c1a2f256e73296e0539bcc33d65adf69dc14d020e3314eae3a8d4d717aab03372bb386136bb97c46a02f91ada2ebbd014da6085c1dbaf3ceeb50094f6be959478b97c0811f3c7484a9ccab6106417ac2f831830411669f7d100f482336583120040f7cf1f10d2c07503048f5f91948d26a9079ff606595b48a4dbf0e7876553c8c0726328434d2cf7a8ab440a0421ede0d5cac0af9095010412ff41f445d64138feeb33979d979252f8f7e903193d12e37a53980a59fadff1acb587e447e8c17695d411b5ec2247ab989b2133040d3a0d6a0e20c27a535a7bb6c91e312a42329cd2cca79ed0f2783dc350d400608d0363c0b3b9b433890158ae77983842e9a3b5879c7070d06cb59a5b1b0b4f0364ecf71d79798ec5b1ac5e5bedc27a0710b070a1255fb43b96db422b33be89978b951750ed395ef9203b0cfc3191807f391975bf7635f8cd90f8960bb8a9944600c31f51433a789970f718e7404baa3ea20ca27fd01e1895d23bcc03a1d96c6a73734ace78ea1819d286f93c323f52b1aeb63aa2d4d693bd3bd5c9033cf0b995c272e93bdea943f37e524070ae2396fbcfdece244dd974cd4703b1c672f76d9125f31fa5f61c4901eb39d237300b4019c22fd253913f0f4c9c42979644d7d1817e48238a6ffaf5934caddc091d2aa09b3d8ea4eecc71a25a25b24cb907110019b67f32bbff037d3db84b2429731418c374e67d28973db26e2ac4a0dbbad4115502c393c7394ff2c1beab94cd0f98ec28eb81b1cb2718577a5e2f4940b6dbde02f1d4d191302c0174f8fb794a92ff3d00552a43f141513e15105ee81a3870b332603151bd19405a58f66e7736a1b7c4662163b4c5fdac3712cfa316c816d00c47a0846de1ea7ac91fdd3745a614e4898a999880fd014ff57bc0a2c34dc498754618fdf69ecd52f65899221612266d9a1b722655d56a08bd31a3829423b352a7270213000880e64b3e7d46e82d90bc91a1b69275df20a93320f3da90fc29b296a29e6426669f0a9e90281fe26e3fa7c906ad7cf00a070754f5b6c0314b724c47db9baba081b244c2b4c2191a51361b1d4122a6bc83572187c34c18199de744e18ab7beda6b08c7f8c6a6cae97362f46d69ecb57483415a9d1d2972213a7323e0f431b095ef091411432c6fe10c596ed3e76a37e24fb25e2e4cbd911420be37b94adae727b153c74d9911277060b5f1d9d14da9cf4a105f92544ae0ca50d5906d7991aeadc6709e32ee3cce01abed65fd2869a29cb26c7ba447ae851e6ed8c218289e2f0c4466b5f9059c864ecc17dd5b88b298713ef9ea247dfe4caf7262fad89cf5ac57e1b3f459e2a72895cc9873b3786c4c80e1dd97cbb505e212f79d6259cf4e019ba974edb0f4fb22d784b9f0d977a15a5e1dfd0d6c2000534b697ffedd9eafc67acd5eb256037da41ef897fa6bd7d92e6b6a012715d385f6235105b37ce18d48013fa99ac35efe98311a0c1bc0cae205c1b5b192627d9819027adc192b43abf5ced8d7aa22ef6337eb63ecf76b50972aa5b5ca4650bee70b6adf294870f429041472b4f530f9b638d76a9c39372a9b683707121c3960335c0c7342ede047767a8e72a99770afa07926897597b02d167040372fbef85b58081b1ef7e508a8a1e9d89f34a41e87e7c0697d63e9ab144178af3aa366f23d0835f13293fdb5cd292443702fb46d5218292e31084be05388207243ca6600d77dd7ca21ed89377f20fb584932d68eca056098cdd2394c33300ea711ebd72db427d11f8865d62f7997733418b2a421deeb0ac55486d314367dc5cc4c4c8c1793cbec710cbcc7259683cddd52d7506d6d123ed28f8b37fd9be96f789ffd7154e24950bd1cd4dcde219289ae6c467a95ceb62e73b4b60443491b6cdbcf6ffb74c654443ccf8dde8691f25814cbe5ffcab716951f48893c656e56c676ba3596767ff6d30fa4fb7eb72cd9bf01d9353e6fa0f6b07a558ec59ac3c17338dd766c4c3e6c38854ec6152a05e0c27526b889171af2af55a2ea7380bcd49e1239016dc08b8accef93a5e37cc840ed7d47b74f73cb3bb0b97eb77953e2516dd5dae2537ba634c47ddcf3c2cd3ed0d556b8732adda5a447ce31b928d5d93db4e13ed4880437550642f552d46c5b2d9dfea1336692ee0fe900c60016f08323a003cdb65e7902c642ccd041381e8460e5c340b369b845068b3f9077a812022ddf6f149a00184186f59b7bf327a5d3e53541bf24c02e49e78a19faf33c7d5d2e281eed0956c1a13219a3ae39d05161a13064e393d6c05302575f436912d1a8333a323c699fd2d6965ed33630139f57509448e9d5685d21b73a7278d6e4cacef5fbe5ea92554cfa81916731cf0c349d4ca8b06aeeaf63f0d876b174e564432bb36ee1b3fdd01d962e160d5cf3139be30083fd65c56faebe4fdea563b4f8ea7f3e8a6ad3339b4669be0e6f2984a7b86e3e33e346072bd7cfcfb4bafd44d8201281e9359ea93f07cfd126cb322f0bb47eb4abe86106edf1741d679a9fb0e95ed969daddcbba60d1b16adee7cc81057ed4ef9a944d15c7b8182d56acf2c3640e1ca442c7abe2a4b4ffa8e2c7b431165f350dac3e05436c4708ae5e94125ef1e1dddb82a93486df3453fe3f7d3e706b2d027546713ffaa11bcde6c4d91260058fdf3e5a50f870b4cb421103120444091e7ed9609e1c66642dcc32a06304891e2da3e7b8abf9a6af05df8aeefcda99988a6cf9baf872eeaa790e0acaccb11f7380b1bedc0e5865ee90e23e6e1cfb3e67d40486cbe210684bb59d0690f3ccd5500cb2fffc3c699e02ffe8194a42e331afd482cc7a5415e2f7e1d5d44fadc92801d14d88033d933b21ecf5b75dff6696ddc633b5e57d137442f67cad58a278feab9d52c3b8fbe823ba083e57b3c16d10a08443ceacf20f9c4d495aa7be6a8f53f293444dcd7c037edded60ed338a37e5269e1498e4f928ef7c4d339e2361d66403403e9db08c72a4c880eede00f5c4c4a3798ca84db5560ad1a0b97625f929c7dae29ce2d13f242b88761f5015efa93b08ab0341bd88fcb774da36b8d96a659f351ff670d65641521f72b69dbac9cabc8c1121e2bb526b1bc4a5e5563172656c6431d6d91b16158e71019ba955cc4633da64ecb605b81594bf587ba53d82f98dd11b57e2a79faa71bee7643ee9c8b2c5e10de496343a55f6c44aa0da7949030fc67d48bdc87443bc8285860b9988886f4ed63465813ac833d53ee9f8ba82e9e3daa3fb4047bc6453fa763ce6e47c97a1c8d9ec7f9a6c00eecd57b667e79526339c5174ee779781742ec2ab73e923d4b329ff0412eaee8adf69631b66b7acf81fe3a1940741f92753114451af66b2da49b7e306d3974c296401557147e8167cd8249463a8c6ace7c898097e6c0c1c0b0dcc01eff587fd354ea36b5257251a343ea7497a95c840fd7ec72be359fd8a4f209dba7f1d1c693b92be3427d7d39b02eeb7b09d46202e2d412eb41ddf29e989cff0459c9d08d0f280180f33eb6683d71fa21101d212838a3c2fda49a9072d37b4ad099a1020e7ae10ceeb73b938df1a1f8b4f02c2afbb007da82ef9d360412638f4375a68e4c214094059f3457ba02f95402ba416ec6f5d58c20882486e745a75795cd3a49e1cedabdcadab6bee3d5c39349080ac5e9f1b0c9e78432aab45b7b120e2612438f7e20aca36e93cb0e6226753e1d5b73653601b388c78e6840ebdba9a7091ae1b634fb0c2cbfda40521073c0d4ffd371d64e64f8c23fa02e4190e3431c0338e48e8ab4e0ed2d88c8fc90d88dec06f3ecd6c475e12e2a4b4a2b89d0065d4404c47d31289d50a6779b901b896cd99418466e5762026c4ea46009f7e575e952ceb02e236b471b1a5ee71164afdf53030a1fa1f42108ebb94964b515cf4901dabd13b98ab368cf82b2d1985434049c12ce47b3c311e766bf7b601ddb211e74d7033aa772e62f9cc9c242f3da97caaccffb0f55b4ee1aa8ab5cc86dfafc2a0ade6a159b319b2c59dabc03952912fc126f74b717320275b73d436dcd0c0e6128b81291512c5784075ac08f6f389ee58ca5cf34e42c0ab81e6336840e9ecd0d3c40e54ef7764140c4a5a7ace63a591dba8b91736f7691e3277b5dc3e695bd3494f1d171be225164f8519a761f705ccc5038b4eeb7c0a867688177ee68075bf8fd1a9048154d9e57807ee8e64587ab1e1b2ae596d55078f222531e99e628c32226b575938ac2e3593fdc87dcb57e4fc6849f596445ea1705cb14b844e81916cb19a2a47462df0590234accb316024cf0856061cb1f01c60dce8e7f57a08886a5a9de80d2ef32e9296af3d004431a58a2a62cfe2e653735cb4539253d66c80c1f8ee8e510153b4f684d39ccc4b98d3f91583d4137d0fdc22e63567a6bd44232de0d5e67c3ed04365de0053d98780b6d8a4c997b7e3dbbf760ac9304a4938141733e22f4a27f3a3ec913ad96d146330a99f2195538a1d83517c1688651fcc5a78db86cf10bc006e31b9a77bb1ac06b17f5d9536252d2031e8336fc0147c5ddd8f27a7031bc8bf3aa4701007396aab026dc2f127879a146ed12531199d85a54e185faf4858efc44607b2218a9d0361f77b73bbe2ba2664eedc584133af3c00e19f3155c878dbbb73f6f0f4d51504c21ecd3611dade7b67e8ba9a99e2afa93a3e194d196aa079a3cc9f392d92d358cba32f4cbc4ea030382906ac440ca20f60d3f83c541d6b5f53f369559f2a9baa1a0c137a97a8194212924b89fba2f0443be530d94ee193e5e02a19a05b4113a09d38f33183a204b7e3f360626b1b929bf033ac4fd86cf1b047a52fb25acae92c188d80a4771a74d5f5b8f4a5b4eb4183049b9859d0b3872498859dd423d1a659547e2fb03f6bdfb0e7b043f1616c515e93f3f7a27beda32365785af0baebaaad785d95e688a3fbf6f8a590bfe55a87f782ccd47e958081cd99724ccdeca03ef210ac397b10722ef82a18fa583a3011ec1c8e2a3aefb2dbf4e3a8cbe6012d750aa6089c10ca57f91735a8b7f15f6c029c57c0b1d947b576c36599357b86d3945b20601a49269e7cf9379b85e73d9634d5ac90d3eea28f222ce9b6c6b11100726f4470aee8bdcf30ee75421ecc0a07786b7d596baf486bebd5b0654f2f12172840e151bd250956dbb88f5c917f719fc978bf6877a3936c5fee2efbd49345695f71a2d76ba2b7d124df097d50ad2b9a625733ff97cda9fe8b4cf9799b0b0285189119e473882f9439c8446e45127781a7dfe96c51b9a93cc23b1ac6258284ac18002bd8a8be9418ce83f726a30ac3a0c90fb7ee5351fa2e3bb1c0074150aa4576ad1e5e3a02eb473252d535fa1abede0ca5846f8ab3322fbbcea07f1a538ea5d5b522c5248a20e67d0a23196d666ab72fe705a33e14e02d9ff4ab113b125b30ccf0e5c06ca0c8ed63bb118636b5b37adfbf92a96a1a6917c807659d22e09febd58674a3f81278e50471067c41f6f0e2e5d45adcf62b132a414ca4b5ec045d131e202be2da8a2fd8f9713a0c84295c65eea42fbcaa3605f816c1a9e044b7b3905eca8ae97c3550c3b7bb0f7457e200f7cf7a155691c61556089173ae46414bdacb2d37ddd895cdd9a67283cdfb2fc1c60c430bb178193f67cd7a571f3dc20039075190ff495582a084f2c478321ce758362a8a9ebc6fb33c381936a36078732c6aa4eaa18d2fbbd64b79fca17d1e42f7940344b307f3652830d4419fdb199b70eb0152f29ac58fcc573c1c79f8b866f6b649ae8fe96434e1d211bccac1a17ea057dff808ac8835cbd3d755b100d13cc42e86dee6b524bf6e67736d70fa88461492359a13ecfeb3fff601767420cd907703c1a872171ecfe8e27dcad4e63671dfc943db4c969faf8b1958b64a6a1a24cd28058b3ee4a2671d97472f18b9320adc7adefcb6b8d83c763cca405328c021045cef867ae4324e644b36776faf3a03133b40a2bd9d505028f0ddd94ea0cb9d044657a0a466ac6f1e9181c392d88de13ef3983daf0505dadef77e2c131faac2fd931c7eee44b7acd83144f777e4bedd964e1c9eb51877ca0699434a3416bc37f37795fb4cfb7cc714ccdc28267cccb370aa5a01a1a99cd7c560843d90d5d5aa286e96317bfff0a70c0983d3b7a4fad5eedbee000300b02d43fe3c0886eea59af24628b2d28caa4435800dc89526c7db37a80f6074007ae2efb4fae036af12f420ea52b3240bf5cf1dc5be75604d4ccbbc814c74d1ddc895ed058c7a3f7cab9445cf23d2b114b71a348fa36c72f2de99d66c004b022f84d6992704f9b81a23349a914e076863c85e18d19528937bfe4e88e4fa1dca134ce676bfc6bc269cdbba4bafa2e944fcc4c2aac8d11a37de171fc9f29a448385e22acae51d2a5c85529dcb94bcd26da686b533bbe04ec50d66fe90411cc0e15ab39b985cff1faed8f012c97727903558df91b7df2f128e636bad09f584c2dc11549df2bad2b23bb463431e8592dda8925ba5618f42bfb3d4a0e2b648ef1e6916128e6393d3df415fbb4b43b7e53c3d4f3a458a4ddfd395151dc292524844e38316a8bdccd10886a400d1e806bebd80fbb28ab09c4f3453f0405a34ed41bc6a9f0c974bf4d3bcfe30e15d986775dc4266d24357825a6ab42b815a4541adde339b39f61a3290cad532d482e405db76afd335d2dcb70e1692954fa14179176c9ee9d725112764816dbe76e9541eb8419dd0ed723e4c5d478496d08658dd26d9aef220c65b794c8bdf756c06fad97979f7456686f751d44d7a7c8359ee57980fbc260a89d77624b0da6295ff994d4e958d83e41437d5c0364e0641c45aba511ffb8cf237769848e6d45e60d83b61460e3207bfc8d135e32bba93442229132c8864dfeebcde6b15247247a2259b81461e9ebaeaea5f40923f8c22ce3be9910aaf3d5d7d6d23d479dee99a133bf0e9455e8f5506602fac72cb9862e1fcd2297bb5b630b3a1f6099a85243103ccddef887b22f8ddce117ddd3c5466bffa7e26142b8f022ecfa2aed1eb0fec3368d575889b248fda28677a852d1d9eea41ef4a25751a4a5c433efac609339d62a822fa8c8b23e096e7d741671581648190e06a134d5ea87aca296081474204d8b37e4254f3611871134b0af7040d7a407d2931e5a8a259c92ab7aed30b655a3689b6feb0fe64bf3707614b2980110b1dfa4cf06a85841582e36ba2d5a45cf0ba6e6c54012b90484da388d955da79987fe537fca28fc03d05e5208df5cf561dd805aa5b7c4bc75d790e379205ad4f9be82a70b925d0490977f93697801bfef7f20a80ad36b3e16917c5c28f2ad39d15fc515fd84ed675116d7ca04d25cb41b24122a03fdad435fdc408c4fa39752c95c183919e6cd71b42a65922e50a041d9649c047fad635714e005db3d3d32a598a8105abd112e32e70082e931fb1211f60864683e90876699f6ad9727f814e06a119a2fa25785eb995c06954c6f08344ddfb4c114d20b7ab3a04cff5fdcf6f6fd6bc235d6cddef43577ecf813c889b412df40ff24cbff165eceb5b28ec0c60acf94344e8fd576a69a22f33649a7347402d7d69541757e4d87bc1ee1cc6ba9a7443478045372cc0f936b7d4407fc209efd035b6576c09f7738c33efb64d5b25197af5e0377168cb62adbca8adbc137a659ba932e0222e01fc3c38e31459f92a2726b6bd5d13e5f56ca559e7a433acb7e52c8f80b3769c053a32f2bf5c3d3f6198db12111cce9546ccadb827bc77b42abd8b72919dba262641721ee7274845a25a24b5e86472dc4ea3401572c10cb6c50c83366280d0938bed91dd8809cca00da87840a107194d116851b91e09feaeb84a301c7d26cc0cad0f7b79bb710f1a24e564fee1122920e1228000e5355d39e415009aa8b434bb6ad1c8b1a27f7aa3b3467373bb4c7666cdf3a18aa094632daf04108f3ef00f61c6cc8c611de28020f7b7a390fa07628530115e4e2259ad61bf667dbdcd84964cfe93c5036c0a95c90922876ff93244a6a89c388946c4f6c34ab806c63a37f076dc854f0e888a46815f513c7ebe7078f6af1e643b447c932f3a3cbdaca1c1c942f0fa49273216ddaccb173377102ad67b8d51c8f2630771db29522d5f4d3f5e926101d3111b11d3f78155037c29dd1c1fb9f10bda15f36ada8108c7ebabbc8b0e84882d5cc66d991aca094f0b23de297b2fab5d62613e6ef9a836498cde0e3571ed35a2b852f7eab7c6001d28a910f4dfd9968bd45e0d91d290578b8c734bb91df6eebf49bfefe2e111cb71dea1932f9fc05290abf6f50f6439be269bc857dbb0a60056a92d3b5bf0d49ea659444c5deb46960fcd033cfc8e42715b953816c61b6e1d077320cf7654ef76b2b9053b29ab43b46e21e5c38cebe66024482fc07d7bc77d777d4f47f26b9a08b7b16f20158a63ddf42e41e87ee1102b8f5da9242cf08e7c4e7b0cd8e5bdf50b6c6d40aaca1385f477f0b2f9ff1fc97e7921fbaa9e9f950b9d7b2927330cacada5f5f4dd551bff6011ffd40625f9204def5c2554f156d435a3103ecd4542d2290ba9b41201e8be1cee68564238e4ecef6ffee47c9e61b9f7b6fdfe9ff2969b63504ab13f4a5e422aa97807526de1da39eeed428e0507d2b0f1598e98d848ac37bba3b5a2754ef09f913e023568986e9805253fcf2dfde17d1a810101595dbf33b4103085c4add00f830d10c1837f1c56841cbcc1df450a8d1df5dd64c091bcace4b88b598e858e61ca2c99792cd7f6a055e1295d9b1761f1df6b6ab1b727367d3f34dc6545544b45864c97a7ae2b4af119d6c9908e15100cc1e1dd3feaed71d1cd43448206b1ef62b166c5291f2fc805b938d6395424b822a86e245a18afeaf6a73e787bf76e0db239523b518bd0fc663cdb7ddb5b69978e6da9329cab0425218011ddbb2730224220e6c93d4dedc34d7f7367c909a96d5487fde62aaa099009240112b1a51434f97641d8fac2eb2ada7b194af032f39175f262817a8e5c8d5c9b7c8c025d35ab1ba9d14663c6f883646e8c60e75fe47fc6402c22f48c72d84dcc86095d8efa85b13a4b77898a4a2981ec4a321e7e4a758b18c27115a643cf3899f52fffa59d4b79ba49fa86d5e76044cfe3517218dcc04c0f022c0a6ad22aa8556a70afcab8bb807ac44ae7b25eca9ea44af70c85d0a22330231e1f08d6a36188126be5564ca9d549afeafef939f59391ded817f2077f95f8c39f0bd43673260163360a328ef8877eeb9efbbedf21c989208b5af9baffca3e34bac4a55fdb169a92941fd788b345b02f7279b83c5cba9e546795ec6d46f9382b836f6edbb8ff5458e67624bb13e7e4e7aaa68c59c616491b7df17e2e64354205847e53c91a61c24666e5ba5689bf6cc95feabc8426dd6747fb05ae7e46825d3bec16fd3eda53bea23349716903a4589dc93a6f2abb0f28429c5e89e8fc367e8a66f4568cf4a9c62f51fb6812eaa22be3f2ab3c2ff54b8631c9aa65e5825aab9051d2bc4a70abd3db51451e5ac9af2e2155d3c46301a97a586b7152f420b346cc839a6bb4437633aa6eb3a512171053127196734ce3eeab7baf81c54e37d20d1763bbddf01108588453c380f01b9ef6b3ac62b30aa168fbbb08fd729a082bc4e7d1ccd70843a1797d334e30e8c6f75a4b4de2e35ae96fcd2042e49106b576a7180046ce70c213adb383b1de0e8e8ec1a67839743bb8cdc03904eaf427632b920c1827246809ba9bf8f2e933be323d0290ab211fe0f17dbc128aee8f79fe8aae7491d7e839ffbdc7683b97ff6f6c163bbfa80fbd868222effc88068fb2f8fb07a730f0bb467cb9b80901d067f17746c766efb5ddecad1c3c3ab65f1ff8ede10b0782877616cb408530639a5e72cdbf6f1a5cf00b67c2a4b1c869d7d321c2028f881660e7aca49be0a08755704e17a7a1487fd274deb135504db55312afbceaf3fcc8ac9ff942e046fabb32cace9c71a383bb1401e8cc1dfc839e80905d8d7183dd286224fb2a910a4c4d24a40b17a4ec24c6dd3025ece6a009306c89c690cce6e3bbf4014b4a497dd335b5b75df4d2e38ce33d5d8c6c2170d914358ef230be952dc63d6bfa5703f60ffa982bf57da9088da3f93c7527afc6d2a88fd40fc5608f51b271f940f413291f71bee9b88dfee084766706311630b49864fa7c38f568d9dbaf92df7a96db9777d1edf23d777b653ca0eb7cfc2e61c234fb023322cb329a7e614e6aebde9201988a3da10b6318cd08cb084c7fa4885dddeb7f161132fa328fbbe1dcf7c9a9530a65ff1475af10288875ce5bd8f8beb34431bbee149b599b114b2e5495e715a4cde120478e9b8810b070a2e6c925382adbde3c5144bb21c66af1f31f452a196ef1bc474e42cdb944e98d7f93be21699b0f578ffb7e2d25c8d64ac8c5e12d46fc884e058b189436c2d4980873706173de6659f322d1347c8d223d8a3e9decee803aaa3669c93af59ba204d2c5a2802635d310d405a41ab85bfdcfe0a8975e0902a11b0083d0c4485ef06f1c7796a0dcab3347566dc56836460b5f0ea48d0253c6e4c83f843da1811b434f77265b02b2e275a1b01808f047e9d1b56262817fa9a4a91abbb0c0d04db95d79bfe9f22da200df315f57385ed0ad260e0618c3c6f81c0728b87b3978a4287cc8111ea6a646dfa09b020caa8b9ce546be1305f1306ea45e184e78a3adea0535fe3db59ca8c6b2d567fb5020c28303624c74684c85eb856dda0462be40aaa17c3cf8e949f6648a1ee37d47d2d55afb047c80a44b6bf0de9ae57617637110a91dc7a045d6f77ef285579b19d15f0719592458828afc7aba3102a1987be95f66727d13f2bd6ed29593da48216f974d0bbb6222cce3b77610fb955a3bbeec219b43333ef02cc7ba46db39b9de5e4e4f59f42fd9c61f29fe2798430dbc4f6a18f970957f71e5a4e0a8ab6115f193010340973081db127b9d27dca5c3424ef1bb2e6a0f56afbfa267fa068cd564be6f6e398537a5620b810c91a1a232e7a51fe33b60619dede1ce05097f2bbd64b400d3cbbbbbf8a4a9816cdebc7cee2d495dc90aecc92e06dc55b6d36176e8767686bb0f8726e840227806fc82a95b3ced6cbf182e795d33391ed453830822857ac9cf77cb5f33eabd63f423cbb915c1b3ae71c7044e35ff7dae56cdb9e273238f45a58026adeacbf3fe087268ff1a21548f29214849c044d6d4e611c12fd29fa2ac1817553554db7d2d3ba91ad769af6e397eea352949e9187f46e5fcd0860d28b20e3863fca3deb8dc62a92399c88c82b5de14fac5cfaff49465cb600563c49557ac0288c08d999810892d712ca121fa45ebf8b8d890c925108e6b6deb57084f7c5b1a1ad8e44052a82d98cfd14ed73b8c8bb6f489bf88b266e37b58254ad326295ba7f0cdf83f0ce2c00dbe2e4d73ea127eb944c8055e7e8639c3042cacd441fb1f0b2bba6a69a5ab654d6eaa9353dc9419684e5add1949f59c8275b15e44d90ecbf40154b4afe1969c45428c217200e345a0b0bfca31688b3c7ab23008c36b8fc213c689a89d5f67ee555ee0fe885cd2a066cba53b081fea95741de2708145799c39fec2e477e9862acbdcb9204ea2731d635ae61a98731bb24d6e58d663d6b1ea92f7520ab3c1ff24be7c1b1369b42f9e7de679f51302ddf9993ac423b36a398d8b42275d3dee5ec4aa5e8e3140ab38ec467a484aa76c9fd8c60dad5514b13339f27eb21106444d6140bfc2d097ce4a2c5d77c6b8d60ec0306ad0dd58f0e2e33174392dae55803469c72c443645babc35355b365645434007121b146cf32e08dc772346de1d920ee7fc21cb6519923d167fe8d5b7589535a8b30f540071d1f01119a8552d216e771fc240ef1d9ae1b6bcbb5c3262f6498066f0f99c0e3992da9c41ce5800be9382eb613b23b1a68979b14b223be6ecd79342c35a6d74a198ab58b683dfd24557ad9ec96b26c253798147cf6903c7c387e5e835927f570c1196d5c8351040ff998c0a6b4a44f82b1f773d548a6b9b6c8826a70f39760807c1a47e35ec6419f39a727e11ac7fedc4e3941914849e47ebd37439e70622be6122d1be45778627642be9f2c1da7c133e14770ad633bd09c20849983b0f171b9155a5dc3236abc5f0bb166602ab85265d6920a30457582bc640b0b85ca6a92c43d90e692b4a8eefd906936bf49225c87e2f8ad6ec406f05ebd52af3bb2f18f24388a32ee801e45563480640ff472a066397e752a37614533ed2c02ba4654c6b5e3a18e1bcef325a0af6800108ead9c9e2e670699d7c192c55df1e31f3a30a2dcebe52d565ba032ba0282ab7e4b2f7ffc056f918f4fe66989837412059b9153c5f2a39c2edce16f56b475050818a6fbc061c79320f6178323abc7a6c4f024008add9a92bbd730303c96cf15a3fdf4077f2ea5e6ca4c7a0dd1048b08137647081b1df07fad5ce91a289c9c2f9fcb05f9c9469bc6abacaaa534f375acdfb0e8ab0f85b5b97b6a8a52485b531a8c9274f519438cad11b15a5fc4867848493eaead0e172fc7265055147e42db0d35a1842ed058ac1e923bd479882fa9b9fc65a2af4f521b93bfb099a2c899ef789838362a1cde78f83d2b981495fd7a5c0848f193d79227989871931df1169d2dfaa062f282e8c3796e9f4790786908843bd0c7f9a585ac216d13b9471761b7ba076a64bc3357f2263c42b4550265378da3672840119491c66277a39ee73e9513180281f32b9b282dd0af2c7d4187d9c89d5a73257161b29a270b9b1fdebe9e7978751eecdb80e18b61269eb6590a9ae3cac6ad16a7393a4d42f042d37472ef46b5fe13fdb461afb1c0d7a25e43fba547703f76d0f9ee505013697375d9235c9ab27d0932d7be88c26a9b37c8233fa8630ca2334838d7f64c3d7d79b24c34e5cda6f16a58b408a24717d25c95670ae0ca1f7e3fbd8afb59d14d843c94cfd190375630aa67f3082d6702bfd22a159dd1d7a149dad4a509fc0a4def6047a04555f64424209549c95e4ece52ca40645d4ccbd2764d9234ce21c2101a5ca47dc3b3a12b6d0f6dc864359c74416cba48655eceec7dcdaea5f4d9e82d3cd0fb8e05822cd22a94bbd21278bb50f77f802ce61a4c71c9c4a3d3d4c2c3d6895d454aa79fe8531f4ad6f05f2d234bfd6fc066d604a7867d4f23b039ab1eea8187d565d0ac27116dd84843edc7f130d9bb55b5534b30fd68693349d1bd8735f52ce9e159f0e5bd31888901b87e6e7185387f70b1faa4ee4ade46d94028d95fb33c1c4d76ccbcb06e9aaf78c519e2524011bf495cb45f3ca051dfca9fa2fce00a559aa9b6cb14c28e1ac279915a35dd217f85db14986d0ccfccc951656457df694a3fd34be0125acead97c2fe1c79b0d8337785926f70c118aa4d83ea43ed0b10e2e7305da97b5061e8822c8a51b6bbb5a727b4a3e0618ef95f4430e4acc2d13d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
