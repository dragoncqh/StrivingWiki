<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91d842a025227efa0f303e80223df33efa1c02584246f6dcc58b3d12c2a2e6ebfafe7312f07626213ce9ec9e6511a0ed59e4533a2e7d8f017c4e198f7782e6e22774e37fd7c1ded2c0affff3cc1e95a17000ba12d650150dc12cb5114a573a5cc6f04457704083779f630aa959fdcc2bf2f3c41354ce4c907990938d5377e5d22ce89e6b47f3a7058d4bcab96d1771342ce45777f96c8c7c2ba1f3f598d7e107003abc6bcc82dde0e618a1de679560898b1d24243b24c7f00296111e216e7ff15e833adc7c2eebec4877e3fd01ca9debbcd5611a839c66ab9ce68aaf1b6dd69af00f9e526da35546b6c5b1f5ba9804a90b964a240751094e37bf81747dd6d1b9b801391eb2909b50d48761754f2ef74550a7a1c3b2ac7665ca09a2acab553776585652979ca6960d911a6e50c3dc7309ebe8b46f8741a6e7d1074c04b2e63a5f1922ce9d704d487af534200954c5c47901b335188ab469ad5d7c1fe7782c6e186ebc2659f64b4f7b63311caaed698f9ae83786574b671d829c1629e17671e6f4360f52c5af91b0c507af4165c9083b41cf73bdd8192b824bfed8e7caae727a3e9ffc2e213f0a4f6183ffed257f9276141afc84d3abc6797cff4bee11b9afb68a8ba345c927ef0e88bbaf6b0dd117224f7c3826c77272507a6ec1ae80f5e1aa0978d32a1e3292e61c6b202a65f107944581a2b0269fc7536650641b6e3766a6d619f998d1edb1322653f0d3bb362259678c946fccbc654fd6d8bc472c39779a2c25de66b6581217164d026eff93994bacf84cdd9906410e04875f23510d261ade36648f7462f11f27b2209c61cc22dbbf71fdda733a9725d42dcf93c99613dba05c4c356a072e091b196958a420be1b1a2d39127fca41ffa05016927894b31f569cd7e9f3790eea4fa019e307356e6b7417a994c9bd15b2aa2a1952a934c0a9fa2df075ba21bb44110f789b8e13cc6b8629c8c9ef24578c09451cc850b5a5c8ce97b36a1f02aad58c39955ea5a30edaca12e9d1fa8d7452f8298ba903faab2163e65cc3df7a9d4df97159312ddd811f050ac20daf2d9b1f3f34fff4fd1a07951b65dc254bfeb07a5305451b790cd21d7c7b293990fd1ada0bf9ff6d1037a1ffda27aebc3ade57fa40b86f29f27ee114d989a672e0c3d5809656ac7ceb1e4c1cc4bcd5b20c80ba7b9534745fdbf95f7e5c3ec1bf988fb045a44fd578ec7005709393713172f554542408a9b393b1598545ef21173026c44c6a6d266036332d5f73cac5cfec68456f824f5cbbfa1d5c810d91e4211e47af24648716ec778f755943cdf7174bec64f4f3806be7e6923c55d130d4e8ce634c27c607eeb69fef0c8f3d948155f5e2bcb795e7362b841d0f508e820adc5241b4301a272fadc8d61365762c5c489ded08c1343266140319a6d4e5ef6ac919f5cc8745820c4d250b8b79f59463b9d8c2756d1de8711d0850cf85af7b1959f9c669bcce6fdd179e4c916ad135c1a96970c7973d051ebcfb851c46a0f7473a4b4f45455fbc754e59e66661d8cd3febf7a27d0c733f14853af9b9bbbee418f10228d0dc9f28a6989627ad27c0ed2e3fb13e2f57a651b8d0d6ed54127e0274e1c2a9b78af976defe0ef42cbecf8118972ae282a0b8cb9277dc2ccf81c0e16a106415f9facbc1d60087a3857604b9fb24a1317d608071a772d496d724b86b81239cf3969f13a80f718c0607db8c205de56d73cfa688d03f3aca705142b0dac4bd35d2e23dce7c14da54b567cdbe7017bd6f6133633872086fd4780fb234da353c7fdc3164849abd7a0d79d49cf1cbef176ea3e25ffd3e9258ca213345ca59a5f185ce1aecc8e74ba526f21708deabd55d7876d9ffdd83729d602f50c371f40f7f55ebe4dd85c6ac142f2dbaed553a78c2b7ccba8d0eb83d1c693d182f6ba86f1628a9e03b30448e34c57a13cab94e3c0daeddebdd980d53630ace32166327381717c1b935ed55e2200cf8606ab01fee6fa75dff808de4a1f3587422bcf292bcc90bab45a4aaec0cf710854d0a8eb6a85e728410bbf87dddb6802f95d5cb960b4b14ecc9cc7215f88a7588d5e2bf6ad13a6c425d366eec42d5b77f12e1eb7f17b7eb8d96702abed6ed0d38b9cf789403d92e9d9b889227629e770dcde103b2696bd5a2c1cd3bb3d513832422c2ecc9c608227a38a7336cd02dfccd1969cab3526ce30054753b1efe61f01f99913342ffe1fa3ba92f766ef6f632fd08a30e91418ed10ddd71c0d118bda3c999ac5c2ed4dcbd9553b18c02c0e62aceba799d20a5c279b4c78491961593e273802cb029f2531b9d8ad7c746d8083b6b1fca48217959e6e38d4a712854a918222d58a8177106784b4f57a22e8b0ba7666f90bba2b5632e6d5305db734c9f90ded83bab9dd4e917fc2c67aff8419a6529e7850357537e0938d97155f478799eba9f3ff684ed723bfb73cb0a17cae72bfb25ccb0cee86c20b7afccabcb10b48eaa727fb3829c8fddd73911f415cc7b0515e70ebd512bae265d427d5c4c2b5209f1dfa955f3e9a8150864e5ae56077257b27cbd5d0f299ebd5aa0e1692a34fc930eed80eccba9bc5e421e19b4b561c04d3779461f4fccc25738ddca63d1f9641a3739b6aa70e9143edca0ed92fb7c9849f0347a889aa1726ac23f3ccf371935b10d1455a00ad574e50ad3337f613bf3181331d2d90fa6947be81a5e6ae3524c1369ea7700122720015fc6889138b3ecae142b7051ea108d4853f0950215842005ee7a4b60f3e79118c26613c8044e03051941ae065f8c7d732521af5ac9b69314db0f9929f73db4768111c9e12fd67abba4033049b1973b248d9802ac47c97509e0ac87a27a56facef6b7f7a90e3181a4c55e697387de61df6cb57dab21e678246432409993cc1c489f70cffff837e635d115b6d4a50e609dfedc35f12b059a51496a2a499eac35166950ee7e3e3b1c83ceb2c2fa89f885fc768c93ef4505944acba3e806f09223a39f7a1a3ad9bf802e8410e0689cec725230ac9a155a29d101b6435e8fc4fd6d90ecfb29b80a5ab3b9de4652399365ca07e176143519ed274ad19152a508708d4e28cf6e9207ddf589b3e2fa3ca8328f1891974c9bd238caf1db9c87fdb51468e5fc208c750d13799d56fce44dd9f06b2daedbfec2e0e9ee73f790f1a1ac808311af79a11dfda6efdf55a2a6bae4b9a9057a1299461881c8d2821c4cf63eec7c27a0b1aef8f3b1436a92c2ffaa0f538bbf61c9c22aecebd3a3693fdd006b4fd3496815d0b663ad2457c8791eb826ac4613d1bb466b786877e137b575d895709bc54acee7209fa43bce67c3e4b1ef34cccaeed5df2378037cb635504a4ccf91773244512f880019be64362e2d584da095c8d5bc493b0d34f0415a365a647edaadd1f7ea75b045c73c5e5a67d466ae2d330ffab606d7c649365030e23be7638636036a4fe4b5f6c245cdde2e4ee6fcce0af17ea0ffa0d31627aae9d020dc9dd7a9a302d9f7c714fb7783043228b4773250edc6d9d4553ec75b80f05062d9520823c64117b4fcb52518df97d1df8fd8bdb31e59d2ad8f812157146b620f0eeaa1b0a98a50fddeecbf86f163025e2118923c49ba8fc77f261976c8a5c9e0ced5d67a859ea083dd344526f6f1d07df25554af5c7e1beabe697fb1ccf386150e854e2052df51cc69a303e656e2029df59fe67b51dc03ec8799b07fd6b53c72e900320aebaae3d2fc2fe3885b8ce0d3b35965dc4fd5f545572d7be21d91d794bbf349f2fde0d6ad98d8edfc425c90fb6ba8094dcc524ee18950ed6de28ee134de571327bb1745609119440874e6abba311c7bc3e8c993bd329f99e7bd179ca06a0f1012bf6597101365e67c986b9e5a4f96c78bb6c3854b327e3d9d802c5af4e73e89d4f6f63abe3a28bb9d8f610b8a17d6a4cb75724e4639b900fc7f142e104cc9148056cd12f839541a96c75de28df4ae66ffd3476e6809186df64ba53141aa01927474638f644159ddbdda6a00ca5fb506e8a4d5a69d27bfa99105ce7b502b59eb96d3b065bacb835da51246aec6f285cba9612c6211070b00e1bd548976ebd9d88cb5f2f23651d60d18fc366936a0f4246a86e4c49cab0e3d05214ab6c976a9c1695d3d4df9227e922a614a3842e93912850faf322127d903f14076bfb5f642cbe69873ae4d15868b1f758517677341ff635b9854c000caa61432d14021527142804fcd515e7bbe19f10aacec8174ee7e34b4aaa609b0f9613bc1b7ddac12ed2a3aa9939163e2262f6299c5acead39071be0c59ba2541a020af998be8b7686dd303c8642e7a96f99244e85217c7fea4e957787d3fcd288c3fee29c335c3b0fee7c80389d4b53a33a3cde49e7e0f464b15f69a0818ee6a1ac8fdf351d7bb1ea8957af34188125a0a6de91ccf1dcc7587c2e7ee4b08cfee9b6d2157f60bcf21f1f2301487cb7e50e2f1077213b52880c89eeb5a3076b464d75030c98c4d2250d96c93778ce89413fe249237320417043425a3e19eb8a6d124093ac14d4854e788367f055d178424bb8f11447f7d83418d4b18abe888ad3e8e2d85861e078ea2c696b94514a80a049bb412b4d1bca1dbe2bab6b582ae1e98bc125c5bc3db622f3036b627b2804724fd591b083fd2ea1e04e580310eeb3b0a674a71e412b27c0f4e9a1b82b05964c17585f06edffae104be143ae6993335aec3aeac2292956dc7a0cd36dfe3ca4a34e226fe2ec0587de46c90fba86d3becf6aca10a20af8986b0b1005802b5408646f50447664d74fa72151e5e75005a1603a7759379f4d0eab473bf13bad454177d0cfb60d400f935bd4eb73aeb8e154e9a1e9fee7f568e9121918774a947835620e04df9ac545630263ad7fa00dce21108ca12043a6339c5ba4c7fd8a73f1e01f8b86ea8ccc3e9bd5e7036df605057755eb6fc0ceaa73283629ca8283259dad79933e2f9843fc505021e8c6a8bad93b95ffa2a8e7c61ad37e36ac6a789f8c3e44622f3cb3f81891d5513ef38011863e157b0d38ff3387fcf026c4e8cd67e5b928c8e38de3c550e0612d6cf01c44b9d7ee4253467cc0f7559e005bb5886624d728591faee1fd7f9a629807dca9977474f72e51f672f94d03255a66f8ec153a622cb399601d3bc21be1c89e4a4a1f867d04490d974e86d55a658a8bf874c202544f345f991ced057e6e80673b19fd2dd0928b698197061f4e1019683333aab365e1ce4897b8c8eb8fcd051e02f632e8a232d3c46b0388e4dd29ecb9668a3456b1fa1f87feade5b05cd138e52a894f714597a469819c7a6fae8e520f1831ba4a22bdd752d7634ec51c2f23af494bdbe8067f6ddfdb747e9228797da3173d9038c446d1e80d6d4ec861878a6da3de85ba3cf31eacf635f2210bdd0a2aa4a5705dd68774e222001991ccdfc4750abd18929fdd50d2d6aa87e85e8ab6a8913d3d333eeb5297d3908df0bbad9884207f616cf3eb90b8b7744216023dff7b2318846cdec7e2b1a5f842df712ada99c6ad90d286e045a198541d87e033fd62765825526e71af63dd3ed70657f141b937943daff9a0f828eecf818183c4971ee806420215d8d52077f80a3bf00515f06a36b584f52caf87966d3de4b2a84aafbbb57ba48f3a16996d0139e392372f61fd1d85e22dd99ae890e2d0227ea8a4bf8626165662afaa63da08443f3f6ae35fdc283535febae4322f58f8659d3e7e900ef9c953597907ce83d42b7d19b9003107a0224579018c6e6012106323d9763ded1b2b381f2d0066b4b839f3dac45f90584b8ec93d4a985779436df0501bcc3050807fefdb8f7fa82c91d45a810193674b50e411a31a27ebdc998a3a70474d34d8078c8813151e148925e628dc5d49fd1f1e8317f616c0e5fe13d84df7307bcd55e521cc909082649e11b76529cc1e2355b143b0b687e6fb11198a0b62467f25b3a86d1e9dff867dfe039342fff0f1effc3f6239583c86cac2fdb732f05ea59e925f7781408e2a014cce0911d589c00b8cf2113a26f2e2970184a22abb1d81c5009b8e790bd24242ca7466097b71210ecb7bb8b840a035526f80ef6460ab6e61511f62badc1329ecbf1bc743a401b33b03151216e03e4fdcc8c097f7c84e83482d41dbf91bee6395b36f53cc10ef0ffbbcd8308f17c841fdb4ff48d4c949943cb678e63ec08639087b14e89740e0f76a699fe0f50cd36cde12acf5120006163cdd5d5445af38f924ff96a9aaa3b2fc753f748426195c5a822c6865f87dcd9466e91e664f29a960dff85423b22698b9f6f588fd67e78c798b024f1f42d95db0cccac679391b94c7b88974538acf83c892a667b1b8eb53e6e632b8f671219ff7d9048e04557e4e4d93c1eaa5c94d550d3c23575a5a3feb91229152b960a48720ab63049b0191102e6d05c236af9d7574dba8df13ddb44fa34d2c31022ce9d506515c167e564074cf7b09a5f7d1ca4e4c3d08da812b5fc1e954ee2685714849648095e3e2b451254319f40a9d1b4c7038c493cbd2bab932d33e2e7a93079a960c42877dc0583c8682df8565592f8713b72cd680ea50b42f26b8612236552d94b1529911d6c95ae92e82806cdd95785d9fc636b792f4a449aa39302c26af70566de08b653357eae738fbd9c1aa5a7509472326c683e88f793787a077f4d0d184fffeda7491107489dfd96fc16f6108849e8288fb875621388e87b7c6a3147f39860ddf750bf8ce2fbc959a280d885853a1da6d55f4d202c1493754641d79362d18a6428c445298244e2f9b6ec3ab66c84e462785ff4f0ba951d8f4a5078497adf6a170a070f41a48bb472d54e9d3de145801bbe727a43fd170dd884cc6cece56e6ad7ffb6275134648d19ef8e38f14cc9bfb0799c0ab387ce2ea76fef2b4583ef297dd9b694ec251eb3b4cee8b2be095a04f1af9932b850e3bfa78f4e69e1157667f69efbbbc2b8a43ee22a2ee775c1103815eca17ccbbc1dd71a16ea57c39357aadb2358c4b44dc8e0e9cbb687f6ea77c3ed09bccd2c1abb96beb7229e223d7eb8ae2f76577623a100c5151aa87f8937a8f0e578d406e1393e1fa8a1c3584fef4ba7da91bbcab486f33ad5015c1d2ef015d10c3ce6db9e0bf5ca40ea235a38b1f50e3740035a271db96fa1b1f759b34d786d7eb88e8750b8942a179f33c8818185b23a4710bef778f920ce26af62f9680d5174976b7f1a45d9ff2b8ee08869dc9ad1324a10a326319c19417f4ed420b1493341854a47dbe4b704031583ccb2e16f6127041053d078567b8bf934fe2e21f087cccb6f5561406b117f15559379aa213f077c34b9840d9b1b1dfb3ef6b13969b8c89adcf3bccac9b0a380ffb3a2eb1f785ca5e83423691fdbf562dcf6cc9dcbda698f73f99c37aeef9283a03fd1fdd5cef3b1d3b4dd9e85140f49dce6be30898129feb54b18f978c5d2a3088b20a4b355b0e4749c457745d7133cb709796836e69c3a1d67885e7f26d2136f2330ee34ae6533e8f50cb6844f025f34b2ff0d02268cdacceb8406c6420a695160acbeab0d531cb56ca517c59acd2721a025f65dc946a725cc8806c96a8d6b86df67cdfa333dc1065bb422c93c8f6385006100d9c1a970445b6d0a45135d9bcafdffda40f98be53959e88cdd8395a2f5395c9f99e9f0143a011c4725a6619ea89ec0ab32b1d0a2db1ebdee24193f79c9d7c7ab9ced99d388a0ced940d4af76b0b543a14153570946f26105d6e6ec11a0aa6d2f22d75ecdd9154d524ab1bb81e918e0040ea62d8ca45642323a4f9b048481fd20c819f2ce45a119d107fb4d3361c4fb3c6569125af4bc1e47bc5e89ff6b701da64960c7f802d124131432160e146fbbb06bfa9ae087fcb434e9e0a449de3b1672387eb486ae319b751a76395e90fe68770c7264ac23652015b2192b02dc39a46c6c18c95449bba8c52edf5d293a0b2cc9581fd3d7082fbc559e5d59492965c345ed28c66eb5efad54a8462997159e2f1809cd32d45816dda4bc51f3069591cddf455b97dc0f76633a7ad672aead5e58308609e715f4a5f4db283d5077a8e39bcc599bb6d87c3547a1cc4bbdda2f1662f26272be83a1cba4cc2c5c3add4696974aae33366ff2c3f044dbac2f64345742604c8150bcd10d3ec1b5d7b53e1c7793ebdfc93fb7642b30aa857f70d492a02f221aa9fc88d3a7bb56e5adf7b9948ae1346228b129904c800df13d12433b242aa467dd022a357ac7acbded1b4b993ee1e1a9dc57a89eceda156ddee1a38a91217e09ecffc434639b74206a557d8c78aae995901991f8490ebb49d528871f9933c0397c0e57b7f505867d75585ea628c9dd86355bfceea15b28b309c545324b2b07b3a961912ff1281dd81f06d70162dee181325809148af4a9ca9a4c19eda4c88c27299b0d9fb61757108f36f40d93ddcb208e93fc1374c08640a39e8cffbdd82d8c6b733a556cc7ff29f954f341a5329569bb948a4a6e7cfcf7200c993d9ba75ea0de75efa0f368caa09a1ca508ec76349efb16f13969ebd380177fa0ea96ef7486dc05dd4a10838c7629be739178e1e897fb150ed15e43a5eb3b2879b67d49182365cfe675dd2ab67e78138422f2a2279b840630751135bbd3b0e0461659f0fbc0c72a98723ddd3f1368b72fd8f805320ed419b3996232d63ff3b7e416965a9deb6f2831000161f899c837f920bcdd2d0f99fad29410c268e6e89fbfe458e869398c35d48be65025cf05d144698804d26d13232197b615dd6388e6ba14876036712b028e5fb470a480dc28c49ac24e9d41d13252ead98ad2f5fd88907168c4e0422b520adc15753dd2ec6a01070483070ba5a3c2b077fa0d6b322d1521c25748802af20cf28d97d0b4f8dba8b29403095627309674c23cac9470c70660793426c0999cbd91b17e52a3f2c509855bf9068aa2e0185cbac49bb634ab64e90516988c76377085e53793583c794dfbae0b806d47a812e51e1e1b06da714a87b261723ed2946a011e818cb1b72806521a57270a1792da33665f01badc6dda88fb7af9729d3e23e6da7fa9c55b3652f3c1fb08d7259d3970ef39bd0625387af92bf0f72eb2811dddf81c8e7fed90c784a98f650bfe21da5288e78dd1f763f4a43dd1ed5a162a087a8dbe4d812da66292b0b44a98b12869c32593cd87410ada2a0bc175587d2cc35bcc31174a1bdf3bc3f08cd9ce725fe6b3a2d6f7ec3feb6075d5fc51c5d90ec4f5b55d9d626518d1a85dd47fc7ede855e0cc1955294d9d6cd12d95fce54ca0483e8d6969e94c7eaf77425eda1bb8e6124eaa20d6b4323aa087f866395658fcabfe383bb4ef739c9f7063ce89d080db318b2b63ff6a9533b1f09fc308dd185b8569ed5b9e19c1ae1d98f1fc29df453be324ff3ab821fa4e756a35702566e96d671fff485af8ba3459c26d6c9cb6168baf8d75637bfa5a5f317067c170701dcc58bc9a1bdb1a2e92b2103d9dd91379097183491abf7e08706ea71bcf74b4af6b0e6a37b699f8461d99ca92e6bd6b37dacbae45163eced9f7efc83d23733badeeb5c155a0daa6d8b9bc51ea31f5df71528860b1e308b2da38eddc5a4b154b15ca9e01bf0a1d56485f1ea0f4606a6d13b61737e803c22338065a56697b10f618b59bf59bb32804242e5a6c5bf3e1a44f0e5ca23f897c5b4abb133fcadab6785723fc870f660e83d0ae20d949d4a3c856859fce4222ce300fd608b7a3e7b20caacaff4f704fd1594257cdd32086d9928358ade48e01a8fd7737e9e5f680e5a4b25011c30c9bdedc500fa7d9ff27f91dc712c883684f831275c974ca4763d82a6e1bad1738b5ca07078f8b93cc7163c80fd5851eef1658aeb6c8f3d292532579c8be1adc8f4d820acec42d77f6285e01cc275a75761bc82bf5c1d4170ece43898d53d29c8669de9286e59c49183a6469ccbb8202ed8660f75043a441150998dd946dd95cb4a41daa389205d76c95564e44386482c1dbc93779cdebfb09c80b6ad60dec7d445d65f9465534d0b7a0f2cbcd3e72d7c05c6c84d41ad7340c702d5ff449da93357bb5c4a310c2c9dc3ba8451052b83724f279ddb42fa8cfd99aab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
