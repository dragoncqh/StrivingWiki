<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"022ff7d560891006a57b7c78d46339ca4a4470de4f23d0333b92edfed5445bef5bf932bbacd4339c215d7ac4c5da72225e96f80144be5f1fc8b7a39788688f0ee207b61f4556baf8c9490b90c005cf87d22085ae9be18861a03d0056d19efd94080d5c0927be16ec8fd1f7d07179fe37f41141c3176bed97f931856b456f06ee6bfede1272b2d0d79a0ec978e533a914338022a28a9716c4edb8eeae94818ca530a3ec4629b64fbfd283a35e597f58cd9a27e0b7054071e5c18fa0686bf32c768bd6365ef0c42098d1c15d323d579600f7609e71a67f441b1886cf8250c1b6bcbf5a5bbfc448891103d6171ef488d1575b75675da8b1305c621927494f95f7f7c3e6f8c056db6955ab3e543679147eba40528cecae900f59458b5252b4a7e2aedf4c6a8e253bfee7bc6f8ccd9b4556397625bc584bf9ee1cae87d657c053c30aff3adb52ae9f3bacd6e758ffb6003964b22ebce741722855be9c0f20a22e795f8d3d13d8c698b870472ec2fd27ee9fa4f6605f08528fc3d6cd7b9798745e9fb508ae63a625b087ca743cb48333bff6560838a6da608956900e09b376a6658b83c86285f2a275442ce39118089bc74bc5363ca0c4f053ad375cb705329bf266db18ed88f8050480223d606da31723f873004241c316361c143c225aeb8e7d537b837b8128ec32f355c26a2b4367cfb824f932b9bd3109edf46c1b5aed98bc0e6d61cfb9c415a6a622d5cc6bb52c72f1b8ed3d0895c4068b96f587fe0a37b546add91ce1f92460838673b18db146a383f7733f2e4716fb595433b98ce4952b55a444946e52962c6416b43318d7f50aa3354dea98524e4d2e60a479bda0e922859f25a63389e6498fe53079465e0949b6655fa25932a4a54973ff93dd46ea746ce759b9cde381f8c7d07266d07efe4462d67047e26c5209da98d0f3e8470b8d9723e81ec528496608fc78f0a2f6406e9dd18c8d01008da3df4a8d5bc0a1a128222d12dfdf42b4583fff7ae77cbc0307ecf53bc157faec5a2a3af738bfe294b297c3da7cf3f2511e82b6e47f4c588c44fbddb43964ebf9f3f112d77069122836d2970c6ee1409f3855a58829ecbe600b9fce6e1778b0de544e67b06dd9fb650397a4a384be424caeaba554c7f64af44c619eba42cc4fb03cf918d3bd74fea221ccccbde9359ffc1c9a0c618aec946e034d17a66c79c269dbdcd6d1c5e37e491335a9a82d39041a387792ec4cf8a65979fd2f1dc26d77f7c1d2e7f21f360ba42ed54d3e258b0d260bb8e05d463c9f60f660c27ada12dc6f8bea0b7aefa7f1dc7535247b624eb8c9cb6b604f38e33a6e0b47af4b49660242ef49ba0dfd45b9df73eee322aa6ff8655cd4376213ec84867871ed2961f32c112de739da12233835f227cf51891b8a4f5dd41fc648b099f1cafde6f4f8b7a98c1879df3d10c51249c657c0d77fe159b4f66e7f2b4b613794226468107b2df20a0dfe0e771d8240bc3251e82b026e50a6b93ef1f33ddfe8babc0fa04ecd3108de186c9ae4a5be9a93e3976ab25d0dcee14e5fa3df733a35043ed68b550bf5188c4b266460ee9e01bc00d21d95fa7392f679be3e98f72c0c49804bf9a20c07fed7210b0652cf472750996e56b635edc6859bc4baa80c57bf3873d733e06d855efe6bda029066df98352c2284dfff4df98533450eb4cca23c0c533bfe1ad9a4ff0d3123e75d4f131c151162529b604a52e000dde84707497eeaee8094ab863174f5d12b8bdab2224598dc714cf34f8f13bbf1fad34f126bb3ca19b9aae72c6d911203aee71029d6583d5e5283faeb33ad7c4fea2655717fdf1a60608e133a5a7f0353422528256c34133d5c8933410d9cf9c74a23d83ace49ebe49f77f15db2c2514315b04e55a42d59b20e176b7d4f13f0b105a6ea8ff174ee059d6666b74f2bff0751994dcffb2a9e730ab34a4afffda0ddf1375e6bd2bf8075eeed4d99b4b754d159fcf719568e0d7d289a134f9cdd35c46579fbbc2c7a49885265189e07aaf38758594a9b7bc6d8be347393aa409e5e6291cfc618ebbffb1e870bb7329d4992fcb407ccc4b31952d6d530cae39ee8321288b992dd504a9b260ba30f45ea40284a0a089ed914e009434ad1eb76b306cc574c3d475d6482fa7ca10cb3796f66aa8eefb8c1f801e13f0b0c5053cdcb7fc38b7f30fdbac84922b5222c1b15ad263b37504b63c5dc510e974bd89adf03fafcf032dd2f61139c3221d3f6bda404a349776f4523751248f2e2ff89012b89ce4b834ddab6205d9f974f67741da06f7fcfb07d89d8f17c79bf743fba0306c120759d3a90c375214630d09e5cee91567092c5fe0b7b935f143d13480c3081203269e62062990e26deea3789c2b60d84bb52b5a1d3c13f49f5235b095467bf61e437557739764b367e267fe7381272f1633b80105b3a293da3d3adb46c306aaaaa0d77297e666a57732a64825000ce35b6074dad518f2c9c1368941703888b06d2b9ba0b902a4ee68d6d6485aec28d2fae6b45d9a21586770a6fb9bba5f80c9e6f769e0c73114587694d495f4a24141f54d8bea3fc408befdebbf1eba9315c1800015b24df5fa80bc480318dcf46cd5c9099a0572983bf8a0a1bf057489f6a0ae1d39c8e8ff5519afe14c10dbeba6260d6062383abf155ee97f4ac1e07edc060e1a4880f316c3ddeb829a1eb9a9a9b518933cb33fd49158e87d03f0e242495d48577ed1ea23fea41c46915675f45cd90ce104f7d1e0c53803a25411c2fa0959124cdbd7973eff14ffa2662c4a64026ef46d3f2c4658d9487899450b3a2e2a843abd7bb69a889df9958dfbaf4da7d5184a1162e4a73be47ddcd6650a1dc68489161608306c6e3e6b4cee86d867166cb271bd57e4d33afbec142806b6d13d5a87dafd95e1163d480f7328be588bc7c5096821d5bb486bd2aa9a2e893cc6bb143629e22b6ef70187061ebe394c7e6342292f6018f82b2e59bada67ad7dfe050b61a3ebb284886c9397f419a1b86c7b1ca8a2204f1f04c745afc33141ce19444bc286a82b66710f57973d29dade395f709d34f46c60ae738aa5dd49d0136331f8cffea75cc24e5033c34229676975c422136fe005f1a756cd26f5d225882cda636992c97f5596a2c0a627080ce8c925ba578f7cac65d840b65eef188e080a2baf4d3125b34029d150d7dc7e47369dae95afcb7d008f77edd0b5b9ecea18817567b7c149f78fb289bdce493a5e68490c5d77324f419ff8525b30f67c00c901b2e1428f78f8bbeff811163d23983abfb3738db3786dc609d57cef11e5f3b5ed639ae694860e6ebd3b89a0318e2e2770df2384f1da91a518f35cd4592aefdabb2143240fffb3fc64d19bbceaa3f71e37b1dabc428cd29c95e0d458cceb11a1a2f03c8e927584ee8aa09c5bfa8f5dd9352e492af3640a905db9467eb3992aa7db1cf7ee25b633dbb9eaac02f2704967295adb20f8ab94bc31886f89df4ba38a531d175134eda256e93aded55785f089675ea1d19d77ff973da0590629240f65683c697508b93a92d36e7e1ddd5894be455e6fb7f0153d8a416b3c4971f8ff0e2af322b8cce8e989f7783b814fc880f86008f06813f898ae846924ff4b9da32f77d803e255be90651ef7752f9efe851715cc6dff50502b6c9d2066bc7a338774127cb08109ccaa894e3aa9c097dd7f785cd4bff92902e7cd3c0f7d9f38f5f6b0ca42bc1b4a146ef518a1847b46414fd7280be7d70e3821f16642219d316e116ab3e8dba7415787406ff678df44f2954947b88a381efcaedf9865334e815a153214240581482eeb1ce3af9d40885c8bc7a2d20e9dbe7dee1abf69b7cf7c903e82aa96e89cb8406fa5d55af06372c6943c78e60865126c8570c9857fc64bf7a56284877240561f5932505795097a5c1029113a779ebc6908ef56489ede2712fc0a12ded0af64a9ece6f99c0c6abfc66afdb9c166418cdaf35bd633d1bf3d520fd2c88ce6644216911d8e3b3e020cd5bd531933063f957fceabe848c2f9a94b3293b508725e9de7441675134df717f74c1fd3132aab97a2ab0cdfa613e99702c20a473f0628952c565d21f830106d45df8845f49ba7edf23006e2eb28ff298fc3932a1371d77b8136706bfe8594ea6461d0b72afa2099bd3c1832800b163f85f438cb9bc52b888280a1b91919837049eb695ebdc727f853aa032d740b4d802f1b7a9d4e028ff54f4b449ecb4fc61c811fb86abf7de77927a7b42499d964f7f7f395282f99bdf8e4770f485ed4ddd3a5d1485aa57fd0bb64e3b2977c22921fe222a9b2b939963513e1029d1251066612efaa76dc7f54d98753dce4e75536e4b54f3802cd88c9115dd4ea44f5be7d0fa66f3124d9ca6cd2b9162d5ed63732c27f3462c9a9fc833e024855d071f71fb651f12b95d2de11bac1f2a5c9b7012f1495040f574d80adda436bc44eb7c40cd490b0dfdfe818d9f69ef2bfba7580b7842870c62bfe09ecd0acceea09ba38e7a1450a07d2f9da497b175056bf953052e1bd8ad68248dbb61e65f43ff4f6c310d75cfa0aede004b3af6dfe9bdc5a7403b0c7a051ddee21edb7bd0245af45b95f93ad5b8ab2c6dd45b1c058b732e272460fbb9fbcc511b9dc572e60f052ab3bfde0da408e106692f7ba3c08f0505b8b53d3de303167734ae1af26ebfc4aa294e2235ce978ddd458850866d2e584b50702e9245ddfdd94bd5f431949482ff7797939b211d451b4ec300719831b87bff69d08334508045185bb25190b050772d68c6aa7905ee3525b4699393dbb6841933be0df52d854c4184380b2275ed465fc5e2dfe1138f04ed6acc57c529c30ca864066f9eb8db236979808389540119183a588925ea43ed0a3ebca0ef64e83165e82ba9ec2039e39ceb97664d86d25c42de01b305a6d33d90e491f9382d8af6544826a212a0769b0a479bac371afcd9fa45df9ce87be9adf49618a64fb2eed1ed9bebc28a8c1703c74d96f255704d16a8b4c6578f34fa5a5d1ddf20a0936d269cd03300a4e0c4c7402516c34c46c7e649f2b2cf9b41f45b1ae5fe211ac445a372a404a3b6dd2edeabf78e0599e8ce638dc5470887baf8bbc78482c291d6473a5c5e3b0369ca5509e92a6fdd2b7f3e2fa3ccc70b795c8886975f885d9f5e02d809f5b64535fd34cbd9900b82072c1bd243bc7b34c5f126872340cf491dc53b7e8d992f5fdc0130e2ff2447a06961e5e51b690d247f96d4685ae602d213ea81a6b3ade455037b34b538af711d055f4892f6f4abfac137245b91b7c3262299d5728980e59ae7bf1f9fa8bfea041521998f7596793a97306e088e2e995d12f6746c4aa4b3c9c11d1067a557c0a79af597fe37a080c75abc2ff4560646ce2a97411d4691956ee0bef9286d6a444054122bc76e7ec05636a4d1bfac74cd69f175946353107aee5ec167743f66b07eb2582bcfa2fc618c2e9705fada901b93e979548c532410994d53c90e078ace3fa3b5f303a5ffbcf305f900ef9aec466ba78a3405868c4c8087f48cd9dcb2d7430dce41d905a18f234afb1534cfb88e75ed098f0be6a7a3a38bdb18fb645fdeda283b99cf272dd4f469828186cfbfa68ca33be6cff64b278422e5eacfa91a5849d578023296559ec6dd62c53be2357754b740b4ffbc2c59295c47f896a7ecb222dec77f5679180995258378dad44082d178b58824faba17611f677a2f4eda6bdd885bde3f388f8ed6bdecbd40280888dc3768c21525f39733ab582f2d648dada059b220141bb48cb9a32f3e82ea21413f7561b8f5f49e7836c8c8b3f8565da62444b9ec497878776fbeadde7913d0374104c9a41cc6cfcb8fcc059cb06c8b624961e7859ed47a4f1f1cc5135f07f3b37c167b737c12f6772c46ed8c09d4ac8c9423625cabc981b091e4e725439c6e11392e067afe13308e6a990eccfc9d90bc479ebef2bc3fcd8358079f59739ed94e1e015e5e30102b2c10d22ca081dc71930a503897c3f11129824b94dcf19955a8e640932899817400c8afd17aa3307fbdf3b631002e3dc0aea68e8cb1516cc4ea3d1972df02b1eb1d3032952859da5de46271d404d7e57a1306ffdd0e740275ea5db1d877877185a619d5b13b01fa1c24ef78724a975fc7550a74a0af33b90f91fc0972d764ac4450d543fdba6aa8e182cb9f11c0c9e7ef47e6077fadef45eaed7994194702f96c168771f8df46a152506bcc7f43c5a5b3a8c3403d0964e0465f3cbd684056023f074154d7b3fef9c40e94c4d9dc10e9c991210b74c597692ff64b749a7f3e5f592923ff51b9ab181fe67254de79578df6b844a8efa1107d668cc182e5a1902f3c1d0de20644c96e5ff4f515ee03186e10a69ced9a55be90b2be3a47c681b86d7fe30a937521b1d812f380064adf76d851c3a91573d06df63dc1d3a0a8c82f299a8a60a9c5e2b1fd1fea149249a0b5b4f2364cd82e67a95b47a4055526da6ec2dd7f01258528f4e876fdb8bc2af7f376c5b6bb48604e10f95eaeb733388ad208eb44eba8b08fb1964934fd621873c9deb5ad973648ced8c8b66345aeb4e1d0389204a9030df83f243192fe89d244f94277658608c127eeb32193b939cef13bdd9953d235fde414ead68cf577105b9965c4177df6f2071a77ff6e306c374f3bba70babecfbe4b020a395b68b5aa7d75480eae9715974f2d8fbd0ab1b23af18e11edfbf93e552fa3f5b2bd332d43f29e5ac1ea3a715f0e52943c70a9897f12b1e6468f15428021417fa2bd5799650da803682c65def3e3e00133273860f1c0549769da7442b2d114223dd71ee5a6244f474e2bd5d9de2e58402f9c268b3854993340f80d84bf7d992e0479b9cfb60b3b8c7934621ce7b0a7bb4e61abe23f29043580e5e2ad52951e99daffa50d3f0755c60f6de7d66e2ae6483721011b7adae9d9effeffec5df68fd0811577c908e61a37eb0b2a6c0e6ec09e9dc68a30de9ee6b2d3a7fb00ccd28b345c037bbe69bda93a23118021dd08205952940923113cd072120c70727572ea37fe93f2adfbe9d7436f75c12c14739bb3baf90caeed51f0c027581ec2fa94b8b772f707432917c8cadf5d2b8180fea7b3f2d7a953658ca083510a9d05af02e98103d67016cd31ece93bfa2e616c8420340e2db7517966c12f63e370db53bf275ee88cf2c4a8c7a8d744f4fd3d4c228bc3e7964f39fb3d4bb80aeb94f927237edf1f809ed575734fd06ca88b8233a5a3138760a201a1e8153efe6fd5d5af2ee4b564d750e2a3e3fb56a0eb310b90cad142150cef034d807c567ee57d78adecb8132bdfecd13b385b19bb1ed6d2c8e0e0d27d147bc6351715777f0e561df4a4efe1a85116a0912c6b595025acd263b32f1c9f1360e9272605bba998e2b350890dfbbe87abe98c1e3926129de3946832b148ec8db15ede272217f992f89bdea14933d09c74534d73fdf727ae1e2340ee84a8f93df62fd1b5a897475e7077c3338141649f10f52c4c43e80959db4f1b40acf3e70fdd5bdf285ea5bd36308d45a3832bad67819aabe8aae2781206f895397737b1431807aec5833cbf227393b5ceb3c6b849ab34394d295e852fd98a3e818356de170a7f050f40444ee913eaf00b2e5686b6ea06f513ae282d56e8133442f3479d015ad41d76231cdbb7e31ca854b73c5234696c8492ddeb71cfd35d0f31e0b801348e41fc066012fd93b73657f141598ad7c144b22446ee3b5fe0092592daf1ff9a8b8fc425715cf6f5b2bf922169fed166f07ab4d9c0eae752d9bc66da061ff831ce9cf342a9ebb90e8c732e51768fe1d58d968c6f2c31739332921d3406d3675aaebcfbd258516204f4d4c032e03ae7196c6827333bc0016151588f74e142b612305b04ad095b7e80e4b510b49b4088dd10530bd25556e1bd4f3d9890a2c145872f55bd91c06267021c62d36917c91987a5d41a1525f15834a601d70c04b1c26f370c021b20321b1e345a0b5a1c782381cdf057e96f54cc353d6982b2305914041d6c2616cb8a66ba7f92efca6f9da7cf8457e844304cd0f8f3c500cb52e4e3bfe47166c8a03dbf26ceb25e538de9bc2d075b456f2092faf57f5cc71b5388959f43b815db6c7448ac03d1a99da7abb811770bf0494760138c66735dc515c62b4c47c4b0815d77f8b902a5ddd59a193cb0b63f4bc9bfe41f74e2f0724d7968c1566ebcb193e6fae29e09cba3be0a8daaaf84906f77db7fcbede6b4ccdb7658a45177633f0b2d35859cf3348fb9ac91b2cab14ce136453f1c37a6de087e5da2d0d76493ad130a13c07fd24dd726e6a4d7ab2043929f34c31931e7e9c894d09efbe2dd42a49073294c900dc35eb605c251fed80db6bc61c8700dbeaedfd127880fa03729d823fe858476ce0298669c4abd67953daf44d635d210920a989b83b7abf0261095ac67a49405f75bffc908fb78bf2327b3d760a1f0c45896a20a0a37a98cd9f99f572c48263311550b631557a87e0c3ef5d36a19dcb19fc808019cd6e6e6184232ec882e4a2593e4a58d089808340d155f862967f52390568ac2d701e3ea3fe2c88593a1f6f3d3627c27560ba03030e5da4dc97213a5941b450dd14f6d68e40c9b4bffe9be5bcbda7602d983c169f77fcd61368d892d0bf4cd4f1c6236e4e688439f41bdc70704b916237b0f73343d60b4ead2459090a864e8c8dbd998ee10def8e3ad93658d5a99dad0fe057e5cae30bbc8c67465c9aeccae369d6f2180b9fbe76777395ad5b5fd5e8e014ea535cc3085ac30e5e5923e84dca757aed06e392a45af777718f30dfabe5f1b13ed9fde592eb431c9fa95f6c1013be20d260568cd5bcf4c0ae6a3d7f92ac6878c66f86d9f91e029564cda3eb572158074675e1a0abd63b088bc4b9ca31c9b4612ea4f2b1b8b87970deac71e5ae602c51424934ef285303eb52a988ea9a276c8d963e5515868a1a61b85f28f1c4434566e8afef5fe1fd3f7fd2801290e70eb0c99c0c8fcec5381c91ce8d651cb9b5e35b0bc795c10d0f3c67dfe2dc3030a9da18926ffb813a35fa078f30a2bd9c9c26e92dd3653b2f0cd67c62c9ef9b2a9dbd4ca2b2dfd7ecbf470a6690326089211f18087a4bb9ce62797af67e8b67692ffc524d6920285731ee4ecbbcf80be8e679e8df39f14bababe31319f23f40ec0c5e1b3b24f26fa5b7e97d7bf0c0ace6a8ddaa45f78b5b91c22ea28e91225d28209569cf8e74f82bcbf286c2726add0da09aefc46109715a6ab4379ea930646626b80ba4777ae254ef55b57d8246122881b0669742df43a75d827ded3e96654894801b5779742eb1dea2cd23ae4094c20e78afc14f703f9f6d0e609b39145e24eecf7bc63cfdeb5a2a18eee5a1b02fa36d4a0e2cb9bf3db040529bf40648f7fce958e940f30f09ad788ce1195f29418e6f68fef96585f91b64e8d8b74a14659d7cf415231e48bb03d346c1f52d0198e6175be3c7e0da4e213c3cfab552b46bcc3b2b586dd34b5f36fd0115c3c8204bc118f843e327794d8460feb5b5f4ece86c29fc80a70f4abeff133882b32d9d91a199989220935d59a78fee41f1faf55cb9a6badceeec5b8de8aeb0b0ee7a20537cec356a5e7ebff05775875175ef0c2adc59e298bc2e67479b5779021f571409fbdbe0e4d42ecfba071934cb66b09efbc9a685283b91d1b84f94f89370326bca75490ac25170620cf89735c045673e090e80443ebad96b237c6b26853d873dc60e5b1c604239e6ba0831f60fd03e07770041d1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
