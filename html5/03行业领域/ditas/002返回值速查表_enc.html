<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bdf74b53ec8be0e04b58eaeb02e67e19d10e8a7055254979118b5b5af19afb757f11b278e2bc61d2cbb944e8bc2ebc00dc0254fc73d6b87e92e721649fd05e4f1ab1ec9fc96599e9ece01f370a1833389263d32b00ad2ff49f44415b9c3b5e6097ea1be362c6e2a41df73cf5ac369d7ba2872866ccd9fbcef9f33ec835d4ad9c59641db435459910d535058e11cfeb372dfdeb09a532d394dd6fc8f40ba357d74b7a51e2d5b64e4ed358c8db396142af47dcda2ad5e27b7f0da5b4cd65f04ad895be4a8a2b485cb7249f4e131c619433a5a4c10382479127f977f1ccc07381701f79d788c4a81974dcbe6c333cad28e7dd7818b36f159ff3e17bb0164de40d62b88f911781784bdc8528c6bb71627b1a5e4150b5a867f3ccb8b1268abfa632078c5dbc5d6564dcc15c180bac8c836976d0e88c8a2245a299ec83728406b9d1f1d264aa60f45ac35097e07ee4a989c83bad98b249f97a4596b9da303e8ae2e0ac7b4db5a33f7320232ba13166e0a03a7bcafa591b58707058232c82ec01f31cee90bc981c7a49be0ccf7ad28342b75427ea74ae5d6e25ce41f1bdf0c3467e0d53cc72f2a9029fb315a940096a99c2143731c7fc9d9c240f48a176f23fd42a3e9dab971f0e53606d48940006cea992845d6bce192aba3b9d2ab1efc157b62c8f91375bda3e3a18681b47c74e5ad2e0d8f6eaa42c277b0a9c26b658f9d5130d0bb68a643711b054dfe09817dd3daf12cc1e22525fa3955c0cffa3845676d72ae0cc21dbeb96b80db3605184b1e46d6f83711ecdaa930767e1bca44003500e06334b2e7d17086a353b5b11c8e67c9540e2113e67269fcd761f827348c2ef0bff01f8f6a65bf41ab643ac24080b7c0584056379a3dcc0a8309886b0cb36a988b3916e1cd9eca7d1c2baa4a353b3d75fc536103b31b94f41264e34e497bc84f6072f4f18aeda34cb65c7af3be6751bca84b664767c24a26ab4649b68c53a2fa959703a32107ee7c2869c998726d5a02eccf51c5c0618b632471e18a2320e5fd097f53cf1064923380d2d145f40a10c9b46d43a308240301970447c29cd0c09e47a1846b6e5a27c697295540794eb8914a2520ee1cd4849b9f03ab144100c1e806e68b5086702e9c013262740502ca517210d13d62f856e97e4db114c480677cb175f7d2823daba74d00d4fbd9d938e1b3cdfa46b220b9f1f24ac5dca9e386df8069575cb48e24a6951deb8441b85bf0f043148ea605993463f6a089c31ad05af344c6b2d22896d4e094e0e157712b467e7717daa1b6b654c039f816f3efac1cbd505d10e259c3e01b11056b74eaf178aaacc2086e516ed0a79230e58afb23f1bfa781a4fc17e01b5b981af5bc9ed37f4d8cf21e8fab00b8224b075226034f0b649ebd48ac68b858fdb5a2944c53f76b496cef0a71cea3bf47f97efb682e46a9e3ca1ca679d299ae5bb23bf57bc3f23f2fa221655fc83cb04fdf7f951d7131224c285e54af902fa388b5e5582f4dea781243b63a3af0878679288cefe603f4be301f6137a00e6e653db286a5c731f9917395aa3c1c2a5b3fcbc2597bffcd128aef34843f9aa988236efb022d35241d831d962bd391c17c73732bc1f5afa1244798fcde9c24f698b7fbf7418470527f38c47c6b2a4da8d46ca7040d4df57d2d6b42c9c6c1994155c656a11016afc336981337079480f8abbfb2fe467e05439db95abeded1f9bdee6b7a59c5ce752cd39a08a06bdddc38451bf7db0579824ed403d222d088eb912dfd106323d38e68c33b9f3377c0f2ade45fd3ec4262f9f635ad08e2d17ff826b43e3a6a9c5c2186d825ee186361539d16e9b99f0a6e28edadae7b6b10f1b6fbfb3caf50bd3f6c7c35a77e44bb625cb539ae2060ea700f4932c5006cd1e68d7af70df69af3d1d6e473b88b6d63cc1580d6f37d8ef7acfa8b076e8dac14287d9c112a8aa109ff9ad8e84d8c90fc06630529e60aca060c0a49a62fd80f59906507d2ab57ec1d944e49be998f091e114c07982332f824a081ab6dd9b0c06744d86d159cbb30e2769bb84433b0ab208b840c5cee7cd2eba438e4340bc0c1e5c2fdcb587a30668f4fd32deaec458567b8d57a786bd048f0f6deac0e81ac29c6298091850adb71650f5a4dc7da1d2d9347f616fc39e4920e9245d59125ab65fb84ff271fcc86d7d06b6fdde342989b684efe0ac2f0c917501252d29072cf24037e416dc25f07c8e5b7078c608893a6820cefff48db0fea84a9227d55d01932e89e19797bda1abb57a28dd03a9da2646a74be339191acc8d8620f08a977b04354ea84d69a526e709f12a1e1ef0accae602ac933c51ae35a0169283a3652fa9db12d3ad18d0fce385c3bdbfeea59f0893fa02a91e059e6aab3276a0c50ac2907c722d0decfa214abad4eb855059ef86dc79e35a194e4a4111abffb641bada725076982ad07ddd1227c4576df810650eeb389a9d70f0e77d05783e2d32b26442994f5270a664e5b2955514e32c394c501fee3e0621a83cec7c7b5653fba4e3a15ccd95965cb18facf4e868a56bdc15a1a5425887a19c3f69afaeb6bc22e774ee43f70d494313199325cb17873d78893cd6e69ce4f82fe7d1382da2d6f36805e28c4e8f287a3a3a6b8d23f80e4fa24505faf0884630287d40e4b757822cdb80b0b2854630814a09300a39acd33fe84037638ac80fcde9fb46759513b630359291663f0e41f2e5c9139393193ef8d9f3819b36554e61f710d2b42528c78fe9488efdad02805c6986b9f40f2c185158e944bb9f9a21ab863c746e99ca63c0839fe860a70468a4766c4d5562d11c094f60373abedd7555f9a00a669c53c0cd9b73face704ebc222e8c08512531b0492c2752de38866182e28cebadc45a1a1244a4c0fbadc5d9c5e0feb30261a6423423c9d907b6756056d11ef4926f9ef6a5ab5707ff6b8ffa09c3288977cadb83cd9247358894c8396ea1db9bce19f4fe6269f5130f495aa3b64f0674b961b78397c0f41189dfa1af03d056535e4c177cfdf6eb7bd851ac4264471a82fc93ba2246e6d658511858d3709e0578f7bc9b32e6fc4d0c3107ed906095bd0c0a1fdb5eae1ecb0d060ecdecaa848663b10d669ac623520e84b203dcbd6f03d7ec68678ff2678b28245138ffdff34b279ea4e24c892b1c6fd18f4fabc3b1e7333d1a998cd4fbbf33b931a68018f2d2f65a7cd017c065fe57552f531cf59f8750e7b5b4a840334bffa37b881738b546fe1d3408f02e2e02eae26981d6342fa1ed2c57bbb3f1439ba94ef8717eebeada8462199910776055ef87b8746200d350e5446ccae20b069018b379ef909fc7542dcf5bcae3ce3c750233bc422254e4dcb7ae3792be844d8f4c1b1c92b39392304721550747866bf172cc8af681239d28b8f17baeca059f624862b427dc46fadc1360766156c4d1d257cb6a936fb717cb6e39ac9f486932e472a2fe361608176c32436e9a3ce480808caac97aa4b2b81a8178c34d34b6d03e80fc7d71e8b54cc653a300c227f7f42d7bc195b36ed696cacf2f02c497c79a1b75dbfcdbb101e5992bebc62dfdda2f8b3b15e08614a333e2edcf6ef6996d17cf912bc3562e32b50ddeb067d5deabc23dca7cefbc3755977e098bcfb4999659e88db42d1f00b5878a9b539991ae5ab24c6573be17d99b5a92e7c5fcfb167edbf92ade91f9c1ecfc411295563897fc4da9eb2a0b87e7810c37096ba9daf6f1ce096848ff5c0355dbcdb832f0feff55c1fd36f3070aaddfcebb6b519a3386378de6b8afee9752317e8a127d33da93c3b9948c61358519e6324a799948a48703ea06abfeaf6a5812c0e4aa8d899f23c2328c2e7c34de8bacd1ca14842e522a4439dd9efb16b9a30f92bd78693be5695b69bac9d4d276a4bdce9ff83e943f9da339782cefbe8d5f48c5f73a3b8076b0d94144c2dd9d668d1f8584103f9efa43275695c2ba7df008f8e19d2eba681cac1af8ab2364849580155f8693046e2529cfddc05d642308e443db1a76666e891893713918cc0b472f3bcda8359bec40d901e445a261b0a845c50e9ace60e811418ab5266033c603a0ed325a8edbce5aff7b7c2554719e8ff115e37a73dcf9b64a74c4ec27f82f9d8e71fc0e9d57cfdc386b5b30ef392899f9307fdcc279a788a657c2f0ba6493b203233cdfbbda3e85d65d900b9327a1568021937b5a4936cd8c3e54bd48af6921790ce2a30ddfa87ecfbdd5bebb5871b48dc85a414334ccdfd217d4c849e0a7d289a92f3190158351fe9c759a333d44f8da6cb98b0698eb73cce883676e6fbc7195094bda40435661f3cbb4f72cb462dfd04066f8a258e2dfacc8461865bcb79d069b3a1ebae8c1bd2e8c4c94fdc31aa5495a168d8a021011dbec84071d4f77f1a1d12ae2ebcd7adedb9bc12be61b6e21a2c212e3666533109a6cb3f1e27b86f1fff452b933339903c96be23bb2f8704f9f67b93b1b2fc256b363c07ce6c28d59e98cb5788fe0f44af1695e2dff89fd1581e7dde3c04bc84c40c688dded39d42594a416d10bcc5cbd6b41d12edac989e99e903fbdee630c5ccbdad41c09c63f0fb625eb26f7d14b2eefea46225462a18b5454cf8f33364ee6028529f13ef3d7daedb36bdabe807ac4745d30fe5a7389c194f1c05052e591b661db75f0f5230ee4e691a557490e367e1c86ba16e30bd25b51bb80b0adbda66bebc04e7a3ad7e38c226115d206288ae30e35930b46b4a76d74abe901f57075f7e86666911d6585545ddbd738574a9f3152f8b207cb8097d30aed788ffa7e9a1de2fc91e427cb889374e660537114deae781ace14318a43e02df600c7e2ffee5fcaa6254bf2e76cd4bbfa961378da4a5fa240baca2e5861f57d1c0f51235d184265531aa2120ed60d6e15a6c503d1c9c6e0ebb18cf0868951dc97df4a5f80f2e1b49811ba49009515b8dbc6d29f7cbe43d50138e2e3afa14a02d281d45bc2b073243083865462618a9a4dfb768815675a07d5b7a91baa39f9dd9ec145f160d76c300d47f47a482eeeef20f81ea883e9c84d63f4905632277e679ccd4f352423cbc8cd1be10adfa4dbaa630ec3d29329a9e42400a733230132f96d560bd61166457ac1739909894348d0023cc5d2ea1407869d8573a4e67451670e62b240478da782439b1494b45c9c15a9289a4d1c6a08063edf6436e10fdb9b0839ac67d1d0504a7692523a2d167f63d8bccb84bc485d143b6ce4ffbf8fd1208d32ac44fa18a2cdeeb20c580105f5fc7851425b8abfb51f2515a6491e171647d6541ef8cd6e4e5a7bc99b5a4528f6ff9fa04bd2a4d80e8f59a761583f57cbde46d5c03e5512dd83a4cabe827c39192bd6acae57e7bf7fa2aae035968dc0c4bc920e80143900d36a0cf4b74a3cf7cccb922d63129576cdf7231d66ffaff89796675044eda9f1e0adc24c7ced9a83e1ce8d91b9356723fc6f748c194ae03297069a1f653adb0b649813dc4d74aefa562873f2fa1b5876b6f8b995f8150c8f9f5b58ebfbaeef416b221b5420dafc7361b8b3fb4523bb6003a3a2c31612e67a9aff81e07c7ff45072641e53391807c7ad8e39c5afbc93e6e35a9802c027deac6eb72fc13b339cb116f12455658ff7ebc093012d2f73125df2744a445a91cdb007b46d366f34a8c86d6ad8d7fcc988bcf0c64fb146281f5ebede4dd586c28c592a2b5034a4773d782829d43f7965fe656e00530cd961f5d1feba6bf8da7c074275818beaace55a2c221de765a6a2468339da03be9995976d42d57bd2a7fe88ae16b72aa19cd09f6b133619434ec4f250027628ac2e35d5874f9012b3f65502a6a2020f28753ac5651f04370d43beb3d3714e6ed332ccf743a62d94f2fc37316d230567a8d5b9e65d074d8f36fe45d54ef266bc8541153f52585087f91f85d2512a93a5d725d4103df232264d77c9ca1d0fb032fc2e8ba182cd7f14c710b4b5533e13b892eb8e74cd196a53c5805f2d8f276dd0e08ff31e67ef3481fd813d4fb798cf2832a240c4031fa36351da387fddfe0254425e00463f1bbdc20fe65726736e1f52a81f7aa8e9e23ec10790746aa46cc7d62ff4f4bcdb5d211b052c8f4bc9376e9ac31fce06ba28324fef7e29a5d8acb64c0fd167317929f4d3170cd0f6ed27b39ded64216fa2ba39a81b5f19513162934d87e7ceea1cfa0bcc89dc45790d501851619991401d7b482d361e533b51fb7d244991c928a849eb6c096837037dc3135857978c8bcdb8b006a0e97ce9e64a9e042abeb73e9bcb4db3389677be08157e544167e9cd28a0435d3f8c8003aeaa65893363fcc68494bd3a792f01d4ef91f5a1c8b6c478d836fb83d13223a6eaeb3e765243a80cf756306ae2d61f01e9682f44be84b36a862ca8d766cd04c1daac70f99a8c4b46e469d378cc063a4c989c53c944aec521e9a63e693b860ad75fffcee41b597fc22f3e552c1d948120ac7290a02d5a033e14c1174c7a997270f96530566af8410e319c94c0104af461034fd7222140a1cf303e85778b61fd4ec93c138bd699e952f1423a5db553a7e9cd9fae6f246755ba3e829d17a670e21548864854d31a6c4ad8a3aee6c6679ab0313c5c5a18281a3369aaaa9ce489795c43aa93b6fe240a4920fcef456cc72bcd65ab9a4ff2f18fce8fc2e3eae67b54c475748c8639119d7c070239ab12e25df3f78047d8d114068446fdf0b9c5936fad3fbccfdd4f940516df0dcbf2d1af38bafe71294b6db0bd7595574c33b7c18a937252d1d6537c9aa21c06db2e41c3f090552440043b7df02c592f82d20c3932c84264e0a3d6d213849e5a32f380a0ffe04d9658dcf37e86827289f70d6faa9602c325fc92884235595385dd920273542adf18acf6e6694d029fd8bc8f7d255d38018e3406a1c2b9bb5951341386e01b5cc188fdfd8ad992ead7061895721b0c88d04277f4f960a4db1d6047cc4447a831f63c64901859d85c41a1e1d6f17bcc89ad17defa72b8be963239de9e4b313be678f819dceb86ed76e1d8ad4e2c0b9829112e534fddd7c149d45a5c67ba25ddde69ff54ce788b1669ddc77e244f23f31a9c3b1506d44bb474f0cb458aca4df8040cff1e18b55dc7bf31eafd9bd9f101795b2644a474ce78ec195ae4994901a06a3528be9a3c070c7c65ee209989af0f1dc55fa5fd47bba6092dd384933a2242db945e46c6f430edcda2489296cb3fa79ec8e276c5fd439d093b0d90fa460b1761d6910fe2f185b01a4285b9a838223878f5bbb1b4cbbd6552db63ab7cf29277aaaee4c3c6b7ccb18d47e8216388c4943a134f2f03dea86a2e37c0ca576f2238d09c053ff49b6b6bf27104f2aec10431b2a8a5565557179c9d0678e6722787ff7e7c8e4f36dae9d2ececf12406c312f7a1a7d60a222fe78c363aaacfd10c52a899f46b208667bb6ef4878d6d3e7d4730f493b97d87e75ad61e2d8258f0d2ea51a6d05a8db73f6921bd31afdebcda8f4cf22fb8a318fe414c6abe45e4fd481568de25831c6498b4901d5631de558df765447c552fb83cdc8cfeced3571a8651e5a1c1077b2d893609b6c899471af3b56a097710a4ed0dd7976e222ff62db5c05dddaf592aabb63a0a0e94935d490c7023231a1f72eab0513edee9c34e05711e7491b9bb243ad753efbddf23608a2d53b1e7a5927cc737e4802679a75254f0286817fb6ed99b9f38b9e8de7d7cbb5ca0adf97df8a8599f23e85b45cb9ca9b1adf3f7ad8e1cd324643f76216fee92693acf726d6d7fab61521ea2547f90ca49da87b7c8accb9460ac4ad9ddf3dec20de2a0e123455e5b2f85d20d70d2ba364351c30d3b4b248113fcda367996703a164fc4c7945b4eed9d928275b281b919e935bc33bf777f2656632b8867a4d3ba62b639f88a66fef037149fa883f19b121f212401403d271b5c5c484469d93efb639212f70e3083bbe849915c555d267a412ac923af3e7f99fd5531ba02e7d60bc6ce64746f77c38336192276172d7c92a0c69eacbb36ba3b991536894cf050510b0c4492a561571eb844bd7bf0047ea4226ad2c6071847c1e020706057a53f351f1a7800fb0397e264190e9e9d759e1a26c173cb1d35a67c702df299eccc9bf590d63266e74b341eb7e9647f2f9e352883c550fa04ce813780ea9834d1685172fe71d8a7ba1ede2b31a1ea163c16a9dd26ec2d2a4936512f4ae85df4603bf04f0b0b2f803f4ff5785ac1a362664ed4be0dce04de16bd01eff69b6030ba58bb78e747ab23ec84f273734635b1c0a188cb592a094bdc18adab0db2273eceee21424dc98e2f75734e6c610fb0fd8a12fe4a9c55f703fd1c9e3cbf4bf99c839d314f89c4fd08817166d2c6ebb64b2c7da65e75e344be6783c44e6484093b23f36d3997bac22cf76b113f960311bb8cc9d8883cc947817e890e9672451bc55baf2c69f62f029678905cfecc399dcc9a89a5fd6ecf0d42888002b751a06f00dc74f73771f7356252b50497e3b3c96d7111c71e3fc6a9b9cb59b4cb32b181dc94f72a3ec193ad852dd639273ed8acfc9200bd1404dac0661c796918c2e24cf516d46336d753fdb15d229ec309be2a656b065c09567eb0d115b4da90910212dbf0a28feffed2f5657bb9362d358875580e6d8f99bd075f78fb41e82b2d7420a9d7087c2ba789ddb2d10d8f659f83020ef32f2cf82e4fe665da135c4fcb2f74ed735360aa3fa7b45f38faac6b03e68249ace793c8f1ece7d388c9d4635dbe601169edd31fb5731bc097cc511861937dada6b8dccf47141b0e61b7c70fd46654f89db7249ebc166b18b5d29b9fb536b87488c372ff8e9f3d255e1a28744761779c281c2aacea2e6cea39aa3a4962bf2b1f80fd8f285be38fe721594b8d1966ffa6f69905d282c1154a37ffa29e99ef1f2df387dfdb0d412132d6df09bc0243e4f80add09ba50fb65a5dcb7c929e6f171b32dc080235ee76317365694af0bc314fdd9d12c885cb1c73875e1a2ec2c1afc062b41cc941320ac1dc7a500ce87463e9e846afe748dda97c35ceb2cc2b695addcab768b5907bd238ce6d0d9a64e5657ddb243823af3ff21fff614cc74b0fbd7466c51820cdf6dcf52c6d111dfae7989658fb95f5d587a44f54d86bc7abea2b5d7f7a580a552d6a8720f069270ea35bbe4f1fd835d26f0a2e88a90bde93a78e64822a9905398215738f3b3302b8db2d76296755832f0d3cb01557f7fbee517f17315a0aeba3374944171d76a74e2dbba4f303495037e5872089e1a88d1b77e3afbbfa90811d2ebd4c0a35bb68acf5cb85e96e3cef480ceb16ff2c81439934a2587cc846cfededb537ea6316db784c6dacec861754aa5a37328e49ca3b84f59af99cf3652bcc73eb852f16b3f7070f1f8c92609e0515bcfad049d209bd3e0cca5a45f9850cec24c0398ff8c6317e8ec578313195e071db76adaa085f09dc603e088136c8ea92e292baf72a78b2c91be7e8201ef7e63456966ee0283dc3c756de862d2371e8df79824344ae2aeac4980c78f207dcabaa0f9bd6edf821cf6b1ea5c790480eeb1c3f7896e76abf6e4635e68b93f9d682eb41598d9ab4922612fe5c381cad489d3df2c6b619cca5899873b1da834f78c9b19f633eb8ab6bba00f00bcdaf98d2b0dc59c3f28ad41ce57e114ba248de732921149f6be4da2cc82494a30c7aa640d0ae2b478b8ddc724831807e80d3b987c54413df8b3ca9adeeaf9d967d799587b148e09551a934600e7f11fe3656b44afcf435d4ae181fe42633cd891c27a80673e6d6b36f067e84c458024527154bde15eaf8002f6439030b3d90049464bdd2909088619b858524db87f2744d16d1ef1510f9bd68df65aac5544e65c8295791c81e01e4e26f50ed7191650054d99f48a6d554e94594ac118ce26ac92cf0d30c800b789001ec46867d76cbe886799579b6c029f30aecad30c0edd1d36a20e9a679fce288f7453295dd6c6056e7a3b5a50fdd2f542b0133799aabcea08aab4a8dfd0565f88de6b7f975ffd81d3cd0aeea0ab12e0117d5e517e93738762f4efaadf0f8d9b517bdaa302d74badbe0f4b4dc4b47d964efe0d047434ca5402696f674f83da717323199eacf6d5d9b7cb4648d7667b0951119182a4378e1b7bcfe7d91e58b5f476ec8e96c82e9d0f11389026683df197760baf8f3d1961cda30b3346b0ab5f8561a130a0b2247698c2e86f0bd537712cdfbc6deda4438c3ea5caca08ee15b0fa03414f8987930be0d6691360a7025aeaff8a5b993e269babc075b23744256de314e18c21140b45225ba08f77f56fe27c2042741caec38e1f5135263489b2fe8f4eb8b84f004578583bbcd1dfd49dd248d90996daf9136efc509c975acfabe251e9d659a46d1f8d2eee14a7ca6005a6dd0f9b52710e2dc55d1b8ace8a4b5c429fb77e2b0c0023858a46ae98cacd49ae9318dd81643899c440d728cb96de15033f776fce4d8d86a189f28804dfd5471359b09d2677eef1b09a2dc9375cfe227262b35f389062be94539b1f9b029ffee78dafa0462de770a11392a17838c7e1db809a93cce9140649d0549ed88605a842d87cb5296d92fa94dc25fe61b539f59e00a5f0bd2d003c49539c6d468a698142084788decef229f25705e9e8c31a81219af6713f6e675d6b2b4255ce1da37c2f5754b9f324fcff3abe5e40c178f7d660f711c9f2b8877bc727d0bbd016ad71e512170491564dff5363048a97ad8a3e4615f7935bb35b45850e64a473db71e39d4248b57e6a09a2fd3dc303e368a2e037a00eca887d2d413bac16967841b1b47eab5a980ecd7bb422148f03131d84b35fa17b44772227eeeb8f9dbd8f60279e33b7c61a8afa08598d74969bf0eec0fc680b2680c0191102c93a282f5d2014b3c426923fb0c0532a90b00cc0619e694703bf05ee4ddad0d07f038792986f21f506c193380e6eb49d6f4b74a2e3bae3d1097d0003542c9a34c97921ec2783d57a69cab936a5027594c00f32621aa5359391e32f1410f2b1640c9a29d51b5f1ede9c3baa74d2de15501403fa28d7b8607fde8634d42552dce5c97de45401ca45295243a2791140300cf0b4001789b400736e2e079307e374fd3b5d1454c1a00fe271b2a66f374bac334876426b2ae7bdb83bc209715eb2d69bb1988920d0c4e26acddf6c9a1b9f4f6557349a7369a64f4ab0f59e59e086cafc38c5e1fdad40162873e8aeea4506400c5ab440da77bc2d44f7cccec126a98a423f43169f348f5404ab5417bc907f634d4be118c664716643cfdf48596d4abb1c85946ba452c0553099319e4e44758703f2bffcfabb976b5d09ff56d3657e327160155b61a6df1bb85a7c4829698ecb7667e1bbfda7208a4668a212598b7d4033cc39ab3e928eaa3843118897d77374a5b7f0f3d8e4637d4543d2f24b3fc44e439bfa146910edebb7d828dd7d1f4ebbf8ef20cebca1ee57900ffa690428f288b323143777d37b99573d0a30936240e3223e4edcdc9b08a9d61066974786ab79e70061f01471858fedc3a49778ca8c62b6c7f09c3c23a2c5c7b88cf353029ab597987b3f72800d40b7a052964eb13f62004645e14977d9465c5a569e60f8876c4fc1c7e742ec72110a2c99ccc8485e4a8924174c87973f2eb4159414884b923030281a50891d1dc15e214c2e0ace8f17ef0222fdab02c79266bbccbdb2140a19b89bc2ca6834d41c70515d69d894eed3e5e0a8923e42d2f40995dbcf13e9b5bcf7a644c48454df8319883e2cd9a8f325981e5eaa34b3cad59b781f6004f829e8d51b0496de42332dae101b9f5ef4fba3d9dae1699eaa2944d622b5b82367921e65bf3b17e022005dfa63a73f3e0bc78dc495a72bade1cf66be5e00aebed6e08aa8e5637f1773a4a383bbadbb332a4cb07a10e268f7952e1f25aae45531fadd97361de77f06f9b2d2ecdfd19b6487b80297f74f7adcc0ae21d2e81731d452601963ad61c2f14faab22db55acf3fbee71f276db055a58f36e5c72b811162b4b298db4c9f0084ad5cfee7ce3e2f48cf3f40cdd8c89b45dd3c0f488bc134ee1973b9660c146316b4b5adb32cfa1d11375bc5b59d734a4bab3469ee3807e6c095a2b195210b01cdeace6ac769925ebe302d67a4d1c5cc9db7b229cecd9cd2eeaeb8bd30d38f248949b5de4f65becaad973fa2472530eb31656820cc6f79c51e40a78c1aea73313e34917311d5eef7659524e9b433050d3c16522e74a6079de101a5f15bef8dc87524203997c082b9988fed854221d056541735b6a1a8b6913cadbf22ffa7368b00f8f9981152886360d58655cc9dfc7734d6f4609eb960b7340ba817fe6c0dc13d3ea2e49af0ff44db1f5ca2247dfd1493349ccab8c8a557920914ce3d13333f268def88ffa89774467e6e34417793fb8fa61cacede2f1185c2bd0f115d5fcf0185e4356f099d8639ac885ac166685b53f8ba71513d0ab89ca52d8008a6375435adf82bd2755793c0fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
