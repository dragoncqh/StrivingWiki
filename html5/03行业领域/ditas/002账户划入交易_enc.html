<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5f9df447f544c7cdc15779191b68dbae7e4ba9c67910c5b95d31a5faf34f2cdd8fc904509118542d2fdde146039849ec19796a6c7ad1d37b3b368c107c7ef54dc4b5b2f71f8090169560a91a9a9a5852fd0a5aa6ee5ec242f3d61ac8d534a9acefbab060a90d07a0eb0daadcac645a84c693e14482f7e90d80aa65c06b356050218d75cd459eab4558644bd21aa47ead837e507351d6cfd2b8b53ccf2eb4c536be187031a5064f50676ae093ee3da5e20941942be05d9359296267736178fa9cf36241c2d00879d48b36c9f3c5e5f1c838fe7f767cc25375727d82f46978df025542e058d77acc0081f5e959e438a4963958982d6c4d0a1881ca440293f929325d4da0cdcfd5209b027363477884cda5807072362541f6e3b37994ebae2b4ff2fb0b02092436a31a94f1f31f258e29d82c8b9ee7ba981f1365e77d5665f0f46827a73421147bc13b1f2cf6e016f095ff8dcd7029149a809a9fb12095ce3f0454992c9acd41a8cda27abe9a46b08bba64ec6e0453df30316b285655044df036c5c066f44b6fb50525ee89bf690b6bb452be762ed7b8f5924f9045b940244adefb4b43fec21c131a1c8735bbb96dc5c47cf40374f1b3a1885fa4ec814486d417fd236de17fa9d39af12235fa7f4b9abefd3be4f8e5a1a00b7d1f1ae92e8d5379de954aa9526189e53f697e4965cfcfd8f9cfc5e3eb49af5c34c6b7b4f2a9acfa952cff2998f68084888ea231614a843ac91d2eca4a8360d46a7bf4ecd12db0e5d8595e94767dd3371fcc07134f72743be842667e58de8c7f5dd2e6802bd0470f04918caa8dab83fae9cc6b8708873a4fd74e90f7c897828c98ca7808c921b0305c3cad6bac82ebd82db45d413c78f0c671bb90539879f8deb29ff576117c22cc4f27feb8b80805fd98dea90e6d72738f5ac271d817e358bec4703cb101f7fd295d402d5d48bfe290d2dcf22a5c042dec552c912e9afd5f65fd5ec53230fb11c20ddc215623c446d8659abb63bf13de26db00377fb3a617d83e483b6ebac15214a494461dff6c0a3a7fc8b297479a1ab11dd45daf03584e28ee4d638c2dfee9597f8fec5f79c1f1fff9864eb89ee74d266db6080d4b1e3c4271c89cb3ad8f3d9e7d437a7b4a67b76a98b89be6207bf9df109baed4df750605303be789bbbfe19b21e652f9d09bd4db177a2b32823a8fc88546a7c3f1467db3c65979d82351e940b035219bfa0ede9820453b725ea96b690c5b1684b8b41ff9f960561c54aedc555aa0b6a8ed3210fcf77cae7f8d3aac2360ba9cded95633a74a0f80d0ac1361000bf78fd55d5c3d843d8d118b75ce213bcf6c7db603eb04e07706f4ae2b03ca670fa5802f7633a2406c245f0ae34a89e2a7b926b845a36bdbb4382d46c4013a6b6a31395d72044bcdff3b602aeb1ce62bcaefb3bdf928a480223168f3d125012d698ed21623ddd7a14e910d4af15f34235496b056779442778ba921483c46402a52c0f557878d4a905ae461d480f58fe340c36b01a42334c184a126d9a184592d4019c88e5e9e7e4ed3927311b1299f2554c726d880eee15ae06f44b3cae06365ba8c1580b1209864c867d0c9bab8c0d122d4653327fc7b6ada353a1b65a9a19fe6bf3bc261c6b459eb69b9ddc9f82c7bf81cf20335a653fd4dbaf3b027fe2486ec3d8054aad6d3f80ab903bfe7cd7a915fa5e170b9183f5906ddeebb81f7af6da2bdf29584daaaeb2de1ba1e0257164b3db9e54a2a0003d34dbb346db52da97662ab27601352aec4318734ba0f23176fed679d71461ada86fc7b3d5fe53de69f158a62be0d76b87651990d678cf8a7328bc1d9209c0c3fbdc256faeaab50b1e6010c3586f433d353d16d41c2df23e8cde5a6e1cb2e56fd419cdceaaf00146ca9babd96d119c8e97af0365823ec328194586d4ea8ab84f32cd5d5e757e0f5b8e47eb22c7c8a1ba77810486f080ab89c7e7cbd8245f1bf41e778a9fd859510bcb54b944e19a2aeef9ae19b8fc7e9cabdb525fbab2ed093c627cd114fb12f259cb3360fe5f6bf957a0dbf783eefd08c0e22b95f03b0dd72ac8470f1c761384b4f2f4395d14677d009a5fce196313297bbb1b81c3748d34054428eea2d6cfb6fa2741231840fb3855e3371cfbe6dd2fb550caebb7fe65d9bc30ff6f64c002ed402dc00f6fc8fb6b18a4c5da3fb10277b368baf4c5d3fa2b7a5f743a134b93127e601ef085172904b093e457d3cdc80fc7ef7c1b9145c9aee04185cef4fe9e6e79d70ef4ab6eb6ffa655d121530efd25a6da1681690523a4550457be86ef186531434648760bdb1b27a3e9aca1d32d104a9ed6c621f9ac59f3112485729de31569a015e27e8c0688fa62f462169d7fccbc5e8c043e2780e3e3bf6f190622e5943bc012201eb4f07ee21c40a45777306c8d9c4ac372691b5dc6e0005d2da73c4c846045f087e27a4c7f549978ce2709ae3ad9b77bd9eb6cd73cdf38be2048582f258854235e286b18cb74ccd57f7b5b3fe65b8f4a6f21801346f8b137580e460835a3b206c3a974ceefab41b2d1d2a2824e14806fdad8026102eba2af741074dbd3d4c7640257395f5a2a1d453bba6508bef2c57955b22e1c3e7e82dfe9fed86bd1a89f5bc7d4167384ef3f4728b92c5fdc73810a9eb3471df670576b14f940c2feb10ce08c4cc9ed081bd7125839256c74975b6e322fbfdf9c4f8af1f86abaf50e21f37dcc3254e0ce64e9cae450f205d50314dfa1620e47dd9db40fe05005434e6052cf3da9db61572b556afe7a811c5f41c972edb2ce1415e4dab91ae5417c6e9ed6804f433456b3b025bfe04543c892528704fba85d0ff77e9e6439755d79a82888bbc423fba092c0782ca16e25853f0681dc097c3914c851f9019754dc7cf911b3716b8ccb9b36bb875b486ffd3889b55ba85c96f0e8656dab671ebcae572a4411459e71af8faed9afc5d76af3787f4e6764d8a33376b6cb5c4361c15c050d7261c42adb410471db8568c2108b4b486d3888ddbf6e694d5f46805cd1b1b79ef4975ea4d8d875584adb762b94a3bcec0f5d3fb82c010873b3bfa8df0f00f9ace07ab6fb6587c82343c6fdca3c928d58e5b4320f8dd6b95b77abd604a5e1713be0820efd4d7fc4c62673c6e744667f6d8de95331cb50bef67b428fdc89087887e77f7d3c70531afb05126b32710142415673387c35928915c78c0c6df5838e9959546435e735de447ecdfad9861509e8c4303626ff17117c04233fcd4517f8475117becc4666faa0906239322e9effe178ce006a5b3ed78070750dd08d974e5bef7f077e5bdd57f7749361f6298a1a76af8a57e426e5c2899a21b2768dfdf6d40f4703e14ff50a787ea8e526add5d21dbf2467b26d576932ddd693bb77806910e30ecc136e92550293295f043f02c3f718b0d0e5396bc1694a46e61c7f396d9cd034a8ac97b7b59465574e4eb7bfb70ad083a7c18c9abd546b0705ff57281424853041347030f354c92f291a4d9a3ea095d0277e6406ea4f5540c3dba79b2660e8584d4d2616a8bff5a91ecb530b35ce844c3dbef9036d582ad73768f949f0e964771db0fdc3c8916a4f3a00266e2741144197996815526c4f2e7215af9367287f0f157e122fba703f349cdda8212a72cc1c95620ced5180958f957caf526ceb7b1e018c266cfef4867694e4b123c8e44e7bc62268f83daf849fb2da245556e3e6fd088950b5b38fa66989d959bd70651855932f41582df51bc660ead7bc5d9e04d427fd575c4520dfc1d9f3b1095b511247df4a586f3a2be92e605b4bd084269a754b946411db4f1de2ede278df4b4436479205d7e54874bd8ae1bc43bc8b6bc13410dca944a1ae438b62713c104ac0de4adb1a07a7275adcc12d8c29f54cf5e757bbfcb1a31c1a1c2396f1531ae5f233d9d318d29c28d1d9bd7d209d5d3a13f18c2938ac58a29bbf679df9be130cfa4b8d7b54275fd2a89d101eccdb5688d3c758ef6360b5370fbf0ef7e2a2bb7ad4a2f0ca0b8581afaf470a0f1fd7218a3ba9eabcf8aa81b5bab57b5b5be808138be57b33102298efbcf57180b7792378dea0319b08947e6102ea0fb84fe935791522700d69cbafafd70aa95ad3f66110e24466df4a49e0cac1d407c5dc8db525746e0b5b5c8fe0d71639b083295414b685246f6c74af1fdd0d3f3530031ab00f89d1013c657a9671e63a30adf2483cf4722c548299388c6efa2f864b2427da6eb27412bd96223ddc7ee7831181836bcfe73140f6176678cd878e1c1338f825bdab309aa1163c7d36707917381fbb6a739ecafda43909be9b0cb706c402a53d5d59bf62065947db17fc3c96a4b066f34b0bcfeee2859928f77f78431bf12d68cef657a7b610635f376036676eb596d8debb202edecaddd7ae689d75a489885af98f1e5117f83ecbe54a1262e55b691e5f9b42a48c6ec1e8c2b5898a6aa6e667d151605c713a718f155e32464d20b5efc8f27991da1141b438cd40f476429506104b6f9f8912481fe59c052082d65ad001106d192c0c346b3ed68fd8a381971f0dae335024ce9341d2566948227c364492ca89f247de10e1027b3aab8b54ebcd23300a7f6c3f5845dac65e4e73dcb9f99fc422276cd4de6c35f13f09afe9643c409b786edae0476e05020db581765b61fbff92c1c4886a50ee42de8df413fde0608fbb8497408f357aad2f5cf063d31ee5aed547304c916741ab8337f5be7e6824879ac035260c7d44c08dc4dac2d76812b203bfdc27a230b58bdb63a11b775082eb9cdbb3d9830980a013ef6bf4ae31edb25ae3a38dcc34d32d71f80784d3645a6b1809eb95c11c7ad8f98429ab04072880cb17f95feef043f04f3db57ab05a7d204a7a105fa830227e24f8b3f25176c4126dedba489245beea79e54d682876fb25d53e2c6fe6532090171d5368e3feacfc3339ecc59d30cdaf5b8a5b0723e180c55151698d80ddbe147ffce4193524ad3e44004f95cfde0b6826b008e68a3f3732d28966f3f30a0e522bdecdd8635946371efa75acf9a33ed144479cd8e5619b8fe58b530f8cdecf572de5abc68f138ef515d661beedf8aa573563495918a510392b8324efc3f6a05295da87acffee46b328de37c2a97d5ee4537d25a929da448ebad7b713c44a253498d419439f05672794a3ee0dcd92245bb7bf6a8e4da83590fb356b220524a8f9e51fa873be6632b3597e195044119753e2dbe7ac1ac1469bfb59b4e451c3eab0615481dd9b967945c0b400ce01e8a6b16b4738514839038ab91762be02a46becdaa055421522cd8fb9be85ad455cc20ef4711d38489c5e733466254ec8af06359199c6bb45e3ddebbfeca50f45d31ddba1edbd00f45a12bce1ceb837ede222435ba499b5eb3db18b855ebfb1efe17c3d921146fda014407ce27924354ff6e639392835c361d4e1f49d2ac999f42597459cc69b9a88ee2de5c60ff83865fe21f024bbe7d6b0347a518d10f88bd0616f41c8e68bca7872c2d9857687f247f72959045e779b6d6901729a1fe2bfbaf46dbbe5982aa3d1ca3dbf81fa4963e966e47786ffe0ac0c4d13774a10dbe1765b2e1be134d0487609feec98ef593b760c95501ec73dc79b29a4f4be9c9153dece5fbe2f615e321b71f95de7cf96fdc6a75379d016cf6e2e080dfd2ec4834a36c6034a6459681957d459265fe232061cf5b3127997788638ca1cdaf99e669a283a1acd946dee395a859bf1c8b691fbd5c4c973817d70c1315525ce9ea5fd70672d449ad817b346b0844b4ec7e7abd408e03567fe89b55209f537727412c5bdc46baf61eb0a6d4c8c5cbd32f75e1ff73ee34d2c0e33489e59e17beae9fe8fe0dcfff8b553b4938e4d643432566d2bfe3a93579e315929db873a909a3217bfa556617332cf37ff4162062a0567bf003a083d4bc61e837c7ef04921f1f5c3dfe97bbc650568450ebfe3981f3c96406891e6d1aff958d3b882c46369daf26c84fdf6fcda21be94f5a562fe7c0b6be08a15510c040507112db7515cb4788b71f3c888427815b4892a74b8c9fd3f85d990ef3590af361540a94e79dd0ac4148e172a01cb82bf2505582b6b7a537ea61e9b5803d7451b21eec1e78a015d8ed1fac4643c69d6ba6039267df5077fad4d9e1a6bcc9bb23bf20b1ce5696d487e31e08822094204588d36c50685b26db5bf4f784dc58216d7ede299aa99e13ad05a4fde30a657e1dc8ed258a771a971c91e6e91f1c83acd746004680aae1010b922b93c14ca95297b3374c9300f3886d3bf7d3a028256f8fb49f3a21b46f92b919aa4281523d04509a4788e48598b6913ab33e34e512f373de20ef1361ac3b3066ca5854e56b2522ff404e7023398100d08a87e4feb1498145ac93f5176e58b18454b1d4184b3d4a504203b1f8ad57218b7c99b74ff57ed4c4fea3f36767e9e22d154851993677e66bcf042bd34764a7227dfbcf58870c04c254d19d643411ed60d4d89adbcad7ee7a53d30be07f9079aa541c2dbf21a9769d8b1afd52d26b06ebf731b08f4904a518c10b13ea18507945a005ab53e1cad77c2f075128ef358a8a946ab071d2fca814db93568cbbd4383b3d323e715b9662620da9e7412189880a1d10dd1c49e3b52768c1307855d3389cc78adad04be64dfd1b13350b409c02fb0603112c3a590d44c95f2dc12068dee39e9ecb0d7273e8d57ce2c168e1b5b2f9f1e5a7575b64151c7b8c35f2cd4a4ca88c9b1a9ffd0e18cfd3b55f0e017046eb2bba08dccb2f553199734a28c23108e258ed8f087039bdfb4ba10ac1d6a180b1bebe1a205a43c193001fe19a3e2a0cfd97a06f297dedd4a603556825e776f3333e32754bc07112ae63adac5064df902d660011e9adbba3201b75cec3b59f0bfac05e6acaa04c9fc12bc3fa167e59aac15ca8af97aec5fb0eb3cbaff5c7e02bc3ddc13fece7ab6b8ffb7997ab542151a6b067849027b539e6be202d5f33d93a84f91e3fe1d4c83ca97cb39933d87a0d2ec59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
