<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87cd7772ddfd03e30421e0a2490e73dda65ed8938d17dc51ddde873c2a0d58325a4fa98e11b8744b0ab3c53fbd3b9c15d6870a0cfc668a7480670098d820b488c58326131693c933b6337dc0e092b049396094642650e37ea7668e9f8b0f80f8f407feb1e554baa5bfbdef0294bc3c1f55cdc996e1096279e7f9f6cb1e2cc1db6f1915b0aef890bbc696492db1455da3365988e156d82b40a250a273444b3cb154a5382c303e98a250fcbaf39206c1ef53b7c4b411dc0536a048fcecfced4c8a1f595cb35330197283bf9d9dfc5d562b3b65273fb59f4e01efbd23d85b29297ec582a800298c0ceb2c3575c4296e7782f3c5080f88ebe6aefebdf63f15525dd5d4fce0ec9f6cc01fb15a0010768bb0dd3ad14e96982a615e550950f450e8b8aada0ce71d262216a5c00e0e4b566009acc02a221e2759476670d99347b29510d70abe838804167ecb6891010d8a38791558e510288f52ce929da7a97de18c72a7e3233929be2225544698a0be3b2aeb51e0e653e002323521305f0f75f35195409dc0c35b0d8539b5f77ef8cd656bcca31783b24cb3c755cff53610c9953487527d76311b9d33f69a85d4931318987081cc35b2860b56fc5fe20e0a93e66fe56895ff116849b4afd0ee566f2760012b621608d146089dfe3e6ab4e315ccb9278123eb8f322ae525a10790e519c6141c111189ddcc45993f05bb6645620989f539b908aeedf223b79d523d0c7c00aece0c41c839f2612e68c94435e0b35afaaa3619042dc6f956bf8086db720572ca81fdf82a81c519157963d17d2c09d476de01b72dcd60d4bd464a3a30ae1e9eba8d1bfc3f7c03596cd6a8b460cb539f5d81df92cf4f14ff64eb5016046cb2cebacdd06d33514326659d6eabd4f30d83bd03c4db343ebbebbea106715600148ff580437b7025d895d8edcc8ae51d4a61a40d2dcd876ca8d92f458528fd76d1da60a3f0354d0cfde65c46c183196c7d4b411edd93ba8d617a1d603f2a1be5bb518ae7ea1fd170e8984ebd281027254cecaed835a3bcb7b9f66be79fb8f2f0d71aaed3ddebc4ecb4a21014459c82a20ddd7e94ab7365aa3192307ab97b00d1c3f0fc51351161d690250ef0cd9d811849ba8cf3053b681722a8879b0b37ad73f852518e69e64819d529c6ebfb035566b110ae4937c15bb0c3d5042da1c9c1c5a6c597a54177d06841e3a14b4d30ffcdb20263242c27150733e522949b40755cc6a448fc2a7d81adea5501ff1e79a2565598575ab08240dae8c933fc9df18481803909feedd342bec4ecba465984d02c359e36a270a50b712c37ea049747f4593f26588a4d56387250226b8640b1534fbc990cdda93008468e464a969b0870a264763615d6d5a7afe5b772c09e1cc838bb4508de531901d9d3d240831908a919e48102a9ecd8f5f9835ade473024f3d4d4b162994fb0786fe53e408b32e60495072b31d6f8256fee815e70e9f4ac1cf6ccd51ab5285ab966bcaf8b4342b49829b1fe75e405d49e470e70e34b07adb819de74e1293d3e5ca04dbb761ae62fdf2aceb1ad491a1c8fc5ede50a38d4f746fcec53a6cbfe040fbbf0ba9554ecbafc4e639d94ebb8c86b3caaeb40d0a01271d2d22c517fa2a791ceec102945a07c5981611a7371dbdc6076e9cf114cbd4596fbbc097b254c257a2013b0b56859ec85cb84ddfc302ba52d7682339b78b1394a907efcf47b0fffd8e45f9795d60d6a7e4f3e22fed44e5a471b5bdec90786523529c91c1aefcb4234e94982c70fe94ef0790376a441d4fcfd7ec47e21f43189763115d22df3525ae81ab55ff86f4beee7622849934dcc3496acc7c70f310af2cba326c7cd0d18b9ec212388941384bb5f349dad51908ab265c0907ad063292f50271a3cf4544bd2945debde4d1801f01dc7951a23b646a44cfb02cacfe27f3da745318e7ab186c8d8f6c9663752cbaa9a560c63b363f7f187646b4f5ab2f84c17c5a3016cd3a5a8e3326da710d33efa4b8a0ec7f5209378f038939006ae53bc54bbb1de2dc782fdf2e68e8f3ff300e19689a5bca065deeda20f54c6fc06f806dc855710eaaf9fef62cfc4662d739b40365eb91d9a280462fadba72d5c2225adcdac076375dfbe3418f83c7d8d3bc97fb454cc0bd48770d9c0270cc5d13a510fa123e6c6adc89e3e74f179656f5df257a4664c6d5f492dcfe082ecedd7597159be3c10729c200c4080163df818d1ff8a24934f913f662dce0ed660645c9988dd26c858d7ad281e4b115688a6e36619a218f6f38b8856b7a502ee5f142bb68735c55afb7bb6f0ddee13887423e438baca474d154d261fd78ee7dc69e538b31097bb529af8d729de5cd3eee82615a6fea6533ebe064acef9ab12439acba033d31fbfd9813d3388f0270545199f789bab39679277009b3b3af7f632ac6445252f65e5101c78314ae52b535cadedefe9eb1c783fea14a008024637fc7c8fb255fb4882c8fd8972c45ae9a75c5010474ec6cfb5568fe5d8b79c695865bbe06d6003af589628a12eb05bf9ca162f1d0dde7ed1072e1aa030bb1e5596fcbc36a8c0c1cdf5fd2a7fe064c0b37eb87f74a017707b56fe8ad53bb779faacf0825b73651496f5ae9563cdc918fd09474b2be8e82881f820e664f3000e49cc098e26a2fe0d9f9ccebceded4fb64d7de1e757fb158950503d1b80328e5ee1d372583efec0907efbfbf708c749cec4e4a076eee5f79ff405ace6b2b9326d18b2ce647c1c5dd3bfa105728dccd29ed39f75ee98043474ae1b8d68fbcf20af64242f040f9a8acb5e6ef77f13bf18d4caa51dca8738165ad62102c40633053ba845b36ed59be892f2c0fce07b670a06dd77b5b09603eb11259bdb60bfdf106a561bd2703e7f356e6c21bbe8ee588a6461e349bfdab357069f78e20839e392561e6a98a01ac7bf813a7fc65148601a703405b548b2226521f6b6cd28774c13b7addee9e6d39be8b0ffb8bab16189221aae00f4c0f4514b638a6dd90d99f7ab1e6d0656041efcaf244d81a2f7d23cc0b88f18cdc283d23fc16bfe68dca1a7b65ca0decb4f2dbaba0a08a5f06b551adaa9e846c5efdbf112622a2949d3eb16c809996698efd0e365fc76253b826aff4541ac02e0ce9851239e5434b7a29dc22fe6f0c59c998103eac6b70b72a98b871412a75c1ab0d30d1e047ad0c6bf62e9b03ff3a77634c6cad033fef328e52efdcd8bd7ef1f2513b58a50ea220fc2a1b85fe5ccd6533f145be2c1b10f3bf9dbd538c63b1fc74adbcf5e777976167136ba43e34e03e4bf1e903207b550710b74ab021ed9156d6850b31f4bb2a38772274d4753e045eaec3e3dc10e9969dfd95e679dfe440b91d9fbd7851fb1a3068ab58767c9642b9657c64d204f20ec4e5dd858f4ca13f8fa6b6b419ab9dbe382c674a78489a2a29481eeaf72575d76f4ac200c0080cb8368764e96cc688f0f01013a4274fbdf2c3a651424f6abcb053afbac23b1e7effefa2eec03113e4e2a8c81c56aaca682bf15399de2ffafcd66ac8b7979e05cba37d41d8104db2f734a84029de1ca9b6b89438a5d699d4027c2aed122c1b7ef646d915af22665fec25a9e3be4d7c869d2006bd1049ba73c5354c5053ccf165c3e7d14bd8c947e9934e97eb26104df0bfc3a22d475cc2d205530568933fc5f9d3606ca66e020ae38f82bd7f6c2facef0c4825683ce3de65d4d7c4fd68c9c793b3590d631647f3197cddb9f4cb1450fad911e42724ad49f284f06044e8650749c4a94f43bdbd7205d18b6379ed91ac686bc6a20eb45f8a2353dd1ed5fe6d101769f46f1973e43d77b8dd660e777683b53919c6d503c776c691c8bf23f933fb11612a80a28d07cd67d95e1058eb1872ca6ea5e382300246aec53f82e7083a4a6071b6e6f0babeb7361ac942f614cb2ea6fafbb31f0ab51fc06b68f990baa29e1d5e3b7a1e9da45aee5156a38edc0547c0381c654a0b1f92d2af4b3465aedeed9fb2aecfe2b0bace495e3f18b149c7cafd104485a0479df4538579684a073680dda342bbf2fd3ed67995f39ff86d5653b7fb2d489f47bf6c9a5f1a12a377abbb7e66b97bba9130844eb07c71a65f5866747d767195baaf802c6ce3722a6e1e8c8f1a6f23f2e0e16cf520bece50c4f4ef914b57fc4376d6316687dfb8eff75b2b89c9e3d57125df917b05a3c6986740a7a7e88bc0dd2efce69d7c7382b8631ace8e039abfa80d97aa9de779d9f9d7ea8a23d4f6f6e2617a96a33a27eba37bdf13e3cb67d6206e18eb14ea882b2c897ee9aeb244dbf05cb041f60c3270cfbb7e1c9f6c3b5b8628bd2b1646b8815b5753e1a6f21fef2c3f92278edb7570660cf0c754f27588f14a3a0d5a8b37bdde724aa9b1105971f1a5165cef7565a41656085b5f6a0b4872ca8faec9b1bda3ade3efeeccb50f775a910aafdd529f186abdd73f2b8f26784fe4b4bee73cb13c39c84c514ecf08748db2b713a9b034115b992133cfd43bfef3df8b7faa55de2fc60d967ad77c63d262584b50eb4ad696206b59b8fd158372cb1936439eb9878b8c9c5ac624d809e8c0949c90f5de822330c2ef5edef8cf842fd7d022ff32480c4de541eb21c9557f7ddfbc581852f5e3c7847bafc864e3a5913db064349c0ba389ed30d5db22e58a348ec281ee2bb082316c7f7ed638539343989faf2ad766d3a2a91a79aeeb2d73e5c10dec22c57cd3d5758859b7e62bf8f3e6586adbe24a8eceaea8d63080a44371c95a9253c83504ad9e870a2127081cda1e061001d4d2ebe82dad89c80523667f8505d49cb463dcdc842f5c6ac1e2ec8d85ef21a77f3cf152b080b6e6dbaeddd5f9a3655708562914715d77894a666e533301edf774633c2f4df3d2a2da510cb578f6c590ab3e9e76162e8e6c94e6b439c624830f14a7fc6401789e58b0e93eaf6c2de57781a169da6ae39f70bd8805f486e2e265a60c25990bcb5913d60ec2ff10f087c027fe5a96667006bb70cfba67fe12ae039427db100a45c1b34491a66159fcd591957a9c131b992c62f4a38c20ea5f04258c43c3df8488c30efc8bdf6a028367759b7d1be934e2bf082938b92638fa46157dbb86dfcb9655871907b9477a3c88ec280393c8e44e9acfe3ff6eff66ce2a07c3ff0339eb891cc15bd99cd4478b4aabb319c81ed71efba227bae07cd11b8329c502be0d862cc7f313b0a125b68d2eff92353f1f0b8c7d967ae4784d885908ca213463821ee64553590b5144e435d350adbd85e144420d3eb399dafa208aad544a0b97dac888d7aa992eb61fdee6f520b415abd65471dc3684ea6429f473e6e2f8147b05194b9abe3b17743f7fa53b8d33f44d0359d3566c5cb6dc3216ed0dfdad9f12cb84f123b4a76ccf209e1432e959fc00131dc40b845d71baef2af8d64154841a650185612f53ace9b9dc11bf045ab555004229564fd1b7846190eb5e3b5e579f9d9ef9ca0d905cfe8d4aaa278210a40acd504ef4b022b2a23d8bce9adb56fbfc26eb86bbd7161b61c484e4dce4d3d501c39faa593758dd14b758c25bf3ed1f320ad89c3530eb684fcdbb6245ff77ee2914f1ad01ac4d441684b2538c39f8269a15b431268c863157ac082be117602158640b2f467301c09a3eb631727e36ac050e98852e232fd065cce974f2c20f40105a957044e4e2c67335041c365a1cd3afc6ee574c1bfac05d8a3e023fe12fcdb43c63cddac4a2d01344c69483f66524b6bd3ed23609e907127b5f4f526c9874dcc442f13c5a2c86e9b3f9cea61edf6429a703807abb5bc6b30960c269e55a26aaff9283de274ca297c6933d82014161461204d0b89326352c5e811503fab8a1bd6b872a4b9d30fb9dd54154a5bf1fda1ed3c54c065bea7cb0f42721256357fd9f2ce925bbac712bea3dc2bcdf59e15ef20eb11f793c452cb00c04586c24882b2c65136279e71a97923f08a48a7b6426bca49e000baf567489dab976754f7aa375e7c53fcddc0df81eed2eb1a6c014cbab52f0deb1cf8cc7138cac7a51d4f8317caa0d3bf91a742ea7fbdcadf22ab0457cb6122043a91bf2dd53ec72c832c036c3df8991aea3d755302d6b0ea7ac2cffecff4284ca15a1dfc8e1498ced08a2112bb40b982853ddf235ed173ce28a5f6529b50647a2d2e69c5da305b100fe932d3d958088ef705b218d15dc2cde6c12d8723f609b6b248cbb239ce181a9ee31119a02ef5fc2b7e50876bc0eeebfd14f5e410cb587c5a6624fdc3c4ac332e492c6881241e1e0a2bcf6ca3f0f7860b45ba974b8e288f89df844e01343654dc70bdef165530f76b7b54c7ed209c73afd02c40cc07a4e0e4149d74935b9df64e73398bc591bdac3d75938dc343493a482f259441bfe32f09cef7ffb4660e3eef486fadf2e9d399fbd625c164c50e166bc36a5254c5cad580932f5f61a1115e1a4ba7a2fc1a1324ecd2886036a6294a95409d0565e81a758b2d28a23734ea5c1e07345486bda72ae14811fbae669cbf049a0549f8d980f7ca95e2a7f96147df06d4ad0824bbed17cf7a2d204a04e8164b1c94c61d65d65212d80d16e1b6ab4e721ffcee3566dbeec7061adc54356898eaad180e67f1d388781e773b9732db2c93a4a19a44b7a7b1ea233f233ffcf7a05e35fa6c93e57243d5783909c580697c37cff031eb211f8611e468e348135db58fcf8c7d66ca10be53aa988ab27ca088a4659226d8e4dd111a805e9a04856e1659f97ceccfd4893d3894369cacacf2439c49b274d733d655f9706936d0c603dba8ffb5765776780f42682be9b9dc66d78da7e26dfe4fb8faeb4d6849988a9ad3e85459d596c132fd777e7537db7063ddeeeba6e5388b84fa4bd4f576f041d8d2bdc78e18e90e7b08fd41c3f7ecb19087e9d4e60f9472aa55da4bf2474d248f04134dfe1f3100e523ee5fa13ebc8ff7721adc6fa029eccc6a85e50b8d4ea4ad33a6f19316d1e57a3f4ad0c83822aa357e48740058eb2343f24317bbff2bce2c49e9de2a2f7c5632e53c05c308685e7b80bdceeb8e85c0241788f71cabbd8e09551b9efff74b18e36b41d67d7213bc669b5325096fd8624b656df0c6363334619f190632eadfecac8b19ec3a84dbcc3398619582f7e72c4f81556e6fe59bf50792dfa63e116078c58158110ccb2b10ad763a0310a666f47958211a690a67a0b769ffece09f4cc78de189c0d8d6f499ac08989a5e40667efcd4830be6fc96bb020e620f5eba9cfe9ecf9239848c5ef94f28b531abed73f3d62a086f83887e017a3a952b836ad63c55b89da90bddf8f4ccbe4d88f8698ab9c5cf9259f50886e842220b41db1a197cf16568f345a329254a124c8df3f92d5d6826b9edf23230741205af9e4325e7ca50ecfd805a6472b8575a3a6a2fe462257a69244483d8f3d541548e38fc7a2e07b4faa076537ab37affb0716db630e7501dc1dcea8e89967432051dd730465efe170940e2cd844738329a08f980eed36699079652a42823dd0d80f97d7ccc6c2b3612c33b4864d1a8afb8a806d92badfc5296e0348a5f5f2a32550b56a864e8698aa34d3e32bd14bac5b026df8cb2026fe7f9689f2f8ee59bab519ac66e4e1eba01732be20386bbbe40e3f9ba9ad1e07f17e0234f7377c9403f4886fda5a8b9bad6113f00c587ed6e034d9d915dbf72c487d0d26ddc83c94af21a615a248e450009c747eddc21bec82f8434761bac7f2d9e36aae293308831e4c965794ac52cb15cdd7c59c4ebc96ec8bfcac9d7450ebed46d9cf35ff95beed663f2fa1d905b657dfdd8ce24ed894fc18862c90d2410ba31fab58e3517a2b68b845167d021dd087b7af5f912ed5622c833447a62ebf79f9c981adbae90054936d98f251d46ae6e25e0978c05a4bfb7ee11798b41526878f7f47adf4f00301f4360984c5e882a9858d91583175023154a8826873617de4a1cf18e1baefb3a182bdea57661cfdbe18bc8c5dc9dd38e7ad3d6d5cfa4bad372cd5a37d4a5bd8006baaa83bc795d9846a3abfeb629e51f2cad1f6738ad5bdb1c8266154ae0a309689385c248545d5d1cef55d2b13e0dd64d46410fe7c3480f3779898987a1c1c43700e7f79f920a284270375dbec96954ca8aa02b89aea74804e2b91d159df85c0eda098c3f42609f16ed1e9ce7f663ef45e8e35298d417b7b95897eee014ae911d66fced04ab54325e2ea644c203dafda330510ee9153cbaf618c68259f5469435cce49e66b855e303e937545e81cac5c9d836c561c4886846061256523903cedb642d36fadcb3ea76e8c2b8e49ee5a0143f886b14ac2fb604ef3758dc8acb7373c9b3dd64599fcd4f656f1f8f9d73be6a742f2074f14635014ea9a660a14ea5816e664d380f56da6de5c4bbf9b392afa96c02d157728dc5c5da9694855a2aae1f007d8ffdec8f486082706a10b2af9f1bc23992b2f87806884e1b3810fd65cc5e539504cbaa19a9b18748b94d0b05794c9b68b9b9717c1014f84c5c26406f5cc882a199451389cf0e25f2f483d52f6418c30250bd250e004ab0953f74be87ed6f2799d3cf016336c2ca9d0635ab1664da1fcfde8a0921b47d208120ca501df4c25fd5ec68c7d7b8b6e7d1d696fe218029358348c2b5676ae1039d5efbfce5b3bc09ef9999bb6cf8283b01d83a469b180886bc3d9a2e3d5a8b5f03d5d5f2df569387a3011860c5dc6a5e6f214a74aacbc23e181c1e7d4607f1e3d164943444029ce58feac8e1b73f1d0e8d4442aa6fa8cad9d365fd4baaf3ed1430518bc5a6ad3c92c22d695779d5ede537fe44b72202956ddc55f9e4e98e800839b7af6e3807707470f5d30456ea2650291a1f371be369ba65f6e888796bbfb3e3a1b18eae6a2e06f8d957cf9c55db9de2bb80cb23585c8c284d8083e279604ea00edac523a56df4b61636250435c7f78450f35d45dbc30980b412042316a16c58ac6f602519574b142cece0bbc07cad88f4ea45719608a6c001f826eba9347f46c8a00012e1e66b669a223d986b02a128e986aee80761f282429ffd4b4070470f141dfb5676967591f13918ba6bcdaf1e099f4cbed1a783047a1d358d1887d9271ac6796f0e087aad48f2b0ea83caca134072886b71db132cb7518e31254cb566ccf0b27660f102854fd950a2b28d0d20bfd1fd3a753c5509a5e6d14a3f12ec3fa48ba0011580fcae0a28c7d36f122106e37f1c2080cdcfa120e5c73611cbcf88881681ca76202ef95716129e82952e5def43adc6dd312109b0e8e7af733d7bfa77457e2792337f42cc9ec1a05a00c630980a7c4da18dbb31ff5c88b8ca7b12d2e4fe692ad49114d7b6eac80af038058ea16c06c89d99ce1405b545c196820323a8183562919347cc3daea21d429cb841134825bb3f96fbac43fee4bea697584653a2050e109265cad75151fe596aa1fc9f50fbad3bb98e4a46d01006a5733d6ce8002c914972ba231950ce6e681f13c1e4d9d3a2dee8595240b9243440842f3a92ea346630d9fb11386b740317a6f227e89244fe25cdc9563f8d1fc309e72af01ddc0850c6a51fb5ba5f7dc798ca4054e8ed252e7219710978cf866775fbb331368a7b397ee34637ccf7458d1b0b8baa4fee5b3a8b2cd6d363773459ef2a79773726c9dbc8aec74dbc9a0885307604d3d9a9026a1646b956faf2a6acc165b4a5659ec4d66f7d9416ef86adf69b4f1e5b1a581f02cbc18abc6edde4d818a5189c87b0c9ab4b388a13ba18fd7ddff9ac7aaa8181d9674d8324b978916dda92d1453a2f715cdd8e795719a457d98bca8b273f4d027a550efef8dcc333fd05f407aa710c66cd2cfa35d9a11a3444c0e5860975612668a613f7bd6b903e9ad0cf3cd3693b855091a84b6c42fc1d205f34ba026e204f0b8d3bfe25e8393dc87a0beaad72a2ac1c34b2ae350c27efd49f63361f8c9154032caf1409ae13b7af1c8ddb925f35c6c421ace6360748772b8a9d5c1b52b342e381a6315c803fa974df8c00ee84a3bd7e4b5e7c316d58a078a3e14c445320f0c1e3536e63f93f3979d7b2eb8def7a9b5cd897117d885ded8d716fac98663e599889830170d7a8223cbdb3caa764eae46d137f20bfbfb128ad0f710c45ca4689ab991fa0432ff74434499c29f66f6558365b174400064cb723f7e31f6a53f7a7e5be05389064319098fcb6d29323f55ecc42ce5721c3facba18a8c21a732573b61adf7b559c92af896599065bcd14be26bbbb298c3c14057432b46bfa0fecc4a404623bb7780ea729776a1198511bbb20a5d2015450bed870fa0ba7dbe9779e6cb72f6efb20eeaf8478c18a26abfdd678f60e5a1d4ae4052450d7d3f7edf70a0d21a4806545d3fbe7dfee2b577b09a340f9393374f273711fcb2c374ea29811f34615b9adbf0e2b7db9db4dfbfd5013efb15a8b5c236c906071f8d26a12e21117727be0fdfcf82454fb69a4c4954965d42341faff4f05f3a3477be1a933a31a75f76a212e181783a203570ccb6e1b66ea4d9004a23c90376d389fc45c8c8a3342f873a2ea7523f982349db110405b3731c788f993e094f6435931be848f535da2984040045e793d3ff0fe091ba676f6dfefa8478ba5540946bf6cc6544e90f0a31fbab43164ffc3f644f98b28cdf371f057475251131cc6bd5810b0247f383ab11f4545dfdc6a64d3458ed4d774afa2e7fd6f055c8c951b0c42e2ab9ca98ae8c750ce36cb836e003afc2c5c5afaceb7deb9dca36e50073413c428dfd6042dd3b76c5312f95ea62e3cc84619bf45db4b8a2b485406f82b16a85fa7994662da86d6a1e51c5e946833761088773d94f1ca9696f75a109dfc0457e524d3cc0e858cc663c3b0ea0c3884b6d1a7e651ebd867077956bf6adfcba878c08e06122d01e1d397f480b0917d9744a9994affc57dd59b7467b28368e89c41f8fcc478e3df16cd43685b326b59a09c609014ae7d49cc1eeee688cbb6a75a7ae8bc2f9cd7d1555b3d31442c2ed54dc4c83f1fdb734f903879c48ec494fdfd9301d6f090d1f399d2c174d1eb36183552e6ff5bdd1b1913cf9a0a5a03cd0c95f3bdc228a1dff3fbf213281088b1a440aa5b3ac2ff64d700027152ad2c03d06e2e5158cac786758cc98b04cf581e2d5d3bcb5a0e53f3a2af280db24fd9e3cf92e9fdf9c9ec1fb5317c7092d00569182b7eee6a3df4f419d44721cd34e63333b1a22f462653751fe7e1cd027df41a10d5478cc323fe8b1177d48533a9f523c3463224a30276eece78c6279e621e6337c3a172d0bd53f0618ef35beabc99b3e6950d23cb3c4d7b3d0147db8f5101f46c395dd18fa34691b200f47a59d66cec49bc4853268982e4530a7643247c3ee190f1e9e4a38726b79f644802ac1f91633dc901a1237f790d17061a32417d0c6d9095090936ffe89ec7a46d31bdaced2fbddfe2101b3ac3d76e22fbb68a43002372f96a282f379f091b177f6f7963f83da521bef7119cb437e8367fb527208f7ebf96dd2fd55df0ca25bc99993467b1ebc0f4001560a9b36eeeda959f0e4af8c621fd7149de0b74f5c9b2dda28686cb1820d987401913ac9d9cccf55a7906441a59bdae379044450e543e5d7be04e3b8a4624babd7283f3d89c099b19964ef8b1257c249a22b6a6c1ac59dcbd855e2fe39b1415cc64cbfbcecc440da976d16d7c8fedec3ffdcc0cf7cde3080e9daf8ea6805f912f54c5fb515d1fcf5372fc69f2b6667c0fd823a263e7e9a6e1ecdb61771d20d42960358b4425f2e786b1b2cc6de631e8d270e2c4ab9f943d6198f5fbb261b1d60bb9281adeaeb15d5f6f542a228bf770611e1bf33db6e27626f455852f431363103448fe76056852c76c8862853c1ab9fc8be7d24a9e77312a13a013b3aa327e5afba06356c433b8316661e7effe0b3de7908ea25ea98677696a682014219adca18495a281d6a4ea61a9b372337f302c7c4a4e17b64c61fd4e06d2311c8faf0eef4b747b050bbe84b4ab1eeb74f33739cd356d2e1a01e078f1f12002d7c7267cf884b3342a1927b998f4665dc08695a3fedc54cc705e5647b971c39f37b08dbb82baf08b9b49a01f36326d55854ba55da9d3489afdd3bdecac8d0049e6d0d4ae333d58d2c65c7ec9a149620a41034641c969d8e5a5a0e74424383295c321bfe57005ebc42396e89d32fda42280bb70cc85018497bba7e280e945f8f030948d7b4ddb31da8f0ad14a75ef00e532414fc68e68a103126b88765ac87667ee002ef673a947f8d176e2c6216e2b3fe132bbcc42df0936a7bc7d048e301ecd6a2ad82ecca3901c1eab9b4dfef3a3addd0a6b2b203f0a75dc263e4981a56799084d384ebdf6e80bc4eadbba6b8795584006f8249852efef4c4e1be7cf0f1bfd6c5f647027c8375f853947f3b3775e35d0e4246cb75b3e34a378dc9e907cc8ec6e5cd2970caf22550fecde4e1bef9db5a24029e45f17471a121430fb5c56d652d2d8486c4901e6348d7a2bb13f8ed7855c5a2327279ec72d0527e2f640f0b4a8b52ad792116e54398c075d9eaa3fb7562821d3c384dedbb48e151bb9030af492f1c6a00f534a5aa31a54383ccee9e7aa1324e2e4847649f9bf823508aa734cbbb0945b1a8605958ebc3f9f7e887fc634fad161d37219dbcb32b90d2b5a04da5832656c1a8973666a31de82c3c4c18bfec654de978223fd1f9b7e42d13fead8525437a9e9957de97e6083253e92c67b04ea8ea6406ec44301a00576e94a3bb2eb5f2c2173655fd494e1093f025f7e29cef37eb68ad36eb29663afa6ade3f7f89b0e90e7cf0a16420407aeedf314ae65413535452b21f45f2909bec10ba090d8b3a9ca63361378c9a7532e835cdad55e5267fa1e2c62bbca7e54bd6e2d6c4c0a49d6817e6b53131b25d227a0bd55e60f24264ca01b666fcf9ad61469346068e80259e447a07cb7bf37836664b083c1fbd2a1457ac37c8cc122ab7ab338a5b65a787a93fa4fcd48b188194aedb3fb1a7a22fe04287ddf296c04f85221a38dd95de9a5310eab70f4521395dec09eb4d24c0e88722633dfad9f9a21ab6ebea242d00eb0e42e6ca9466acccf06087fbbce29877fb780ec592b2e0e9115f5b3751c191eaabf80e610d75bace1e60a31e721e6d52276c78db2b197aab852f3a92deeda0bb03146ce0f8bf02da8e9a6833af9f03cc126feb0778e06ac50bbbe68d28ff4bd1b3702ac84a238a38359a8f026a3a4a1654624b5ebc8fefd4b43d5c53cf90c8b08aedd4a1addb65b169cf31fad482fd7b6e2141b6f75f5fa2b8b98ec6134acdcef3f5634d039743360503ef70dd9b5cac3f62dd341babab5ab4820dc44294bbc594df17aa26a0ed4bfa245b81e8709bb9081bd87223006a946193ac168647321c730b16f3eca3ef580f96e925f4d2126177b6136da1dc6ad959bdd5c95547f8f65689345c43aa519b4011c311d423018cf984a754e78f11a5752fcac78b7a4f3af88e25210ca20e350c9a25ac608ad78913e7f0310bab681c883b5b7691bf6bf3cfbbf17880f294d065a53cf5a0e461330db208dcbc798f4a6a33bcc4b96bc7681470b38c752eec9e2a5d1c13e4940d0acb39838d2166a954644a107f6585e8f0eb959a9a6484fbc9ca96de330db0356b2599309777d7fccb21205810a7cc63f5e0219b020690ba35aa1297eef25b1cb7f791c4e539d3449714cc39f78f094d23db8c5ae2bd9134b8e84a157a3825476fb151874f00faffeda3d9b5d142cd6e85e1143b7711b17cecd96c65fbc44293a9703df0f875af1d38687ac059a88795561ee56ede0be5c3ed0d4612d6a41bfbe468a06ceaab070e1c3e237c956351df75640236e20f880447afeec51aacc4d9ec01ad829d6f66f1cbaf48f738f70e895bbec37140fa06e67fa304105682b1576c3e22d94ec9f98ee788c9872bbabf2908322e2e5be98ab349471c1778f0d3f8987021eaddd9ee4834aa6861b223375ac54018a93fb336fa702fae6adcc74026b0980e5a54287f2a8dd1f347082d1e4026394783636de0ec3b1ced9e15b9b164f295d91a1c73cf85922af0fc15432d0f2202f5d0468f4526bae7dba5859885980b37d6a6e1a73252526aef6d1e9a307532180543382f050136f4f05be5f7748a543ca6273f84e994f05aeb00afbfb01997d198595f86da2c37761d09c7f7f3de0e87e0858e9d3d75565dbf8931899d82d28f3de7e336b65caa6accb2aa4db4ea9a58a9b8485e991d138dfe0d1ff4c1b8c849ef6f3c3c5c5e828d49db3f6740718426d2e0dbe564e6660e51fda1c05c21e70affbe9c4e339bbb74dd825c9f18451f17453431e7ff78aa071053e399b01d7ce6f180f53dbbcc69886c2da6c5a4662958bb668bc061e233c8dabe73feb69979fd4ac78366de52b0e2b243d54991ae74cb86d161803449aafda06b62bfe762cf4974b582b14907ba5f3e6656161e1aaf95ef7410d179732bff3330423c0ccbe7aa94c0fc576a65bf68d5e4dfd1671759bb12692500c557f4c0456fc9fc497ef235e918330455c2855210853fd72666441ca21af91287a44e5d112406372b7a77cb8f99663be7fc698d8c97e1d3719200a9dca1ff8c7d9f0d46f442654221c7d0b6d8d85549c06e494ff00bc40557f805695f21da23b0454c1d11f367e5a2123aec2045a887ebaa1bfe4b3ce68c1e20d605a2ac717373939decdc0f94df7f55f8bcac12fba9a9316e96c6e602efd84b1108ee6e640a443974f537df560c5bba691909ded2a508326d5de24f3d07a0300cb23a1e0fa010e9555dbf64c5590266c4948b31549c46cebf0916367869d4563e3243cef420110d82971e76b303ef1bcac50036a68c6def1a5365212d7442750be41a877492fc4acaf58523dcaea8b46d8cf7c8943b087bfdd7a844b4fdabe14b91857eb32cef2f9c8af6fec882291bb1665ef346e68dc21c2d4196e9de991fb2d4c3ce28f9e123f8118d24f33ee2119e3f5301ca2daa6483140808fe400b46b2033f05a6a77f984fa21f1a797ac3d196eb9fd410af8c763e2d4d1ff42f62ee468d89c6f4c6f72f7c06b17e04d3e064ad006f8b5769a40d4522c358d5a4808f38a59547ba029e3abfe5ea4e7d8d7b77702537e3ef50b0c8a10f514de0ac4fa1a9ff51098c32001b48d9ea9512d8180a9249323d1ce30067bb2faacb34ddd245bd86e41d8a817e1575bbdb57e9ec506932a4f78f3ea0d159bc0aa88730853cf3b165d7c692e035240a7bf175be0679a8c626a85ebab79be46a95d6cb28909f82eb701367063e169441e52bc4a3cbf33dc699fc6f6a8c054ba6abb347d29807f763f78c7c303296d5669ba045aa92f3d1099ce5955992e97a3c6520ae750fb47047f7dc8527126ea22c11fa1c59771c30d1291681ca6841d827ecfd55789ad64b1c30c34453aba840b7d8fb2babd910b97e9f60e3ddfce02572b37f14e774b327fe7dbfe386033a5c7ea16cd8229f7aff941ba20375a8a307a5f4f3202816b663c9f733c9112ac67cfce6fb17ec267c0146e72692afbc2db5e560a0410aea41a76609985fac286616b26a8246f9df2633becf885b47e35e3839214224be149f5f057b7e7d7f2a2fe7f1cab2f51585e75022821a483da0786a21f89bfdaf997e90616284ae3933c4d496ecd55310cc104d0b3cf845b2e1ee7ca2b049afb5129dc9dd84c2e93452a20971484e455652ba20f396824fa1ae3b52a0bff5d9db4379e66b2a917c844cdec10696e1ae75e0cde6ecae7fd9b00ce4441e21c77ded8ec6916a81a6a4e947eae145f5e49e1868254ef0bc8c4bc3879dcad30426dbfe0256f9baaf0f1706f132611bee1a9232f016407110cabeff8636e3dbab8e049889dc250a14979b670b3b4a68b76c48cd3371772fa65d5d3b171d23c02a0eda9b57fb2b81b1cffd62e0b284d88cc6e7010fed5288e6a2ed23f5d0879f2d9c7eaf410bd5874a749ba2daaaa84654cdaa50dabdd3c0d6ce1d44817c4f64e4e59bc984536c5a5c5aab6ad02ae305d0abf7f77d7320b47943d253ac768c3f9f6bd5e0520c623f0669b4dba03b3ccd01d29c0eab171579c7231d4a6f7a702187e0b94cc2469812d8ece49e296f7c446258b3da4dde013e3a51bf48b6c4bcdd56c5e9ef06f79a73a8ae9c98bf7ddd5930a66f90e762c9147a4e2769e0797d02f0dfd073a4c81b728a72c924b4e245006a5ce3cb69df8670998d18ba8526b49dd602bf4cac6c424a23863048178796c438a79bb887655459791874af40b119090ae76b6df729a66e055df711ee9edc57d5bd6779815a4ba89683e9d9daf07e3cd3278231e1e89f7fe25179efd1734d1a2f240c5f96eeace18522846fdc96669f68d52b92099d2969abb10422fa72462b7a5baa4fcd825711717557ebf9e837426f97e07fb9eed866c18e1ea66d20343595da29a7a876b6dd0995234890791f62fb1146801f4d4b2e7c1412316f64670a59ec56bb362ae5a3385997eff77df123f616127bf5146610d7d07e671ec1f0aec96a352f25db383f0a76415f97f70ca0e9fcbfe90a365d73c58f12a8db2a755ea21c683e759f5e5715f82fec8e987ca3ed3a695261cbfcc4644f9c06079a8a21109e839f872940e29a34d77098908990382e06f40230b1d108d1ed49c27585ec48a894f407eee747169bf95254de9f4572c07c382eb11d1841283c30d9d81ce72710673d9c42b5ef58805f06284ed859a353d43386d91ea373096baeb6334ca5c688","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
