<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2c530b267711184da0a98b1b43fa0f5668b5c06911f2005c7908c60d9896c0e1384455926f5eaacd4c42c4806b6f3ae9770306375ea8fafe8d5c48bae032bcd5c98493ba5e7bd2d7908e459884c17800c33a7f841a36105f8cfb07a53b598bc38bc5c2597f99def8303a339977e8c8c375f987baf50adb429c0a4ad1c2d3f1abef319f7d6b576d48059ffd24fb6084aa3519c42784335c25bb58279ba1f9839426d0fb52a44b8822d05492c4516ee8d95127d463db73bfb6ebf3635d7a663002b15d50be817db60a44c8f01c615dee7a6879313408a0b3791b3d6281d5c2d65a25aace1449074a928f3cfb1936fc4d77b877a0152bdd3a3836b827db3100547af67a853d132194786d6848febf08616aaf88188d095961748d4b3f3da3f3455ca5cb62f75cb85a5716f99d2cfe2b24168cf87c86436668b80fe9b319504352c98f81bc2628e408bc3a28a3acad771129adb253d522c147e10e99384fe4ec661dce4a0305eeee4fd05b81327436c4d99d0651eebc731f09c36a989a79a0180901af9331c9ada2b7c0edc777d8e0c43363efb4e70d7a8beff5e5454abd8f45865257b4bfab3cc69bfb2fdee878c71f62bb741aca5ee9f25f933efd5deb7831bcc2953ffde60a205414d01a718ad9a166ff22e8c3eea4b697cce422e038f4ed82892131fc3e6f03b9f706c094cd397b34d0b1364d303169a6f4821e8c962076e20b0b31c0f725425978a4625d7a4061f242ede23ff509da6f9f237d901b264b58ed134ab791166749541c523a3759cd9ad5f4ec2d305c29c415364b550228869b29b304f6f2aa168fce76d89f7c688078d43d43635702c7c0ae5f0d2423498471f244c62532897921178a083488e7f298159bf019243064bf782c5d996c73daef5fd3c93534615986588f5b4311137a95943c264181ab2ea41d317ab5e04afd0de125d720a270ecc4ff4ae4280f45d9214f33ad3b52ec106e9be820f9dd7a236f8cb7e623de605f1d6247294ac35e79ba4dcf536a0274ce5356820d3a0db7b982a04971cfdcbb0db59cfbe86a1dab3313b70fce1addad80ffed6db9da1de7c8494326d795b4324bcb54cdf61b2ff1c5932e5aa89a562a605600a7f0181737deed86e0b60837be18f36abb3c6144f2c19ffd1335fa59ff63d179f2fff2a61c7663d73fdcbd112c4498376df78940f0af1dc7c06cac24acb843ed182cb331ec52c2e6762bd33a8eaf5d7514073a46171a3e23d04706b212a492f4b0963e4e6a218ed2de94cf504525067461af7e14937693cdfed827daf6fb7c8ad6ab3d7bfcff677ad9c1d4b87d30120540b259598d273168dd498fa342a21476b87fdea192f5e7f4eb97d1329c6ce8a05297bed2849161c5686076606a2904a7b0a5609114cfe5f0647fffe278601a0bc449f20d5bec83cd1c722fe0c02268347b5680efe66445af356d9ae84a098064940be0733ddd606c42da665906693a61d95f90cb2da3172af44ddffbd7e380af1541bee7be84246a411d3d7b01d8cc3ca2fad12b10fee115cdcefa3213eb18baaad1f9fee1449797690ffb33c9baba802bc9a657df0cd9b6aed3013f63fd3b392948a329cbf0899e75c0de33b7e8f692562942e76a5373285a8c9da50c8fc777bc560a2b4f54d943794312fb3073722e1e8fed89dae40fa4d272396b53c349131fd2e2ef4e8ae7b41e2268672f1468f59b10ac220391391ff802469e08109033c98c23b499fc064b5828c9ebec24f80f6b9618678c2f28416f951cc02ace59b774c294081c48984cd2712da53c186a9439bc4496d5aa83bd510c440bb03dfd46be13568b9310c452d1af0868a1a8a02f308106fb6cad7c8d76aabf98bd04165cff9315f008f5b0b3618e1b8c0290e909301e6735eda86bf7ce8c7c67a182c5a0923f390e1de932b310d92506aaf2541e26d9623252e72e3709ac94ca8204530455dbe8ab21bee7e90e6632087dc60e126b5b4b63c69ab4926e7fc72f7c7a2301794c6db1f3c388a2a6d544ac789ab12ff6942f7c88be02251a2a7a20e7987c329cace501d082523c195f569c20d2be683b462f727ae2d520e075701fc01eab0ffea671a1a2d8ccc6e1bde35c9b48f8c8ed2ef0cf4e7ab186ad9c3c5ad3eb71f70be108265435279a0a751f9496355aee163bae07c75eda68e8d87df1d0be116ea0246b2669365a50fcf2c965ba4f572dac6ce96f1dae9447a2ff6ea507a91fa050561cdd1cd781a96b88c4e534ebf1408c117613ab4e1881cef918ff37a08ec22754969808cf40205fe4e1894849c81486361c22a95cff406ef1d70f88a73b3bccc04a2fcd48645424c5be44d594e28d245ba37bafb11d338aa26a0497a27129cead343e405644530da113809f51d9c253cc89467dc833733bc771ed6bc98ace8de307634e852ffad4c49fe8c043564801ce8b474bda259f66bc14aacf4f7a8ee659e9160da8bfb2b8d7c6521445e9caaf5f135efaee68424768f019a174c00c3f1b5256654f514375492a59ac354a65754306fd6332d1b497a661eaac651cc0ee4eef91078445ad61048cb94f313fa2209ab041ff25c5486e5f1bc548666067893119b93690ae4ff8ca95260ea4e4af164cdc52eaf6be3e5a5ee70179ea5096d8e72b60f857d32961a7c6fd72cd6c3abcd4c35b1927f78fb54b6a6cdcace0aa77e4dcb2a2f65a9e96ade3bf4179f6dc352a10bc9d887af876381de2a2713a063128c417c0f5b53dc1e1850987beee97c9b52aa741566b712363e29f5cda203656bd32ef3321598bdff7a902f76652838782cf33c1b3f907de7e136703e0180fbf34aaf97ccaa15c68e0102836ca28737e76de4871a7a6acde5f16a642f460a0e8c4b232a5bf6aabd7051a69e6206e823d55223a8d8c260090219d89a1667c1ca24ed4fc7c09174927c6f2122ebefbb1e8e9c0caf7d1ec1a4e067f807f76433fec4a1465d8c1456006aa8f0277a6914d36e9e22d86e9ce169a928543f96397881aeb203341318b66dc231d8c2a7ddead0f9df198a276acfa64f70b24d5b56d6a9c2b4ea8afc13eeeccc36580fee890f0c62ac06bd6070487dd09abc33224022c7097d6344784336793806a97927af57f7f9921aa050fd5a15d8f1138cf6d495eb40fbfe747c03688f19c26993b15a58259c8308a6aafd82409bc4785953ee4c6c1f96bcb9a6d06d432d316833bf00fe97092a11cb57e1631ec60a6e717bd37dd214464775efbb9c5337f4c921d07d10623572e1266b0bdb78fcf5e8245c431aa468c38c02ce9b65e2304d5b3c468622bf980c3743b46184f5217f956f348bba2523e19d02f7c6f5b059db391a31ee1bdf46387d80419c080c49e1cad16a426e26cb3fa87dc741b6932e459a115595d747b808a431e58e79ab92a93010c0733c8ad133119af2026607b123f8059fc790bd50f907257724e4c1550c9d5e717a6e738269b750b7977f7af519e02c1cab1dab1360fa8ef0a96415f1a62eb10ba92ab01c427e423e28cc6f857f55a4953d8c26e6af80062456cadca060aeed21e8c87e330b6721a449e03683a1d1e90cf7a38ddbf3f1e9e771deb94e8a9f54d308e1131c54457f727f2eaac8570d1a92f6b88afa50c299883f14a9245e812c09de9436eca595770f3198ff51ced80eb7e8f231d440016d40ffb1032bc48106f0a9a3d063ef6ade63a7033d7276d5ddae7f0bd18e26cf53a6b75e3d4360d6eb7681284ae0aaa8c5ee178ce35b0ad56b2c910a6ee8384c7479d2c4b1a0cdb69297e9b0769a57485b1f5c59655fc1537f413ac43b1870243fec90c9e27ee467cc63c3240b13e4d812c18ed2a686caddab27c46a6146d1a6b5cd815808db1b8d15e80597b5bc8a81101ff97561a3909e27ba1c1f82f2bb5e89330887404826ed3c5e35b153ae5d7b4146e97e2c4c9b3483ef468a69a3613ad0061d608c4f5a132c7111105ea20f7ac63c63a26555a69f3ae4bcd03723d86635c1c1f37348b6b7c850d6bdce961cac1343e1285f8198012a60ab33be9717fb2f7d4020f051831977b6e154ae4b21d6b39510131de98819a4b756db9efee047832bab433d4f477d81efeda4648fe58235eac8e199d0eb8cd26a286ab5258a771fa45b2d41511835690460108ee0fc4ec3b6b0ce7c52fec5085a07d05dec3c0a001f263cb2a14847fe940ab491ce0284ebd2882a203b488fb241aed1650bdef43f1f9aba8b33443bfc8acadcc3036f6822253db44f1ae471bcf161c69aa0b4b0dca91e477053336ce2622fd2307e0733e2f68b5df2986acd72a5e5f1863db9059d017a0b629f561a530da8ae2dd8a68ecf931d8f73d8fe884a359e192661332d2e1ea5b41ca0631f0480c94cde5e3582bfb3cac0e028d16caa69927a384a3d5e4fe8006718e8a22041c70a06e1772c4ff4eda279d3bd2e16fcdc8120f9d9040d7a715d731614f4272427e82157466f1997d79f44da96701c2373773b65ad7240b893564c748a0ed21fd179374d10fdaaf609c09c40703a1b333a4a4ec6eb25a9ce15377e9428b16f4dd3acd4bf53bf7c110f43516538bb4604e7c83fbe8ec4382ac46ac224d53d07c0b392c1864675105551e9aa75837a82be12e6bf6a318d2fa51b9e8b41814d9e1160bd6d8666712e53da51d0f7ca3a0ef94b9332a1662b3970e69e330d6459459bfac02402de4dd549b09c4d55f636d2c39ede1ef1cdb95de3107480f9b6fcd7d37311af9e5b1b43ab0d7cced1fba1a75dea14a35a60441916bf95ad532241c7dfe40526b3d4aac426cbabfe07faeb5c38e6fca9aa1841e1306c927d1cc37f7bd28dbc2d31abd29806889efefa70cb3dc21905eca3de7aa94734a0546f81b17bf46d36ab4f31e309324cb09408977b6fe46076368f18c86a7d14ff7a344223bdce1703729aef84349c8a22860f8d19c20d03d69192843011edb1d41f1ea31f28008c9448e4550f9de17bf42146ae917ef06210135dcd930fe8968a8af3dc326398f1f0062b72c4b1a73fa6b2139637973aec609a4248ae91e8ca2ffa829458f66121c280de6f4671dc158cda392b506f80fcea25bb36d2cded9a2f3fe26dce365cf4fcad30db2f65bf0c296ec43ae011ab816a44635965d726081a13e90652293e2f71ab1d316be26eb582077c5cbeadc1c62bbc4f7caf901f70331f6d2a7e0c578202bb0789409f05f260888c77d4cb8d801a92f344a35c4327ccdda867ee7312e5a8e4507c6f1078785c4c209f7afd16711c9edc58c8bc0bbefaebc14fd1d043eebc9199e3b4a3de7d9b2a0d3f9bd8e0618d0567e333143e1d12c3f47e64a70a0fb49943086d7c7c6da7b1fe7420c47384cc0eb72e88585b469156356ce066d107abdceed61ca2b17de8ea5e9529bc1d440933899b7688bdd1da5a0c441ab9266a3caaed8837bc9e0d4a291786db4a2c6b315b2e5240f4c7247987b712518f7f687c24af83ad71cfca5798288f0954698ca332f7bd095589b41ad05b60223ee1dde0519cbf9bc194601bfe94e13a9b31597aa9489df6b223e79087f5cc125e69429d19bc5a1c7b8c44a8932dbb8bb7edf229d4914f1bb2af3d74a82cc71e04ed8b5c8fdaaf6ad555cf3a12d782d0b99640563fe899bd7e6327567a805ca73c055d0c2878b44e69530325627df55b725f9ac6b1adcd138dffe62a52be43eb2844b4330b929c80bb15899085117392c88f9479cbd24dc53aae2e71d47ba4eda1bf914f50f55b523f8c2d074e6ba4e58c91bcecf7cf1554f1dbf650a6aa6cdcfe7937a6e67c025d040456d91116e2cb4c8f63b2b9f38fad57aa63369ee4d313b45b0db941f94223c3c9c566406c28ae8a8b0ab9202cbad3c8f0a8d68a57b5441e8c361a6adbbf09071ccb2084a17fbfb6842acc2b02ae4def40162d769146e76fabbdfd0f747c7ee961d933c5a045e0522d1fa03174aa91c029f14c96028bbc8a66d9df609f10c123352101a6690fee2d8e20ee673ca1469f82077853ff368558a43f018572b348d5b2a735b287e34072b080c16fc56b35ea2030eeb7cb973ae4a8c2b7266357306fa9e3a2c13f15f0f4eb85f17059718bee500721412324d281fdb415657673cf75dc7001683ec9edf74bbbd0197297149a43a5453ee2d18139dfcce7eb423045447d81f352c6be7064dbfc4f109f9b7e102eaa16089191489f88bb7c8924338847b159f7eec3c82b167924dd227b4f8158db96120f4ca9b151060d7da4fad2425ec77f8b0f8d7d75db197b921217f41e9744022348641bd3fa3aeb30c890523c45510fcc9fe992dfba43de2367c37b3c0486c0e579d91e563e841d7ecd4418d563c0ea9bc4a14f57aa88a28b1eb8a75eba0a907a5014057ff4eac5734332fc3943485adea2378e0b06101e5afaea0fd3cb8c89ba82a6bcdf7879bd49b0b3571098b6c284402bd1198b3f0a955eda24a626ccf503ce02d2cf7e7ad60c443d8baac142f09b35a8bddcdbe6488ebf40da8d9e135b9603ea4cffe81437b69c38986cf82270e585ec5adc642eeff177b9cc04941c12901d91a85c013acb08c88e5ce41a4ae4843d32dd24f2b01bf663ff58cd15977eaa9fde6aff8224ec26815ff88d34fbc37cedc47c5c2d0f3d0ddff98a5d647abd5007a68e754ac807ea109252e2327c76166630392cb2c09d3f8377102c287c7afffe09db8af281f1cdfe0e663db2b7dfb44a79a8132d5e7e917e5fbf6b599a7062806805bdc0d1177521ca9d2e9b807b622592765f7fd06e2f371a7414a29423e5caa702a412de8740ddc0d50c61138ce91dd3d7991a51b86cef030e13fd1ec7250489b834e427ca3a7239014c9d4533c53c9c7b771f81eb1473823e4bca898c151230e95d469187ea6944723963ab3097c43de794aba8af5f2d50642d5c37e44f708fe884d3f340e33da6e46af916d060d222b0459f942354f17f02287c2eaa132dc1cf28697b8666500b9bfd1b3ac363395d1eef5260f9e87235bb28622dd5164029b08233e3144a1665b99f16d0f101b1e536db42f468946b4fb9d31208e917556167de127591ceab497fa4dc8e88f9f54bfd0d8e8a8534eb82fb2daea5ea6da837ea3bc6dcd22a9b88ba2cd1bdaa483490e257691147470af0b363fccdb59ec6463444ab7a1d1e0092d5a123df5793786a547f6c7275e4c63a140281eea57838bf408b250ce240066b2af0c94cf2313e84e21203668d633ccf6aec61fa77389572f7df340a0ef90d9665e757149f113e59ab8fb68b5ca6c577f3509e25d28be9098a43ad64e287464af21752a268ffa4be97193b030a8e5bf7674a0ab61614054112cdfcd81eb690410e528eb620b8c5f8bea8db209d7eca901c5de3c0836f4d6bd9ef50d789e8142bff48f923ded375f12d9c30611a91554de5e5c004e53b0ab64ac34317d9d42201c5a384786076cc58ea42452d3a2c16a82e89c25c09c30bc02da43d03aa4d91254f234eaaf57196b74ad7f423d2d788ce2516b612ba94244a5ce962c46c8abaf40f09afd4b581aa34edf984f4ee40d509953d3f6e51a48df20bc407fea195c5a67f65b58344d7179a925cee4e0a366e318c26d7a5f9896171662486f0003ea6d4c93f7a109266b05d2f3f0ba9d4081cfca2c64dbd304c58a837795a8f849749a33a5067624f0daa975c6904bf65afd85a2d2200e08b27fe8aa307a6ffa9fabd46faf4557af041350037977eaa59305ead8c60cb0f8cbe0c6d627af7af2a3c4a6ec71f2b475a60c3dfb119da861067c06c6333943f264a8e72b73652fdc94e5c6cb34614799c6adad74d0e453d0e1ab89d338e678cbd09e6ed1fc1a4fcce769ea539eaa7417723e49b35650ef3429cb2d15f4330f0f2d32d41bd2184a4fcc240d527e28f8f2a87b3d4ccf02fa23bdd62b349059ab9c34093fb5ccf009ad6df2e9d8b5f0dfd9f93471c9af1dfe5e75737464e4663f5a0df613c4884580ab5a54d0a18422f5b0ffc09b509a00b9a48136f0722039721fefc634deb4c48d03cc14e3d909d7f593b90d90a3ab9dd01d079ae37144f8def8a6612d7944e63b23f1e835b7c623b0b2d95e0471e013344a26165645edf6767d2bd4fc816d8cbc092fcb1bb38738cfcc6186413ed46de4d7a2ec2a316339bfc5fc784043fbfad11c9fb822752721688ba79f656a59b7b39a3f1726b927d8ff36efec2f4b1d8011a27cd81575b083cb23504af66dc0ed84733e051298654d8cda8d7b11d5ff12a45390144c02d687d0ab436916ec20b3cf18498819e9deb39110848bef1b39acf67841e9cdfa6bdea9cc6b729e3fdd272c3630dc78480e7e5334ff2abd50d97a9b7e9e9dcec1bb523ba95735a280540bb59e1f32c05543bfa2c1afe032e527c0d4ac92653ad8326e2fbc5ddd68ac7ec607d3d7a84fbf020766983f94b6dca3233a8837c81ce5713bc672e33aed4d929897bdd2711fe666d2fcc14d2de59f99f3f48097ddb18c74438ef289b54b573dda637fbc8c928f9ff0d54bc910744ca5e7e51be2cf2fc375fcd93489f444a063d02aebb70cb6b285d4799e7919e4f722359c1e8e863cd24e6ed65663d6cc2198f492760b4f4cdb5cadf53888b7cfb20549800a3a62d180862ddb2adcf71abda63a247ae3b380ba873cdb91b7fe51b6eecca987b8d43432a994c04c5de7e9463735c2fb5047ec048b1a577827188e432ac64fdfc746ed8e4a29bf0684d4a4359592c945eef0fa20b3ba7920940986335678c1411e00c95462adcb9918d2120da66a65c233dc6a350d204704e4c2ee2009d86419a3e0f80a20998974654dc7d205e6d67f4354d8c785fe3f56947b8522483008d4cf1580aeead91c5a437ac8961a09cdc18840c880600d012b22cc51762ee89775cdb5a0a523b896b8839b53c2624794a3fe80fc27fb54a02b4f605d6a7f394db16d143b45ff1074eb33a832ec75a42f1a1f2905400fe6533ce3b22fc9c67b8b7eb6f0265918b7b80c8078d6b302924a3443403d0238d66aa7d252c208c5f599ee2675b8b317e750d858ff6f367fe69d3c7b404adcd4624f7d1c3fbbff8cb2282d8abf059ce3eb2b27768582890596e39151f60bbeb72eec715062de6d8c33fdd057226bbf37ccb3215a89d5db28febaddf7073d877edbb08f82a7506e937f7700a70e9635ed0f59aca8b1f583e9b16dc535b6958b8f98eb9be8ca7c4be793cc5631779507c06014a0bfc50da53dd10a1b39f44e1bc5c87aeafd070de0c65c877924d049bae263d7719a0a6c323288c36ee4f0cde346a7262b44f3e720091e290e11da9d326ef665a64b752d4b55335f9332c282c7914b3892c17bf305b9be2375af0c9ecaf276b73eba2cd1e52732ad5f972e68e89447ae98697f2fba4d5a8f904e9b73fc0d84a787d08db6dd63daff6c323f1bcd3c4c6cf815b811c09599afb050719aa98b70de0efc86350a82699ca8c1e095eb4e408b2056d54d5e29dd8027accf73f9b670a5e11359764fc2df9ebf7cda1ad55cbbd6fae62e45b99bbb9ff8d99ae440c02c3a7242dc95b76e4085d3ff2457ac3bef8548544b8e2cf8831a1200414b56e83ef9f0e12e358ded29a5da20dfea6b7f5da7a24833873ad298efdc387695aa9fa7c504e15dc6d47a0a85264a098ae00fc0e52b8810a9923f2ca25e1fbeb691e82aa4a4d32a71612af6ffe540093a1f0951e0110e9822c2ab9452f647ad341cbb6b4e4b771c1f226b18f854791aab50db5d29adba3b47325ec8a4fa592ca65cf84c197c0913f685e91688c84433e4d79d463b7afb1f4da9c5defcd1a9220eada576223533112c98590ba1dd31aa3c972827b4e954b65aeabdc91c2491ec1a389a2574f339ae8d192c792f7c2137902b9fc770c7d97a26de11b67b3a514ccc6d2f997519196aceb04fd481703d9eca1ac8ea7fdde1a48867d734975f4170dbe96613d68915404cb53e7e1e81ca42a8d8a5d706843ef7e75b760dd4fa24c7bbf5c337e0884a71011d48548897eab766730af02da854879b2032fe38ab0cbf2d9476d5d922abcf39135c99a07c7884d8d71d380dacf476a68b5c957eb4c9534100749ed2d8ce3925eff06e0ebdb33ae3fe4d3c851a5c88c372d21a64bb4bc961077b16664048c634f96b5fa83ba1e47a956333becf222c3d41c64f1597bead1b8bdce1dc2bb91290b83d7dcc825354229a5007f29ea6e9a4f259f289a7e233a24f516ee8a3e14ea9a8fc312b37aa12266ccf6e634311c827260b847e5fcd10392186199da7e84f7ffe8fe260a9a3f5e5ef5a8f5f8cb57fdaab925ecef164bb3c2624e5a3cef981515de9a294561c818af9caeeeaba93109348a33f0c5dfe12ecbe52ba16bff2d78e76e6bd202890d5877acdf03f976b0f58c2c9b9f0fecfaa2c046673a9cfc3245e50095b2cd1aab76a10186fe21ba9f660a82f5df1e5c9f9317886ccb57d98102fe0548de815a7c0262a64f6e4e46ef5f5be848d619a3460819afbced8e3d75898acc03ddbb1c6b6b37f7888538913f8c254cef62e075f62a2ebbceaa34d8ec0f985b6274e22c001bf01d744a38d20c0664418b505a1817f96daf5c58a709c77321e7cebb4d5ada88b166b8b9d1c0186879eb911d2250314ddbe1a6aff3da47afc81e0c2c7bf2858bd6eacdddd039ef06dca18fd5a33d255e165769f004f716a64cb9eb38e22291196c9f469b8e6695598c80fa9fad5e884f771ca3a307117b9a091c2923463b503ffd0186257cc805807498ae93f90b3e0d66ec4660b050aa7dbbb02fb271a116c988ebef60a7c63400d4659a9656a50256e828a1e85bb78cfa466a3cb9dac67681c513e3ebf1faee41a1e233e5ca5bef1532fe7ac548b873d56c0ac37b594e75b11e671baf0694a1abdb365b18989479deb6d52ba86e911a9147da3d031dcc92e3ad99e64fdbbb0d0572b8ab0d94a2d76bc20edd3e4a4a5fce8188f79c0b8946c9c47040f2bbcc766ac1be592429a4d3b6dc4caeaf8853c235f1d1982e0763c2080b1871f5907e5e679ac95e54625ea12b17379c42f514003541d877413ca31e6efc470fa5784f2656332ecb84c883c85d56fe9690d755fc01d078b023a9e4142652f409999ec6092f4568cc501da25267ca1191610d2451bbd9b9293dae4bbc31650fa6c5bd919f53dd351fc4841b7f36e01bea6598ff7d6c0d854222c766caa14a1c402233b7e5e1a0b3fa94fc8150147d32ae30613b7295f1d6a4b33776738075c71357936105840e2a72d5e63fd178ed231beea7be95c2fd7e54fd4974b7a361d5fdaffc4254de6021afff808921dfc92f33459dc77c3b036c170191d1dd2469a21f3ffdf23b27c6867191a0e03caaf712c37f8350dd6133d894ce90d45596587050b7f92d35a4496e0769c025631c48d74c2f75ff29fe1869277022432a35933bd8d70cd5065e03d9f5d6ef7d4519729b63b3880e711eb7f88577b1bd2db3e86ba9751783327dc645f65db4a893bfcd6df69222bb5ad53055346c8ed7da09d7a1e39db8e07dd2539355c47acaf279c134d1904beff37c3415c54882a92d2d4b605d81105691478c1f6708ccd99f71a2ce78cc5dd5b489e1a4937bba637f2b9d398cc00b6bca9833234b6327c7c80123a3cd3cd86e5e00a0ba0c48b074439ccc51515be59e360e81491b043122b550d767498247fd8e42441b019b89f1dd4abebe731679123f80e2ae5bf630f67068231c5e88b08ed0b8424c3f15f1041247fc7b5bdcd122d5c2a3d83d150cf259dbede718383b07a3e879fa78b99cc00461a3bf546a737e7351dbc5085ca381bde788f5552a24cc7d4de3ceef041b834ba8abee2419e976504c76211e1952e8b8092482cb35a967863329d7ff71af7ffd2b49f01f5adc3e72613cbbf562d73fc8bc0792ad9177722d32028af7ee59d867759fd79d2ed54dddc7176af57070097f59e930f7a7e894a31591a10228b08d3fbc88557b3ffe254d85874be5e12c9185a3e877dddbdcd60e045e8523913828fd36ea94b4daaa1da031e2dcf6ddb2328eeb5538741508b982d66a96c65c2019a16292041deeeab7c98ea624e589853109df387ab5b182b8a765f5861a098e02b2579a1263d0c943a9943dc534845550e8daeda525a94b5bd9d406cce8ee1dc183e2f51589474e7244fa49d997597712ad5187dd648fed29803ecba190003c3951a02521e92de77a725c43ad19dfc3c836a0c71c808c32b91fe0822a6c7c33c6fddcaf73e55827d86c1f8d8386e0418eeb2dff1de5b578bf4eab876b9d18eaf29fe74d4ed42c7c365fa61c784b92dcca21a64c9a6a152783f4eeb64acbbdd774f7774a565e495887e1818d60f799921dedc3836407cd3101fb21319cc4a415b62bb8aabeda1f053c2fd5f2de55b7ef7cc0d0d8660644c8f31d9f32d96f501603f16d48cd77ac7a7cdc324446793064cd2ba7f98f295b85e7c2ae9fa1767a92b981c8915258b5abba072f0c4e61c0e296f3f528c3a8ce89c0db037196b138235b1b0b315aaf04d801b7a40e0c8017f3388e14eef2d71f90d40084af97edbd19bb07b56c743a3f9f1572661b3224fdffb66ed095478aeeed49558b7640795eb54ef291cd20398652771ce658d5bb24ff9723a33f774b0b4de469040322ca10c0a98591ccc93a437de5bc6c2e2e09a2af7b490fdafdca36e71ffc4eac4b000b67bcb87e095ffa00b5bbc1645863b83ae66f115a241d7344867e183081553e8cf67d0968c91e5a7b4d2baa1400701009a9b619dfd0fe178a6f7f5e6e3185415f66d516a256e9e67cb37193f43ffcc7d03fee04acf18ec095dc29f0a6c39adc8d67979a33301bf6c6831c7389f38d5095dd8327d96efbcdc5b81a4a3dc1fbe2111f1f22b46feb73b580370d79c93b0268400c54a6518bf08f2a6026f346e2d70b46e0c51c4b8ea2781783039e45a2b5a9829f8bb661544674c7ecfee40c96de4d301a74405e1166724d244c120d0d69bf6d0dc04a00d00496315499abb98f9b021e96ba6f70d6fcfbbe9b34cbda77ea88e5717f35b6e132d67e27c015100ca5ff78f655e67714363f8a683ac43606d29e75d4c7b866077f110a23a9f48608f43104d50a5bd3617754b8a393cf6c9c795269919bbd7af6f9a8bf1567b069db5ad4a9b8279710c51bb25cd3d780bcbd9ad1552d13dc71fa50fb5e435a0ce5acf40fe18fd7b60db1d0ce7d242a1e7ae364267d07046c75ccd05672132624b4954b49bfe35805164029a8ccd8be8bbb60f19994a5a47a09de4fe4767d3e3af9d761e460fe2b936449b7346ce6bb0339755ac7c8e8a1334642dcc41570691e883eea9b5895e06332e07259e21037198303fe49b37fe0d184d5d9d66bde905a710795be9489503abcc6b534d35d510e567922cb5bb682234e00cb6beeeeca0ad69ef58995e28ca530dc68a3ed07ef584d1187116206ad152da3c227f802897e460e1774d2b1e846b515806b1b9d1a0b08841fcde5ccedbdb17859d1ecc51b996e7f3ee41b2efc1cd4bf47b15f990afc4268e0a3fa3c1a91a6e472f4b98c85fe06e5c4480f022ed62ef1dd43458256baaa26e781c7fd6dfee6ca2207bed7ea4e5f4aec39f6483a3a5189a5545e5569e33b029679263bb87ba63f47fbad94d825e5a20c3cadb5fd5628fb75a96551c6c6562b632ed544c1e97979251b5a60e9d1591dfe19d8e6de0110703527dab36fbe57c4c3b7ee2f3dad2b548435d57fc7e8e2fed8c17877ef0983f0b423175b3e2809f6c1e3a54b272ff25eb06cb79b7cc7dce98b7065938dfcacb241f4c9b089d23657be6d5f8a4d544d95d843443cb86244c61fab24d650cdb5d2d9f4c30bd777c0b9b24552edc309feae2a34d3df086e19f45e53148a878479f8ff471a56f9035f1c9e5132a4fb8e2002be7af8c21c2002ba83dc82a0b4852e9fa5decb5248b07e75e7fc43fbf9277388c0b79ddfc712897365af5e610c09676c0a625cffa5c8bbb8c81da915e13744b00e71bc4c975a13f27fef2208f1e5bd8bf06cec671c6ea26b8030ca904a650850b34a3db58408a32e920965d811239ecfad9efea60d262f9dc3838458cbc57cda7a97de89cbbe9fa4541c1df34d0f65482020be8db46bd47080072a85cb725da5316aaf38e9c602e8e283e55a6d19a5f6345eba711790693214e9812e0525b3eb30cdd2c8dbab2a588503bbe58cb5cc6a514208a1fc79c0eea27893c6a203e502ac1d9eb1875ef9018d97eda076d76c6ad1df62fac1bc47d074a6175af164132c9eff13ac38e4f71fe7c0671dae93b3d9b02e09276682df0433e1c8561634a3f22e03f73d119c1bc2e730badddba644e794c07b732f6cfaffb8af916e798516a1ca685a34fd432390b8a208196b7cffd295916b9eb64bb46b1b7927cf0df2f948ecef9962a57bf49b7f6c6660fe1694af0014ad537c5a7e1f48b63529cce214b96d6179ef424378a0435f23b8de675586b555297890e780ee32302d8c1a0c548a5ab9b8747836383a08c0e539d5277f901cd8f6de6f604af4589d873da5c46c1c841c94255414ed2041b7c0e4a2f0d91f054c87236ae0e4f2032fa74dfd7f8107301ae86760301bfb998bac015b2cecdc9312203b64efbaee84a2e52a1d4525d80c2a47de04df12cf1a51245095604093f4726909ffeb3c18c396e0ce87ea54ae7a0aadf1df262131d756e32b39c412700c6e4e106ccaf7214a2c23b253b90512d04afad48d73f2ad9305ce1817525014fa8714e3ebdb6e614f93add10603d3feffd69e1eb41dc78667e2af0ce1a173d298232815c38375790b74ba4fbf75081bb78979fd2ba38bc9249e944bbd5936eb7ed1d0fd31f8d239910aeb2eecd101a0229091e32fd79abf9c22b5c3caf65195a2b64c1db7aa24e5f6f28f64085474c3ea3ede9ae6dd321fd8b07e664880d43497fb5ae436d253f6350af1b7a8c5a73d470f4faf4474f04fedbb91a3284623f13aa135ab655d2cd8b0665446d8921c52ef24d1d61bc93bef422837fc6374bc0c81e14860f6eba097934cb9b0dc6c31799d00f70f4befb08dbed0337bba76bbe2fc08f737f484f6788a998e73c11d0263857487647f1350649b14cf55e945b737c830bf0263489b2d23f683c7d3f64abf55479ea32235ebc55ebda92d4e435fae1d8d1565a064a7bb8698ac365659da9e2057fcdc95ddc623694196c7105df1a75fd7f2db602e4147c236c2831da9e95c23da4cbe0a1d1f33db69af56fe0cb7a0aa4c391b8e01020be55090b59b7afb49363610b6fdedabb9942f2dd20328360df8eaf41b7a426d3ec9a3f18a025a964e566b7f3e01c899af99c0101cd093d619df1296aeadcc95aa3ced17880997c4a822405afd6e11b0eee021e2c504d82f50d4718de92833d76e874827c9ed0e48f208a50eacb691eb6dde59f46260c3d5796e47df32b171866ff01a8f401860ff341e6b04fbb7f901e91f0818e8265195382fae783fa1c5d3d5ce3557716e3a3c00e1a9722d7656f6596a5d7e25b01b02b170de30ac8a45d4361e27ffb7a68e32c66c9e493972d44ecaa3c28a966cceea69a8d387cf8af68da83d5dc40193d792d34a9a4da50d35223494bc67e13fb1b69173aea5538c9ddf48434ca1d4d18d598c29e9ac560ab2a9f9f14c1c724dee1a5c49bd07db63cad78627c4ffa11ad5e6e0fc402e88c434b925989f944d690739e301800ebb690240288b9662d9f226c66fb602c588ba67ca2392692cc328e0bb53e2a88a679978ef32f522051500efbbfd5798c1c3df25e9b29d885bc1fb02c4a358f67e2676ab7a2b7ce2f6531bda2f7deef88c23bc9a492e077124a8f177afe29f26dc9385c22498d535b6bffd954dce7ab321bfa9ee190486708d94658098ded563339b9ed41693cf20c57ae4a59c95b880d2eda3439c0cf77a0089e900f4d7af0e2bdb6aa4c7f3ba04b38d6cab6c043779b2814b7af9950ca34dc09e388d590737d2debac1d581c8d9c5da087135a7ba66d451ce84d15f47eb187443df1b590eda5523d430f153134d9fd111ae41e71e0b67301cb399f7cc24452ce843a981d981ef757bba23f152e95321fdd9221bd5fc7c6b426225fbad1299a0f4d4d3a1d0b0f2fcddd2ee5822b83af9912a851301ffc4a4808cd025c9ef66fe37a8842e2a74958ca020cb5b45edc0d03b5f8adb75bdcb0cb93229a17fedd802476a5487921932db605a24fc667e37f6240a2ba119ab7c5d6f2788cf90d1f53229c2847dd11e638aae30c1558a269c80552d5ba3f436f3c145921d2db9fd4a770b697b2986ab0923fce7a2417c65ee38c0c31ced478397dd704a4fd0e4d87ee6ae6e203efd07e97c81bd5e9dea08d79c32fd9aeb81dd01c697d50a5e1b1ab7404ffd0ea9a788a10b3f0edc5febdd6c9f6cefb6422086b95041d8f098b8bec402adf11b8fe90ae5356efc69a1e0da8b4a96e0e6990df0416fa9dbf8ee584e855cfc2fa4dbae65bf8f96de76d6c496181633f899647f041e8ce50a26f16b4832b430bada64102131544a1402d81f32ee03bc163049c39a9f690fca6ddd767e3bf7b6dd9d881bcf37daa206dc0145107940ee74d357d71f9e51a2c0e839e0de0e70b7cde0c3c217eda7b5b5cdeaad0f842897c647e598b0217389aa8b0db5924520f68a11481fb35723ac8983609eb01e1cf2550ac16d5c85ce1e3dd9ed1aac0bf61c71c7bd8d24e75e717d85c3746994e3629823d77a77727eb61d2695a7856c7e4f64afb6b79ee872fd5bc3e5a35def53ff1840a5cfef37855202dbb4ed9af96a679a58b6d206f36655696f59913a0921ec085c65843ea382d8dbb95b0b12e32e5cfb87b7572dd956a93dea355c05fd60d03a0a8eff1a15ae06703d419401bb00d5895e1961018f10d5315844451912fa532ad60c9b5d3f099e40849355b79e2c03f5ce2dfdbc7dd50bc400ae0d540c33fe7307b2ee17ec012da9fcc64b3c157a9a2d8af943985a633dcf2ca7fd112e317bfcfe73f6c2bcc0ee0ae21006b5067819ee867ece51c09595523a58b78fa03561b98cce2331a80ee19c0f7ddbfee0514e8a43161a7fb5ad48aa1fb27d20bffd45cde2fc835dd9915d0db64982b87ef5614aa080d2a8caab1f9b1c789dca912364b64629db200c2c72589f2a550a9f081d21eb61e6688e88fba7f53d863271e9a92a458ba429c873e523d128bb8fa42c6e8492ff62db2863aea6655283e1b09efe647c091040eff27a18535008b9a7154793b17fd62c8445eaebf273ad48f2d6b3985ce2a8330819601a9ef2f86a35f8de63d3414cb0ae1d8da4ee0790be5dbb1a73d4b10a16aecd3ece696bef42e8af7d4a2f9634b1bf0439703b6be42d7760f5ed591565e00ccfacd6d0e53c0186c0778989579aa690265ab0450f31e66647e6441185a4e32bcabd57c50d5dc276e7f53f3f0c27911296ad9bdbd000494a32ed1b37548adde06e889ab54d94f1420b1c3039cffbcc8783413944606b7374aee1713f3d77faf901f0b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
