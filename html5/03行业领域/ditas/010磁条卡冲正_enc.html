<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a235848a65dd907c0ba0f5ffa1774f9d0249afe1951d32d131b5b35d0f744850dd7618a9a99183034a71a89ca8d81bdcd31ba38e5380f933b7628416690a7c693a6bb050f3dc44ca2839778dad5805d2e2241b96c2c958bf64bc9f7c488b3ef6c9c8a0dfe80ab0ee9cba157d04755e360286266e923866bfe15baeeee055b8809d4046514d539ef1f3f05dfd90001efd210daff1f0909c2d19e88ee95dca9d3baaa16d2b043a77b14b2274c053df35d951f905c92b200273b484139a06d0ae118f2a6597e05a5b5bb9887a40ef21554c246b2a1ebaaa460576cce28d977eb6ba464fb19612881abb6813d3e5d22ad54e1a5f0643405d89bc7d7692dfa416d4b2bae5e94a2a89b22a79f228e039d6689a1bb1b96855f34fa1457624c1674f9da843646914d4f8145218df3e11248a36b24eb93cbe591fb7d2289e673a37be7e9a49c8a9335e3bc1d0bb255fb1fd0b49b7a9646ed57c201e81f559e9b95b088eb0a675fe31e93f01094248583142f391dd7620fbaeb0dcaa677146bdf1263186ed9d8b3fd2f8e9677b8bd579056474c1f3feb5a5a811a96521e057befed7568f9c9dfe6449097020984ba67cebfc20571e051a887923de026a17aaa9e6ede3eafdf487376dd6f63cb06b184d419afda733e46afea01d34c6a14de3b25216fe23b51084aeca0cdc683081e9c7f14c82aac6780c3fa9bf7239af669ce42f4bdde7b1019129784aa767cd831153b161c3702051378ba58a61df0bfce19b2cc9b5dffb049c4504fc5c2f899045323156995390f1211bf91e97081e6b9274c018843a397c778f4cba4cc0ee688547abdd6c944431a7559a1f69c2e30c2635533d98efccf821d8830a7758c336d99433e7b3d4cbeb977b9bd2af3b1631472d395bb995e110919b5e4045322e83fda61feb81701dca732537b5231622905287d391279c80a30636bec9ba8b6f7389d17a627f19b8cbbbcf0462a47649603f7a3ba9c1943a442da90171421e84a48efc57594ac7fb2cc35998d8fc05a6105e92d754d27556a28ab9e0d32fb031df170337012969e1dbdf87809056ec9402684eb30feef4d7cbc9634bd204815def1dc9a622ee2ee858ab8dccab41784aedf95127d11e5f2c2a2c8c827e1b8febd57ca737fcdea6f443b5af2a487e212cbc2541f4228c2a11950b5dd0d0f04c66c46bbc4639ac857982195a5a33bc1b4b8852f6eafa51bd248c9cb9793cdfab64c1af94babf3a99d144a7501879aab6cbaa2f7cc2d6e0c613730f282e2a235d8827c6cada8d8ca19c236cf7b9102a2fc9a445a8872399ffbd0f55628286de9270782b5f4f65f6b23a5ae05ee247d56c06835eef3233cd28b96f02852a6e03012619e346f32f6df275a885b5b56d6345e529dc6b9db1238c7b5afa50f45943bd5b12ae70f465360ad2e3b45e948e0adff7d5bbf523d7b9908d2ac728b6d6cfbcead8885228d7242e55cec612ab6784fecc6e2a80a1b02167be4f24e20209b21249cb7fec9d30f872df4e761a23f96bce5fbc45cb12eeb195041eea4468f11a2b3268830f7f1a60a78e418d744bce74b58803fdf0e2ed84dfd63f364367edaf9afdb0efdbfd62ea2ecf5b044eb84719907f6eb1b51026227ed936c0b988e7236726d07d834ed1d10cebfa579467f693c66c1222a1bc9ad892907135026b2ed2de6751892da68d1e38804dfd43808e028c3616916c8a005e0595a19e0fc69ab4e031e93d773af396dd051eec914ab15d3fd49d4e7a124f712b0c17a1d7b801247be1acc3e6e52b8a52d8c739bde23830fd28fe63087a21e9ec466788b822b2f6a5cfcbb126b525e44914f0460606f9d27245a848d8ae8c940ed3188ab63d815d5b29f5f9dfd4a2c7941761daf77b889f3f7bc55fa5dc7a700cff31dda6fa103b0feeb26775fd6b6678ae55d3b19840759da4d66476c2882714bd7781e1c165e3581b9a6d2242af7352cdb2f69c17e2abe606bbe1ec717705d528fe30b13468280fb7846a440cd8cb635f55c286c07d2819e44206eba48b95268671528320d65a7e7fa2d4a4525c00420d875686088a83f5137155b8136dec1224e18a25d0a6822e6c3bb7eca649f81e6351e9d8006caa85932550a10b29cde00ee7d1b1ae0565eabd74bd5a3801fa670c839b0986aec824988d315859764535b36f8e54873c34e61b7a8bc7a1666393795a08e478c04291cdf2622a44613138fefe2ac9cb6efabf124fe064b528ba210e77af3c7991dd8c9d526b59ccf5e2976d9c7460ee58a3ea74870f9205dceab68b96d02a5e57096492f8f8eb4a0e39268396ebb605e04897e53cb8c81a7df09a82c88bfd10fbfcebadb34379a648cc398d923a9bb02dd1e0a8aaea5305d1d3e8bc2390915cbd791e5e03df4163bfe85942698823bd3bbec6c504617f33e526e5bd8af752ddb5cce6c5f831218e4bbffe1bf39295078175734b542bf6039d2e9d109cd2072d689399a93f042d0783f0b1d1b251724294087aa5e36d72fdf0781d5dc450752f87c032804ffb1dbe3a61363d44c225520b29b46e2e509cd055a3490bfdc6fb3cd0f5bcfa2f64704ad39fac057b16af7f030aca0268d69ae7570eecbbef0b7e0182b1d8319acd47f47bba88e914941ea464ff81dc77f40b052ecd42953fbc55ea8ba5a8eb26c22119cfface3b759a418daaf90c8eb852a05473e2fb1dc4a7f9fd51f39efc0290c10e613986c20f25ca8e586350e52b18312bcc88048a8885e9dbf0fe739e8f2dd3a5b0c17bfea0d019005e06c8a2587d0584c216ff0689134d1e70633c75be430082d9d15439e05967f987ac383973da38dd5dd91d7105588d05cd62ed648312e92ad36b734304d75c1e01e5a0033547ea9873b27b01497660a74d448d9b9171de6d57068d027800a0b286f52e1c005695566a9b40dacf53ac86f59db25afb8bbb36c339db9fe79976b4fe993fd54569aa651de1ca910c6b269e40697a13168f8c64c55a21ea8b395f73d260828da6db4b7072ddc0f45c0af1e43e9a358e4a3f551a54ced41622396dd0f93c10d676d8b05ef124546a13ba909afed2ca8ae981d041dbacb227e8ceac422fbd5dfc974d26397c2b24a0ef3499b48e8541a05390ce7013510baa60fc41b279d39e0ec16aa46baf99f6d421cb019a2ed6f479522a487297ae004d59c4983fbcf840ca6f57dfa89de7beaa1476473cc8e225a4666eabd836685dc214005b030b5bcf42ae30aa240d6c32f4624226f709936db3fd008ca0f6884a9a5a35682a0c30f50dbaf0570905800598a367bc9c0d55744dd2af1b432300ba97c72abb84340d16763a9f808ce91dfe1ee6ec829dca4dcb0d6fe6b3bb7db0b70f65fc8855fa9476e2fde97e5db8dc99098052039acc565bf58e4a2ce2287335a2c89f2fef8223c14523f83c13317692e9af9a408d56dfa1b6f1e8f6920998ab72b9c16d935cf765dbe49684db907e3349f916c735f73812c602efe3b5f859261d0179493077de02f30dc45e171bbcb7b9f673678ebaf874e24cac8d789544729518dca46a3af671787102cc4deac79333783a9427f7513b0866c770083e319ac51167d4d249df4d120c877db1c2347cc166cefe42b8afb7de6a20b19efab343860df06e18916395860300f7cd544aa074b96fe9fd470ceef7ccdfd7696ebf3347405e7a8d0831feb4a10d1d41a526cfb575a8e5f71704246b0125d32b427b7d41abd7b1ca75a18dcc112fed9b2f086ce609f2cfbdb20570ffd167710adb20078bdd06efffdd23354bbcabf00569705b11367b4f1b72ce579257544b0b99992e7ffd577f7ce9d4ccadca756062b8a9ac33ca7cb272918dd64140405b0a8284cfb6d89f8a38bd138521a59531bbd5c912ed6616d7e22882d8be02db26f651f6539d1a8da4d92666a3dcd60eb7489312e74ea3ddd59c005e92a6a1db5a219e44dca9e4a47c611238840f80c279645ac91d8204888878eac222f931b928588c5b79748f3f6cd82dda4b3f8315959c9d390b51121c912920531019df93aec89177c10c9420c6fb4763cc5e08036253afe4087afd1e0af4b3d3671bc9fedef4d9773d617542079c27d2d6e7d5a9db504030430435688de3ebee5f8cc61889fac62877d2f674351cd40766047ef21c1500b3621d9da0d8a20e49f88119a7e9cc64e558043edecae8020d9931e3deb1ce69e1cb21bd6dfcf89ea842fae81b3265521134933f6fdc2f2dd9975c97f0a1a257f7d45b39b6e2eb469ec607dd581b3cc360d0f58437b9a667e068741f9e7be5e56e3ba55df7debf8ce944a31677993c5d690fe4a477c21df078524f4aef1826db544fe6aa13c4ee01366c688ece22a267b27b947aa137b66ad99d61ad5ff793180f9e45f1fd1bedf6f7a4dc1723c872463eb99a00b0cba74b650d63324bb69fc21dd8978a17cfa882e62ca0af4fea886032d0200960833f6144ecad029abe614fc8f5e8f1036f17e36b656e16f934f420e7fd2754dfd9e04ab49e4f11f05b01441ed3b68c395665ea9828675dbda7b3b9daf767e35646ee04b88ec8aa8713bc2a2cf3ec8966edd1c4c1f85e075ef90f08475ed5164f5f182a096f2b96beba7bc4f5d24d66ea4ac2d18cba2a4927f2ff799d1aa74ea24b96bf74f91ff7e0b136094919b30b086e3c985aec1a78510b6cda4f165483fa2470257d9ce47719b8e79a767159f0759d636906a1527dc69ff0de7f5ed7b6067958e1ae24441d77e266125200791cb3c34cbc6cb5fb68ad8a757fe7f2ce925a2ad43201cd16364f7ce964fb16fbc3a9619a9c1a12fe973e23d9f239134581f3186257e2a820d63550783fdb76b646af9507a4b85abeb9e44cddc18ac085d0e7fd0175be3556def8b9b9348b70fc101e647f0b3f99d3411d0d7893992159a3b258160db2db8308205d6402c45886678342b3c1deb5c6615e87915562ced163056993cd639d8d0f551553fb51ed33c36d6ddb5a5ecfd15795c8740a00dc0bae3862bfeaba8869798ace6061751cd3fd1d8bc351d4d078b53ba434328e3357f711763cbf8401db79d26a0684b896d8a3e00d047b25c768fe8e344d95f6a7f6812cc5736d9860b69aad30d727950cf2fe65e57185cefa56ea0b4f56b54d26ecc61d399981917c8bdd96a3d46295950bc62d612af78be7bd6112d319023d581136e0251ecf52208f26c8e1eacd4ba578e0ec5352f956ae2504ecc32de13cc72cb0a507e367c40443b4d19de9f14265b0615da6a11ede76291ef59df8854b3570619c5f20fd3bedf4d31389210332ee62e365bfe2b05e9e8e421db93884b872e84a0d0e85f4156c978073d70e2ffece26923319d674cd4bc34f9296f440c84d01a69a9171fbd941fb27f99a52d817d1e03e99830fbb5bbf0b1707b0d0cbe80a7f010671ad9190ac30efe8ca39e26717cd5c7e2a705bcb17602c49a9722e9010a657ae490c76dbdaf8bcea7a752c318336e617db9817962db5b23a83df1eacf45ec2e22b9cbee8321d93f6a505707035c0f51d2521d1b6f987f2656f0854dda43af847ff1678867d74bbe8cbeabbac1b69cccd7a7ba8bb9ff08b13c95fa10b3e3e96a8a2a07e993761214d17b1a1e270caabca9d33dec01e610241878b896c81a5386cd8c6e3164b16601bcecba3894b370695f2d8cc8815b9651ea9be566a5928b60a5fa39fb5fa9de1e8b4e307cf039c23e00536aa40876b9382894ef5b7d4179c604bb76d3304ceda164cd49ebe67a9d6a748baf951c89801177c6b8a0918548a957a91dd036fc20596717e0d4ca1d6dff34136996b87a182a086f53f759839ab9c421d83fa629d8a624100e6a4bca6eb61e689932422cb475de147b3f0bd6e040b3ab848e571c26c93da99d303b5e3aae6523b5b0b2f13ae6666248b4954132a5b2f44ab0b6e4d6cb6892f4b2179c4897caa125b1d740346ef677768009fa5d6723039b39ad475c5d1041ea3eb20752f29f54144fa04d77d35634c0d5f1209b212e53a75a48caeb94790bc2ab30139b24accaf58d2f0f3fdbd934edd1cce346814ddc9cb0052170fdfb9763749876e0f973f4b5e8f3a612eddebe2d9f70b3345a18507bb7ccd422702f12d7d11d85a35c64344ef22b564b3fdde509e2a40f9d5eae8aff64f29fc70b77c515c0d4608265e4a29433bef84633c59be186283d8950ddb4e30395ed419941f47c3de5b1b63cdc9e278dcdfb48ee2d20ef3320046a936fd78296da55480a7457c547fca4c8f0f86daf6fb716e666a908c3bb3dabb75ef03b2ee290ddd6c9b492ba97e67c01b56e230629b0373ebe4e201155a8b568ab3bfebaa1a64f6fc20bc0b455d07ba4af7d7c684501365a931929dfae1fbb2caaa7d7cbf4b239ecfcf0091d048762ea4ff497955ef1823367eb4bbe8f3f71313701db2ca20736b89e38914bdd67cfd7d52ef1359d5c3ab025d3482d89b0faa9b858589799bc40f4bf3bb71d6c522106ba63800e44a3f2bbbc39758e40b6a1ff82b85cec67cb41d3d8083b0d86e61faf57e60a40cbf7e74696a5fbd4061ee14cf0a20f0ba62a5f8b84d563b799595669a6597f3a1d0eb58d597f8816477a317f06c26c7f9832dbb5607bcace3753f5545f21096bc1f3c196b1e02d96e370d17e7d029719c1f77ce8e9e0ad466a0bb2f2b41130c103c757585dc69aa567789c7055f3b53e63b6c4f224e44afc6ff2d4f0ac1c12de7755b7ef026e854278483340b67d8b2fb7576e915bcdd6305ce98f3d7ee80b42be9175a6a18b2a4260ea215a3d517c977d60c643f080b53f20fe3603a59f635ca80e9fade17b85ad77652c188c82a5fbd152c85b363a3191977bad73aa6fc5436433af9299bc47a3bda0ea59aa86629625f5fb138a5498648eaf7c58349875141581e5cff4b3a6e6a7646767262c210313acaaeb3551db58aa9a8471eff1c8350bc176092b19d9156505f0e2cc9bc12bfa1f6f157b379b10d612564ed4600ca5d0abd88d3cdd5b88553954b9f2039d45109d9cf4c5912206d6d80b6c694c67a584fba32b8558bbf6771dc4780058f350d04fffdf32907cfbba1be6d9570be9b25640cf85e90eff05dc7a786ad0f338cbe5eac0b121f8c899070634fde043994f7ba51c6b3ac2eda18b9070aa0df437f74a61955eec615cec6cc2de79a7489b7a3eee3a23fc76e0a822ad062063bae858ef8ced326c9b8ecdadedfcf9ed3ed726700ab915752ea311e7a5d3ff80035e4ccabf153e5181e7be0f26a883e10f5ee71f300b64cd81e920aab052fda4f2d224f813d5e0084d91cbec6405dcbae420ecdbee8d82147805651a4628bece9238d3da1f47b9205b7f17202a6583c19ad1853456e935bfd6d624b8d68758ac5b426c7b25b617cf9eb0de37a81a24138702816c41266de4221b13584aaa2726b26b74d557261b1d36e095384ad11edcef4357ba31e8f1c03f7aafbf597f4fa158f58c7a8730a3ddbaddd75aa381e9eb25659ad88efc3d524b4754bc187980062d04e1dc2c3f0b88f3e3e601c79d5c492259d729e0086cab5c4c2c799cdf584515c5671b4c22d93d43152ed36e8ccb866bfae9e1b9d55c9bfe8a3484f4807a80edfb3ca28eb720a8b668295fc18f1b11cb8c671585238c958351a2f46f3848779b01fc6c9d47a84980427c5827c086f8423b7f7d5e3097eae51b94034cb413f3f0bc770b5ab6226734472e532bfeeaf3726951f9510b59b01f54c195a4cc01c1106c5ecda35af943fdf859e88ec97d2cedf20401df54aafdafafc70dd642bfc89d0f235d0a3a8f5e89353ca3694e22802d8c5cc7ea72b3cd7c27adc49c476e16fa35713dc1de93320ab011c4b7bdc52c229fb9f0a968a819ed5b609852571200f8ae7af89b97421fdca78262c86cc2117a38838c74414001ed731113d6602f9c727cbbc593d0640ac6b2aa79c9f27e55778356941f25e37c28c01362bed9d3cb1d0edc1a80d85191bcfc1692ff18f87c9e004ada50fbf304ec77365da0954405f819ee13fbfe6e14b1d6f38b8ca9335845576395bfdc73c7c7b815b3faecb91013fe759d5bfbfde00630ed86e9b79878a26a5d5567ff05dd62e5edeca51cbd4bb207f1434de6f8698a62fd9a152f214d7ed08e2901b822d036c7bb81f913f10a8eef61ec98a787a0029c14ea2b24eb6ef701cc88873e607da37eab2f1259e8adc54a46ab8680adf0fab1dbfb73bfec879c5bdcb094c074625e94002f239cb247056410198140fd5fb24c51943e5cb3f9e716a8b82b101e6835994eb886359ce6897207855d1b6e59098cabe915e93b9cb2e0e60f019fdd58fd8c6a591455d3317c04d15197d4e926a3a16c674a93499f8b418af0ad0b67814708af8d355ccfe646b6fcab4827846b26dcd4c4e7a9bb9b4d357db256ef0e49572b61a865a0c35d54035d4bb2293bc8ae267708772245eadc9b2cbab2087fa21881c9143ff1a742b381119929cb3b45a118fb05abab6bd62717211fd668ecabda918bc7b8bbabf09646c413ee886bd0e302ec3e69e6fd2d00c987613b30ac92d30a8c038bea12ee4090a7491811fcb50a63c9aa5700716af9d99782810a88b6fe1d991a8a2190e8e9fb5a51bad1f6884431025bf3d01f1ffe0254dda723eb714d93513524037d2f0dd365ed73e1e54eca61b0566656b4f9eafa4f145f302573678c2c47cde497f396eddb27c320cf3b1fd80846ab44910b76cb3b58a324932288c8ca9214f155fee4e2692e7b24004c6a68d4227e7f9db3b647fd8aaa9d92f722e9831f30c22e54ef306c91be11f0880bdd72b735dcb879741ebe58d918bbee81a69b425d5e8fb74af75bdf58df1d3cfbb878125b6c0210fe521af51e3cb0a4f4866ae0530833506022ddcfd4399770899666a2f702","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
