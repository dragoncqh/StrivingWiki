<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0aad1cd398bd145114a39e2f6df7477e7bf919b14ecf8b7714d6d599b5d69a1d1082aeb9279dc2bd7882b23e67da303430f8aed4a04c4b374cb94d096acbd05a27c0bee44dc049488f1ee4903c88dc04d654b0fb1074442681b30c266202ad18aabd704b850e4270f2ac0c55ab31e8bf6674896f8cf9308575a1eb411f7e7f30e60d67ebdb727811032ff61a2fc28c18d3e27d2d28c3bb4fbedd9e6defb324168d2a326ae4a881eb45e275f2435dd4232fe0b55136b7880db4ac94700af8585c2fe6bdde2ccbed228a4777dd4f1020c94381577868c5a12fb57e260b045fa24c8ead3ca6af68dbe6fb1927999f6bd350615b5e80b092e970a5a88ec95ec53a36bbb3718f44fc4781db98bc2a39299fcf7222fc42280b76905b4571537b9d1ff1b9c597c2bba994918f70a70a8ab1d9dfc9c35c75c857fa26306f3fed22d01dbff1af0e54c59e1f14b009d9d394e7b104185d56d6968aa0b3c6072639d81bd2eac16d31ade99100edfb853cf04701ec90ee542c6c82beeff305eab41e244004188eee0cbb18bb44f817c347d6081bcdd890a0963aeeb5e1113efaaa2fafa5aaba9fc9914cb85bc7b2431c275d261427fb82a129ffac34eda368fe6a63ba14f0b533d7a3ce4014ca937cd82e55ecc809d1dd988c95ebd396b9fc06099a333498916ea16548b18817f700b2f65b33cf9465d19c2ef4e81f89bc444d4d1be2e6b4bb5e00d8aaef2fa74384ed13bc917589ac8d2b7c8b8ce637876032a91e1de72c59cb8c307af8f6cf42724ed77c1742751925ed7be9d0ae2e40d05c1440bbda3be4265139c13f9eef1e5dc83ae6efe381441bfeb185b50286dd47c5bcfe121df7031d59ac89af24ed0046774bf4e2bc5b4846ccc59ccf06af20cdd9edb03f05a019765198768e3a01787b43e8ecb06b19ac66e6256c1ad4007e347dcd405fea2a9c4129130425886c994d8be6103e4f955b788383beb3b792e5a73f9974ea6d2f2453614ddbaf3af693d3702b5acab152ff405cd50f8c10cf6b5772e630a5da29d82c208e764f0903242e7162c491c681fd45330663b69e6eff00f5344f7ab07419f315087d08eb20b7acaea4033c013dca3f9f65a521bfbf88da9d3ad42baa9ff21b503780b8d1ac651940bbaf70d3d83e0fe2f87820282a3fe5d3f488a1b67c7795def14369ee02c8d828e5ca40086c7b42c95fbe1ddccaadd7711b1e48d9e31871885e670ea0cb71d105396a34e1e5688b86f44a923b8630b7de3a9d402f1f9d9a3fdb471441347f9ba7e9a3528b023c9d633b24b9d8be7b75845ad452a6a7501f4bd1e21c4759914765a54a1aba68c5847cb47bf2ee8d119ed7d302661303617620d77f2b245ca6afb1cc423968011f5645a7aeecea073f3103755a80eba126f6dae0a9e2ed282b91a13f2c433ec6a62526fbec2851060f71d7b49e644b8d8e711ab3f606ce941487c968aea82d8997cf378319be5781301633ae11310427554365a3234e342f25619ee730edc6f1bf7d2bb99a8dc7639d10c60db2f1a85891057b91155bc2be48dce1286e53a66336ce4f7991757870f7af40ae9c2f3e98e022be12d8bf06a8f70aae757acd40576582d4e7a9b75c3640348b745358fec20a1abaf54abb7a7440f9c01730ee0b21b16a681c87c7e9a4293d51715effd15ece33d34ddcbf60764380c343ffe1cbd197e021abb9d8d04ef5c0a093ed9fca35bfe7e0488b98bcf5b84d9bc59a2824cbf637f3002735a11754cd593d24aa37b9de69ee594f391d5c34062227b094150c008d3365c1d86bcb1594676a7f6ac2a39f51e5ed255a0fa846577288ce618942140647886dc2fe64f14381f973a1507cc203f02fff24487a3f771dd3d0d9f4d67eb01981ba323cc771741c95e3f7e889eeb97080901b1ae52123253191531b3389f3f6243940f2fafee254e4893aea9e226fa570c516b89f9cc08946afeda75f58ce73355a165c21e7580fc9a89c1e493663efff809b9105d9cff31b6fb715413263e99828fd85c5853975ce97034d484be884d849fd2397378990d8f2fba51c3eec720f209410b2822c4c3f9ab2c28b30be44b8f867da784f0eb987cf80d1adc10926f74cdf51f0699918c8a49e40a1d491a3a17c1fc7390a675ae17517e53023e5148c4a12169ab2e28ea7b77a27429b9c331acd7f8cada6b09778bb14db9ecbc36e0e8a3910e8e43ebaac78e8fcdb66cd3187f781591b079f83d280f26eae008e777d0e3c63df5de913244e5a401ce53ab9805ec3e8086f9d70f9d1f7e630c644410a3f56fa5a135262e50c9300881bb7fd039ea46fcd04af070e754f9201a9bc4aa91023f55bc29acc5abef61c2592eb86440e0c2e1c502a6cc11d159113bbe2ad1ea455b5295de7155716e42913a13dd79069953f7d75d9464249c92a3ff3b18459212be32c08462d6898a7aeb2546832dd3ccd94ea41fb5e1fe69740d424948d72b9906b56a203058d63aac0819e2397c16d22f7d219ea151fa4ad4549c5c6218544f6068b53f0acc7cc0a222a39ac4876199d88caa72215f04003f4bf63b43c43c3e7cb94f8b4c622f2044bccac5eaafbc49079ea9e878e06952565796a8b7f91295431fe4b43d6dcd76409e101d3df3a1ad668a15d63247870b5af65c57280a64de65a0feb6c166ca9017d4d7c51b39b0045fc01ae4286200e630d7bba647f256846db70551024766f06e9a3a3827ed12e5c3798e1a42aa8cc905cb8578ad82653e15914bc96744f61e38be7586627dc4e3db9abebc7e065f0697716dd95669c6201b62c3f7fdf581e9840d2728e28e4b23573f1554fc98185620b9e89e0bd9d9c4caf2c2db5709047f903732356f3ba5da21d332c2d695a752142af857faa665f7bd63bf8cd68d945775aa1f0be1ca956daf23652d65593dff54be6f8ed3aa6b013089909a974e53fba9ee5ef4ec9d5649171045493b7c4b4786fb5f2dcc3ed7c6280cf6c02d266a098497785f18723f4bac5ffa7ea50555fe28684941ab3016d63e131813dd8610a73da8842b87628df8b6acdddb929f00aa3734526d0d559daeea80212fa440e36ae320213576ad342097a7b4071a73c860160795b6496c8ae526cede5dffb34f0481ff2e047ddb5f2b1f6dbf2ec94bc1041002dd716c4dc403973edb4b3475c4c165e5fb51823ac7d0cfd12d4584014cc222246e4a98b4d1b1468936ad0131a267fa8078c574b20bf4e36c76a06a4906825a639696e4d29014c88763fbba891d1ba69838ccc7b033ef6467237c5861ce48ff4f94631e08b0460796336cd2decdc67bf0c4eafeffa24b31b440900afe2e843d211fe20f42a2650f70b1e7d6fe489b0f5d5757941dc3feeaff0d36865967a864cfeca45c83571980d0d882e5b1f72e30528b738eb68a17bd7ed82d5ec7334b92dae6e89dc9f729f58eebe1ffd03278338142ed96c8c23ced838f880d9e361be9384ae4c8d4b66288079f5f688358f329f159754d3fdbd94c20089b8ddda4531a6bb9f28c6bbbdba522429b5f9216ed8d94b87906924a3de8d1bc3d58112327ebc1f7ae4022ce2ea180673b110e2dbcbe1ecd861982df43c7cc3717d3cb9426300e059c325f1dbf04bc1d7998dfb8ff5cc7d8ffe79d315db5759fcd6f949cf7572ee9111f7f1a182f58bc494d0be8af165cc43aefb052360f0868d14504fca425a90521ec299b358f4c2d3fe6abd3eb4002ef3b5f23e0d8395f5ae877f26acb7df61f6d767053c041600aee6cae25cf65ec55550d5625712598e2e834c093de5a55d7de52e974987683880363e8792f0c5c2b9d9d9d7f44549cacdabeb086c08742e494c103d2a0c65e8bc68feaf5a587e7361f4a13e0c342a508ddd59daf18925d01e45416c96b2334cee48c749a0db95f073b9573a7f74417535165be61430957a0d5cf7932049f48ae6891c7ea6b5cb273d5a47030c876b3d913e9567255949898e77e597d9cb1839d4bf556420bf4a33e2adea63e26a2520d2012fc03dd4847676edab57ae4549c7932ce535a21308af839162d64dd043f4966ce8c59602e9c18516e25e6bf436b54e62c05d890d3b9e6fcb8ef0f3a1ab60ef98c2d51afe44f8e8c4b784cb0f4748d2ffe314791638ddbd17feccbf81dbb986fbf331784676c6e212080264be72ca4f781d52f69922256e44287e1af6d855929328015e17bee5bf0a8d8ca6a08bd722aae96ae9970bfc4d802d966a35f2ad2bacb6e44e6d8a59a0064ea1c256b7a84fa956d81f17fca1880ac2665a59dcc9343cb5377427b68d0b7086a248404427c2cd2422ed0f4f59db87355e65575b8d3c22e1ed377de7e047b3cdbba4619c87ce7c6d00341e3015f5fbf4e1069427c643f855f44c826f9c95bb534ac0d47c5e6ccbb29f7573cf4c55941bb3500a76042fd9a9be9c0cc4e297c9547541b0e5f64b6b91858540951bbb6528c3720f6d13206f955249defc6325e580e79aee302e4670ae9e9ea33dd860f38f5d567d3be6439212091dc322bbd88ba73ff729e9caa4e9ea51680901fa71d9eea1c239795fc80daffad0687f45822319f292927e421038e2596dc715509625f1f1e3468e2f2ff84130da3d88a1f534badd9f0885924cb7b0a870f7b9a0411269698968a37900b252830c84d14b4c1761b51f3865abf4897a934488a96aaa992eaf12ab9d6d89df184a85912b8737792c8b0d115724f4168a5f06458964acce23e6caf341ef6782b8de0f9db268da527f77693d52848978ee417f014ec8fa3221424ce4a7432148c09636b7602fe49bf40bf1cf261c143352124229f2662e5f6feb285e36ad1739b457f4cf66c4b05c20d4056f9a4bf3ff02dc3936d1c43d88fe713f06f2d0bf8d66d4b8d663b9d4f992f1784d98dc52da7b2fae2bd3a66c7a30a652d8f3d055b6d45830880758c02a7c826d9d23d8a6bd639fd8a73d24b41208f0abff609ec02138603d08a1e0b35e057f51dd5659246ce7ac7e811a6fad7c2bc09442abf7e863c23b10040f2a46bf842ea9841657c48e6885c37c6b150e33d67fc8d48804bd370fcd382d214f607b9c4ac376071f589fc9a08feea6d5b216bf581762b749032555587df00475d854f50c9b9c25f6e79e84bde824f01dd21b216ada5a21282612259ba82749bb1d2573a2adc99649c5341efb7cf92b2049da3b669070268e71fb078563a6b9300f74dbea8c5fd98cf99c9f124748404d5f4881ee8e846f2873844c7c63101d367310b045eeba03a0e8408cc239a59b84df8577083686aa73d4462eff5b30d999f7b38d37806ca5e5ff95191115908b02b901d405f7690cf7f72639f4757af8d9249859c55ec8551934303eb557935266ee2b7b2f01eb7869666b6395b9450ad14d925973f757b103a66c9716faf7b1d6fec73c71f9517c90c7227ce3f1b7b9f95c0453b92375c6c7407fdc432fec2c515d2e09509c84931a0486481179cc083c60ed79e1f79994945752209ca47893bcdf88bc0f8d60349428d53850bb514a26bb793bd9bfbbafdbb639e17af615f9a99599a66ef20299f0dce838cd8d9797daf973e222e8f68456c7119467919c26bea9c93bd2b52b519c32dcab3de258ee2cd57fc466b2ec47407e802f99f0f62ed1ba70b6e925a6fd6e71c789ad13b2fae47a312ec252e9508a5c17b7702143c2f56b0733328c68423a2ba73d8f8dbca49d964f549dd514897259702be193a2b851e35c5b281f69c540ff7f95a1a10e002f427bedefee5c37841bc8fae04e7d0faf77a214d1e0b8f378fe6a05d59a909d9a223fa0fd476a1d962c4b91a80c0beffc55d4e1a99f8e287f6220120002e46f428eab2473791a660479ad92e1873e60a5ba4f73d8b24a28bf3eba82b49d1e5ef86bb42018c49cd942b4e1fa9f812550735024ae063af74a80ac10f30af0536e3f92770f20a4095347d27bf8b587e30e18c33cba981c67a44d70920a78389bf104d6124ea6db3abaf4cd11f6fc84654157929d556e48e45b0bff74371d9fcc0969154b6399d86d413d25b08dd46460ead056d3b3ee4535114748d52cf3b2cef77a96b489dc135a5e8d672117201ec4334b0ca82bfb6e4c75ebc3436c52b60bfbd2c77e4c0d96b16b13ebaaf1d26db4680bbdaf114c0e4a6ec0ccfcf033fbf4a1be0907b46b03678d3fe27ea5a5a1eefcb8db606e1a27a8e612e1a29fb178fac610c50cd5b9adb95b03222d57cb5a0f45d57d18651359d02ca44174d9ba1630ef16c3eda5d9989e640be2c27e3c9e74d2ec5227d78fadc38fe3e5aae85919f9e2935e642f68bb4239da4a2441b701526ac860460051bead3be051f91516d50f7176f419a0c4a799b2ba7824cfc82167e9b19f2559cd905f886f3be92c4eaf8aef3a08d7500abc74e21014b3cf2df85c2b1db3c8b704649a7a3ab203a0029bec16ce3bb37631b1036ace6164229797187d2f26cb6f69cc4cabae8bc9571b80f866863da940bb5921a6d8b8ca49f8c1644b26898133d16f7688b90c7c2dd1010cae62f2bdd5f53b367217f3a1cf940557ee41bcaeb2711264a73c20bae6804fffe69379cd98fafc9b49dfc446e49c15ce0b269ad0c4583b6b486172d63fb5f262d1a6ac748927a4461997d06b14ccc097248cd2c21314cd62c0210e336c2256ceb09aca7c6e12394b12a44c30906376da4cfb355844f165116de67e26653d17b11aaa41c9d67fab2b128efa9604d41a7ed1b620d235cbda06505e1b122f9eaa8f27a729a7b429df788bd1856729f212ce60806770336b59022226916062980404d19afd95e90d153f45d072f00b77baa27c547f880c09c25a2033becc700d9b2be90190d602a24ea3d0ffb71b0f310ad07f5fd467b4811180dad2dbddfac104d49cb00fec906778db7b043f072c6510a5c263634c69028db742c40195b37f8cfeb66885aa4c5503bdffcba29e564bce2877a9caf0b2bad5ca25d13a9cc9b430ed6b22f796167b8b68dd2b7878523d666dc513c42923939f12076e15d77d5bcfee7da1baf0dc148f59acdf651fd2e8296ebea4588bde24cd224682416f7921a97df6b80b6466f74d9a949be2f1d12f5c80bd188e229e4f86183ae7dfe547cc6c594872e4b830c2f53044ad0fbdb114549685da216f40f69d8cf02b2e4afa1c6469366c8a1f9284fd656990b8b576614d7af2ca6a97652d56d255f5eb3028fb6588d4e64976ff53d48f5bf039c4f42b31bf0678f9d39fb2b55986785c05e5b4cc6bc40352b5528764fe4c9604408672d8e655d399924228b70003cd79af10932e101d0634db1537aa4b683942af8c3ebd000cd17af242a3f792fa97e600705a2cc385b2097e2e9dc4d2d77763c4cb19aabbae8174f45d7e98e51929a65b1e2fa64bcdcaa18f006a3a374ea60575dad2bb61bc5b56c9c46765aa6270cf493dc5eb5c94baa821e8481fdbdb208b18e2c8b0906b8adc56905cfe1c4db0875e75d3629a56e20b509310972d1415ad6cb83131c52d0d196b6200afd5e9981d3a4cddd9146e1ed791eb80173d2e81f068d3ef3c12d549734161040b91dd0d2d22b9b4cb16a4f6326d9041305fe9bc28199aafe788a9a30cfcd71ba5c5b1967eced3f237e22cb2931eebb39d0a462f9dcff283dbb5eee357f0eab5fe548e11e2d0ebfd244125a08441e9150e15268d9fd7567fe5fa90d7a648af5ebb79f34dba495c6f8c999fb372e3dc8784ce18613297abe9bd65880dca46595c767013b4f02ecafb1f8d1630c68c7ef25d72d90232f990c900d878eed15e2ea143a5efb2235d5e267cb8016796e7dae0b2770f6664e7e8b5fe37b4c018726f320b8de23a5114658c8d6f1ee4c0e2c31ce64cdb32c4927a851009e93c66dc38ee640658ffd3bd24cece42ccd32b644b80bc0b6093829196b899c15701aea7f67625466de42f605a1158b0d8b3e1c3f27628ce96af12ccc9e872e86a601a723255c16d3a9a0a05d01d417ce5130e978aae8a1e2adf5c246bf1e4d5bde1e20bc24796f5b016727ac5667e2015a2fb7445d3ee5559e80244e4e745bc2414a4b1b197e57886d1486acb3eb21280f1ffe10879f2c06843c9d7ae76482aff874d8896419180bbbf050257fb526abc72e797d4e17456bf5f23468e36d9518db3d505fc06ae366558668528277d7aa277b66f86ab7b33377adccf14ae68ed3d763d105f2e801fee2c2701dbaf2f7dccffc9249f607fbbc6b5a8b87d663d4fd95b72a871a621810f7e0b42314de49852c0082674cea9106756a77f69efec3bb86d89905d7f7c55ea30f58d1c3bfa044b8eef659b2bd5a6ac70443ae4093d578c9256484bd9445f4f31f84a080630474bf327c015a09440254e4e871e6516814773bd5f3bad66eb91b8098d5a38c2198aa768e05cbdd903235d85f386b66af446a1526823bc49b95a5ce6fad653234cacfd3b9d83e9807349181a8c35fcfc55aa552ea714400fd1b777e662f5097dbe04d5111c659fe7244b9c6fed0ecb2056240ba78ae97e3d5cab3ac2178553d622b66db1ce63e5cad6cb53110383dd4715e2927ef0346b689ed904f0847f614fbc6ae14ea911c220c1b353943ac1f7dda3803fdbd18e5616ff6ef4ff6669b09a38aa48a09d120004f5086eb4d0245d8b863ce504a3d06a3a4cd4cf2c07c9695a2176e2822b33e11bce24db85fd01f3a23cac908c91e38fff31e00c375b05d5775d2c40bbc42ed4183b707dd2e112e3d07ef0d2fbbe94bd2c46f2aa775ea57aa44c615824633ff9a8dd66c63a52011b3e2586024721dfb0d3ff57d0c3bf045dc805a5a17a986f1c52883691fe49e45b81446438c6f4cecc828d6c59fe5eaf9c44362c1699d1484de43f16ef349680e7b557e18655550168090d7e08beff6df90fc3739e4e34fca9969e9e3aefb3348a8023b2c3eb3093e2c4a8a20f3dc0c443522dadbb98f7ced8131c83f94ee65a0cbb218929d67ebd785c1399b05e6783937426822eddb2a7e913ee5cb7b5b6cdeaeea8e3424808cb88fe290df1e212db1e069005cc5ccb60d4a4b996a5e3a3cb6531929605685b6537f165987a00631d248385f78b6326fd500f08713042d44d5077918ae6311013ea6fe878ec1c0c9494b8933af69dc99a71758a07c88da4b06c7c253c4e4002db8b3f41f484d8ba768b815697adf17f7152ead267b3f5ada9ee4f6d6d36219958f2e6aed7c19564bbc1add35eb29840138d954bc02930a7d29c060e2203f62dd2eda8d5bcb0b9b871d79be38de94cd73d589395ecc386357a34567bbd8f69a576e0b901986fb24102cd1241c321da6505b49a26614571d688ef24e58e54801bb35439710d4067fca44a99d7e1e976472664c7b01ed513552e7fcae4ba0d292a79789f81d6e8d9946310c64a8eee125a6b5e6c835178f6eabfa9bdac586fd84dd8ce649a485940b77d743cf2f7f942f592b99731b5359bff15912718effb4c968dc2f195eee594d48b95f23014c9f2b605abf0dfcda2f3e09c3394aa0031c39ec5e7bf52914c2a0a23fab90af2747de101b33716d3da0b9f1b60c623f9847874fc369137caf7ec4ec90a08f8125388c36007da3b72c702a67051478b853b8bf67d417e02a82c0fb89dcf4408310c1d1144ac4144bd690924ce2de13d77332954c9cbf67188fa9bdbe0da169b4d842879b048e49b3390a0abe907fda96223ef81eb1693fe9bdb650fd4fd7b8d70b4c7d89b0d0b7a109fd253e670afcf9a017451c38f1d61675b7297d3aa97c9f175d8bb020dfb10f8d3955947cddbaaef13f6f5c89f46162821da638efd655adbc614fec7d52686e84c588839f6c551eb32d53920b71240b28d3edd5d505032e8dff410bf7df378de2f00cd34e7f371cea327c6c01f15869ca59ed8cea11cbd29fb38d40dd3632867204ac5f4108b2a894b6fed165d87ad961dee1f495386ee898db09779b2d5a0e8fada2e98f933cabebf0f81b306d28d503080796f0018a8633233203be9d259fd5f06feee3a57109e271d748c19ceabed15c24c0bcb76a65db2fb94e95faabfc395fb0c38b40563eb1c26039fa1c64e66de60ceb185734e1dacf710332f7267b4e50fe2bb82c5637a0b7b4d2b44a5e9ce08f6f51776c20dfa0a72adee815ad0d6b7f1af27788a653e11e5e4cf69ef75afda0466db254b2f138bd0d7dca788cd1ab526ffaf94d9e159bc18cf9fdbe3f512849e8ae51f55a897ab7dd776ddbca7dee310b43024492f813fc87629e30273bcde072719564c2b3522bb567ea317377953e716f8a197d41294b58cc34d36f25115e6547588df1a21c874fdde600c955fac1980c843556412f3e43884e2d5ea9d23bf51a2002d41fd2ef8380345149ae658f872ecb7d17906deba0b80fc610564219f63c3530dbcc8be553686c829a5bd07cd11458694cb7779dff0298efce27b81af4c2a25fd3d20697739d8eb756b4b3f20ab37e60293aaf027b5e5625e244b571830a8b3386e9485d74bd38fb31052d1306d6861ab80d373cf1b9564a78326a5ea568acb8f76e38ed40b54491be512f4ca8a01e82ab868573deb1f0b78bfe6b77d253c96fc5efba1bc4008e05060ad78522458fac3ceecd9aea153725ca66eca40012f73b60185976c16d6c9e64d2f231b5cb06091950bcb30755751f8d491233773fb5d2d60fbe6e446ecb56a3f2fd648477696a54310cee907b907616a9a74f42bfcdb5ae1633ec9d7e59b19ed9ebe0d75f2ef25dc0f3f8099c068221cee9816c9418ddf572ea53bf16b1786a44fb29645fc54e88beeac08bc693983558de27a4809191423ce178c98f5a73f631c986dc87d51e2678a321d4e9fcb51dd025c0ac9ef9d3c7136b9f5d652aabd6cf8d63d689655959c1bea6d8b0bc5ee7f836e1bfb19558264c49f7c2fddc44b54df493dab9b19e622ca2c7287cfea344bd3a21fbbeaf36938787db2ca00d53c646b5f9299ea04e013cd811266b38772e102a805f87c49783b269ad62919cd3ed554c5be9ef0143f4121cc6886445bee8a2a1792806d385af68a1d35dc4db9363a6a80767c952929db7be23b51c9fb5ec93f34c908f5a11c84d1e27dfff033ed81cbe8df911d5773a40d3128c6a592dd742273654387fe86cd3e5a5ee7ad13fcf743fb6725c86bd36a011df1f950210750e241a366b3044633bc2c17f020c13728f18f8b6e91d2a6055364f12c0f85f7271b6dd73fb1439f77367090328645ffbd50acd2ce9341e7aed6349fb4445fa59a47fbc6e2abc7da1491f9c7167d227949bb4676e8152c86cbf46cc3bd2e2872627150a6a7a5704fae8c7932c1a85f25e86df85f2da953f60db49f9c236ca3cd4df17b678f910678704b6a410fe103329b3d9b947ec09ce173c01eff655db7425f995392f544cb7f91edb417174e1ec56dd765c1ca622d5d508f2d86c026427ef8bb691695fbffaa2daf5f24216f78a4ff2dcc5034beb31f6b6ce06618f8ff6b0cf9ddac02c29be82932da94bfee503ceb665fb920ababc4b3afb0f2ab4670d8e7321dd5131cb8d620730c8e7c50bb9f64a9b5f89d237679056bc1ba240decbdeb612bd39e9fa8eff5da0c8282b7f4438617598459c167affc16a89cf94eff3213d4f7fa9e30e98a587595c3239511f84cefdd824e3d7c69b76fb44a4ae56032cba52947456cf6d9d3c47b92949184dafa3f3a8d39a110e55c437d60d3fe079b31862e59da8fe58216ae9e97bd1b3592404e482ee5c12af6aa4273edeec7bf2c0a6d006eefbc9e119c67278ced3750b678fefdd2c3d666ee6a0799990c4b6bcfff8a60ac82491f01d62dcf0a38274ed14daa734f7e918e77fe14adc20f57d2ec63c4827e97f665add65b5f09185e15a5e7679577150769b8f254d2465a74ab2338ad327a5ca6f4af72338390d68b0da9fb2adf52c14991ad24e0c33aca9aed978999f84b75d9ab7f5292efe023841922565ba225efc3d549c5cfa0d2b60dec3ae3ea6397bcb4cb0a7d18a96f9d37c32610b403a068d00a17f9b516dc93ab591c1d5ee1a80cd727f91bf7eb5a91ec5a43c3ce1978e39f5644fb55832db4b51be1c8e7589174881427b636093c3e9fee2c71eabab607538f509f727109d9147e26132a03b5e2ee1a63571b2208abab5f3462948c11c50e357a519775671328cbcee679c5b0fc32f215c82e31c36f74a88cf8f3ead7cb00d16b7a7ddea5d4d9c827e6a5ec5abcbe3f57b7047ff5cc54ed51083d97e8e57be4769ec5b6b06314d575565962a948652c282c20ab17126794b2bd97a21ba32b961a6d40040438edd876d9a2d89636faa99a0f660a02c6018e3b5af3639e9c55e9bbea4a666635edacb0a69ed7f6270e7734758694c2815a8b450cd4f226ec94247b5cafeeb6d100185f063c43b393b32619179c8e57b510383943224b7992041c669e602381a33387428a5bb30674da3686558925400afb49c446129888c0c56abd174c28a0480eba006846dae0e6cb6098b210bc9677aa5fa7111ad826a998d7b2b2ecbddffae6d582def02544c8e664fe3800c2400a8d97d1e0564c05dc8429fc5946241a12cb01aafb16a9365e4c88e14e5056ad9bc90084f5316cd1aff525cb48a994b1add38bb840f685e17595f284cb525446a01ec48bafb37f56761a2e032a4d5415572eb4dfc95a20cd67daccc026fcc0042b7b502b9214734e4f8ca1614f7b946596cddd1de62cf7930ebfd45e0bfae20df9a15eb387374663fac8f846c5bea938ae5b327dbcacc25bdbe1c0a227ee3ccd574f8286d8cceaac7a57c37971e3c4404e2676e54bdad08b93e3845a9881e89d2c25b5adf05555af2260a0a7751ab93b4979282677541f610cea35e19b88357638b823f389962e28a25a90f7d4e6f67f8198278e6e6106b6eb640360699a33aaf50c60cf9b8760954d7e0fa8ab65b7ca54de7cacafbd120b335634939ca4d43b3383f9b2e5b84dd900b276a158db8ccaa6c4c907ef17567ffe7ef7ba736abfe40af05731c1d6d44bbe23ac9233bc74f2b85c6704222dc7934ac613664522cb3e418c59f0cdba57c5d25495f4ffc2ab922a8ed86c152a51a01f140ebe25a3ba467be2b7e34ecf5232920c10c4ccc4a4135a38cceccfa3eab72e52bd8e9705b7279360362f9ffa0fa2cf14830cf105efdf89843e3798ab1d9fb4587d19e80f3c74ca9708d17439497c9a29b8f069e3f0defc95701943b5a81bf9268429fab7ae8554c04c3ec8ccb04c1128f044acd3ebdf13bb6d1f91a8e0551cf1ed8d5a62a008e801219d33ae453ca499a372203acc6c53ac8da21ad1fa363be6f267ad2a3e82c70aaef252225ded634b4545f1cb819838d89ae6ba0f88b273848f512af8e7bc8226b5655464d08172eb3c566db002a4c562e8a382874477f55d36955bbc59f2037c248a1c10b1fe274f3649be6b2a3851fac2a89ee5afdfbe0c5f07229e4863f142bea2d5b6726d11dbc8dbd08cf2b0dbb0a7adf2bfa214652eb224da5d879844f6e897839124dd3c9ba03d24ceef8c158cd2debe365b33a83f9ee9c2ca17dfa9e74e1cc16c43c94443b27f96cbbc38e6be4a3a90e51f5b210e52e55b1ed09af422be091e2b674ce243d5bd3e2bd5c41141acf57cf7cb7dd64cc9414acd0238176fd862b857d84f05b04fcde39ccdf1db99f3f1adc2ef534ceeb1b58c6618bfd22c5275088fcf9e1dd4590c66890f3eebcc0e7e2b153ebc50fd6733d1e3a9475b1fa972d8967c9113e4316a26d370e665d12e53576e2ffb79d1f502c40f9c2c0ba1dde46137d85436f592e1b2b4b0bd646f65d6dd69624cdd6743a6fd4bbbe94736c8967d631de1c1b0d0b43c9096c08c74be97c5aa54a18055c4311c831221bbcd5c551531d91859dce41b7b580bb0de102ce90b4c2a62bf899f7b976ef8bb340be6f242720adf14e888a3c4af8741b1eb348b850afa9e90d115ffe66b750e578325aff6a0359b8c7ca5800bd7dd76b8e170d7762d4fc0a4ebece74bab5d66dc5cf082b7e175fafb2545a6a996ea23df070b044aa762ca5235f5a0585db692cf1e3c608427f4db14cb64200dfd6c2e7b2aafb43f7b512df8b3632db727fd961bc7a11109766dbf6dadc11126a659ba17638f51ecb33017a661268fe8545781adf169708ac603938cd20534e171494aef410ceb57d079ff92a4950f8bfde25b8e5b9bf21c048c5f50348882b2b06e6e9439620704c7149d8a66a37e7aa333283b8c933f06c88c80df79599f1bf47e1d585f640cd3fe120d128a9b4fe0ef72279b29e68d95f3f08d662984d093e7e008aac8de3852cdab0f2575890f5136ba9b81072b62712f5a96cea388d950f19bd7183a5e63a1c810ddacd47bdb08d0797fa07afd92da18894b1e3425b94af865dcdad5c378a37d167b871e40bfdbe5eea40de316fe891b2be8b38e20b330575991249d756324d1014817b78c32b34335a6cef0babfcfb6175613a17d73d606df344f6455199218e189a73592f467b80647877c87873504745cbd4dc3254cf28b1c03a831dd27740146fd76be10bf09025c5fbaebe88064d3caedeea53b34e265c84a876b0b5b9b7d60cb424deb5c6ed8bc1b21a1ca66eeb02e16d7c8e25fcc5d64ddded2b48b010bee6fdfe9d16901ed94a3e34805e6ac07d57dcfbc2ddbf4642c5843c6ebb3ebe15d70072d6c05b1bfecf43368669c8b630aa41e966b5ec7c5e506cc614e34d7736ab7517e91fc3fab016326b5ceb873ef0642884b562ca5bab99511cedfd6fd3347fd6bb752c28cd8c5b449178eba5b2ec78275ee647facc939474f24b8162b4db5ab91d9db109e63cec0bb76f6b185601ad6b89b95740dcc38c142952a9701c6eaed58614cdffa16862d0e6d677bb8c90ea9fcf8e01fbf180e35dec6c9df4620c03f6f3f7755104b61860192bb8729273ffcd1c4fbe3d5011dd806a0cf02a1602c068cdfe7fa9b837b58292e95ce4c4d04876c712fd3bc0d3f86166fd6a90e68af4227ece7e2741237cc18ff34c8a5acb4616b94c2493f41d5ab12b7ffe33956ae229388dcf91235bc6c18adc05d3f9da0634928f3785fa03e162836e8175c85d8659812a6f1846ec200f92e3e6cd7c7fde7af296971887ef8730677da9e61c999a4e31559a2ec6cf0bb3fbac6ff4d78f2fa57d7f54879ccdff9ff85f753f71697ba73cfecd9dbc0bec0f813ed9a9846ae3f33a9e227a94e80a132a4fff6b1277fff2c7e33837e497bc785104a17aa6c7e35decd6780430ba24eab718943347e3d892aa3d83ffcd1f411040e6e3d7d133a3e9e07184f760be300f6d1bf0dcf329676cdb4ef5c45a7de9a28148aed3d46b76dd5bdbfbfff37c34bbf15926f36e2e122a9117af4f202bbdf3fcd859d02a9d066fdfbc299609a2bdd0172780c42ca4b26ecb8ee5c2e142e1ce97aaf785f180ae4c6d2c5bf6811c39214f593fee57eb13679464bb6d557c134e049cfab07e418c6854091de5e4fe46f078f89cc41fcdf4cc5ce573abd76a6e087fb65bcc22b7c08497c048a444c8ae312af1ef2f7bb4aada8fe53399b18a032d6b6e539a7041e743a9186d05a784eba759a9c508257f3e781cd783ff64f6f277bff9e2bf44ec84c2d3496da7cc4b185cc620deb0a3f42e1774e79884bb1cd8fcebbee63e5ab0766cfedcb561702095fe1faec587509744d8000f8a56277d36ea8020a76f2f87209a8835299708a8cd486954208470101ea096fa6ae800ccf1f120657226fe987efaec4710896861679e6f16be647b7269fc95dba5d9007aa314b5164063e5f9952414e23d38c2362056ab5a0077572e363ec78185c545f45011e108eb4f8cb58a55c631c9ad176d8250e3e2c5c6bfe9e107d801d6e75e989d01c6e623b76466a095dedcc029df4e1aeacb8e24615ebfe1c62d5eb28552ad98c89c9885907a006b87648ef0544c1336b0dcc7227f90f159a38629dc582eee06fa526d816ac131b74b5e3b9b276d791198f09b1012a190585fefc8c222df23650f142d35f66f43a8b4ad9e315800d58c536af6c29ddce8af60eb67da4731b4613fbbddff6c966b87a37dbf24ef1ad9b56d002ac29613c7019d30830c6a6ea4326abb2e0a362a9404c999bcedaedfe14b4a4e86dc32fbcd5ad56f9136fa95c63ef5f9964f434a0ea04c6bc73ed87c090045562a073457f6450c66171b573a0c9b6cfafbb7aa9e0fafdd50b42751a19b628a2ea18dbe9b0fe4dd9727bbd45e3f5572e43dc748d6490f9df0d38df123bde7d8881e714f130fae481e803259d219fb118b600c3bba67f896b61983b5c36cc48ab8d61b2b00ea72a58202325763df4849a105b9be31c9f963946452960a3a6e6bc64c102b265079bf6095cb20d446fe6c2a5a4d28816f69eabba597644efbe1b0ead9a4750c13d6f01d407095e9f5560486c05cbebb23721a41e2dd57bfc198dbc63e3f108e53f254ed4f0e3c60fe680eb55cad132d2b6a36d94cbf4b58fd851e0960b9ed295e365b1877b84a7477808c8aea47e3b72e03df17f69f0a3aaa29aa3e5d1d9aa98c9a87f6c938a893181163b397e819cbd6ebeb6fa7ca1d890c5b72cfec76426b01e07662b015e618e22c68424a0f6ee2202a4ce5f9b5c80cf48e984b2fbb5c327b32c2e90f2a39621db02e865369c34b349f351806f56679d5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
