<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4475525a22508d11d63c24d1f43828f04e6d340a1dabae51a001394854b9d90e4c1a1e4baec4d4c54c196bc7c0364a95df62daa2fbdec1ee897ffe407d6b39909468d10d8bfd8a25368a66330008302d854e09492d1e280f0823e7ec68d06baa6d8ff65599f516d3721347d381c32de0a7ecc932bb7c00f95c01be017178981e392f64df49bfdaea31add4c49091f795935acde23e01790957a9e448eed34adfa4a8e4de3d87bace1dcbbe86521f0611a3f996c9bb6cf3970b5bcb785e873f8f491aad01982c37301246825b56369df60c4d2194153c3f1a0285f8822ff271b68432c49d5b07f34bdb1e44fb53304d6d69bee802f5ef9f85c416210b92ac4987250db696b45df7748fdc1700ef7d2b86cd66eaac81f459a773abfdecffd0438dcd8c268c93b73a4b652e1775caa7db6df3d80e668fe3568e8898d2822b33452593140ae9f46677b8ea003e4caac823d8ef5eb38e91968b7b0356545a0ca20cf2e0a1121038cf752ab3f24d753725a28bdf2e5ba27710965e68ab12cf55356c9b47e785d03c38f50d3f53b672171567a6b106b20a0340b1ab4aa08bb848efffd9abdfece095908d97f23a01d3c4972f0bfed10a3752e123023210d45956848ab2ed0bda0a546feca8584a1e6e04bb917f6ae27ae53d506174eb098579aed2983ef13151d72885801c8dacb0a1c65346c9a3fe8ce22c5fb02e64347b19b56edd7b88dbfd9f20299b45e03576aea47eec380d78ee8f0c24b1186645906db566efd76260c6babcc34476c9a7ffc93786f2cc711073b5098a389778877dd9fd97444a2761931ef3f3525256f8aa6f45b158693de976659791f52a5bcdc0beef0fe17b4c85797759e30a01f29bb37f6be4203ac0925a6a06ea0c5d7c7bb0c55a8e754cf629f829697e867ba464cd394e78d79b953a4dcd86b1290a498034b1d6abb6c493d406950bc79d46cac4ae5b6321c7239ecc25adc2cab97f1631898802eaace6391168b52688dc29a96bafa0cae44d89f89ac52ce17238e4488d2477d44982d460b6c7ef863ca8d491345af9d1bc0465d086e449f287c79f6d786f4fc4fc4adc9ec45e407a8267588a598599027196e9191200302426bf0ff428a8db1d9386d73fd684058776127e61833787e79b399c8c0320b61f548668234347814905930e11ae1cf90daf61597cb4d4d9f8908beaf4b0d848ded9a874f832a3340433c5c224d2686dbddf8c772bf051260299ec90908bf9bc4dfc1f4b7d6dab9ca281abf4544dae60875a7fb504dbb36c9cd98a291ff3b1447c868a5bdbbed07581b4fd71d2e0c546d542828d48ce12c0d889ceda36793a0cce745413fb8b7346601d5ad0c0f139285aeca6f5b130f677fb2b557a1292937d8cefee6e7ddcef194bb069d9af31e19d8fefbb96a32897382c206eeee58c62da0be127d22d7874f7bb29756dcb5d9fed0293895a71250dbc102f4933298443604aa979933441ac3254b30e18bef380612c428663de0b7371654d4eec64d5951acb5be112ba1f644ba2dc6502e8ca245d7e96b9902aad06ded5e99eb104a290ae62d5e2681fa568cc3a8a982a7b3087b805793ba4ac8be752b0577433f55003cd57ad0244588d1b6967bcf2229e2c1e5be9f89e8edcf5ce8d7722f95a89505537577a737b6f2c0eb35d229ab5209833d9c75bd92acf3e4ec66cb4d855a9a260eaf72b0e0b4620868d0c167260fe65f50f3e3f5224cc6159ee8ec5c66cd1fc76ab76a4ff33317f0a8de44caf560c55197e154649c6db02c036588884cdeadffaa8f82f5ca2f74d7d9a572d70dddddaa9b1fedc6daedf4d1bbb99d5b9787b3eb7142a9bad21b8b04700fa8007b86ce73eaa952da5d46f65e36dd44da15e89a74ca43615ecc2e01d53fcbde429763fabdc7103828f587d86051c3e470a4cdb30c70579a2343c4c4c655dabaf75d4e0ab46ef753d662f541bb6738b6d466c75e8511513cf0a2a94ff8a2cc5b8de39bcb8f44fd0b7f5d4a38b7c1034427cfb9cdd11c3f1567bb6fb3c832ce40ee8fab15ed4627f076b1d7d09edc3c38f91fdb3b167333099065d9b349b39f65b7a2be54fc9918d9e5cdc016965141d6026329d06b328402605281183a160407cfc70dfb777b28fd9aa2044c1397d87bc2a33768eb17a1a7594bb6db81f7edd7504ce8868dc30bf04f9d3ba5969d9735b3cce835cfd35f179850ec6159668913b188dbe61af0c8d6a26ece7be6b5c91cecbacc36e049b1cae2872897ae6376b76fc62b046d25fbf1b8a5e7acb1cf0551cb2af3abcab2396dc163d8dd8ecf45eda2674af873c9aae354d78e1dbd68ff33890ab1a041e7de8ee3ac0107dfad10449888a8a9b509b16bcdb79f4eb5ce5d569f854a4dba63dfe8354c9eb77288c5d982ca0166ed8c2c8523b330c899577d2b27364c7fa61aa11c560eeb86f2af6dd2959900a847bdea697a6402bc6ba3bbc05b1606bccd382ed0074e52158a10af4b5f54d743554a5d42e07202b8c8b185c397640b2ed5cd2d1ce930d71e4fcb2c2a582038b4483969e73ce2cc201463f242b8d4890560bf96ade3944440c8cf88aff41c74d993c84f1f54e460f3848423e52bb552a6cc0463c3ccff9ad4441885aa6ee92b3e5278f92f19eb81f3b81734d95a4533ff7e6b32b873e0dafd55cbba0a0119265425b6d7a6ef57938d2e8932a17bc6046c1ac8b2d67cc7cefc5df8922b07832473b67a734b27de5c121be8787a067eb5e0dda3db15288f2938c2c976418c47485dd433adb4aeae4bacc45e30a3c8e54fa1faf2aae33076fd1e23ceca35958d38ffbd73cbbfda567de840f49ec87d053ad26f1e3634b38ed1cc72f558615434c65120e31f224338d1ed6d4f47f6bc714383b1c0271a67a8d48e48ce3c1e14d04e0bfe1f2a1c8839a87d8cea684b0c8e4e7e4bd9bda866f107b6cc798a53af8710c1f0f8a27535306c57500f2206960cbaee93dc45079414efccda0457a8a8b50d57083438e1258a599faa0f5daa8aab72adcf1c09d1c161b91d7a4a5a986cabdfe57b74913dfe3732fe1c7e5b6ebb3083c3176e23244a4b3cfce22e8d3b3b95c4c4d445b1359a95c8b89e3abf1fd07f50ea4f9256d45d0b3e9bc9f2b142ae21b383c8412c02f9ee456b6d12166ddefbfb13a76eecb7e481fb13fccefd294aadf15002ffa926c1a5e0e53a4ada499e9701d9e54a55e155bcb3e1bc64f5e189093edcc1321dfb42461b6a19773fe5b8e40e9a93cfebdbde80ee63b8f1971500bdb4a8bfac9405d0fee3ffcdcb79c6909a30d9875d468cd71445e9667fcda2b250ee5615ecab7b05db5081fb8dd21fc0d2df240bf5e88cfaf8151ca1c88b68e0b8efe3717b0a86ceb5895f5f2f06eadc9471de2c6b01db49deb9c3f57a3145ecc86bdc7a9907e8d5357912006648cd1e013092cd1131236e3b5d6650d55eed26df33edab0558983f792e6838106de7ac9f60ddab11ebb9a5bbe8474dfda3b6aac08e3967d8d282c5139a2c4c23fd7f712732fe523bc6e59c5e4c67721bc2059899e8369f5d00525c091dc7be4ea421806a4f0de852bd78041154ab90e41b3496bf19ba0660bf8911f2291b9d9c9ea5b1dd734e3b60cf6ef1ecc001699d17a223a9c1e6d8e69c7de9ce490987822553a738524a11c0ee077966753b6060b595cc3e85ce29aa6dbc4b07d8aef3546c67607f31d232757731e2144e20960dbec3fc941f76d893b004129c9b6d39485df338b1971e1c6f900d3b53d04bf4e34f56184abffde500451db26b16bee64ffe3fd4a203bb1e2b4df460b94cbadf8e699f4a0a08c6e8b7113b2ea18e2c7e25ebf0796d8b16a39cc660a41860bc1f33e25cfa57ed596c5bbe6263c3c708a5334b5a29f657c4d1beb616b43a0e2b364e0840ca11cc34213d0ecf10deb4dd589221df3703206224df6cdde299e03e87b18b7fc1cac3f0587ee2755ca1f16a720c392efe20339424be26672a1f405b4c65f8639ce9c074e801aaf104313f3856166a164a086d9e7afd1c9605c407b6771964bd207d46da813de9525bdccf0e46ab30c462ad283834069c6d9dafc5476ca19aa8e3aa21f6726cff55fc9ef07f54f1aa80af6cc4fc2578371de126cbd32b0107cfa3c62a0e1325cc34384ac32f66bf21cbd97305c9e5055e744ad62dfee5f656d96e9a35fec119c28ea1d7c6e1db5ba8d0e49b463c81a0cc964e15559183be4a1d42f34575ccaa48758feca692054011aef4059f591c10b188d65392491ce4b4bd2158927c56c57f1136f3a49cd182b451d70abe4b344b6e05d4f0d128ff27361fdfa711da3de5a76d8d09e49932f3c9cc68ae613306273ae85ace73a2c257f99d9413238432d78180dba81d84270289a54552b334e0b6f1f80af5432534226a5f0116d3273d2900224ca684f9f0565ee6a78657245710e523d68be1c43b81f7c6d8eb5cd8a99198b01fa2698ef0f1c29bdf6eb3163ca2c0e4bf4e665d44a7f0cbfbad58110d0b0f6d84b0614700c0f31332165b77a24a4b277c09783b2403a94839052af2f8af75428d49319dfdf53463ac3bd073452da77869e1fcce5de7ebef0c4a730c18d5dacf934f9043b8d862436d9bb6ad16cc570574f3fe9dfba45c2bdcdcc24ece74db6806821f859dc37a8a9ad3b72c9e2228532ad595314966ad3477a0781dada07f53ac7cbe908a47f543b5f4a9f9061e6ab6a0c5746b6175bda6cb5623131ce9bd3aa36b51e6e6a36214c47af9ef4967b52e7e5e20f5144d0cbbc45b0b8f4f66f00dbac72566a5a4726141fc77785c160c12acc2554d3f03ea215a9807f907c36fce6197ac2f9172fe4a4c59cc7712eb8ffb2a36e1673f9c78bd10c32a78392970d99a1eeb77202e6ef622f9467af1fe2882ddc6eaf77ba5c46af6d9fb8a5979142f868c8b6e18118d7d37e73643b57bb691e4f228f8d9daabe060640e5cee69bae67845f5dbb6bf302654da20c1d0dd1f2c09d5a127231be352ee4648aaf236ca36511f112832dd96ff48107843efbd21544529a392c8af663dfa0a4ac2110cbba8487907ae24241afa94eaaecbdb9e089108f08855b93ff6e3b2af3b9bb89ebc05f73e45c039caff232b5a37739b4b43a2db647a28886a0b4ac13e7c5d674ed61528de9ee5a8705e08c67151cd7b53c2ac8372b59462bcabd7db15d6b8050a4caf45bbc9d717663500ff9e307728b6b3017634724a74df70e7823cd98118b744edc63a0cf7135dbf47c74ef7470129bf5e1dccd44d700ce8936656f9bf6c47c57c9801876fdc9fe8f0f2a3266d0027ecac1493fdb2fe2257609a10dcd57c372ba28a077cea3e2c4a27b034db4514576728997b1433b15d0f6d313687714f424e7580724cc2e3890c60a38c08b447d52ae9b12fa7b2aa5f44d5a7282be78bf8f5b50be2c4b67492fa1012bd4976c0c55d89fad981dd219a0b1e16464980d7ee9a5615b990d3514a6f1a565abc5b60a3cbd3c16526f15b5f914c9919a8442d38f1c5b8a9069b78d4e3a7c2adc9d2ae35bb9be0fb877f23b3128fc2d172ccbaffd55fcd6c0511e2560e8745f8eebc9e6c519eded390c1522a6c1874380d31851bfd6d482089cbf2d91de9b31cbcd713804db0180ea9245759a713b538aa46935a1c14b422152e9c7cc0ea4086517af95186247240e1c4a5230ecf408dd6f164f83a8eea44447f1a65d4e0d8c45335d4a7d88a29393c5517a1ac813f2b98dc7679bfbf7802ab454214a415eb455c2cd5fc3abf3ce81f6a26e33eaaa67ce497ed29e5085b98c79756b4efa948b931d04bb7cfb25dbeb621655e50a160d7d74943428327b1a06d949bcca61dd1b9eb4522c2956d1fdd52cffe6e640c8e7ae1a9e52571f5804ecdd123a317b7357ce6dbfaa176adf985026ed75542b26cfdea570c2bab6fca8474703a0389b6d4be443162a3825d6fc5cb363d199f31938de2ac228034811412bfd77f7a3c27445f87b5b179eda011128f9b9bd967ae93aed94b4cae5efe30a7dc589df3823cb5819bfad8b58d2aa7482ae21cb554c2634567f327fe76a878b740353b845dbaa31b3eb8f435415f5b47ab680a24b7044220890724aaba1cd2445b74b68a257f94abc2ed792ac8e1f4c3d3f31a319279ff24b1a2b45f1279c07f41a255365bc22b23015d27af8ebd6f9f34b8b0e3d30d8b7cbebfd5c24b3ae8e869af405a052ff91c0f80c595b98247014fa2b2e3ee18d5e1de8213a67602b4c8ecadfb433f9ba4e689c9b592c839926c0d4797d4f1d828101dd777f8dba4b76f25d562f062e00f3d18ae4e93f84a1077856a8673570c4838eb90079e7661aac57681f621c27567d6c95c725cf87931b6d35d704a157381b2ac0f66931e44430b3786c33bc1dd13f5585ae372c623839317b4167428e8b6877f160d034399fd9812c54cbe191119fb5450386a4d8941f7708be3af67f58fc4b6b97e59325f355006ec2955de2c00405fb79ed0e9e9ca5eb6fb34669afc53738fb0af39ffcdec062c523dcceddb6779e09f41e0b45d52d5914fcc92f1d49e863cb39e54f0637ac0902075000b79916a5776ad1cb5d7f638b4b5fd0b3ac69129008eff42802686208b5cc47e9c78b949033b22359876fd788f8c122f1cfe49d35ebfb0db7085fafae65bc0840688edc4121bd3d0535081331c7f891ae05210cd4d8c99634b436f082498fe662ee822ecdc40357f281392636d621b496ea9b5856b301606b0ed0f474e506a111a0c8dad0a914b1fb22c6a2f5f538c1d0b278d7bee491157b4816b7a50347e48647a176c7c385a4fd31604adb6deea6d116cb779f77ca43539961760d5126ec49c9b6a7eaa95134375c30d9b5e2926cb24692fc8df3387d616375a85daf52349b6af88580025cc17f4a89315c789a5bbb8baf17dd535cbee8150beb19e66ceee040952522ee6b8c0a1172e2a13c953c8f3b036cd571af1dc262df44a4a592f26563266bc6b58d7bc9c1ea2cbc4ff8d6d05f34c5ecec4e0e1a75d02fcccdf3e92a3755c9cf0b1f6f08969261dd699facbc898182df241febc64af60a6286fede14848505ebe6d4c5f05d70f0b4924ec634cfb1dfe02e0f1a33449925992a00efb323df38700e8fcdbc04f06004d09acd4d9422bfb59c3318c16fdd45da0f647b2bcc48d8ad5c5bc60abd9ca072b0c5faf3de1f889f3f94bf7ec9b5df1ab715a65f56ea0154ab9d483e0df862194274cb86b853f89494d3ecdadd00fb1e8e5f6ab6986ebede57b88ae8a12cd07d28fe7d66124400bd696aa368c1138bc352b65af33e410458ed35ed89c7a5ee0ce679829cbda8a82e9dbe2400bf370dda68f3a22de978a7fea0a11cc8f443d5a8c02f528db06996ad7218d44fbbb559257557afd842bb9a8ac9b1d87b33f15aef413e06674618ebf70211dfaf9a10dc25d843055412ff97e3b2060472b35f281ac333b25e4eb4467c99adbc6b50e6b3adbba7fb96ff78ae77b757e353bd21e5c9a5e8f7ab443d42a58762ea473e736de2d0e8a511bda9017e26bda7ebeccdab6325365a9a82a3ad15bf23d9ea0ced1b05c34c8d14434b2955c9f2fd1107f123aa1dcc502c0d5f1b56b73f9acf1b411fa8d37fe0130c0f11b6afd745877f4caa1e7a9337d30f458aaa0f79feeb28f91358cb22c1bde9d7280de5e98fed995b00aca9209e039ff9b03f9b6567c43cde687f1745210cbd9edd59d6daf2a64dbdddd2a5396a971f77b3f101a1415782c8d4e80129300caf827c615b98026743cc16dc252108eb143d20d6a2a6c2260a3a57c9640fdc18e08099225053576c25c74e8dc639e60237d34b61ec43201e52c62a86abb34d798e5a25b81883cde75075e8e1b6c3a0871e805ec3cc28c0c6a0c0e6b141b0a7362c7409d9203085ce1856d4a9014c97b792fb21034a55b399dc004a4864643ce2244d30468f322f7c7e3e029c8712bfbf4a90abcc0beb634e0df46921077f24d88d8234d37d5d97920b07e5c104cc8ff63227e3c16b626895c8372c2a950ebdd8d6cae665c79fa63e8a16814f95cfcfd94d1b86558fe9b516bf3afe062c02296bed89c86e52a95ec66eef27ec4af0c24d5ab73d1f58046e60fdb60482234e0572582f260063d0cd47f986477002c85625e6e4da233764bea6b7adb7c2aef51f3d5a69880476a72c40e1a2096fe81c030a33d0e5f8738cbd010324bf262915287475829c2cac062704c2dfc48d884c0331af97609eb17430af3a19e45f8b0983d8c0ba2775ef40dbab6b041c3e53d5b915ca36042406c2d576747f4aef45c39e7ad2cbf81f126f280e7a30b4f09f4de5c61e736ca30fe953b35f4bd3ae57db70581d38d0111040d41dac58dc0aaea51ef1738beb6871d8e1a91989eeb361330ca73f9ff970862ab90a476cb4bd94adc2ac255d63368c946554863b6fb8aa7bf7b9fe79f7e3c9903831f84a869bdca2d10ba0de78e1628baff96388658e197ddf08060efcb7569560edc2998f50932a561a0513a29a7f046103cfab00c9d5449dae8aaad6f8c18c1d7f0a3e2b71edc3d9b71aa14780a1b2b442a872a0b2e5be3735346d773f243c820fbaf0a1c16ade5db781706d38b1f6e8a9cc89cc9e7c2dd84942eea2e8db8857f597a4384d84dc684df0187133761b430a28f10e90d1a5059566ace91a8a32ff3289133b90a8f732ce9ad1df9a9597e9b3e8885877edc6e11dc524fd77999e5f2505765d02d49acfdd95b1b7b2eef7ec3865c58e7cb7074274ee687c2d964e66223c320ef70aebbe0b52e9f06a2ba7ce7ffc2dab6254722c730af1aae14096c9c80d06ff5970c02cad43f891272cb60dd3dcef7b173f431b3612cc38a0101d560c14dc72cb11440e224bf527e325ced44238dc5fa4c03bb6eb0cd849c8129abc4b221c844a4c53415b0228acacfcae5f2c70b3a77cdadc5815c81d8853674a5ac6a3e5fe863be9ddbbd55a976bdaeb06523c875e0fd5fc1f2e229bcb7fb1f110aadda8889b5fefed41ebaa31138ca050cf4bc54e876371f451f4b8378c44ad02e270e5a8293ed4636b7e16677fbc25567e7243b21792111018aeff4349aafb34a56d691d0bb6974adf9b7d864cbaf778c98e2e2251d204895e4a881293bcc7a43d50724193fa36dc729a8e4f9594935cc8875e2b0e4e2f5b8c96c55c57167ef01d8197af33e2a5901210fa13048feb65919f43207e24ca094b60d68ff384e4b2e0e8f0973b947bf1169f6fdc588b9e6af1d0ed6b23f7b166e6b3ee78f8b125a4d25694c985c655cf24f3be0a1b47b2a1c7a0881d2c4a6e06272b1b4b6600a5232529a50ef8c118dbd1c2d510bb4f928b4d78e1e3bec2f5350817bc494a786f65ce0cb5923b00c3925cafa381d568040731e142494602ad48e28dd95a55d343c8212f1279064647bcf6128962b547af89f87e32041ecc090612060b0ea9d70f06bcf5e6882ec82265e845bfdc1916b431cb8116128677490b922ebade0efb8db131d67f4f77c6121a8230e0187f9ff633fed4ad32288fd72c4869b400420b2bbecf15e2559f10ce9f53b32d5de8980a3e71efeec1713452efc03fea6d75e71a29e5ec920e1e64854fd1d9e2e9b636af93309a32b5d33a30a3c4c241050a329698d27da119254863f1a1c57b85aa002cf6464fbaf1768153f22639fb9b44b2191e57ffe9e3adc7e6a5358ec4c09db4c4d25554a10f7467c462a07c34f9b8f6ee92df6b9c535c764e81f59f9144034b15cd6e14b85cd2e3aa8d9250406e74b960d09a589d2365c32517bd79c3b88e089e4b09afbd8aeaa570b7852dc4a78b3cc07673c43778a0e3063903760c7ff5227f0e9054824024d69b5d8b3d2145da65aca3de2e05970b5b00486d9393bf424bd58995139de985c9254dc1a0a23f428dfcba4308c28e05ae483096605d2f8c6f0f09178260c5b381044fa31c65ad5906e77f4a30fe1308025478e434749aae976f107fd40e404f4948da5039e57c84265ae92fcce9104048f924f74b2b66ef0f6d17ec2a44be6abefed028f6368319390678348a645b7dc803a7aa9ff32159c42d0054534ff487d6e84521d5f678f20b285c2e0821576fa1cb62effcd5c5c775aac8d47a093b035c80e5bf81b37095f99bbb3029c8f1c0a4a0bce58defa47840202d5df14580ce02594bf76e6006d0860e782305c61e37cbd83749eda8dc19ab11a0d5bce1feacc8daac5284a9c326e95c4d708c74bf5e12cc524b0a61be587cb46bd390705858730870c8c551871a7c851735fd7ed9edeb6cbbcebf34683f603b017e7105ec97e13450893d86c3664789107326c9e8a7ddfbd2c205cca438d3542f6d4e56f957b9623b3d0052d323f0e7b0130e4a24cc8d96599da341667fab13ec8fe2735d30cd17846619c9e65e9080f68ff54a47ec215873f495db51fb31275555d0cefb57367a5de125a19cb2927fe33d8b99da794a2ebacfd404bb78baed025824ad961ebf322d48d0936f9ef90a1eddd650d4b6d8da0ae76ef722f2d5650fb656b16b279f057a4e780c9000b889f18e47005ef1d41c71ed2520791db179f560a1568648de66acfa7b0951ea82699ff3d9e41e6b0b124566099ca89cb63202aa6e57c011297c03cc92a3ed663e7d7a78fba92e239aa82a90146f58fb871e0ea8c680d453c241cbc66ba1daa316edaf0d60211bc8292577f7ddd1669ed58ba185015ed612bbd6c2b50c10160f6a494093e4edbfd7fad95ce516d2a0c14cd5094b808b4b4ecb5b92038bf973ee5c193c47fd478ebe19122a4870af0ac9fa25afd6976e1f29b5f17963c1e29ff8014089098395dcdf94cb3187797e63e8f67227806c9aa3138b880f3f081c8af2ec51b301e9f1e0299fbc4da5dae885244c46dfd7495c156996b964db2af2c95bbecea931b0a0b8e3de3e799d7632be38b0d3245ff6042c21000c0c78c920b05d70771811ea0f9be988bdab05921c0f4fd009e66348c07290d756cf5019933809985d3b4c7a75e9fa5b0cf911741a5b4b71186b7c54568ec93466f759438dafe0cac96d54ef316b58b87f07807e1c9347270b63feabd0741343b6ff5b3ef630f0009b26d141787ab68d41aa9c5ec0e66453b17121833146cdc0a8c309e6d14640c28e0c66ca25de4f58f927499292ed53cedaf234f1cf59b1e036a85ea100f6d2a5be49ba4d6b5c1a321544884d8df361c6e76b60048fb0bf2b9cbd335eac9727387ec13caaea50edea5bbe352113d679f72857d55135aa192d049588568b0cad68fe76fc4393379af5a43d9a7d72d96b175b8e1b5e77ab85da91b730aa001533b3b1b5e1f7a8a7cbb045f9cbc2dbd915bd9843b26ebb54b56d55046dda3de6e78e814aa00dd0d6ca50d12ad3ffabf45c68a8a764d1a2d5c1fc25191cb240e5951f549400ca9158a670fe6f1463fb459df74684913921756e47d917a54989d78525ad047ee7fe1f12ec609cb54865fa132cda6e0e9171902c67de1e9eecc5fe70a97f6e9519ccd2d24f80bc88ae1330d66481f3e93c53107e69d70f0e9d20e75a6ee4ef8a7b60e2b2a9b3fc538279c07220a09e47caaee9d6a6ea1bf77587e1d3c9b68c9b60af122ef06d15d25f26c4023da863eca70d04327bdf65d24d12e8ecbf0acc98158ca8163d765e551a0c014337b0e3aba43c5d177ae9351f740e14d294b61eb2529a248fa68970b586061a59b8e5dfb77d6d020ef2298a0ee7f984590c8d58ac6d947562406e20cca3283da048888506a722e15787c2dc9bbc36e7640836efd97724f5fed4a572d8d36186d3bef382c142a733bbe0413f7676645ad6903d040de9341f29cd0cec6c9f5bd75a10432a64bf717f97cced85960c9026d00eba648df4f6906504595129a32f68daeeb843a91b0670e563096e60c154cefad8b297f98ca2f259d9c327594ffb8e4acc0dd4d604bb6b8d5bdbd22131525e4e009b2fb7bdc3e18ef035a027b8cc45613082ec49eb3f4e7d08474f9ed4f65d379b779866ce21d0205eb956e1ca197dffccb69a7f94d0bdf1dc89df9f5ac807e3e8f09e484ac6040240f786f5554aea234af52e2dd0d5593b4b84485bec7d4d90240a06b4014aa2211a123b69e6dc4f6a72c893fc6b3481922b0883a25e7f36d19c777ab42d85e661be33c6c4a82d452edbbdbed0d2e0360c58cd19ee2c83b07594c32a712eb7d34de676e4dafc8e8eab5cb8e427f5f84fb843c15fb3475a97cebf3e9da7a72876e3d8347113b8185a925d3f971bf6432c6be53ffb6b3618517a1ff1ce4288838c487b9f104e14588b717a643faedb343827226494ad695683e9531abdc35e03b38b7dfcdf525b83ae41c131e927d097a6bb9cf8d90754d0177b21af4ad06db874d4e2879946eb3b069f02232c3539f38e2d17d019494e1d50e4f5092f33e8ef9b8d24a0cc0e8b344ed64eebc82cd1bf974281da924730aba2b896c8e0c0d90915b30ed31914f0b705d0bd121d20f7b629962de07f3d2a7aa4983e2bf146d6877b9850f865d67d28a700a5b1abdfe0d7935c5cd8f74c332f313be9b9d60cb562e141e0f816da3ebd7b4002b30732bddede508f667061f868a385cf46982257e61542e0e67d0cafad85f6a242651f351f92da100586bcf9e844d7fe4fd45fed7830907dbf46b878a8577ae712f7646a525e9803a181d368a09f2c4fad6c5cb989970a072f716c7f64298e15534174b54e56b1bd0c47a839ebeb50496fe3f33e35c394cdd6c66474d7f8957927cfe9f759446933de796694c43673b8fd8b84d7fe87b177344924137494254d0a337c5f984bfaaaf94eaa11d14575c6335c5910ec6afa67f4425648ea63185d1b32d4b8aa4e81b081e2521753e58f10ce5f17032d3f65b6def31d40fe5a831a872f7841e35b9ebbac33f2e7a35f973550ae887f93ca4fc1c509984ffc1383f810cab8208b8b67eae4b83cbd961a30a83b0e3070f6b6443813bf86e5269b1d36411af10bb2e58ef9988fcabed319d2ccc6bd19b67e1ee2ef6324bdd065af03242a926c521b029fd93005a6e8db41217867658d104aa1227e2e1490e07912238294e6b0cf8cb3f9b29893288e9ebde4e543f6d54954c5cafb5945c7c18caf0063d3f7cd962a4b39ca72c2e65159bdc6216ef5fd5703ffcee1fd3bd28ca23ef44cbac347efd6a2b4e24db86f64bc0ca5d50ee79ae24c492416ffa99b681aebe77699b8191be81c242260aa5b69ba486c32dd7c648e99b0b5bcbb54c17b7bfe23bdb4278f2bbde93fbd610e9091228cccd10737ef1ebfe7cf80e91d127f9e6972e0b312407f78594d024a567e0f31fa700d9fd00905f140de632a6cf6c501d2fc091051c4d8bcb846160e3b04e0920a1dd39efab8ac4a4f3ed4178d91a5b81920193b0cc3828df5780a24e5b61305203e9f0619c011600343fb7a878196142794266a5dc7f0e2755ab840352df8e99c314565cd4a0eed2ad2d9fffb3431d4cef9f564953baea4f32ea02ca16ce47a1053d382fdd5e65ccae373572060d3aa0fcfa8209bea55bf6e410dc22adf045a2f16e785745db6f03fd819b3dc6083c8f452b54ab2c95676fc9a273dc0ad2481846fe33d0ff022f3221a8960892438852b3ebcb20a61e3ac696c0a3c0a606e6859bd3208d6f65c7a8ad9892d78114df8caac7ae7df6bfe3066409e69e3bdfe0ec00aa4363eed6deec8bbc2ada99f9a4271825a4c037ba1e998932dbb95d889dc8408d095bd86b3e23b94b1173af08b0e835b3b517cef9db33855d5287ea2a530f9ffe4e6ad61831582169c7f39181e2caaf6550021210c2141a3717a785e586704477e5621605958b74c96961839f6fb11c7913a4878b16f6d65329b95683e37d30bd4396c754598e7ae04b6c2230273d35e31da190f033aa93ceb8a516f43cbccbf32c7c1009e0662b575970096b8b7ea585ba0ed16badcdf2b5149de0dfeea2a40eca39cff6aa97a2461a1addb032402b4bfd24d1e3dccf2c1daf6372888e5ce06fdf152fe5ee5db26289a40f93e1284eedc3a76d504cf3946fa97afe9ece033d6c0909e11eca90b72a3ab785c71300938b4ee3fe39e50e804d1c8c8aa16a154f5a197367efe12b83319d11eab2f3386e4b91c019e93c7bc570826c95f9e77952e8b6f1cab53caf964edf3f134f688ebf07dba3970f5a18baa67df5722eee1d3de938cadb5816a8cea04b2946c2c9afbf5d66b11e47b5465a6951fe5a7b10b89bb403cc418de4994ca794acf4100d94f329bd153830ace4bc9ea4b24e27860d6ece086403109513b82078464389e0f029ecfbe0662c4dca46a08e5f8dfdfc5da731a02ee1fb749764eff4071480ce5c07e0b3ce86b307f11ea9380a4a7a9c99ccdc4b48575183e307a440ddd297114fa99cdd31b6aa6d365010d2ae700c01e02b790b01617cbcbd41d8e4f3d7d2b7407e826a15de6db4b43fb6ef7b5083537a6412621c82871cb49452bebe6bba9795d0cbb04765b366c0f8b49b8a04e0b62b62dbe5bff9af672ea9a5ae08bbb32f9c7eb7eb3e67b4f452c6fdedd4f0d2b029afd96bd80829d37fe25aa177631189043c933dc76bd4db5163adacf2cb4b15a3ba6431daaf747029f449b14c0f08827aa7fe77526032e9fdeb946d7adeddb0d156ce784e143d27d60658bc36705e959bcaa29b5d945989a527246038ce3b7781f7419cba67d5c9a6caaf2a9a7ef23bd71c3e2359314a69852101638a44fb3d50d13b1f0700b82f6ccd7f004ff52a651eac694616c308b00d1e246da4ca7ad19dd6410e0502e56317c455961dfd595862cc50ca5c87ee6f49f5e924cacb461f886bfd60389a87657674673ae9e695aa5a907c607d3d8dd5f6491ca3955787954fad0fa61fd6addfc5f5d39106126d0e2d33f858430b517cd976003b98db4e497c072ee9aa26e6d04c782539d8998abf17df1036b82082a1379bdfe0868ffd34ee4068b5bfb656cea04cd30e8aceda6172ef726f3da8148b82837d70a9ca66dc8d788554a72074a8158353058012e7910d15b86ab09c34e2779d9954a20d79c233b1cba1d06441d2f1d3514dbdfbc3bd37b73ca777e4b56537aabe52ec999f7f1dbd7c655dcb3c4d49170665103e8e26e937bbd61eca01dac386d2757c46bc154e71304084fc64a9a8bfb7a8d49f3e2202de7fed4d8c0714ddf954d58762b097e6f223d678712619be1906214df45e02861ed02045a6251b35863e538f294032db8a0cf03ea667c503ecf34dee7fe38d24edac88d7c5ae348abf2cff2cf50c269a494aa6d8db2e50f4a793605739efe989e08aa51c794457f03a39cf2faf469cf069ccb4c59256141379b93cd5c63fc2bda6e13df5a4ce84db7154d09b0ea995c1cf7d3d5fd61f04188f133342655d6cb9d1915cae3d233f33ee35b09f17335fdb7041feab2852320bf14046f0d89bbf82a95dcde7bafc23f31f2652a7cce58a7b84ce81ad0a3ff4d3547f6b2ea5639262fafd7424571f425adf13c735e3d1c847baf3ac53676cdf900c03934b7a21f945cf1c41f5ebd3f3ff5413f1cdd75369d0c90aace48cb67eab8701688ec127150e32de8369f1d8143ca210b6bfeb9462333028f62c7104aec54ab4bf62107aba7ef19227dd90337fc542104b0b1b3f3cea8ddc48bb76a816ad77531c01626b137b5f549d5f45e414a4d6d19dd995bd34e2483ae9d5f79ce5f232861895ee58163b21317eadd8a107718b31c481bc166442bf9c172bfa9af7c2ae1714e9efb9e40afc66009b4c73d8ffe9cf1678d5da2b92a9c08ae342d676a9fa4df347f7d560d175ca1a09be666bf2e5e32ee109c83f906e12204c40c3c067f0ff7282b9b0794ef8d885e27af3986416358bbb4dc166aa7ebaa53c8728ef41b6c5769e7f13b8404dfa4572f5450c3546609a3c885ecb0b887cc778ba6b4e5c9c590a4c480e9b19e27fd542505ad7652c9e1f809ce320e98a278a9cc90ce917335d409aab3cd5b185e1740519aa2285e6c1f9bddddf0293e5c975953ac9b34ab540a5cffa9b8bac732d1a9db4dc82074b3f9421be492fd174db5c113050d0bde6f33678695add3b2ec21d4f12c2e66019d90cc1bd6dabfe90a04c1b2f63018347ffcaa82f25ebc1912a92f8134457e65ccb6f7f815bec6099f6d26b7ce797b5c15837d8625b94e7affd29d75f9eaa3a24d03b989fee214ee13a7f06914aebfde1ecd0155abbddbc30ebb770294d76297ebcda26295622986aa81d706290c93787c7b9243801ce3ed4ceb2e8155a9240bf1167c046c5ddb0f34661d928fae6066f0863b415fb2629219a8e13f6b3d444726495a23350317b61ddf65cefdabc4546eaa888105ddffd4b7be9661c511d7472da3b3db611fb950ed1b986d1a1aa5301b8b6131d04655e71910e48db2f79b19605138b60f2aa33fcff9bdef64242db31502e7a483f959c78dc8f664ca6ccfec56b6e0dd79797dd16ed1f8fb55722e36495ee02068400bf9b246db0a75c5d37ae8c47d01bf3b2e2b91e3b933e5a28951e501611d19bcb65590b8ccecfcfd6d17468243a87541aaa507243e8aaff779717e7d27d5f2fc7d931eb46b1e13788a5bc5f235159e62038a25c5cbb9a78ae377b15227fff7a55fe8cbb2e9b00b9a1e587c3f5771c0c2209fb35217009280d0307cc93cee860cf63a3653df3292ef1ebd901d2ae2b54b9a899629d5fe00b1663d787d69a722879c81bbf23e243e5b195dec0bfde536c13e5bf94d6af21a01beab19a6cf0145c5166fcce4d25bbd0803ed998054d0a911cd261d3b260736b0b39ec93b98907b17c2890e431a69dee0aab952577e6e804d57b62b1cd32895bbb4e954cd1dee39ee259a02625a796304cb56985b00d56944b4b0cc425264df339e1b9a90f1e1bc5c065c2928ffd02e5638d7ad5b9b9f9e3f74245415ddd270a821229aac8a69548ecada35b5056e4e748389044d1222db3bb742d72176588a863dd9023703b7e061e7aa944bcc9b5e45895994cb25081efda73746cc4bc809faa1edfaa6708a3355d1b6e7ee87ca0f17118a7c70b1ff278476fa1ee96fe75907319b94377ca2d91a00f270146dd6e6ab1328a576c8a7b635bc881cee936c40b151fb50fbfefe2e606508a11eadc8aa2226f224330a86a499bbb47ca6526034ba1650ebd952dd9f347bff53243efbc2e1ba62bc381285f77efd9d114dd6eb1a09490f8f4abb2b19feb447899ab8406a4518f698a24c90f6c6e9ad299d07970260cb7f84e02dfb144df167009850afcdcf23944808484d538aecf1bcb68edfc7afb887ae14f628c83f8f716be618c2005c0c651b1f57a7e03ec47f1ed04f420c6ecfb4496443f95b99f39c2ab95314434c1ccb8a4903a0668a43528f0dc6d81cce7e4c482ac904faf7ff5bad17f1138eda49815988fc30761539f8c6a76e500eee1f35d683df33c9d774c4705f62985e261d4bc55db30aeed0d3e0384c5ff09fba303742a440a2f0e36e1599dd09b30f80fe1af2be0553ac2a0dc2635ba75bf9a72e03b8e3029eaecc02e72532a9ee7ddaf425cec6f4323e59a1126b42a0935a7322edad6154d31e879e4d7d07ce235a16c78640333be5d49504b5b9139c4280baffc85ebcf93bbd74564d22b0ed458c5c140b4c778bcaeb6ec31281ac234465648f7c4e2136bdc163880a5231ae1aeae5328a496528316833cffd3d716a4fae038b92b7144c3d8bfff5f9516f127e6042ee7ec32a448a871d96f75a30481b3f43c84f880fc2bfce2f65698674de9b895c68d1d03813e672f3523e804d2ee872ebb0cf0faa1bb04f39dee55960bf88ea2ebbf1e7b5cd65fd5a954b403b1e2da3caa2affb61404d1f7b97878f4f1467f9ac2b70901f9360dd13e545bdd4905980cda3d8501f44d6a96f7e3640b2bba1202d8f47571be6d4dda4f3b91d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
