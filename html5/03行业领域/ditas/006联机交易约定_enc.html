<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12650d5a9ab3783c083f3e6bd4a932d0b47c4cf6353fb73306782fd5608539218e323cf97da3d16b5dab9da7181c657424c22d530e4bf97f43e59b7168aee1105db4195c374f8bac345f7bdacfdaf90235300551c031800146e2b80ff7d6023343b4852d41eba60a0f3159ac3691f1c1e5865efbabf4c68c381f25712a56955e99b2793ad57602c3742d2574ca4aaa55062e66a65020048ce49220dd83f05ef4b407cf85f7591c248707bed0552aa530d7a6c673bf0899eed7e630b81b243220c581afffa795bef8b8be8f552b0e0ba70395dc5939103efd0c2925c280ac0da1e877401bdeffa8a46712a75ef693eb6517e107f180bf1b203aa89adf1ff1ff05cdafc3d8baa54b7c0cf18c89b09ad0221ba6b3d04aa89a8f2d42b8ae9d0e5768fb8cd8b1e95022bddc3bd4f9ecda787913954ed10748cda3a4dc8d8c6c715b2e2e9517c948133a2d714877f1293432b02eb5281cab4156ec9b6ea17db617dadd9eec4804297964e32dea73bcdc00c4d4e2ac7b2c052c13ef67c7d6269adcd1eaeab9da35a9f32b1d7f083c216c10f4653536cc8cce7468c666d22a0c0915a61c58460a7bfccf5d5f3e01ac5ccfb67eec54e05ef5a13ccd54c0c978964446d085618a8db0121cf098ac10f5d8bcf45fc61ca8512f365f18f7050b294ad5f1526c36b4be7e5b6231f1681a7089b12a791859dd35a8f5b729ba97d1b6ec58935acb3db5b2c7d4c3e90cbf784c422bfca8de47de3b276ae5fe81b140b8d96644898ffb6f5feb0cba7216373915f7d29cea452e760cb5b98846c4365f5905c65bef3ec2f9acf73ada421f4ee5a07a8784a81dcdacdfea9702584710e08a1600ff56536786e32244f5621b5393b83eb391f0db6a29ff7493da2cbeb698eec80ce25c613ebb5ad525b170904ec2e1e0c6a72b15d9530ac62d735e348d4df7bdee53a0e23dca855864deaf2e2756679408ddc18141d7da4509848663367a2cba82f4ec5d03cd8bf91fe442727da00c03c296b17d2b62ae237b16051ecd94354126bae2c138508caa6f3a5d2d23ff0f9d86a28b6468b839b1a204362ab559f95e03a25bc5fe5e5b2c47d76d2ee9bb225e9b1d45294edd630d95a327848af2a0a5f1d0de5af3c8c1f070730c802d74ec98e45069fe8d1c3f64306f3f3e04e55b2d48361ecd80e7e0ba5ad9d68ef773735628cf0c81156fb510aa79bb2daf5a472ae7fd10c339f9cf9d179dcf287e91bf5179770b5419057566c10fbd866b65eaf2f92e3dd7b4806678930a4a7a33c3c8f2d9c444bd197a06ff8485925a3f25a87f9bf675f6f9369d62a5d9e0740854da6df332f01240ed922457c63600d3cbe85514ed58bdd1dcc86abc3b22b5f84e40a3433f6e1715d685820bb142829f2f9773f324d01517e64c5c02b45862e3500687128a1a9d3fd180f567dbfd21c3c7623c7596e293602e07b5af84ab6eb6e69971963d33232b68ec395fd5a59f48d9d64073aa45d1054106ea8dec574246b0eb3c3a372dd2f0b7c217dd8edbc5ca4c660376f3d9815f58491069edfe435c0113ec616a3dcb7b30d9131cc208e64802ef37e9a37e5936d527cc940fcf17ee5417b74f83472cfde5797b132c337f77f68486454dd1e44871e880445903bddbb80596f1944b5fd1a5bb4187fa0b98d7d1bf7173978ea0ecb0a711bb13054f14d5ae8d37b14322868a42e0bf03bd3d661654fad6ddb40c7d7cf6921550e531447a81bb7b32210521b14f2e88f59fd83af625fbf1e16466e3f52fcd38353ccbaa1d13fbaf337183ee971a6b2906fe9e47d64054f92bbf6b5d53b4d6271022c3fcf8a8661785c32d48fd1710fdc9a1a36599c1fe7d5dbd1aa704e69fffa625acd4ebb921357ec1df07a77867da8da08525d084157a5971f632d53957ae6143ab26a942b05933aecef579463cd83773dd3896eda51b3d411272f504d20e491f017b883c4d99cbeadf85c4f5a2009788b486f24a392b9b4e7941b55fb9a303d55bc47f885f3b026c7db2fbe4bd732cb282feac36c9a4d71e6e9292b048204e5c9327cd2ac3d8bf1dab97500fa8d7886eedad0afb915da1159c28b16ceac073704a26776c212a1b59e31f2d30bb5d8d107803391333b9fd1f015092955ff49979abc1f0fc462d5752361b08efdc99c3ab8ba50cc9e9e6c1a02e2e044f92c59816932fa3fd8d3bed90bac0a3e7cad209f41e40e141ac936626a974da2a3f1a8c5cf7cf15386dd0c385752d2bec632db6c58f25f1b18ac5582dd97b057780903d0c91c8d2ede292f418aa3e8b8d5e645af209f3991ec5f3df670617946e43671b71d4508faec1a7f5b4fb6105f28f830178f854484800fb8c1127a69a5062b67fc214ce66761ef1507e9a7579fa71f3061328f5623cc656bc2854915c6331d43fb97091582468b431c64b978d42cdc77f091e3c937a5d295b6fa95a6ab40c5e9ca38c32050c305b2ed661c04ba631bf859df801875474b243eea4d33f6a79076cb95ac822aedfc6eda8587b77f8ac6a518a3ca4a59fa3b5e57806283234fe8b2e361faa0b8734d1872e88e358661c0c6ffd1d7ca69b4e315fb58d8538612f2450dd800fbea4e6baf97c054c52ebd3f282de60c3eaa2d02cf48f940d0eef3a3ffd398e6d596073015d373629dfa94601690e0603114a79cc736fc6e8cb35595aa76c7c17c624140b0bbfc3f38f3fac9e2d9620f63a7cfd43dd6dd2559195a5aa8099063ce6434c520345e37ec9cbb4395c623e8978edd634bc3673ec7229d36d8e41c8806df3ebd659a825006d000dd7c53ab074fd88b9fafd9968ece7a9e48f93ab4e23f1205bd2d958f439f027b4b0eac4ef5519310573e9a521cf8cf1779ef47798c86e337c79f428dba8e2736c4cc9befe5ef78437139d8b475c6f341c05933b4829cdbdaba2bd706bec0be8127df3fd3c6c5dea435a52747c1021c56e0ae0fe67103edf8e684ec2f367f106afffc42cee90e2b11e65751b2690db069c339413b07ee84c9f602d45efa47caaf74d721b72e3c64045ef19be4e5b5d6a51471a1f7454725260c4936bef95a00b4ad08c436aa2e7a245ed4a4cc12945aa7003d9509a9a8cc8d4ac173d24fe56b5c40f2cb4d2336f952044c8d7aec6ef3ced4eab024afe806f7c43c0083a4a4f5d14cacb9c66f23014d6755f07d9501056599f9a2f14cba55e125de6c325e401a82597515b60fc38b761d48f49703972279570668949b5f15ea98826b7855e5d31507aae643f9c59246739033abc5d30f2e71f5c6bbeb071b398e7816732066bae9e5b4e8c0430c99bfc7c0f2c199c1c824c01c1997a35087f4cf53f99680121507464c268201acab71601d77449ecaf8744591ad259598d5019bd6a31790b01ce3763a00d1a7d508240958e9d787292f673e604ced4860d4d0829122f760b7ddeb671aafd42bee864975d55b1d6dea3fb63d0d67a4ee2972905d25ff34fdd7fb7b074f2e13570c6e7982b5206e4fa68b8f291e0df7a79ddc3ed3d69092f19c4d267079714fca0248fd2968aa0af22a7aae82ceec783adb8d348dcdfd472fac7c60e54e8ede03de865156ca5d8dee69a1c233089b24f5fefd2ccf0d102b9ab0692cbdd92766e50987f3f84e22fd526fb1802e86d6a584c19d960a6a93f8d1f337010d011012db62995b2d2fd6caac8cac77e9fb82fb87bd2b34db7af1fef5e973b1d788f65c5e5ae8a9d8e5cd15c0c0ea9aa01930e8e191939aabc8262eef4ed29bde785c18a5afc721bd97d0ef528b369c75404fad7a45333754e2997b3b8aec1df61377ecca6266fed7739d982b1ac630ccf415aef105757d035c302cac9b59c811e50f852624b430830a87892cf747cf6109b0d76dcc6c2d9d8350e3719a001479083668a701da98378dbc02d9483397300d32abf3034adcaf5ac4eb3bb001075af1075423cd114646332b70fb7c39e7b046238f992aae7f445bb76208e4a90886c5545cb2e2fe6c69d46d7f2b53bdf41bf24f7d1e1da9bc0dc009cb9a6145e407760d7e914d87be4c271d1c5299651fd2932f98ee053b285c997a89e07d5b7157f4dc669de4622eb3755e6f20cccb006d4cf10117b083d0152f9107ff6b50c9c208976a8bd82a682f406feba8f8166a81b811a2b9879dc1d96e40432dce3274e081e1e3ddf0be4abe2af5b48a55ad704850ce3682815e89ddc7d59538b3aac39d7a797d5014ce619991479487536e6f343dbba49194ab8de97ea21669591c7f3c091b827fde438d04db64ad672a38b783deb09b2670d6990b93ccdabf82feaf0afd85053311f65fc2f8d6e08a480136f4569c683b30daccea5d5211ce52c017ee3b930905d671023bd427a519f07349b4a6b0aac59765c3f272af51815ff3ab072fbc95207740a799c1efe8bd0e2ea43281fbab4422bacede5119c159ebf1bd001d87af9cd959d208b8ef9443bda50912ee724b518b34443cffa1e98715a7904dea6c415d82f3e887b6896c9d2b4a892624b1bd470650d99e2da0bc054621f2a49f98b7ee0ce782c2c1b25ac91a0c1b57d993482d0de24995dd0187e7b4d33eddc0eb7111dea63781f440a6e4caeee4f6d818a165d7a1b6e09e9d516d25036c8adf34a1dab3af2d1afcabd544400c4d92cb6d6d9f3144c285078487bc15ee9df024fea5f4e9c3192043b570506aee6009dc33cb2ce54958d59aad4961af049c483a0ec1de78cd1544fd806b9cc47be6db4a3dfff79b1a0c268c1d2a27e2738c7bea216c4cb426a7842b5cb0ab5b3981894628c2484ae839285ab89d7646bf59930756347f3bcb6e40cc08f724120e8c6132fda695c379729a10ef93a7059eb9bee2be9518dc36cd214f33a66febe7259c6d3c6a7e77096354c0efe9af8a06b864b3b3582cc71fdf668f6fbbdbac6c080dc4c3b59ee94553808947feb56d7e5bec13549b591e7ef24f24b15c5691dfbbdf484cc5633c954cf3ef437feed87b4c95a636ec4c895dcd211ffe425c17f6ee3281730659c6868ee718bf3a5d58f14ed77383bb7d955954ac07dc2e8c59d0db246b5047655fc900defb66c6ad97b537f108464209bbfd6a87d9cb712783f2c3930189ddd9eee9129ead8a0a6470ad6df89fbbb5fdb1f1542a9137baa1952079d386a330b377b3b287faac00fa3aa0edf0721468be6ac692bcd6d78ee777161321bd6f7971c78582fb86d674eaab8daa5ae0efed812ab2f6cf25c0c6c023f2cbbaab7204f88de8c21fbbb6369cb65bae7d185899111e5bbf7b6acc8ac9003951c4d1b216d497bb7536bb5dd781a390074ec3c60d94aa9ee5d6ad1bfb5543cde43efc01d28fd2651dd3740e13cc4553ec505e0f22aa9d9e403eacce33029d41ae7a7cdb20a2c980f207dc19d3aca87354dfa348f3aced4c3b61fb3456f3b83c6aa02963ea9eb6334baf634692fbed3727657fd1dbd9cda454263aa87785dfce1a04749547df0f396f0a49af2a41e28d522bc2d19f646a6d0c6a89e2c1986d361ac92b497a8081ab9fe78e6dd27f41b2328b0fd8b7d14a4845fc8dbec9118b20060bb467ccb07d72d5d4b627e19564d07d83fb5fb2b336aa49485a95264abcf215090a215371017b63f8634dd6b5f128efbf39881cff50e189bdf794d5f68170fab426adbfcadbb2b8eaae6030aa1519fdb0dbb8bb764055bb80038e841577ef4377313b81fc33e0e6c50a1acf02fb2c46178e5eb11881071a9022acdc6fb0c186529a9e4c98928f644513bb675b706873953ce42cba4298521ab099a6751bd8cdf0d6cb819d30216f5e9a0ad00ddf5dccd1f819bee23bd8298955e5a3967b002011fff608a0e9ce558cd371426873b163365e1c72ea75ca9ea09810088bc0c32eed0ff6d5151e29cc35e6e2429c4d0cc73acde519803579e3e4b3930d7eb4a545294ac6b7b03e0cda921eafe394d668e6597af8bf98116d074a6b86d01c28867088be4749bdeb06409e7a99746b2c4df2a72a1fd7e6ee599bf36e1b86946dd8ed6390c0050a00121af27b49318990fb33d358076bcd755ee96ea87ad8485f0237e918f8b6d6563fd710e1ba14bdcf1f9762fcdc6b1c781ab7120246d9d2e26ecb10e7c41e6356ae516f3c6e49d9f82048247cdeb2f5cbbefe58abcc540d99db42dae280469ad66633055034d99f32694f67ec294234b342c2e16520ba8d5c60df90d8d1b06c7a83a021dd4a7d1a94b9b8c26297f9531fe02fc0ef4a19b57b49f0bcdde7cd612cd2903e8ce90fb59e41676133858d55f1f0e72260654651a34227b24d2b1e1ab92816d0adecdfd0e80c71c37d9d1ae96997ace99f2aaa578006413ff0a812199188447a7d16b8c6f07e254de0b06b412131a7e9544dfff2ac794cc0dd232c90416d0851c0fa3efe1c8e14cba2335fc7c69c520324d40489174977903604ff3fb783d53bf97f74d4017e0475f844bc32bcd00d8809da64f53a6c5b5581f1a0c29fca9ec8836d84be375e0f175d553239fc39316412862aab52c041229ca1c4d282679b4e273407ffad6abf2cdb360da7ea2e76f23ae9b51165c21f2693bfc7e7c4205e9b335c8c93705f05ebc56347e6c0f4150feee657b70ca82cbd4e4436b1995a38581ecad57fe66424f5b54e2b92ddcfbc1aa28bc7add76a54b804bc64d95d5f684a3785aff2408d6dd28a158c2f33a211f97ea913e40ade74b711ce7bb6e2b6b26e2b464b874a49fd1e6b2febb7b559bc8c4eea5694f8c3afd48e1f4434e02e5744cfd502717fda3cbc1d5c372d74ecd31c4660024eae43b50b1dff82fe6382cca49cbbac886146b7aa54d7686cdb529cdf586a27093bae4b4e243b6126c508bd13dfa3c1506c4d2e071a2a60f1a5b57155966cd5e8ad94738d719e5db0dec31d06bd38d0c8818a20c5cfff625303c195f3f86144943a7a50dad19d3699cbc16c3b84618902d0fb9bf8c4014e1ec5810918dd12b44995a1eac9362b665a02c54ba5178f0333302808132c587be2c48b4b65067bbdc8e45110109df8e9aa3d5b6d2ee248c088023cace686bedddfd5b177d243e6dde3c27396e3916bcba13bfa12299ef28406a637f9be92de41c699bfe8db5e841263763fdca52db370e9903d5cfcfc7e80c81afa58d6af100045e4536733131ea336b263c75f2a57ee7d8359693b77c78e1bdb45f6d210e4c6734f148e3cc276eb1055f00e3702385e6e87352d8050c56486d95e6abc1694c03c87535ea8db4b1f77092c2de43b3a1a135be1044d53b6aa156da7a42d7a687bcec15d662a6eb7218b1f15a8bcdd79bd043fa6e2474259571e5d98be48703b8101b620314d31ef0ca17d24c272055d6780d4eaafc395a9eb6ffd1914c522030923cdeeb2dc34a08031dcb6e6a1434f5136c4606a3f52c4e094fff43bbd4e54c95da87485b4aba48c0ac98997aa95cf664a7d8282cddf2620d531a6e80188fd946bde4dfcb544b298f3e613625af6e0904ed8e282054c960517de34ee17e70c60efc1065fb0d671d7719cf120921a8a634da78861638c34c2d4070dc2cc769a065799c5bf2a06ce40ae3c9eb1c7705cf56a874ff4a097012e28c644adc28f5acf2099934c892b1c979829faa705831963f9781f44ff651ccb92486737f06f8e3c6f3807f28d848f2abe5c79f52233aebe10d0cc716157a701dec304f0fecbeb3054790f0bee03868525a2f828f39e1b4177d7628e98092743241c72196cc9391d9ba411f1dae87ebe823a86e48c820a94f042eaf6d6e2c0965efa723ae38baa67efb8d7af49ebbfdcec0b77f7bc88bece9de825c210d0eb93d07c16f1fba728809f900656f81e31a99f4010ed8c0244cfc9daf18c0fae91b8b51bd21bad8e38fdc1c2dbccafe5ce19c9ebe3affca406aa4a2da6315d703f7a92273a2ac285e5f66716d5a2f9edb0da1244ce04d85fdd92726afeb5fc4cbbf1d062f6d7a72c96c8bd45247900d04779076ef9989dc8ea5cecd4e1393e85283122888c043093129d78af7440f0ee797d5839f741368b4bd797d39b81b84ea05ed070e27c272af36d9e70af0a0f42c8a0b1ceba711af27768ba0917961bd5cf9cf7964ee0b978b2788e69e206786a5418e0d3ccffa15e1527d7c9453ecdf374cc920271684f4c257f5e76009d50159e62b6edba98293700e3e65d4887dfacdf01c5cde7c828e1636cdd78abd2185711bd8439891258c67599a8393e5cc1db7875ea88cc826e300960be435a286e4c7031d5470aebe5767bfe2cfc8795ac48729fef532074e0ff85233501b356183feaaba54507e4c12a44879298b2671f9e5c11cb078a17ba801f487e120e29c848e7b6ee2a6a07d1556fd8c46289757be1a6f56edc17d1f4299c9d830ffadb26728b87ce977f87a58680864b2eb8f9c5687d453b3361b76adeb2cc8568fd74b1f212ad3f43e1f24245059123991bf4e812b81d73128af8a479b84712b00ab95a8f8aafb6a7a10fddfc6643fd05a8ce6f22e4e5e4128fab8e2f8602580612fe1c77b0cd0a88fdd25621e98f64c782284a1ac770ce56714bcfe61ea3bb544c5d5ab8b1cf344e4dab76147e28798401f1a05252d141d9d9c103892d2e5a768d6d4fb75c827091666c9f9e6272cc3aaad9bfdb1b7da3383045f7ddc65762bee5bcdc67df19fd87f380b56bfbc3c9b3440f0c01c46c19f395c459c06804a1902ef8cb2c342bc52ef21cda1644ccc6ab3d307e45e0e74de70ef48c15917eca8528c16808e352ecd5644c0404fb8f54fede999be0368bcec79ac4808d94bd718c506785d1e4224b8fa621b4fbc980c2183cd233c21f4d947b7977ccead287daf97d3b99d0dd32da6bfc776cdf94f20c2378a899431f49347483d6b27aef59fb51285aa7537c0e830bac16b5a97095f295a0c3bd21398d39b454fb63091dc02a6352b418d324e86051e1c39bd0c7c2def18d5b60eae92aa36957c1c098a7d5c22a3f4cdc1979f588c2cf5a0ec8e2b9790e1b100331c5fef1bd8d0ac6912eda4acd36f909d91c6dcd22e64d853332b9b03e109ba3a50d6e257baad9323f06c5ced785dcbd7b7e96f4f3d54e44fde95930885ed9ee44527b739f9cca6fd498d71a9d86bd714021294461f1f3fd8cd6667f7df54169d51bd09762c38d01c4cc365485fa9665d8ea1431017063544810ba6629e8f3987735d7252dadfa5d4f3da66f2118da7fac1fcbbc3a3768fb277e720098617b8f971e271e268afeee36142f4031a3463b60897d43c4fc1fc7219de0db2932884519c4a23d4e0c106326a8f7db2b6490e7d149176bfdd37a8003b083e1c2e44f43882b0a403e099e26c629e29f60f80215c6ff7ebde79e9b00a1d6b91bc270f38b374f635596a8f5ddff0f94d87ec236bf742d56a29f34225534590acecd1885e55eb5ef147ce160a43636079d5a59f3e94025776eea9b8ccf54d9b1242975c7980704475b8e40a8df9abd1754d27e2862f0ffda3a18e4812c5fc81609b4eca0d945dbce65b39c8835c937044a3e90c7e2adc0b1ada68ce18df5e4b659afb763c4c4b03f33d2e51afe81b9edff0ca1acac2276d5c769e5c03e25fedcd78d80e6e06a2c3bb32233c3f04c634d2d7d0ae1c0c130da473d61e2cdc800144a49f13a45cc82f56444e779508287affd287eb29c56b17804a9af442c3b1c71a6434fbe210069bf1131c2b1bf807c299962dc82cf47378a61cd23e973cc2209da74bf3df3167d6f8fcf4d3c4972e477a63adb74c9eabc7a95157389d59eb599bf7c6b099c536a3be7ce9631c53b2669e95262f35e4e61cba6b0900dd946650486ca1d46036920b6b69c35ad0fbd19494d48ef9ae05f0a0459628e2f03bc3a15763a9afe95387ec77f2c3402b30635759096eaa86712dd2b3848700ab0808cab1d804e2183c21510de168387cc714fad10629d6ba73ef3c72f3826a5ffc424c1c73e106eb72f0d885f38b1d52fd520167ad1d2d50bb72b7fb6d4779c39faaa9dc86b4882ecd9ddaef6a76b8827ffd0c3b3f13a36cd67819a6cd3c459f01d03f8af3889b6473c24e6e5290fbcefdb4a1e2db8248edf6236e70043762e7fd1b966e027c98e7f4953fef1d77de20cc3af771692572e60426f08b16999c64757d73e1d10bb74422913b004c008d3ce0f83423ebeefda589608b9fff3cd393305a2d79464f24a0b3574b046e93ed392c9db34aa4d1be0d63e9e6f85e7478c8d96ad311d17503d2c9e4831e2ee671f29eab213c4f7881262b18743081a31ea4b06ccef71c28c9b4f415d095c3ef9a0211d3cc973b46a364447ec804e2abfe7615de8e97be7be843f24026bd2e13c6b065af245a70f3af7d080aad3bb437c8ce0d71ce49a041caf999eb294c8b3e7744a372128bf08021ed8da8b59d1689a45b7245984f0953fdb515322ef6a75b0daf6980ab52cca7ef91fae8240ef47cffb58d93b8b74d297298b60e3497f9057d50ac54fb9ee30c0403f0b73e57765d70bccfb4b6f86dd0ad4dffaf75223d44e3cf9c20f5d2883853483e94de621441d512657dcb7990ecac239dc480c12ee1b88426fe609c798d63ebb3ede84ec403553b658fd78bf1a3d6323891d7198149e69c25e1229f8315426d35e62cb5e9acc5b0f0168f488eb2dc833a0f4cb886d48ec0c1c13a6df2cfea9be967092d0a19341f11d5c803583dcf37f22b6e40c78ef62a9eb96142ef7fb7e4395c7c2ed01f4614d5c72a74c7e687150a8a1d785f2bb27122f2101af5444274b9618db140b2ee187cf8bdd73e9b61fe9d5a29da72976f6e1adb8331633f863d87681948ecd12ed3b0abdac33336167aef697b51840bff296946f65a2d7b8d7d6ce3dea25a2ed913bfede60ae5e38f1ca05ddfc2f2198b0e11057128a5ac1344906f5f529d7f9355c6613c43ecea5f91932d00d9217a5bb7e9e7f3c6ff5d93586e7a52ea6fd392056922a37c7ed1a977cfd37a75b516ec503d0569fc22238520f8692868d4a50f07f94db79ff8a1fec22989694fc534cbdb35ceb556c96e256992947c23546081be70e74f3879b7590d18289b6742fdb851fed236e7af20a9d735b6e0b7c8e028d6705e9ab0d3558c081048559e008517fb48aa451b0649d20ecbbc11ccdd5d3a6d64533f198085c1bf826ac999f0a0e3bc0873f4e994c2f8db4f1c3a5c2516851b233c69636491981557c06df43b97dcbaa2cb96e7eead54cb77864452d34224096aa4d89ac3f635c1e2eb1213e8325ce8dc94fb4c222c6cf905c034f4bbb5405df21f22072f48b8d4a59449d2fcc5c82a7c2023f3578f728ed8d2d6d5c23589d9bae9f962db22d8aa28086d5bd19cbb04f7ba2b0bf3e7d78ebe7ee17121ed22b40a509aff3373aa0fcde110392ab88a5e0b27851491f37a2a4545b91ee1976f8932531d473812ae2d4e86d14885ceb2a24369923ea93fa793a801af1e47b7023e63c03032378cdf139873e63865b2aba8eea2215431fc18e9f928291d0fbfc4bf201da4cc626de2884d4aeaeea659ce159123846fe678ad41ff958327a10404ccb182b5801ba795023f8bd27abf843f4679e3044bc0abc3d81688a470f309de841afe4ce2e6f9aa0b5e4bcf20d8a95fa83e0ccc6d957060f804cce466eded38ecff83dc93a3ce90abeb50ad851bd01d26b2fde1855e46c931e4f9c2266f484cbfdbdc78637548bfd9b6072f4694fbf6f27da4ec10175bf1fd3f310072ff275a1dba227c64d715abeb0464696e0d4eface0a923b961f942f4fc2bf8011d8a01a01777ca309147b3ba082229ecdc70b0778f751823655850182ec85cde9cc3f2d57dcbae6b8f7de3b4c42e71f2783f9e64613d02340ca3e2e8b9fdde60e33ded1e6bbde5fe59285ec970b08aee7804d4a1b20a73e6353e893b1536cd9bd83d7ad8b17a5fda3dde6b55ae5d19b479a7e2e7ffa584c6cb5a22cab0cf4981867899394f5c98ad8a2cdc2db43a4c24f43ae735f35a67600dce8651a4576edae517af47a68afe40d59e47e79eb383da6aff3daf2d4ae3972dce8c5b0cbc220e23d403cd114fdf50d2252a41a9ac6cff4718649ab6a88391b6b7565c47453624dfc2dcd9406c0cf316d7e222c15622fc0492c4be9fc325677a9db0ebffbbb0ccec8565e41b1a9c608f02cdfbe3604eefade212670d928b62a580266b6a8bddf26d44b2b4ddda043b31ae1a8a84775a2b059102a8067ba5311162ecafa97f7a9d596e75056f5f1aba5cc190a57a82d996405f7d97480429072235c1047bd20c9221ea328af035f20eef2009b1b674aba32179a615e002e96c0835bc70255d4531498c72ed8a95654eb5d93a9147a68881d8c0cce9653854051f8cd344def9208e653cb53591b92533f2165958966d5e111514c82ff4aaf11792a50ad193a538eacfde4445bd44fa0aca23bbfd0b5ea0cebc4c9bb4a41e1e46814b298a99974db9b81a1079d1595e57e95f861a1e0a886be44af12c5ae6ae4898d2625ff916ed49680791bd02c557fec3befbe9b756786224a5cb15630ba8bd882b8e0ec1234d27c6913b44ea49f30cfd76afc2a451ed233af2d3c24be5235b6307dfb7e7f61c070fabfd2eb0b53ec3856f08139ebc36ac3e507e13dd996bbfac593c8b1d4c21b7e716375eacdf5778bebd4c164dcdba7144cb3b5719cfa6fff00d640ce6853549c1a583ede964539a150fda1855789c7fef1ccff994858f752941c08f9b12fc4e5861bb31e97f75496576d13d691f810829328e0bd1de5cf4b6f3198691a17906ae3a443676ab2efab82d27e090574828891268f2d5282c9cdcde806ccba67d6a107dcca24ba7205de011e22711d82ad6c99f549168be381542640a86a652f796f9f166e0f44d80fd918a354932b516d76fef15bb742196aa9144cd3315ee3724a85750aefa1bc2285097b0928394bf6f0dd43c541c9b4dab7d75fa7980ab893b9d24c24d30b9af567ac4ee726792b209ebbf7b8a95ab6c9471f4731a61b9406cebab42e5b1070c430445a7d9314912f7006ca2aa9ada3002b9d876ead6d2f3b02ac28f182aa3d07412c7904dd0222e5acfd421807e8a8208ba57c74c1b0d7a8796758728bf27663794f4ee313c28ba8344b28167ae65464ea773a8434fab0b232e9149ba132fd9b307f8f650fdf557a8357aff6de215206f3887601274444628961a5d0ee0271c97fc568b572937401e48bf14ed3d7493b2027c8684a2fcbba64bdde93bef3fd10d7e64aedbccf78cfe5db7fdc410ece157af7fbe53364837c0a8cea9c6517805ec0391a88dc199f36289cc2ae78e7356a65a8090db7baebc85a92b04e6e09ff5260ec330327cf4711f91b281959af3ba0f927fa743f4f82960e37f652e6f46a7296bce1b0cd170ceb6be46482352c782de06799e119c2b8385871a948c534ba918d936f92016b8ffa67e63f5f74244e3a177c7cf23a3f5fe52e3e878640ce221fbb90759550fde0c0c889ef2994bd31d339be7b074b014b1977c4ae536f34bec21c9d3b5f71c1c5f7839ab646f965c56f8ee2baf2ed571298b18045e9a81898d3ab4144f1fdac516a4a980d1e16c5be7ff4c2d9ed352b6f34a13d7783639937d72ee159a645b20f9b5406a75601181c73a0b1683ffc3185a7c878d1e0b133558ed878cd76b9a6eff06f7dafd3efba5e2bb9e1496430b939c3f1895362348f095fbc6a4ba15eb886be95c38a02eac48edbdc5f3ed7afe124c424d3701462d9a6d87e316ddfbb1d3d499ed12c1492440b68791a3de7e75a7da0bd1ecec7fe9ceb3d4d984326674a92082f550b1808cd0b52063c7c3374e3e00d96ec8ab3e9ace71496a7d70419b77338fa2f21b43ece7033f10dfef1621529ba9dc3c70e8df98d8848b1d92256bda52bf2c8aae0ee311248abfdaf3211f282a3ff78bbac14ced068eb13be54ac37620510119e03c3a066c24697287565a6f2ee1828b0896a8208185a024dc9d4567dc7eacebf99bde5bd89ee0327c835b3c1c8914d370e5ee8f7b9060b23216d4af4e5a65469ed207c0298deb806b4a7b79506a4e66a0c329c8f9641539c3785e76df363a3ea7c31c2bb29334f3dcae92b175896c476403cf74bcbad595a0d3731e6bbf4e5f1c6ff302b30ff99b25c4f5b764cd2345783ea779eecec274f50cd24c33a3b0b6ce1653edfc541d2ef949749959ca371500ad77be56f2322da62534277637301a5fa2a8cd302a6ca4180306780f946dec98498b9e0e101f54b238561f1144f8ca09d5f88defdcc7f710497fc4e8566ea7285fc5de20a964da0ee04995d86586ad13e74f0b5414bbadc8395ccb7433b8d3e5485f703734f288bb05c451a3407edd4e9a5678eefd9d8e6f3bee83154069f44562332ee2f104758c176b32680e0d94b2429855d1a3062858d6afbac3ed537286cc86f1ca6b150d00794af0e6469d2a7a9130f6afb1bed1624b602e6506802f9183a6b570e5c4233b0d083a79673234abd7e2a295fb97bdcba3656e5a6e192c1e2bc648e957cfbf3b8dec2fcd79713924f076110c19eb0f54d5cb0cad70ab41726806d0237537131ed1fca74d9d343f33ab7650475faaaa8425fa7a1e6e29c12a72cc80b3aede722d7cc8f4a919df1f7340ad2a18a7df1c51a9bd19aec214f811a5429007aada7f813cd2091b183a37f8edeb4c008959eaf7f1f1930c26c032a09581c821d03e0a66621350dacc997f9ecc78d230bb4291e80cb98e7e65fc02b85e5a3f8852a1cb270c37c360dae972ae42e4295d7468d3d17855fa513d28e949d89e9944e769df72429042ce11cf99f2a192959656554dab993b04d6fcfcf1265e363cfe25aa406dcf76903e077d3ca73d247a410210c66d6d1ec60f2d4de57a5feef495cd93a88d61645e18f846dab59992d31da6773af4b3b38bc584007782d235137eeb1cf75b5700900609322b9d03433d9cd8977a5e1ddbe12d1db96fc2f074ec9fd464ca8499a2d94fb3a48b042a6fa0d0a1ebd1bb025bc7d57537879f91e13e693d31e08a653217a0feb6e0936642f9af2393c6cd9beabf3683270151ee383ba11e1b72daeeacddbbe789a954fbd548622414a18aae16bb8875b4eda5e0fcf97faa6aad4769742c83536d1e43caee7a2858305b2d4d3d1f89c11994939713fcf296475a18dc382d96f630be9158dc5f9815f3e41a048d85e941f59302d5b5f885b569c9d814d4cb83a442a9da23d2e3beae17da61373f0924a7234a465f4e5aedefbfa8c628fcbfd0e4c058b5a33737301c29775148c2b46f5a74ca9a6bf0de77eac9dc732101694defd31abf092d6228cbea355cd253dcc29836c7babbd5c881dca99c9020352f753c7ec722bd4b0d7eaa4fd4164b48e2f2cea426ec7613b9de75b4caa1cbdbce77349f3daa7dc6a78b0f9c296ddda5bc0caff038ce968a01ea2774ecf238b271a369a37b53a3d9fe13b6c8181d1fcbb5a2a03d395a13a57ae22153139c3e31e0b078cac575923ad6a87db8e9ba3840ef5411df88c6dd5dbb60d58c3235ccee94d4edc7726fca91ed4e01c8ea600fc995fd3e2439f67d1e690a68e7588277ebb855a7c3e7042783f6afc1e27b757bc3c50dead12a06a96b34ca9e77ed5b904116b24967f9bdf48473b27a87234fe36a7de323ae3df8f156d9e220d67161b697396ae25784807f1fac5bc8824ce9ee3beba9c8d7f4d8fc1eb416280d9af21c9d7384f3058afee4b079c54dbb4ff606f3d2f0cb78b38cf4689e7140142bb8f608256e4252ac0cc855e452d3824f175eb79f7b203ee2548e7b274897d3b8612407cc50162d5990dc468e33f116b7d95694907244ef8b11de5e5bba2063318361c5c3bfb6fd74e43358468fb8e942427990736c4ad07ed0d1eb1a2334ca7299dc198598193c2fd5ae665055c8c7df1cd76eb594677b559cfa13a82f7874898e402828de60eb30949517ecd7c07d3a3719680ce4c4f1c9ff6fe608f2e47ad76e31db23f82d3b6f1a3f71dc269e130ad17cc4ee1c016823fef0dd427745f47058ae3308c65f0f16d28f24fea53b3aa76773d3c9a9948191aadd85fec89dded743548ca1282c448f6fa176fbc08567b831551b0f977c4aacddbb66fe2096c352020024e0d3f2b2aa9346839780cecad35b2d0e4a3d47a30b867135637c7776f09c96b82073d4366ac265ecf9bf040dc84a68d9757be0f3795eda057ed1e6dc59af76d71d6166623db8a02687cdcc46048244628b1dc1c282ef159cbfd75d49538416da6c58f79a1a19636ed46cbca8974a5f55949e5ca3da903427bae1f590e53c35bd096c9f48902ed966596de5a08b23918826ee7561073add586f97d18e6591acee0a01f3d6c2ea6328e4d827493e6ef4e6f120951606dfe3376dc844778322f3a66b35335a2d53a5e153809b45e72b33dadb123e71ec2520fb3bf4f9fc1eb6224fb8107ee810f15610f7e82bb8ebaae66ec2c72dd24c0f0fd551143a3ab3c87cbb4fa87db2d95b7153da2cbfe4d6c63b655c1e839e04270f980c83cc41174a73a10014b245bf9035fe744d6180305e9f946e6a78d66b0299437be028cf722e5aeb13dd9790dfe6959f8c16c6e74475a7c5254ab7454d6e07b307e2e5bdff90dd23a394e63097280df82cc2b02624a454ddd8bb7013d472fa00475de5198aba3dd5af36d039dcfab951ac0033813466d797187ed4ab628fdf6eb3a89885aa1897d3b678ae1e00590e91d5b795133d3b4f12253454a6cb21ce6a82529ecffd2ace8174c322e73b67fc8b4c1980c9c5dc3090e64d069","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
