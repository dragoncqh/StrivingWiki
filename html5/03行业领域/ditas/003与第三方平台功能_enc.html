<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5ba9e1acd672c2db5cbe8add88d5cb0ee840300f5df708dbc734b4695e00acd9503f26ed3a4293085d7e0c319e5da13662959cd9b0c38dc3dc3a1960cf018381ae52b81a6147ba934c51cc46c1ad3cb21cff09a4f2d133321d454793b50fa1b954359317620e5a23f2e685a018d428d514c6e632ec2453af32ea60ec2d9227d93cf388ca661038a0867cc15b902ed4364249028960fafd4c43fa8a92e1fd237707a791d2e070a583d0946399ee4cdded2b6c75e247d545182a392ec51d531cdcaf1878025eeae287e0d4c4dea18778444461120b1b944be561a733c307abc75e2bb2003d4344bc8bf053495fe6ccd1cd47626f87a736116487ec54a6e45d783cff2d909f8c167e05f9eaa23b01ae39c5afc86f603375eee1079c39359e073f97bce88985f812490840962cf54dac0acd1a9acfe337f538a173cd6b473ce939165f288f32d56b432ba5b23ccb9018ff120343f8294943ffc30baf68706248d884acc1a59ac5d35867a929fba6a9ef936ddc6cd8782e19ac44564013ffc02464fae1da55475c422f4d7bdf96d7cedea1217da95ddc372e51004c8608550942584633e5adb46cbc465f0f1db4262bdb4746b3f23e0808479ee65a1a2071be8ec910b9e7ef01e64000b1680e764ef23dc724591de66a6ca3cffaa3e13923b74716a79c066fd1cd70d1d52492a7c19c0f504486e03d7c0634f41d1807dda7e46387259ca797b8cbbfc1be769387b3039c9a67129909ebb4d6d8c7aefb61851374c975e3da559295a193e9445325fddfcef9f4ee882154abeb2bb68952dec68be3d6dfd295f1cbb04348e804ffd17afdc9a859eae6272e4595df8b5ec7bf0413489ccce172fead6f3e965c47ee433c28f9a7f6ba1364ca7039891b15f4ceb2c16d78717857c83e550482fef497f7bd6ba1d7489e9e49bdb18ebfc9cd2228abaaadefb3a646820863beddf74e612ab357d4dbf0ccc06b92a8e209bd031aa9cf0ca0660bb678fb66d94b87ba4d4622c7b0aaa8e24028a39dedec08b05cbae139ad0a93c07afc03055add8cd76b345e7e498f636c68c8b8c620d72662bfe3d851e9b134ac1090f10d7e9e0d8194acdb6154f769c07d1075d6f1b591948660090f58fe460196fc15cef7265503cdbeff6e6e806836814feda00b4ab9e82d2f78197aae8eb2aa9e1f37600a2ee28c1cb2a5c7403227386d8122fca2d3876bc441a39109030d3867e12926866c610be359d8ea270bfb87c549ca1bdfe35b94e71a182f7d6d530beea3f3153bab7eef8d034830f05e3a8a792aa073d95dae9f58aeeb17b3dd6e88aaf26fce337f696e47d4ed76b2c1656d178538d0365c1d86554d1a8dc9b9bb39e86a480ef4941a219007b2f759566e57d1b8006f1b9f86f7ac97bb2730c0061b1886d27a2298a382dd81d27f6d6e05e8fd38bc7551081fa3e6f15453319c92f392c9d08c9538f0f5c56813d9945bc5db7be68074f4dbc39c27925b7dde452d531cdc5b8f31d967ae22028b4f1a20d78b96cad823c531c87844cd83fa52e71295ec5063caa24e43f5adee02b3b2457eb22156e0637f799e2d99f48d4210d1f597475d1ea6b9b58b5650dd02098a24c8c7c3e7d97161a5a0591ddfbf1922437067dab96816f674b7d31700b4b1b12aeca982e253272720952adf386da0f2e59e06f93c51930e32dfee27ab7a11e4aca5a9acdbe88e5cc7de9848b325d56523ac4e7bc2a8511ff807b1ccf826b9c984ed48d3ae7aa87fe1e1af1839b80e65afb0a9948872e2dfae53d14ce310c904bc47224cac2f0561396445e445bb4dbeb6c5149157f090d1993335177500025cb25c4f8f3b442c17b513719347861a8fbe51b15886cf0ea1d43c6fc9ed8cf663dca0c6cda92f4c2501dc48700fa09351fb51f86c4b8b8396b10209015f13ab25cfd21de96b4a7f3e0867bdf7f2344110e941dbecf3de807fa69be55135b37f62a3161c19a64e0f0660c644017f5d916ff16fd15e131d089bd771da1a6875832999bdfbf72dca914872143b87b4d2dc28d51488eab0ef66d5f214257f3dc8862b28aa356010cdfc132a95c162fe3b0791cf828465cd33d52636e1bc189ade17538d729ad52ae5b080b330e77a60d8befd17cc24a0e96cb59ed1e389a2243af869e8da46f7c7287a2335f105c949215cb54e22bbacc1e428c3495a18be4af3f3a02a63147beacdb6007499ae2b84550496292b767e68dfd8f36c40f840da1bc1f018d2488ac2182783c6cf6871d82bfdc5edb485fa1eecdae738e5b2e81a789edf2d10111d86e6788929996491aba6fdc871eae60b86bc8710e2e2295014e3b5ee399ec094852f4bac4db54a2170026659948fb5328211bd5a487934874329dae469321378895038933bef001cf0aac897fdaccdabfcd6a26f0d3fa154d2775ea5da710998b930157875273ff6c55c301695341f1a1e4f671576258450996ae453ec6ab66d5c41bef4d31eae1e3a327df5d18c92d6ee5f204d8560eef39e4f81eb426c614fa072c59067f683a8a3e927e4f0b221842c69fdf4975b34286734b118efead299b966fa8653792bef0da4ef12164e50d3be81b96e763ff7f8fba7c96d4de5a9956d1eac9b2d95fc4791fdb479d196826635c9a6775b18fd9bd9afc70641f4db0ff8221875f1d58f1837b691a4b7a1893e03bc5b60cfbe1d9c308799209ac0623fd5c0693243b1eff3e70945771574867994a86983f82584f88ee8dbd1339758ede9265592dbd0ce2b2bd9836eeefaca49b6eea0ef25c0a32df699cb8e2a1dd596b756311994925076caa2f3b1092760b359a42ceae9f4e34c9c1f1a3fb1abb59185c277655cc9cdaec4fab74b51b930f6aabcb2ef74edfd54976ed417ca122b9d39263a706223029af038412eec818b326cb7c76cd3aedcfdd7f67568a2f77cfe99dddca96c1dd0f85070bdedf888f33bb0efeb429aabaf4ca3f0391496b20ff3c76e7bf2a66a427c6ceb1b45b865a4df52a05f6b79eabb94e0fb128ab9d94d4e5df7627cbde3d0d4f9c48811c9952ca9f24a35eebd9a8b351e9774a473b1ad598517bd6d0e1668c7bad3ad806e7af0cac279b15abe1b94ade0e6cba0121cbe44567d414eb9faec4444ed2541b0c8ae08d690783087278b914dee804f70fd0cf6643319ac550835cdcaa3712b1444146a58f818ea1124c2ecf7edb66b672c2f6b3c837ca3078273d3a8e5750cb806cd82e1062f46c93622e019334170b0c36c15edd637267bdc929f29ba692a5ab19366dff592dda4f95b3fd1a293a1042e25e338615f8fe864a08f02dd16a2b15cc6bbd826709787f07fe3162f8eab5eed891d4de2241c0b132f6e9091e156331d065b8b8c5b6d3fc1a6aaa67bf591cc1d064b31f656ca838d4caf8e8c7749903f5209a3a9adf0e3d8d1da44a41b2f0d9238050ec3fa74668e17110b16ff8ef0c5ef70be6c096d70fcded87979e5f0d1e81bcdb0f4be0c25bb57a8ea10e80e39120e55ef183a197358031379ec524ba34d661413d48ad2ebc2df4d2dfd4b93f3e7d202e5ddcb6260aca66037d9109a13d5acba03314e1360e4d57aacee6def590939571920d11e58a468a298dbbbae644c807edbd33d8c280543e2ea738f6cf98d32d5f461612512954e1e143246dfd7b35025b6fcb2410220c1e2b4cbc85c4a205d710d296be1368b615e6e8caae4726408b9b3aa5070983991ffe6573fb6c792daf23d8941dad7cc4bca235073a16fc7491145b218ecc25f9015abd45edbf47d54c052c8da86d690ed24b4a9aa64db18c3acbd122cdcac203be8b9ac4d95b78cf05a39ad8683490c0209530a8da5460583146d77e40d64e0aee96d3ee36ba4ff609e83d061e136b84415edc9103140a5c3d89ec77e6105f07c26832b483b669677a22455b414eb766642dc323a54d47438fbd6a38b170f9b6f5b276aac6c2fad1b108a5d14cabfc0f4ec0d7506b4423c32c53662dfb212f519ad05f4fee7a14962f37c311cf53d20fcbeb4d20fcd42a5403f31b264f1143c88ed6a742a5749b43f7d77524c5dc931442dadb4cbba2d4ee012f78b1262b8c2ef73d587b82b10d8bad539f8ead1d08cf6652caccd9c464a76fd19b865473f16ba15ed168a4b7e94aab5788120e3cf162425e2a0801a36854d0e3c4c5eb3d968eb17c9b20a67f3ed954259a5c74fdf7ec9ea8a40085384788d7a5041ff01a70604ce6272a957adad41f5c0d91342f35ce3eacad758aab9f695e9ce978f71bbabd3c29f812fcb7c5fc268aacb9ccf0cbf5f21ee8afbcc9d2099e064a9aa8ac8b61642b25733e6cf4454ecef1d60915f02fe145834b023813c9ebfb4b48f6b3f2cd53b28bd65e30c41a2f7e2b5207832628463b6781d0ee3f3fa756450fbc73c8ba8721064664b1822a32f3c933d00ce7170869b3ae69cdc0f666c655bde06059cdb262c4337b074f68b47e88f68297ef31a73e2f18316a7d886659984057965f308a56fb71d4c285d5183dcafd2edd3320bf1c33b3a32ca39b50d9bd733b17093f45b127f775e401f0b3a1c957fdb4bd270d33df4abda6ab496f44ab442e1e19026581bd5b4a5527fa0c0f8b504eb9ecf18b5a0299d9c42e6004f8d74562c0372b8dbfc5da0fa2019e1413f40479d4bd5f222ca56ab74df2170cbf34744c0f522d4ec87fe754d6120e6164fc25632388e787c389a7e7ebdcba5ece5b90d57758d9dd4348bd3da32daeddbfbf884a368e9c93f5fdab4d7cad1b6011fbf1757f8977bbb0ae0cb6336e5f622053a6ad0fef7207273cedf52ddacc3104a9f5c3b35d6b20ed5254c5c54844f5e21cffe388d13f985cc86862fb7f715938d46c4d2a1e4b644cc7d34026a5cc0cd7756e36e27af335676003cc90a6814395a4bb74b63865b5dde43aa28f02ea9d2ba53efcb1a18fdb33dee6635b355a6c984a0ec9ad6f3677a2887b8aed862fc7417c6dbb202daa225927d74a50e014ace4d23f84123a47291a3f89586a56cde4646fdef9360193ba14bd7c42e5f98c1037eaa35e217e2facdb8659965d8fb81adf7ac5df8d0257fd051957cc7c0a311ca6e4fa6d7cc3179949754f7a9c130700d28df428defc5b7509c6c290e6a39b77a721d4f4e6893bc098ec1865346ac6d3ffc72c89024786e2db0f181e42564002bdd7eb29c6c2b11de3eee222b74b8b48ec0d86a8f35ad2b6ea00361d5950e710db7ae8ab92ab0273ae3b2a5bd76a476b801719beae70bb354d0d5758e238527cf4585b7a122d732ff229bf8f8c097cdb1c18e1dfb9d4b8d10198c08be333f6178718752f55acf535b752358e8b94abeee0e4e2f09f9b4be668bc39950c5b2842dd93b5e7f9672765912d578c485867f57e83328879978fbd2e5cf737a02dab63828669e395a9cfabe936dd395130565e5d4a69f12ebb1ebd34950c347a8963d47e7070fb3ab9db4d7a2046a4eb10540d7d09e448c102a95d47d0ec4567de8fc1c887df00be28b91a6578eb4ee3baff7182b73f0040f07fb748d9877f2beb93c9e4b7c89ed5e2d2140df27a245aa65a2dd8343bee9aa8ac0c01518bff479244233f2f303611488432aa9769c9d840760ac0487f7f7d92cec53c8bee3aaa8bc647eb8ef8adb2573dbd0cb2a39c72ea05f110b74212a404d32968481034983d4c02eb207e9f096618a93f7d2805afa3fccf4661a559c024e7985ed165f53f2bf3bb111b0e5033f38917eecad900ce691a2468d58dc05c92257b1dd3cf6f2c33188fb6e712c63ec949434d9ed33c1490eea56364bcc5e4b59d5f0c291181c77cbcd0b20a3fc491cfd1d518ad7abe3cf71cfc08cc8a5486666eafca493f67622bd80fd24ea199ccd45f223455ae4f5a08805f1b0cc4ce29818388e4cc2c90cc1c5918bf240b8ca45b290e568defff937f728116f0c06a63a2445ae34a92f97b9cc93ce326eb6db647cbce7d2d5061100aad64ae2961e61e1c9886379702c301b491722b3017da6f1d2f1fec381c167893554c39147a1067120f25a58238c2af70dc635da3d1dc36a786330b963d1085cef262c0e73f59be702fded8a853542a4db674a4c762f51999c6a79790bd7086bcc53d6feaa2a66943ebd6b811bbdf0327facd650574a7a8b06bafc8183c84b187676d1daa2d7fd7da2f1620fddbc7ddfaa5665096483e08eb3095e7775e1d6891712319a4a99af633b93500abb3a392312896e2fb838202bcaee895de4c85f97f0bafdfcb0c5809917b786eb6c6c9c58f1596bd9e41e65636c68c8f3c0166855c181f8e8c891761e11ab24f4e004986e02d5b40b27296373aa4b8ecbdfcc85cd5e54736c4f2afb756e3a282c3726c04d65b3ab5b63b23f7a5f45c65b0c93e029246fb746fc5df65ba99d13d509003dca290e34049427536bd41b122bac47f9df6bde0ebb3534e6a2fe49b2d73be48ccc91b96a069ae1e7355e093f83f399d322c6f65cc476ccfb6a36908bbd17da693ef02c73c4ba49b213849b1fbb8d027509f1d9c5d0521725bacdaed0a5e04adf96d81f6ddd3f9d22d85e1c0a69bf42ecd248d4c10750a3f95e1863d7f35663d28b511384bafc446bf31ade20b5d2da5531b43ea30f93fb1003fcd1c0b1ba140c813b7ade210a6cd30a796b3bc2861b3109151a347c8c8150ded79fc25abddd66007fa07ff38c6bb489628fb822db24b6e1e359605814b69f4d8eb087a0099e8564e8f7d49936b7b1674155f964fe1743ae37eae4aa58b83c30da423cf8be0f129f832f21e8b61de10aad4781b9e44a06ff891048524ef7841f1cf62554129b081846ce99da0aad55acc98c047415d95507442aa52f3e26b736189e977d60a1724b41a0bc2ac48e3ce8cf3442b60840cd6082a6cfb9390fa26a1028aa61709a82b7aea8764ab7ed205223092ce65f116971bc7591d3f263640cd1c00e8a0fe3ed5a9e006171b4d14f88bf7da9d41ed00c9184cebc64d2b9e02b2c63f32fcbb547a1323e78af3d5ad50767b28860b8f1ad105322de934311f864a80c8ba22348c83e9d12d8c973e32ec551517d1991c0119f60a643d7fe2c36b589ef73e3d05e07d5d853ce0ecf2d995bb0809043a8e682d62d872615729d2709a89551699c32d4d0c49ce51b3e234e7e712144e58e9068b04e608ed4b7751ece8b19905c7c23932d7ecbc9cf9b635ce0982cd3fc58f49100020cee1f4ec054c475b6c0099a9a214461c63340300887240c0c3fb08c96322d0d523a9c53836b7607b174d29ba8d2fbe955c5940ba4d3221f1271f859e793647e43349d122573f1e07170353d89a15145c83448f579cf9df68f4654750e5976e49f3ee846e9cb9530a302ab36dbc9938a7442b2489259ccbd5e9cc83ff0a32bb0abc977aed687d476a204278b0bd2092e838379f1586e0c8a2e2da7cdd8a1aabfa19934f5a81bf7b57189f944a7d3e031f69aa30b6eddf1af28de5cf8e7ebdd6224ba6500476930ccc76282309fb9f335135b36b88794c8818a9afd41660b0f01b488da577046b31e057b2e021695d59758d21bfd74592a97209f7c16cc0870edaf9f8cd82256d9c0f9eedd4676650ef5f4cc75d350091dc245d4818a4f21a1978aab3f20b6547ed0211455e58efe7fba36e7afe883135d3a2bcedd9eeed8c531625dabffbcc8dc24f85bfb6b018220dbc12b6ea5c3b581575c075e2600ee196fa22097ac5dabb2fe14ffaa89ba611ab9a0ff78989bde6017334cac299a79c2f69b1aea41fdbc18302369f1222c11133a96e09a45808d8de6a4ad591df2739fd3972b7fb5ff8fafb21e83dc47b4a8343f680d6e05db50eecb7795ee0160b5e884c044c89d37375d9c503b8ccfab53b8d67b5508247e2692d93c7397a913927b60a4f4af31b6642d4338495338751a4ad5c65ddd73663af6a50522d1c164773fdc9786ae8f12bb358c60c4befada13306ad6dfc30381f40f5671d0242db5b046b5f996efe876c6c5b3cf729e269f84374e9c8b151c9168d4382107cb4c9b8f367287177fd9f26e6af4ce519ff3b80738003e555c31fe0ac020bc51b7c124eec9b5cff9badc74ee8309d7708ada3a769766a6551e150d51d3950c9585f5f714dd1ab86f186df8424f9aeb098176dab0fdc78b4e81e1b690184b0e303ae913b82a565fee7e4e242b55e9a7dbca573fc36d07423ef832b0d0264918f7638066be0425bb6e2534fc5dc555773b2147bcf48485b297189442b83bd9427e4b63596c8a1b8151348cf59676fdb0934ddb1c6568b383809f201402f46452cc9f47d9921fe1111dbee3a0de9393bcf0554f1a9d0d6a78b30d8f8fdf68c173afda4c1151bb6b48be00e479fb78feafa6c90e9c04a14776cda6bd7af06dd29660e4de7b1864b0100f7a855595cce5c4dedbde52c8fc2b6ab2bf6893c9214b553082ea87703e59354726037d22ac71b97a38b65814987b1a5768520944138a70e99d60844af826662980789ece4d540fb070af6e243699247b399a4154ce4d69a96f639846f29d10749218aeecb243e7ad709e12f0b55a80ec7f18a7fa27ee3f2b0b6b22019ad32c3561d907a7206c06199e97d5eeb79505ca48e7bcdf6d3f37b4fec50080f7d116ed5b9326dd3cdd351b690334d2c86313086eff4ec3382363351ddbe2ba298d06b7f6108277674d1324456a4c9e8446ac56b00a93250107149b446e05adaf746a407b19083d04340c61f51facd2e7b07caa0340ef2c53378ebb15eeef208452a7bbd5006763244f93b49f04dee8422a972feebc22ab883b883a396966a1fc6cb06c324361d502bcdf1e6ef1826ed6d5e35bfcd6d3dd970dc44d51737108889305881dcbfeeba2561bf1214d542017f4ca14fb0e542ff8f6e81f356922f8dd9b65a6c404c11543067bedca4f3b154924dcdc0e3b2949d7167c8a8e5081a1a55821e69a825ec2dfd31cc9bce92cc3425a2e801f62204f00e0d6a5ee449b79799255f7905e881d29be7a87e83609e9999044c0a88e87a8831955eef92af019379f5317554dd72d75c715f4a21c5a975e20d263450090a605f9ec641427ab8326f60ac2746ea3e2671301efdcc79cd2949811e849a046598f67c8032e2a40eb6266b4232c0e7a752189ef920295c3a9f86d51b32979e19254513176104d1cd04d7a4acda0a04e5ae7a59fde24ea6b6fe63acd3219820e0848e4c75e810053080d9806125296e5afd8c83387fcced3c82fa526e0b2ebda0334337177d20eb786b19a5af7e1302667744b1c160858556f420633febf18d506c9068fd38e20a94a04e66634e6767657924cf1eab84e98dd422ff8a9e3b0bdcff286587f5db913645999bbb9d487f100a771700e2f4cd41b6bcc28f8286aff7b83076028ae6ab6e6e81821cc3c7dd8e85cfefe4ae2d6e77141482a05d125b6106a4e67904a5f22e83d5a720522344006f8ee789ad9d051ef6445bdcec42194336c965d61228ee2beac0ab9ca14fa063a2167e9cf78202dc534b57f786d3908df11e9abe619b3cd713fb991f1c582b558cd6eb92438842c0e4118534829f96c1298232881e8820c8ffae71e697a5dab1d1a10392f3435a7afa787523866fb9bfb0bd6c72eb15f449bee0282afdc902b91e8328fa46e449014fc43571ccfc8217363fb30a4a13e60f0f8980479576f54950eaf4d7696bf5808a52b31f55f621c787f2f60b20c78c1a836533657efba6a7fa85649b3a6631ecb26397062d295e5519806c1a4015193b6679727ce67ceafd45eda9178a03eaf9e92f40741a290cb4db061108f610ccdde371347aef81bc9790d6fda2b03d6c9a6960e8bacc64a4d4b57dced214c4827c0a5ce60f48fcd5c084085b5c42efe8fcc0cab7aaf621458078a779ac3ea0dfc0fec3f6ea8319531870f28fd365c089ae78fa508a46032c4108c28eb443ec14ddb5679e047c08cf505060543884ec92495a940d55c94e4c6b8e635d4893867eb2f4dca943e78c9e16b227256327843b31cde550b9ecd4c37b9aadac26d474c4c77dc51e191445c245745f3bc7fe35a1e4642ba51df1041336c7f40b8c09f5afbe1687ec85e9a3da2b20020811e28b4957cc3e3015bcdfaa2dc3ffd51fdf153318bca9c56be52b315d46425dcfc6d6381c4ae52891441330e52a84446c4d359491e45e4ef6e8f9d8e0ed9c511747fc9a3143ce0afd2ccecb6c7919e0973ed531b1186fe4894e9225e61ddf874751ae78b77da12640b2ff631bcc943b591e4138a24dfc61305057a9d1bf4f3f05e6594ab7f2857aab02ed261a92baa6307dd1b4072461cd9d143978c731408db7f1739d4823f53b5863514ed9054a16009ee028e1399bcc1069610f8b22d9f451d768d2b374e38bd2e6bf4ce9236d002ef632d1428bf8ec607129ae3c77ca0644553ff5c40398c2b7f9fba9fc6cdc9776f8a457e082a639996f5edd531646ac98680627e70286fe834cb8d0623aec8a26315bf64bee07cdd92c1a4268638e1ff4e80edc64ad002a687899b50643468b5745d2213879ff3031e70cf319feb2a56a1a1be5a3b8279b338714201893c1c5f6289bdc725069745845adcc274331578b0270f4980f55648118b545f7e4ed86cdf6df65ef150453d38eba7d486e36152a190877f206b8a1cad5c47dfb43546423e269e5d4d3878984c4bb6a6fae5f0002ff483fd688dfa80d1b919328e8d3bd952f8ddb1f1f1af3c985bb651b5a4090156415b624099b3095ec6981584e5a8183bc4a669c2dc3e9b611374a54b53bf9434f6cd57817bbfe525b87ec7cc03cb081bbfeecae7aee622b9236198be86ff46165a3286b4ff4c4d84c95c3a1f90be78c9e9b144ecc1ae9cb7087c6d5fe24e4573c0246b466a675d79c99afc33d4f53f4fa1cef79bc8596c6b08d3a2ff1bc4b3a6845134149cd18f6561074b6cdcbaeb2d354899ac3eaf5bda6158466b0195f5912dfceebb204224ad1cbdfd14a250da976f6a4a111482d611920c34c524e3412a9ea831fbdf610eff5d67e4534a1c13c60eae77fd04dc30ade74ecd46d28350c95c3fe6b1d69fb8e3cf8cbc8aa3910243d237d61fa76ee8687c60eef28f43107e1796284ca83bd326d2038e792fa7ea0d14fb7bcc687a74e7bf78c3670442baaae319b24beee0a4032ee70c7566f458885eb9c0f4a62644ed4b964f7d82c325118c36e081fb5a1227015be9dbaa7029821a2582ec4c52f5d9e7109944b7b873ffc67445ed1c1bdf9c19f46e5da5367aef4c614818d8db804d1111906a8bc46a40376b320bf45ce8d3138a8388a96ce9d23b705e84787ecfde9b394ae7398bd644d5c64a2591fe41414edbc533e4469e4c617b8d65d2ea570689de489f9a32ff4d5b0f8cd60f3ccd476790f2b2a019c52e4b074d6d57475d2868e541895ec30add3a5d4cac812501d873215086fbdebb938da3e3d037fac22d4f2b1c349833cdeba6fbdeb20314e1c386889e409f985b59dfd07701de5977ffb0abd327ca92a04d15dbfd89644f149bce3bcd9a540459009f024fecf812093d0ee97ee8465cb3679d59a0d7184dedbf1928bd576f70be0da8164ee73ba7f7afab0a0b64cdb6242aea81a66abcefee1ba53d5529a1d30785e84e771e55dbb0a4faec7fad844032b32076a213505fd25bd8a70fa2273fc42b83202a2fa90555f177a6d811ba391a4ece9747d249a6441e60d3fca8419a0b65528fa0c2cdee1d36b1ae34efa13536ef30018c0f76db193fc7725d2c745eb5c76a54a7ad433fc1e447507e118f66a1d951206a240c6c82681b399d497cd0f88db029b7ecd8df57b3eb07f69cc209454472e97a431de29ebab03e1ba95fd68281222d40ed602c847306cbdbb9110a7c89db1915c73ec6e8d782e52fe9a269c526a524b3b0f8f236c8950c4ed000463a8948b7860c8f912ab3712dbd6974aa11ba3e3100f419afc4d1ef83ee8b2e0a687aea48b95ab47699b5193a117ee718215adac4e796b7dbf8da191b72e807da6a70392f1e0cf72fc4b6f20c5feb932d1ac54964d3728df22b544ada7fbd44bd54467621031937bcebfec91deb48670f12743dcc0ad99cf07ca14126f724cb2330b07097161e7efd13f1f2d94fa55c42906154222de8376392a0c6ecad78c9f5bc59534bf941f5abb545a5f9b46f305f07bddf5019b21b49c679832e36dcc9c8d4dda933a455b48e8e400a49fa18f0808fb6c21a705a3589b1b2d05db5286cd62e5e7455a83bc866ec13735da702f0ff342c6d025bf501d1b2637af88b2eb7740eb97628b367139d935d248f9b1f2f49dd1fff6265329ffbbde2541cbf570b286979557183ace411e10a37a809db098ec9157dd40d7becd5dbeaaf791e83e85f3baa289d17f50a20f041239545bd6941d0e8cb8bb20fc57d0020dd2f714b9527100a7da96f7b41327f277451420874349f16fbd2c466fcde701e6fd30cdeb702408e4c3583bee24f27943ea2ef428f7055863b1a4372443b9fa97787ba7a94100283af9d0dbb32d0ecbe87eeb4934c03a4d5b63509988734a96e9213a46a354c05cb8d488c84ce6a462982a448cfc3aa87da83ef69eeb33c1bf82d861abb80098295774417c4bc09fc93a9b0a36231975a94010bd77c1217cae89aa22cf1dd057ed18728d412a1456a292d81cbf605af072795bf4a40f82ea580c34b91b3ad26aa8b6ec45001f047ca13248895bdf75c8a0da69b1074af49b245005759a10cc23dfb0faf57d881b079e074d49005e2ad0a735bf0cfa8676a4e0b8d3c80c18178a8c90685647f68a8f1969596ca38b5a70c95b6d81745c48d8a53480d70fbc78e1b8ebbf4394182f82a801a90dbbcfa8640e0f9c16bc7106516a6d1b2e355ba8e3dc461cbbfeb4e8b509bcb55204ae196ffcd6a0559df308080e6ac842151f6ca59230aa229b56c3ff816ab1330b38f564221701ef4bb01b7baf1bc495fd7524dcea2eb4652aab90a85ee0d42662b1beacb6d77d334c622a3f5c3ace4e129d386520cb351f0756f971063653d492ced5005a82e8e8013f8a002c0c6f2ace6fa03cf6bd11d0ce93d04eb2161d2ddcfcadb29ef7fdc89c77f18f25003c5e3924502ac8d5363fd8113b29323dc121f9df366ff144630bf8cace2a5a407eb56728e9bc35b215031b7a68cd2938608ad8a6d28932682f02847c4f6a8c7d2e8dc5ba1445cba160cf8d130dc4ca46b2cba6b5646c3a3ec5e829a7936e8b5d534bec59a321fdf40a496418edc78e362676b75c694c4c0b4428329a8e1840edbd9a2707ad93bd07fe9db75e696bdd5e62c71d183f6fb8e5aa69745014763b239b36647488f1d7b8814bea0555f746c50eb3fc71d9958673f1ea85e1e338488e2379fe4f0f570df289590d64342d88a4b590f2c3d6fa27f60d9684e15abfeae9dbe6097f11057a8734ef53c88b5f42e1d15c2017d1ead6ab3ff1ef5735e4c9393faf4648854d0faba17538c430781b084a4e34a352129e4330e814d36285a36bfb405f27db78664111401d43674764e0b8631f76fec04b0eed1101691212217f6af3056e312b0a19f5a1803b3669f70e0e5d7a32aa581e69c8269cba1ccadf01d8dece645982233f3111a00bb86f4386f2647ba186bff9678ea5bacb9a3d41d7471acfbb4cacabde6be0342328158671328fe93664060afc3abde33b5cfaa4636e7949a9895ec52cba57796a1802d5d52bfa9a6f756056ed4429c49168a4071bd0c96b92a5772b3f4354c45b162c3c7d356ae220370f66b7bad46e950e9843b117c23461cdf6ea94d8af051b2f3dbdee09cbcc885cf04f123e9f783f888761ce5dab3eb5bb9e114bb09678b8b36badb7244cfe5c29a1ef83618ccdb142ca5b2cebdba65e6815639af03dcfe5e421b2c81ca974a39fa3420b02146ff61d355ca71002b233d573994f46eccbed760f15e9b3bc0e9a9f02a2154d0fcb5280057834ec95ffa37aa17eff4aec16e1165da0c2ca0509bc3b396a4e88dee915dd1fd24172e522be45a07ae807ef69117a4280982de9409ec7900eb360d9474b6db48c508283d9a5cc0863bee75387a18437f437aaa0fcf2936915f8ce074894c8fc270e801a28f8c37de56402041786fe7d3c7ecc9443f7b4309095b9d18e0c37f80d9694d54e1c1fef529d89b36f26c27dedc114334655985338e5fb6fd26777dd53d6111b31d30db7016efe9d06bb862a98a013a0fad9bbd843d3da4c938236a3e279e66958cfa2bfe3bcc1217282a4d4318eb40e0f02164983133f096200ab85ab113b8d80d7d9127c6bb7166f85c8c632399e0069e64df32eb449f4527d1d6457a5d84250dc11a1f236d6a86e10bfac7c812ef11b1b97d2da1f586235cec75cc9a5bf78f22670b1a45fea58d5c7bbfe85d0af72ddb5b143c01ca79b7e951088efda468f28a181dfd451f5da72cd28a996abc7944b2bd72aee61c3343313f9b24b4942cdad13500f53099dbe47c264d26a9ad35298df6747e4205913ffcf792d948abd8b9b44558e25a51fbdc9b6b8346fe2e180af825b58a4c3dc008d1bdc346b6bd8690f86362cb90522e81175dbbaa43ac9edbf5773f74201db7455942dc5acf98ca11cad1a0227803911a27e97ace0220e3fe2d57f18151e143060922dec3cfa3524818cc4ddce83d4bab2a2f27a3abfd7033f0cb851fb1e2653875dfafad03c2d8ac1416b16cb3cd19b33acaead0dcaf2d0095e7fd7ab3e0b15e785fae66c21f65933478a457677782edfba45a17643d4e1bf6a780328c101fb40b2be6e1578189293df1e7f27f792ca16119db7ecf0874d74577a92ea10b6e8769cebd1d03bcc3fe993e26f7470b035a3a58f4b112192d18dc6ae93c602185a89f07af5e238252ab606c55fe7fd4c97a083dfe783db296779b58213fff802ab813bd45c5d7d9d76adafe399b607b5998eab719e9fdc34e9ee708105616e4ec303fb1316d8421e644f520c5c56137ae1cb483865cafaa3b4164aa101e45014b3fba1a2306fab877813fb5b3850b24ed51e65c4c2a1301517339ce0a4e547420ffe47f3a9f49ecc4a1584ebe3b0990002fc121c4c4aa4f2a5bf7661767a17d2beb6d9bf3a0f698c25484fed1fb7a65a9def7251c88b3fa579a0aa774075cd473b4f22b0376369ac8373c9f21f94a9ed3a3a3999b839397e292ae5385d7731cb43eb016635a77ac1f28b22d485bd59e89250e0143f44c444ec98b2e150d347482bc4146c59bed818e752745f589c0cf9f358e2374b6809a3011ea0f48a31c71af19e2a3f46d906e63ecb878126949c0df52c23700768a1bf85c278a83cf3bc3a0f3a643670ab7b079fad1101ef0b5385dd13904042d86669bda8702ec1c070c1ef063658787a9b6ad2e1deead618326ccbee50f2cc1c2136f104f6133b878ea0f126fc8b21f19d080b524c6d477c175b921a856c8c8bffe7b72b3ddc165407f5a0c8a956ba06ba2dd43db7f8ea215a465ba1d8b3536f9e93b75392778d5e1f0340ff5d8fe91423662dc1af5e26c28082c8809af43a8e0924976ca2264ffda9e832af4b4ab4e0a7977eabcd5f0ac81666796d1bbd3aa5f8e16c8f46bb47f961222482605e573e11e92962dff1df3ef86caec070faad6ca0c34e1c68e0d9ee53f2673d651eb6d0dc5a763a5f1523521fb43bcb6d8f8e5239d37d3b5e284bd5ba9bc4de258bfaca09b51486069ed4d605c2f697acafc8c5b90adb7e68101fd2ef81362c968e79a6db39a19883a02a906c528bd1582b9f386bf280278779a17b73edec48cd80e7477d38db32cb4793cf6e43fcb5e1872a1372d4360f9e9e29125a73d50c635ba29649512623e2fdfea50bf2a8015973bf35ada5f0a63c0ca9dd88b0351b0fbd95ab447200eb90821791c0c3bb9fbe91cdcb02cbc0fc8e73710b2134e108abd04781277d65e819d0b646980ef0f847df6140f31b63e2d7788d4466530cb490af64fd764d11145f22d5384141f97d1188181ac0dd3a9940d040102b8408486f9bf45f7ab1646133a21e6799aae66380f54adca6430512a11ec69e7c0835e74788c3d52db9fe41d6f1c17f69758b557d12da5437fc39c1df5ad8d6dc2a1fee11deb53970b0db235244dd8d8f1d53b27ad6f5cd543d456c8409810ca0ff7bc9dc75e68d924eebb3978c38d48cb765b8d353b211b6f3277431738c4097e4a18bada0f86d9218feb35dec7df87eef7e844ae67f8e253fef6013b1ac8f39dfdac332cc33994c7d96d02918e01d95863c27a03c5e35f50ef4cddc23a02e7a32e4b3c8d55849587dfbad6b8d134e3fd52db0f3c495de5e66e4ef715537a31a7752532cf0f03a8400e48c8745758c32d12bb59d1291d68f972e6f5f67a82a7bdc26374ca9656950dd4df604cfb5bd17e2b1f854238ac5e312ad713279fbcf3e15f871100264850fbd44d13ca907adbe71db0c10ad7e61809a1ea0e052e0dc1a6713e55cbfcb63c5dcabb57cea189a56e18206d75febd1164c5304059e9ea2df93c1f84e0319464287aef575cda379347da941aed4f8f2e7359860d2abd4f0967bee55b5ec3a13e6ceda380951ac37fc0e04ebe7da33e04caa5d05472fdd17752bc5f6fdc54ee089495c4206b8370de6c69c6f2074254b6a5a0d64eb712c0d3f552df0ebfc529d67a4003270db9e25645b1ad8077f302d1f0f0f04b1f9ed5a01c70f1e8b67a69fdcc4fb75acef4e5d8e8be47c32f524f88424c8f96f0617ce2eabeb07dd01dd5bc6749451095d637ade7a3873c60d061518dab229df4df919a8d108469dab95fac79e2bd62b555772be12453cc63cac21893b93bab8a13de2e550a35a5d3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
