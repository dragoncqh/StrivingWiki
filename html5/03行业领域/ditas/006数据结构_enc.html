<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9462030c40a1edacd8a6dd245e0ef5b7f3a22686550d0558d61813bab93a07f71391da0716dd1e7c9aad4d0d703ab79b74522c7ab87f7f0822cd1845c71fa0dd29e743213cab742a451af9517e33aef27938c4db189535f74ea1087a27dc8a999deac81a74ad2d162d8ce12bae1278d14cb35e7688cbc90d309289f5406326ca145db4b41be9f9d235cca229487024519acbcead55548078311b38665c8cae4a653ec0cefac3b8a43fb2be694fcd556e5a33e091bf6e09aa2a805082c2c90fabfb8e9f9292806e4055e28cea529ad884b67bb2804c864dcb0c4f6dedd2c5bccb3e374d55470ca0b16544737bda835f4c010c65b115453711314167f3719ed4ebf3d7cbe32d922de16d3e0191ea6adad5a67bcb75238babd311c7d23d94fa144585f0654ceb2cb5dff9a3d4736cd3b2183a16bce69b6a9b5b5ca797c2c00a17f2e852bee7bdc7621229e5c6e0557d622f760c631efa9b37eff12aaf2c95672da0700bf7154ea4ee0f1eee37fd0d9c51b42356a8b3bb60f5b7e8bec62e2cf032f6dc4132e2c637a428b2834eab7cdb0f45a6710efb722fda519527fe651a3c2a37dd5bb0c9a7ef121bbb407570257f6bc7e05e3a725a38b8d9114bcf5599ed5e503e8237adf6ae2a3ddbd6d9707f82f0b4f151d23b4e26a48206bc49054dc58780440b813dcc380caf4cf2da272b7e3e910d3e8cb254fd1df2f87305c3f86767a5d940d9c87ddd2d96a87cdab0b82489a150d575714289d80107b6cef866caa7c9dc97910e3dac936c050b22aa9209182ad36669335de272ae031a58234e2b2928cd76f5a9ecad8f1281da883d49f1cedc123d870790a3e43a8c3844db64e9accf8759f27c4ea3ca7dd7ca09c0da652e9f106bbbfe6761d6adff01c9411d5946cb4640e6bad9ee5da1455a510527ef9ccc72643b4d73ad4f49151dca8ba5e700a6dd08672dece6531e58d0743d75ff4692b388bb22a8f534ab88726458d0436ef8e714570a21a3538802d198f73c293bc228c81cdbf52d30f78dadbf7f46740c6b6d35dd72ca15fd2d140f7b3738227d80ec55852a32e4dc1de875194989b7294c05b43198e06d953f552a407d4d619d5d30e188910c4a00c4aa0d86de337888ee79f003e20ddd2db6081301bba41501766a6ea85fb34c82d5014e36496cf3c4c5553538d3d4eb769c8674a6b1e934c09136ca78210fc671152477ec1b7c1b3118e82f5c16e6f1564c15f21bcdd518f043077fc8c8e321cb4eda075aec672453a33f1318645326ecba6fe2b9e98b50e2b436f7c88202ad0ff98fa16a5d8233ac2a6a4388e8f25440b03e9633c3d3bb06f1234a59fc463b263e1e143118f740ff5acc93c692a6320d604af7acdc10aa4fc0b94a7b477bd1c168111cd372980643643d02b8fff61af1696f12c6c0cceb6a10da390b7082450eb4180e30f5c1a62428ac2e8d05074d2b05e5eefae2278f192a790b84e3feae420aef14367d794f296a5100a8763476a0c8458b9715eb4d4b4ea99fc1dbf2d3b1993052a1a10361edc891e487a7dd76cb3030091098d14b3b2aba26a19ed4780d2e8d437a413174dfe8da4dd9cb4df3d2906514ef0814fa4637e6932f1aee14a1bd0dd529028d33c1d775dba6b2ed93ff195b534a9d5a55b9947ff58cc14f6d56efd9d1c90d0b4f30686979c96216804bd1952f579797764c3dc9a1c4e77c857c0677b71947187db20c60b842e4a333fe021e0d198491f477de2bf5f256135970f15224163e1776fea77fe9d6142bfc348e742b0debcff6dfa755bbe485a27043cbe71bde6c5492a35de8caaacb86892f8ab854e827d22a1c313bca1cbb036c8bd7f3868437b327b0b847ee96bd8f6edf81cc6329e35f0d55ad627a3db29f6c0057cf540d8f5d67e181dc421a8ff2759dd6a3b2b931e8ccd8d2dc471e7b9a276d31621c8387cf100a43016f31aea570748b96396b8a3cfa0d0dbf8fc49e188dff608831f9d83b45b3614a1c5ceb7efe66f77cfcc427c3cd711fbc14465a772bf13af0d04c6ecc9caf73b6bbe60a5297111c325feb76f45b1a3f3ef174ca827c5669ea762c13ea6b9092128c40638596d14752cefce2f812ad613016df4164510ceff0bf304d04856af16149f7618cdd0a52fdd056ba2be9eec4d89ba21824796a14f4df2e8faf8676582cb97cf618bc17a62aea128835497544cffd4d8dd2ddbebc517bcb51328ccb78dde8a26865e1d290a48f7f21d24ea9e24815085a4010df08bc5a63113f8dae9c813ca9d6ec79c3d9a7f8470fa8ebfb070fed3d890bf95a6ec380c427c7294a716427cbf7c9b84dc6c5cc3d7b65f406e6cd7205114cfe552333a59e475b60a69fe73993ae28688fd20769a2a88f5b5acf8469ab5573630c59d7abdff227c5a722b3a91104760507941e0644539fbb9b7e40938fbf84843e2f4a1fcf9175070a67c998022784999fe298772fc6efd6951f29f445960f044c9b32869ded94a67ce35639a4f84895c43bbd7a34eecacdc572992dd4a34c1dbf5e18b8e97ddd15b691319a081e440b6fdcdaa0c91209917b3cef3f9cf46f9292bf41d29992cab0303cee15beaa651ef189c5199b7cb25af38e9c9ee726b2bb94f68876242ef9e8524d3df8d275412e04fe9939e63fc968281293f22c18d5c48c952d6f7e56b2ea252eee7a914a39f7973afc5435b8b06b5ece5bca2bcb0a9b08f71ce38526ae40453e66795bf8bdcbddee8db965767a379abf615f99dd4f3aa3c3ac054c8afde215e3dd9f4a63df4d42b13f44c6a127a5192007f3be28a10726a9dedc0ae8300de6b7c8e0b4302d11a7f0e7e396a85718d7840ab637b31ead31627f78273f4cb4018ef0d4e07a9884b350aaf2f6fffdd74236aa694c609e7a95a26e5823e6cb9afee28d776844d94a5451d72f5bfbcccb26b2b8d6d3045dbc449ffff191faf99b4be885358519794f70a34aca9cd3033724a8af7cc9e81da5a6d2cf14a5bb199fe9bb1720cb620dec7fd2416e7183ec47d5d18c900d80b642aac48f85534d1d209f866d36b99d2e6ebe9487e9f563a782924936d4f8f8eb9369d8cc269acf10e89e19a2b62fb70e23fbc3e95c4edeac19446c8f2fbd022cffb09c2af6e8db454a99729bc629c2592bc2d14bcb8aa4d12f76a76fc78fd3d28f52ba30a7adfdcf98788c15b25e7002dedc029ae00ba8568a75a418b0abc6aa2a81e3723951fef533bedea7d2521be37f7801d438d4ef472402312fb97e6d6b7e9332943192ee426b8d10803a2e5fb90b9d7a8d70af9f2879870dead9fb499f1e9c0291d21f7fe71cbfdeeb888015ae31acbafec4c971d1b02ca79a3f13b67d9fac8343a1d03fd076c14664b0a7685e35c16c4c60cc96245756526327a9902b6c1ddbaef5cb09bbf5c4a9ddae072ae2a2c0fd94ef43a2d5daf831209d6c07980ae100c407d376ac6defc7905f37a7aed04369213ac6f15e8fea28e3f394b63622d54fc627b486be384b35964495f67b85d6eded7dcdd605b41a8615583e1b5983c5df03968271e843cafc51e44ab9f32898df5061bb990f6b0350515ed8e070ca6ab909b863ac2b427ed589ecd4bc35684444eb5d08dbab508ba3619a09c56a8984a267bb43727b941e328bc340d32729e3737c038c4ef438ccc581718f01387010bf607f740d1ad90f34cbd95ac3d14b8cecd14cf7c5b163e80a99998b8ea9896673e811eee6aac0a1d4127d54dd85cfe51132650c0feeaab658a17980b880c3ad4fbb458c6fbf70bccf8075efa6529a3041452f6306a9825208e0bafd3318b5ebb7a43039606ceac07ce904b991fb62b16b8b04956de73eb63cbf8c2ca8320aac38b67fc14b2fedb854a58037629c82898c6c872aa909853b412bb5bc9befb56fc92ac64f6d4652ac3d31c02d74421c61ac5e796b0c17bb3729fa37a5113aa3066a6bf09c17888880580e772c855df8e7e9fe9a6d62373ebe6e4949e002eb2f90e06099e93cf7724a981a61d56366bd89868f4ea3bfe4c455b38fad28759a27462adac8400ebede1a72a8e3a97942675831da3e4a1773d3feca8a8ce1c24c5d008a7985a969768edf29cdcca63bc5f6cc0697e32a5f531dfeb8faa8f9dbcf81cda6e955268d2a32bbfe6523baf2b3e84617ba4f3a9884e2d6d6ddb99290417a64311133dcde5aa7f25eb68513f788289c2d41fcc1d6ce5206df50a43fc315ccfc7cf5b8076d1ba1a98492cdf629b03bc082b5cc41cc0b68450675b9269c8c57376974ad0ce2a0c88c8cb0899323759e4ee9e54e5a11175104fdb2ccadf113f7e16315d91f49b0447f7f13aa71042ceb9cc325f01415f9dd472a992b6fc89230914fd968c5087f115ac23f2f32b468ead2baea7aab3eb324c07f6bc8cd88264e86583db792f23a1e1ae682cc38c0baba424e61b639ff70bff5afa3cf55c2a2896b680cf1f91a726d6929768051c0447787c9567fd9e37a2c2def5614180173573a80cb57987997002bc43ea4a6baecb7efab1a04ab3548b8ac8fcd62c3e7b1452ed0c3da501d14e6e29e262bd6f8b68571389ae2473d7bb4151943b11b20d34e6729f8d34ca4bb1f7d44204a1bb31c7d9ed80898948e21a0777c20302828d1b3a5b435c4ce5b6982b4a06852a6aa20ba0ba923f353ec43724c9132c9199eb5d9cae893ebdf7b24d92d0389260465c5d6d092aa07ff915be3a697a3d28794684c9a450fa646e4049a7b37467219ff76708d4478d706d3b961898fdfe15f9418b71fca73c301b52437a47fb35c9d7a619463223a185ffb18702bf4a4f1652e0b8489155edb60a899b59c42a19509b616fb447ac11ca9d9962b4170cca4042f73541b1331f8c7164b94c42cedbcc2c06bd23830526f525901c5d7fb821844a99763fd2313bb7b9200e1d481a344699bdc364629d3a416afe65170619e5eaedbafd78dfcc12341646b5776a36ce0339701d2168310e386a42b8879c1ea4295aa9bb134a82d01702f6d779f21b5f0e410b87f8f08919aaef2a9d4bc10497d44e1966a4c6d9d2699e3b706ac7f02f1cb9a006006be706b02cbe4872244f8b24b83e03c3de344d9053954d4253532ef6e9efc87ddf17a67c84b146f1692ad1e2bd352cd71ab300fd2d264ee51d1815527596f6882db46e10ac36e5dc2fab013e90fb415428390bcd4b6538c9b7c0bdec17fe975ddf62edae63e94477648b28e5d31bff7a72e0ad1647ccb3ac505cab35348f9aac0c8c5839a6b7976c69a5c479163d8bb9e88fba6f9f0b86a8a3643211a48987f72adf212d2680aa255d27df0f7033a6017acee46a2c9bd495fe72c36cec20acbce46af96ed68aa1422fa60b7bddcd8b6592696b01575d97f8884a825c740d8835917bddbda7bb4255010f76be40ffe67d30e18e6be830dac3f5ebbdc85beba69dde0067d67a2188be9e456aa40e7885d214209ed001cff98475f3997a31e93b9b48ae8b98751ad713ce126072616bbeb24abdaf1a645cb376f882450d10d2a5f993891e6fbeeeb8da582d62ce937b952e929b3490da15b3caa292a995c6f9a1fc4fd8b5ed6f5820c479d8e76efd842a781337f2b13d4273f144deca1fb784e8d72044913655dce462f44c1c8a0ffce1e4ff09a18bd45140ee63e6e59d366f44a58d9579bb6a38f5c58de52f26813b4772510abeae0d3e9dd9d293ab16c888fd0c6a01efb4ab29ddb2238e19f254368e132d9b55dcc9c5dbd468e9a130695c15a6b4c2773be75265dd86ecc343ad8a5c1c4e7721739db2e475fbb37a05cbf2e45149076d8d8c6947264fe0e40c6f5e9d97b3f949abb0bdd57865d74fdedf95e4469fa6c2c6b2059abf1a7b4dc53f4e315256463f9530aba95c3f06fe5b5c2bb2269765e77251ff933640d3461a2664d28117f8ab6bfe63f2ce6667e880fff2ac96c5fa4a3b5d9826b1d377ba9e8d97dbf4d3ed2f39a42e263c75da1d0e36ecaa127e78921d74dbe5812fb3ac96b18492e90d07cf8efb500108d5f8d21b15fe9ac1cde7fa3346a9c4d8a0471cb8c8c218eaa73c91ace811719c045b9c2d43c8bc051456f21b8e267a030cb126919854349f2ce16b2fe16c87c2b3d0e68bae974ed9f9b85720e5354466a3ef3e8a020a32f3902b9b4d6a72daa1e0a61ba6304b639f28ea50b4d99d4a9db928337395198df62ec216b9e3545b56e92835b443083630ec3172b9ff46cffe9b7ce29d15af913d262cecbb30d4ba7ae8479e5f9e39379e56f68a70b181db9ee05f283d747792d3759530526cc8d7081d1d261b0890d5ab512a748caca0052889248030c8709d6e97b02d02cb11f2b64d7f0623a6700a6c6c438dad4d6c1e65d569126ef5e1e237abf936f453f8175594023f0f3bfbe213ad9241dc06f641aa2cbb284def13947360131aa3ae9302c8275dd1af0223ca9161d4939a32f989369d6662a04e9696b684299448aa6bc1794ecc53346780763ea5d21306c72cac9dd92f82ba576cd0075af6a4e8ea76324e4bee7896920f1e0aa3f110dd902af85cb2926f1a9e1b48ef40fe2de06a83e31ae636dc3e65006e752b1d0ed1a45b5100a7e5a71c234301bbdbd1641aa49e94844025826e31f8cf0a36c60cee8ee392c95372265513e96d8e77235cf60d6698fb0261b161559b2c893fa5be68bd1f9ec81f28845c19485e07985bc7f8eec1cc19805ac1ae7f4d7213b7f22ecb7cf2385857d11bd828114dc431fe71312c6b5d51cee7e6eb4ce1ba50cf645e1c7593e3ebb06e28bd16708ad89dd4a8bf9ab1e5ccbda584706592f173f20e64764b4d9edbdf4af70556a90593b69bafefd29dcbade85a9415bc4fa0069e51501f7db36b44c4302a627522bd1348d0df351c1aefbf15f5847663cb3d87a754bc6e96719c01b8a964f74e31d47562feb6e86f86fce46a5dfaa9b0de5ab1d653b271a3d9b155ba65dd9e5470aef4b66591448058af4194c7d3278ca08425dbfdc86349d65257367f25ab6fd3fe7639809b285b66da7fb654bd7917ed72e04ec6a2c2a86f0fc036d6c4589907bd423dc1346edf711a6f704a73951baf57a2c9625ee0c57ae4b4b6a5a3b58473599bebe90cf5281c3420f306870aa1fc9d6ef0adabc8243cd63d87a8573ca6ad7fb00289131e89017ac18c640ac7b641c7c995caba15691f8f40d613378e018989e8c83bf1500b0397cc1f79b1c5ff21209ca6293d444f0536d3e934c232bc9492e20d1dc33fe12965206ae445c0f66efca278aac93b8831367b716d25f9f1586a9075ecaa2fc29a48df0fea0483f9cf88befc9a71fc98d30165116aaad25b1e7cfa02f0b5df958faa772290bc30af9cea13bf47daa6ae508c4e8a529bf5881ee393f97ef18fd70077810b51ee6209f8f85756b4dfb79d060f00d42627bc49eadb221f02137dd58c0f113b383b772b06c245f68034893cdeb78f3c5993a61f2bc0514e15e91cd3fded8e36d698b014755ce511f866e6f79ea7bcd67de786d68fe90160a901fa9d84153d3b3617238702f0563db98c5a5e65a6f2463aea947d9dfbdb0ff18e96ed7da1e462b2d4993c3a2920f94ee6288810bdc1b8a131b9f7d0e15032fa9ed432021e8a763d64b035abac70d729eb2c71b59c02381865fff89381e9764183b6072b3f77bfee6de2caba3c3139ab9fe5222301b5c2ca47628ebfc83872991aa67699f6457e2f62cbfc3a134ecb3e29dbdf35f3ace737fb5ae04133d655d05e0e0ec50a94f1b0c3a826e429ba310641432e7f13a629331cbd639909a0705b72bbd761192206f5fcbc977796dfa2aa1740583f2c03213d42ac927c174defd4d5c7520c0e74a5b6da0b1d876b778b7f4eb04245c8669a1d645128ad5f167e95e74d5a85e32b111c9fbb83b2eae7c903bf3f7e5f541df8043aed23e1e364a102285a61d7f03d7ba3a687572b03c3ff1feed95d03ccbb57440057148b54cba975e01b641496a527ab8d9a7c064d3cd1d13747d9e1956cbc411094325f1590b6d742bc61fc484ad1ff0fbe1c791197efaedcd18b92f3aa2bd53e30155495f86d7572f7410569caac21942a4a0aae9db606859c476d6f40c4245ec809f7999dab70fba1ea845a511a6f14320ad4717d44114c2a593981ca428","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
