<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1cb7639af0eedca1760e646ab320f2827f0ed0becd7f16f943d4aee03ba4f72f272b313cfcfbea77d87d0eed67307d787553e1ebe98fc026931231ae6f53c54f6b81301de0defeb899882899b6fe7cef63c0341e6ef5700909e87c87a86c3b7b1a56d80e4a5423c79fd69dbbde61b228e36decd7bcb227a4dba4182cc9aed8c17afad79dc8d4c8d5176ee5fdbef4925d4b472f9955f6dd2665dd17c9db1081efb2fbf74675d8de7313df52945c45fa9fa32e55ad8318f831b06598e13a89e246514a09cc02392105a796015345fa37bc644756080e1eebe98c58e0436908003ff6e87f47d4ba446f0e2e83ec27763111d948a53beb961e7837eb6ab8dab81533fc436d88c366671f815d6975fec6f7cc8d2bebffc4686028de9e3843882ba6949a89f59d3de0f95b55f32354f545ac70c8924f658e69f3af8233fd547cc84f7579f6be0fa0a614552f37caa919adfe6793248410aeac30fc8fdd78c8c9b076735fd146feb4028d0b38335904f392c31b20748373a770a73e32b1872cac5371ca8bf31ad48280bfe4d511b63d9673fd36c94e99c0c93ed427a3f28176be518b5905d98dbad2f18c5ee8a3719e57fbd5a188fc15e2bf1cb12e02298a5e31a28692af0fd153140c9044f56a53c5bf7d4e3af38ce53990861c6336cba6c65c0f476629044fbab23ead7f93521b1fa1d272934a650095d13c296776efbc011a7a5664f2485bd8667a4b8d5f56944ad93679feec14d029d792b1816235825b7b54a7f131aee6e2bf58425c260fd581507f0e6a7178d24c176365dbb60f71179a2cf3b3198d246f4396f5fe67e957e9058cac73de0046b8ecdc78e0ac8a1e4f1607eb33b39216df492598c74b80c9f41d391c4f53cfa7950d4114e9300c71868b91211207bcd806c406958464f18d08011509b06143526dba7cbdcd7b6c7db42fe9dcb7668c1d850b2cb69cd2fd429221ec43b66299cda00b1b2adff34689885ab22b1540991e6ff2c700eab9eff6f03f8ed478be6ce44d8f1fcb9d4c46c55860a56e8b00ead2154cf75c262bbdee0b4e32e692566c8e79b8252b6b058d20e32eed210ded9dea3e4885c73a8b0b0e0473e6c68d8815f21e8cd9d1790d2bfdaaedd27c5736e4a125a8399d636cb458b88fbd27b5316637a798d4081c62a4257ebcd580c65c23f1ed837325ea3b8400dc599f60479307137fcfd5af0cdda81a7e378fc80502f0c9a8496c582039161380ac8c77ab2c832d9f0d4ff3b9c0066e02a1a7888cf47d99831dad9596c5b42c9fa42a2d762009777a3f4cb181220090e511ec30faef667aec845961e8132c00183520ace39b6f17e2e7589f999aee580140f5d3ccd2b2cc05c155f9c9b1f6f9c831f02ebc46408e126a0b4ccffbe2effa63c6589d3b5b2500ccf8e7dcdde71ddb81cbd533282152abc6022ce1a44e8017faa28735d20c90c3f43fc9ae5fd367781c0ea948ead6a47f8d165b8b85e2ed68bcd8a8a68cbbfc0ce0e242a35d928a3dcc36e0dffa3ff496f45ca4d038ada3f765435e5212d943bc3597eefb87f0754d7e25ba03b38f711ec1f0de869c128017aff18abf15537ae94eb66f3b3137af3d9b28444629dfaea58ac49a78e986eb762c08e4c059ad7cb270e1aa8a0332bb62a2d81a17b1bc60ffb0e7b4f7c6f126ce827fe0f5fef8ff68ba41842d201ec3d9064c255cf9e918b4a7489773c157956381a43a6f15268aa6a0a4c4d93ab16ebe73af42efb2b06d527380675e2a93ae0671da1b9ad41409590d7341e2b805469192d4eb3da83d117e1af6ca36b40e521985b5ea15a6dfa6f73e38e1466d1f6a37fd9c1e6b2ccf0e2e9d92388e07a44452887cd2cd73fa6736a68434bbf49222ac0c499ed85ab65180fd3f9569a145a7680b8df9a0413350884f62f64d6eab36d8646e9ffcc4d7ccc0124588302d6b790930763851005785c33ca0f77036dc5cdf146d8562f1744bb7359628bb0d82215614bb846acdf0c45cafea21d06003a07e528556889bae38291d7f06127e14c92d47f78d9f1474c85dfa8146cefa89dfca4d59ba159b8610568bbbb273120de4baa557e9492e79ea772517d31cae737c81c943b55d7cae7e8fea2f9f4e6ca18feee16db9326b3ee56bdf42444780f137510425c0c7620f27c23424860a2ec9b3ede0ebf616922ce6e37bfff814ad5d849fb1ffc91a76c15485d71e7f59a5e9eeb570f4181049a362f227a845a002b343f46c4d4f23b38b9a302c9bcda6c8315db3205394d9148d2ed7e8c756a6251761d33d7ef640a2f1983732d472afca1fd561fd801480429b60931ca4f396591a529c6f168b6e4e25f4d475f7a383b9daf2e090e00c4da716d1a611e110f91dfd1fd7829b23aaab0365f4b110318ee99e5e757f38ad6a4f12fa186dad01a2af0e1635e29d978ba48e7311d6af70306765342e9a77f06d2242486dbc737ed656c06872ed50e4e48ad724e04612dca9ad9d59e8557ca2e48bf4ac20b5ef9d51af25dd390721a8ac78490eb8b6ebe6bceb466eddef77ac857cd4b75dbce5f69e472d0267b7bebe30e77f82ddbb9360e71e0c3c38bfafbf8a7d56f501c2e2ba180c95a57183bb55180b7aa9e20a318e96f170f9b56b32a6ade20665cc5e79293046e0583778e7f0593042cf7d605c742615e6172a1054e6c1733305061898058d6c5bc375cc275fef0872de62f254702a9b1cd2dd462cc411bd6b7d218b9309c2ead7f108f001b4fd732c64fc85e5598840b0545e97f245620c5a38dcc8c3e8e81d87511924a111d9fd57aaeedf5ef74878722ff9a0264c4383792a5d8d14c8ba1b51881b0b4a63fe47ef57d6c8db5d9a98efe92a15723bf6966ac4e043bdd10dbc198c125db470db32e5b75571f0b9ff5721469ed6eefd7fe6fa112ac95c6d23ddaaf5251dc497fe1c76ec4df2af19704665740428b3a74a247eb0688c20d6a33c84ac8e11d748be682ce84e9da7144e786be1491e0ee9ed18cd1b32c9f5b02b6483411852c069b841574f4ba62f987bc302e846d4fb8bfb85c986a44feff0202b892329d9db7ae5d784108741be37adce4931c3ca98a0c032c0c7ce75addd0e69bd196b023f82e7982154e636f1fa538766ee00b8fa4c55989bfeebe09462caf0f48242b5a7bbd26f46e02dac2b944a726873341c25912cdf4de533d7922b04bc7863657fe33fe8fb4c02c2036cf2b3d738601175d3068ec075dc267f64d645d33615b9d302b223ef0dd0ac9c9db9b917f4ae14817df37bc6581e41a4b7181294c5f81423a55237d419d51fd01f31588794bca4a968154b6bc5c094e0d6b26c09aa8d10ce472fa680467e35a297ce377b37a71280e3d77cb224a71702616fdfba0297d407a324bdb198e655a58c1e1110b83c267945391021b1be3428bde98221904072192197e06d8d129856b746f0c18fbbf98d9759d11e520140c06b9e7078321e5f82f39e3d5787019de3c8739ab53c1d2be9d295d8c3ce8b8f21cced46e69620ac42334d76315b5f00b0f17b5f38f9841e578b2e94bd7d43057f10577c77fcbc9e7207356397833fb6ef4c6b80fb4f66c47d41145149603fa9b0ead19723162b7ce483aaf77a5ebdac08bc805ca44cea74106cca7d36c77f1c3948a87e16a1cf9bc9f0e28446b33b3c2db883251bacffd641c5d641c0ff5d678b3e636719f28037d22988b66a1c8b943cd1b2f726f52710cee535a029fba5e7dd1734c30973490a781836ad233f8b8e7d34793b0341f6cc4309ccffbc478a6a5b8d43483645d81489575603762dc6d7bf94f61786df99829b2c1753563b09d59e0d88692ef2223d384d4acef1cccda0f477d0288fb4ac982162d22d3c49a45ab867171575d2282e125ede4b752a683cb8c69506e91931f9bef4702290a55fe312664cb73ad5244a45ee26ce641788fbcf0e1c8792f78a7b9e6517c08d82a25c13bb75ea9519f4324fa4279b4cb89984f23990a74b252ec8246aa67387bb7dc4ec928f1d41820c3d417caa85f7373a4ae17c78ed6a1976f3c19664e783de46a856d156339524e0b46e19ed42225cb386bd298c35d2a5298a899795ec06cbd6d81e06b4b2394eafdc6fab63dc152ddfd13e9dd419df5c5b2e164cc50ad47fbc028bcf5058fcdc2b8b24c2afb49afe219c0dca6fa65eef50d6ce6287fe258532b49813e5ce2c620b92aa7b14d364b01ad5808120bc6749eda30bd6ebf2483eddc33418dc23f2e810b0a45425998fcbaf13d023f59e19718095f742a08f79ec73499c1f51879ccb37aff64b978e76c25cf58b6256a24686251e69663590e09c91e776fdf3b53f4ffb9ec1161b215f8e8b33651ccb38cab8e860be62a609104a3f118e1755639dbaf51ec956dab26e47b8cafb587e2a391bf088ed1a9e99d0d156bd7173e934bb82a675da422e59d9fe1cc7dafa23bb8cda93b4dd62bef085fec7fec5626718d1443c9c42592d1a563ad0fe2ea9faaf445eb401d7f72b6c916055b542af0e5eac8c39c97feb4211bb1a94397f061f76280090db3b61a58cdf4db771f58faeba91700c83ee57646584c400d52839084e4179368072b6bdbd8ae1b3066e52d394d0531a75dfe314cd888edbf1c327e23c64ecd36cb6c417b974b2e74771278d20d0c5b23d0fc5117321ce8d698bee300a9eb39eebbb2c7c8ba45c3fabb51a7fb800db2ff57ca5029c73e8c006c636f42e1a2ab883f9030e64b44f9ad1df9a04d175c8633f3303ecc1236d3041647e2213ae7e75087f27ad1c025e667c4eda6cd818c1369d9c6c3e0b4098752132b1ebcc7d0c1f8ce6bd14c4931fa283e76fbd15f87e4902931e357da510095aad9e6817f4812066ac56d52aba92dc9c6f2fa3e49e3c734d6e3ce99b0f64a5d135f82e58f72fa09bc7887d3ce72b53a28fec9129d494f7dcbf29c62819368a8918b03b0cbbafc1adf54b8f569bf88bad43ce260028cda40b51020090ce38184f5447bf992cddbd1471d4fd0a3c8ee475d7062ec22808b196c66ece231836f7f581f5a65e7a5b4b7a63fb67607be821972f590aa12a902c34e38b3244e1f97430027369d3b093f9df0c1ba01460c61fa064ccd380eccd75e51e3a92b8337e13d2177c7bb9e042d48f1fe90b1bb352f56c32aec5335ba9f341768f3bc1b875089d233750add44bdd47112ffd3f4cf789d4e205ec776fe0ed8680d74ea1eddf29460c4f9b6f1f024c16e88178b2c627aed04b32f1ca2e50b3d934cab3b5cc5827da8f19bfbd348bae9eadb05f6dd29c9406dd370b1accf9f7bd42b6d1b10367f3c2b1c46618f082231f52c14d3e4ac2631d2d59db360fc62a84ede33975a6150d85851450f1f0cef34082d76e60d5310eb4d30d4e58c0062cde305f259527c9518f5e13457f1a48b74ef0d851713128fe645c5094d88ac8e4dfdfe3594f80a5578be1669813a68ee3fbb486d6d9e3aa89401d85298224c7d094a286cd49f98b6711576ae64e5dd44272f9d21e6ff049d3b6d03e8dba0ec9b499acbcb65ff162a79fff1740db06c1a155b273198b292e197f3fb841e81fc1eb3abb77a3de9c0b44bbf64ed9dd366b2e235437c747db630468557b5fe5ac64c58ea4030c2a60e3607e4178c5d72ab1a4983d8299bb38b7562a241aa96045babf3f4408a8d13e0bb38704e7346e7919c529c228d17efeb3b0d73a9a2437a7adc78e7824c04983c7746acf7025ea7a2c106369950642a46349f776b4ada28f73b4022e8e7a9f51dedde9d9425e1f78a54116514c881d2b4883cd5a29e3626c4c0eecdd8ea4e0fff8edccba671c2f84ecbc100c9b0a2f9b51301d328ea8d8c09c92140095c53f73bbad9e72d0711abd81de41dfd9b7898199ca91fe9b7e994d5caf20a7ebe5e098e20b9d1a4e706caf014477826d6891b75ccf375840602e3c5fdd4be7e37ae0d02dc0b71f85e7cc12793f2d91d4379e610c9ea873b14ac98952e0a4ac4ceff3506cfb1ba7a2d83642f7c7224aed7bc8f61e0c21c1e88b3672bb5bd50f57afe22d25dc69e01f1954a6efdb127085e2d532f798f8ffb5e4d28c1cece816889edc8c35dc8bf64407487801b73e232c57779f49a930b60c6a30264e8dcce3d459e0dcbe1beb0332bc3d989af72835e3cabcd229a557a313f7fdae828ab7fdcf348dff8ce86a7c18e3174a2009fed2447c088cf8f5a5eebf1b21de9b0efeb5da66e752bf8bbabaaad82e43b5437ae9bc13450671180106a2fd567cfe11c6a6ec22c53dedba2f6ea2a8b1166ab7fb00ff4fc2b8088f4b169d4efce5c9bf5efa21eb9e84336aadb8ab01eda77a2047f3dc29dba7ee7d280a8d6c4650b034985d24386f8a0b252c162aadebec54100d396d3c2c0a154967ed635e59ccc366ecc885a26c9197acc7b6ac3c4c55f0f02f7d4d0e133fbc0957a2d1958594f45f02179224ca4b6edd753677991ad7885d08867f1202ff44dbdb501ad22727e5d2957bdc62fb656f25c3cc26778e2b438cff87fe0b4a1421de85195dcf083612e68a6120932ef34fe460c9a6c6990d9aac00fbdc7da4eed9003002fae976c64f49e96b957af31f6d4368acc07c0c9578e8f53e62afe8adf26fe9ddf6515103a5e138cf0d17acb90c712bcfb1f6408981b42b1c451c0e60a4f7f0ae66d604920268398b7ffdba9fdd8e6cb4db9105481c8c88d3c0ce364d1e93eb11838b432c8964a467a8502b4bc6f883e5f393bd37a1d6eee1c3016296266a55285e340a5af900f43d59f3cae20530a8f30dd624c2698cf9e749a3817649bfcb26c43809ff7bc8edfc77152741d6ffdf87ef65fd1b48eddfb225c96d272515c7661778ad41f8fc440e79a76f12dc7837713cad7d655cef925174607effe77f8349000e22cfac8ce9d3e3edf14db99ea7be7c832676a5444c7b8859d5fb52a939349eeb5a8ec518dbdf91abec8b5c5718520f835f5c1ce159d3609e4bfc21a1cc3ee730aa5c1374d3394444305cb6c66b3bf16f55b5ab702a308e2244d12cc405cbeb807da3c7b525a481a5ca39f737d98a40976ae5861288d05cfabd7e62f473a86a0930f4436c668c788ecd6c5fddfb49ed30300acdc16b1fd8177088595fb20805c35ddff00c1fa8605f87ea6eccdf8395d66259aa3ae660615d6dd2134ab7cea913cc8c6abbd34507678fa1acbd22078a43cf6f72f1fdb3ffbfef2877ac62d98a1e92778babada66b65370f6b1b1b0cc3a285452813e962ecb10d583d0068e2859350ec7306cdfaa425f910877ee7240f1cbad699846f9f5b9821cfd6285b97e65f2433431a76a7bd6b7cda89ff6ec0016fde03db3a684b3df46e072d9e844ec8ee39a3c31b25b93c180a433c37f54e22be6b21d9d989c3d2722302c3eee86b755051d2ad7fb493164fcb9d91c5119b9b588f549cd20331e91a69dd5807d39537a043caea309cc386082a1cd5edf48a63208e7b79a1f1602b523bca3da2dd0ac3390d6b3cca6ef698c96d207a09a4d4eb89241c0ba87b34b31cb4d4e37cc2413410e2f9a65c0b2328b20e24639b826dfcfcd59e4dd4c7bce5121d2c0b20d82887d642f1e2518189d1519a0d6203c983dbfd680ab97ec860b56458d9673b30925e385e965a4633bd51206ef04f90868d870d209b24b76916901d1a98380d4968d97a0a4078ac0148d181e0a9f6928a9bf2e3cec3308e14a710f65f87c8c536e0e821047ad79b01b8126964ceeb539f4d1a4f7bb9731e72be8434aa1e69c7dcb8f854ed4ab5fb0f4e6012869c8017db41549b470411c2e88a071a5b86e45447051757f2ead7cf26224e51f6fbf79e4b5b71f90a104e73313c28303cbbcd37ebb162cdf479bef0d8ca3712d755ef64b0c92ba711fea74f7825f18b058e229d9f978e6d8b9a41c2b7dae4b60caa1cf53d218d91c6419e3901350381dd387c0905b38cd3bc6b1de59d6c25b6896651a1cd8b6a831e114c58161c3162114e0405fc0ceb1e49c26651ee39c58a0a2b8c2aba83fa5ac96d028fd8eee0cdb899f930547a6ce3ae8f90b73f643beb9c0dc8f4de865fda1d174a58ce98251b4f6a1e67f9235106be44c02eed65fd22fba29a7715a813bd4dd09ce5a9978ea99cc8b56df21c5e11e44ee7f54cf74431bf86fde7d2bd66798da461274f13b91af4b4b6d35ff17f9f312183987b6597846635459faf720ba275fdee92ba613133097bb8f62179bbdaeb2f7cdefe1a4fab6cceccc3af3dbef238a2b63ef157e0e900f0a053f5a28860a6a196c873528de357825929d141fba9867afb9652d393c325cd989e4a791fe683c01d80aeb5340e4379f84a9c5a9f2b15ab591a9cb11b4acdefd4fde1bf2648b079d21064c29e660ff8bac88661d94e8735b49361c2770bf2e98da29eeca64fd8c2ac15630ffc40a265d7f6bd5cd400e0db321809ef32a58665da6075498d470d529ac1f27e42454ea9ccadca7f2cfe9fcbad0bb027f9874dc3f3d3fe183cadc1e8ab869085c4d417897ccf2728f52567967ea4c64400f148ae07d546657f2f9de81fea2dc1bebcdfcfae8f39ef89bb11a3e17423a20ee9ac7227a1d371078f52c7930a402593d429f8f49c4a38545da7b47d6d20f73f6e5d3abae4135ac1a17bae7798fdb3eabff8b734125a924c53ee23be47e9f7701c1dd602a0197f4c98d8b0fb87f8c495f08270d31df8ac1713ce3719fdaacdcd940cf38875def06bf3defc49b5e0e932097f7dd34a5aab23d7cc32e6753d5935c450800d4e639586b1ed45a9e5defda1fb438aa2f22658bc6fa042f5a32e5e28dce05db3ef7a1272eb56e5814cfc23863470ba15777c729d4f7249e22dcdb222a283e9ea144615be4d8bff5fb5a416a1af4e34f4a7104890903e2e9f2ba422d0e6765479ac47737981973e54414921d030199654a9f4175063ed69ec47c63a1c9783ea7f066f9c05d2eda69261f7dbe3c6ed7ea88844226d935fc09af52277a2ecb2b240a393a38ce32974b37ffaa28104626e9f80b0618f7a0a6ab3faed9876291d17738914c18ca0df1a3bcdd68afd84adc155cadbb82f5512c5e76e4f3351eacc6c97bb834aba72106350806a3bfb63b2ec6e684dc5f070dea1cbbd6e8933018b8c2a7e48a605fa994b14a63fcea1f88834dfbf94e8d8db60e5c43484fd16b0fcf8e6b4cabcc607e7743a61cb54ffd589aa391537b477ac48e35d75edbb8c35398bcf62aa54f66fa8390f12425d1504c3c10f77f7b2f89e16dab09156cb6a32c5f576560c568ff6b8ed6f941e1ba9110190ed79b01a1a9de713b06b095dc95d15761e95a96b56664d10a7c16db938d62553654e253f9d55a57fecaeae6fb654ef9263d9a7630e07b7e6e2e39f46d49cc671d1955755e2dfbc24f0d170ed86f4762c0e0d5c7777f893a4f17be657d245370a80bdda3e9fffeb56e7cf474e796d6e3ede7903b6f056e87b4613214624646645be66832c91d870a55b903a3db384fccfdbc9d85b9f4ea98c05eb6b42690f439584895e73b1608662b0d200d9409e1055b7be47093aa7adccb719f780300201860e75a9e07f87b74f9180df73b707afea20185b49b7150dc2fe3a28b973bb393ed65626bd4b6ecb22b4d3edb7ff9d77d795dfbcc0b8ba3ada2aec3f733a1751a19192e7aa4d718b2dcd74708c79addd57717f662952925c3341c901a05a2668a10a82a1ebda969af065cf1dde383f5e1b28abd81d91d6d86de8110a0e4e3c04522d32432fde62eb7e5fe015f27fc8e7a053d4b6d829db2023b22dbc66c6f8decc978e53d632e7351036851d217ff1b0f760965bf7ea444a8780c9b8fee440556ca3b94ec228f922051753816acd7abe06279a89b0279f430efe0b1190f3605ff4c60a7a5bd149f379d063a85e73a11937edc6e7b98238729a91d35b04d5222463fcd32455932996c0d4b2bed8a4ef9b137144530244e8538f08190c9cf508cd379ca5becb3a14c5715b3fdf5cc6df639ba461a2b343d7c0293a89aa270f518502ccdce65ac29d267481e03afe431f69c90661c9dc4389c6a47862229211a683b600dc1b49e09b20262b393771f3fbf1d93c04908a1a4fd8f6c1af5564d1ab9531edc2e4343860481eb74f8b05b12142a14a5de5a56108cc58da57d088d2051e69d0b41790c0d4fc790553489270e5c85c77e2f646d6513a4ee0948e788a83e3cdedd92ca0aec2fe1deadffdef88a358d5519798d93c0fe34d43ca5a762ea7dcd9abbad251b698ac7ac5f90b2d28cff15280b37e4089afabfecb8788c5daac93a842b2928b3796787f9c6a329ae6010f9d1723d8b2443596fdb02f9170e0d73d4b488871d69056aa187f62de9c63422871684694166c6f7b4da5eea14e13ce37fdec309f32ffc039f298aa1e767dfba13581d4b4d0e095b0d7958cd7b8059d6473b8a94ed085b891e81756c9e41b297223f87324e30a39e7cc17bdaac7d588e01d5abc8bf1283178f594a56f057c775e77fe279162a1ae4e74775c8f1efb6881092bc7f73148b37f118265b43cca8abd33aac32ba4f2aad3f3db11613e82a75b9fea0c28e59d6bc03a70c28ada84b7ce4f2b6a9a40e6ce3ed777fb6e418886f11139a7d4e6b4a284507aaf6c5ed46e177b7c7dd2a4beb19b4ac97284b5fbe5de2433907e5181130c4d6dfcd0c626990dd9d29c3eabb02f42ad7a82125153193a6dbacdc214524c67decbdc2a96aa3e1fc40825273ac4b103d8d50e3019b7d3dfdb20f89b412a7a1c233bf1b786bd14b5160e0c876e642705aec75946271d20da4673dafbacb4da8b388cbd69da9d58fb4893839ed13dfbff04c670400d3ba856657bc7c9417be04413279219f867504e9993eaf76415a37b44c0b1e2d7035db9526b5cf4c0d714a14a7784eb1cc44154e14f33123af8f844482f021cabc7ac7d5f835eb96ef0d8c73f531a7af31b3835458c656faf00f29e45523863d6b356adc2e76be2297a67ae9a555959d327b0610fcdcc4010ee2c7441f67148590d9023d5637e22c0da2a304274f0a1bebdfe8a7e5c3da4c297073d6ee1689844594296c759a368cf94b9cc171b8bc25c3ff0bcc6ce5272c8b0c524379f5f34078a110c4aa41e1056f44641e4c77d9afda6a407e6a6b98046dc1829863b51286c95c36e1abe07cb2b56ee7f3a7b9747df5022b0561d2cdd33d7e458eb65ff356cf6034c28223e0d9d134f120bb7c9079fdde377dd55bb9ae5636179d837499385e42a5e40201f2787f98b8e5eb070f528632d3bed334f5171482a7d532641cabdd7a4642626c57f671d107d60374556da38e36d9a74e501a1b98d1c32bdece71a37f192113165aec1d23cf835652a04367faea170261e7f5c5cb58ced9a8038246fa891a1ce87b580332705dc0aadb2f4fa0cd305c8059f8a7e9962335c77a5bc9c86967edbd648706d21560a01893d95df853d1f809deb1c4c6e8b40e365f2c8edb17be560300933c97e196f6878ecd70783aae2993c82199d9b3873a867802cb902b2c75329c4a709f639b442b041c227fa1cab24bf5c209f8df509197696b3ec6cce572f5392f72435f8ad09ad2ce03bafd5f979027a2a0e0d3a3ffd7dd05dfb72b53e17a4af3bc1c539d883cfb0a952402d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
