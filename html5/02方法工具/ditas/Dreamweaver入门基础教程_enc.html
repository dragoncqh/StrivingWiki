<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d62e4653ba63fdc1159d36d29031bc5b85d405c548deac04c665e7a0828b3c621c082bb088e2674cdabd6b15797fe40ef678ccc275feed69c6eaa8b81abfa43aafe4007cf44ab0052b7d9d85d5be6d05c1995bf4f9d27075972db3fcccaed10d94f99197cfbe459b1a1db60c20c45b43b3f731828f0f26fef1212fc014e782cf9f4ec0d17d8d0ead0e4f68565daa36f9fec3ea207663b4cdc1dd83f20bf89c6fdf8576c49f1c4b275d89a0df75b50c9b1d8360d27a9ef7738698da3e18b4fc72f1784ea8205f9c10391e7695729fb202aae71935b859854c9d1f98d615b2b98fb9691e5e5605e963bd0504d400c06b21f29110c816abbf0c5f73d3a7335dc42750f0a13f7930e7df1a35b6eafca3ad7da128ad22c93d890220e398582bfc2cf2df042797a45ce328dcc4ee4b7681dff94e4a170d029b8b9c15dc8a2396531d857e43c4038e06a7704c4bf8f51d7d39f8041b16f934663e27556e1f5f8267e3d79631df3b9be8c557ad4d4324447ba675e120b3f869e980aa7d0d1f386563b352d26aa086a760d863acb64030af986b8f882c13c42b52f80020ff0fc349bb5ead24237fd6a26311aa38bdfb63b3309ccbc4feebd5d228ab9367151ed82d6fe33ba634784000783464f2d3946e15e3ccb5bb073092aaf90107ad8897a415022ed35628c22bf7e59dc5fe8433dca8cfaf4e95ef6e3442702250aace6ec3a3486d03e814d679fa01a80074168637f3e4fcbd4e3e7ace2faf681ad3361ace8dfcf433cceaf8eb6f6a253e36718264aea2628bde5643135aea7e336e6f00c7adb65e200babe84446c825d23c5de7cae82e0a458800842c44e50425398e4c37aeeda9eb625e639e3495508b1b763142fa03c9bccc15a0ed267190f7213efc1b048631762e4557154f7931e392887d96ada77f2f61576bdb60fd63a6d8a234a095471c813b39169a8c24de9d285bdd9f5d68d69a9564eac6af50f065faf764fe22216db74d77c8666c0dee21bc6c8e4ceab40f525d487b259919d739949201454fe7729a2dda538f78fe6d3f25c50b55b94959e4973fb71e83dfb926e51edd7d09913554d5bbc0d9c0bb440713303b5858e2821da89d078abf5cdf2462b640239f266386919fc8334f847c79f639bfe9ba09b99b34e1cc18fd1c8b6e3991d5663bc27e66af0f58297ff2385a231eedc869c57b598a1a39c1233b9737006c7cf10cee956c9eaeb6bbc01cb795623b5251f4d1f04039d93fbea1c2267a36e58854a48691e68b12a9ba487d6bb1cc67837f58601ef9f6e0d7dd174311ee9ecb5530027c946d45a7a4e03c4661d6809227491f6b9807bee2f3fbfb36c5a6029af64c71e0eccc6d67c6f2ef25d68c1a81e516aa56dc709a04d3e5bcb859dbfd23d18d99a81e10801eef408286bbff0bb1bbc290c644bef95f0c09e5d021f13897e3fc44b8286bfaf7290019ba23d58a2ba48069fd3757b11fcba46b23472305b86c1d68fad18bd3367e47888f6704ddeb04b4f61ccfca9e54475ee0a00bc087cc826a5fc572a42e29499c891cecbf137d22724da6a068f8e4ecc1dbd1e64b374cab17c0a55f09554e19bd22e88c5aafd61ecc7076d8452281589fd8e55cb191a0919afcc3c56b513a02e96e369a4141a480a5972df9493edb10b225b285d515e3220ceaa94c32a4ed6a3faeb65d44dbc852454749439e979834023d78471d3098a088e86be8e08e17681abd76db4c9bf1ee0cbf9369a6bc177addc0de20b7c672c22f08abd048a69ec6377323ae7e3f499f743f45e345250789d1e68ca098f2659712a2598cbc3c75aedfdde2c3935a418880f0e74610d8c756943cfa16637620bdf26e34793ac072118c609fd519c8f021b6e9f6334292d8d63b0db7a36dbd5850e86ed864c164c8c52b9d65ad9200dce377dfea207e124fcc73220dbeb76a3b552c87687f623c184149c81227c059998efd3ec529426d82f89484d877bed8de3769c101277c54b133a8c64a5c53466cc8d75ed0b405c4e97c6a09eda3ad734f37294667c06578e0b4b7be043ad0d5b18e08718080c950cfade7e563514bd19a982e015cf4befc5a8a39297fb5ae5197206a756bc1f178a1c3382bb84b5087ac37d5a1a681a88770e9ecfb2c410190d5668c0b65a5bdd6649c989c6a8ea2d822326b900bb2c3eff34e51dc99e1c1f98346a2d635bba375f484255964a2f78ffdd8da4e93501dead63973be43df4e08f85f557e7af8f9a1fed6884566b9a6159f63ab2cced6aaee39f0889441ef84f16f675d81b4dfeb349c5c58c5e928b004071f0c0cba5982f4f549aaa70bbb003028be2ca934def60d223b23df0f78e6f73472ba29e1dcdfd442f5ff75e245e48ff37004e1485cbed08d31a4b4db232316a8d929d237c1ff6490d5f706148461dd7c7fc240aef0fedd1b01b2617116877337e53d96f947cf3c9406cece8da2bb1dd39d6651a712ac375eb6f5296df150c6d0e5e140e7a723751fcf9f4e092f4eda132892ec3710049369d1f52547189c60e5ddcfb0819addc6253b0eff1b331d953af8831dc426875dfe335709ed6ce5e170121c6d263ed73924183f0ca6fe1644938e4b1dbdeae96a11ede6aa6222019f303a137e797cddab39f422762bd60abdc4ed68ee275bc9ee9288c43a930555091b6fa525c42e7b5b17affa13ea5538ffff096f9ff4f6c194e3f48e319fc1385734a648a683a0ffc478aee07ba25d14e0af127d9b58c78e100312cd13ed613796f1eda64714cc7284c4722baf971f360b5d11a31ca01b9555211cea1cb84e7662307d5a5e5ca54c9a4268dad3efaf6749218b81f1bbf352b10cdde33a3f19c846c66652debe21680c9949ef4aeefaf68a4725ca041bc98487a54c972b8abad3dcacbf1a825b8e6720f0d78c6cc5cad62528e07089dbe81b8a27ab32935f27bd2c34778da08e823dcbded045bf7515957f08066ec5234aa69690b17d4e9e1c749b2538b4eb07edaf20c51571126ee98618d3af028b8bdb19e2cdcb38b1ba4d1cf3b1b5a292bf171b781a996f6ac242862f955106da9fc116dfdc075e750679f7b088b694bc2e02fa7d05a5bc1ec23b00205a77eae08d05c38da96c9488a9c6e6cbce95ccaef2f8ddbffcb6849c6d52ac97daa0b4878154e47f5232160b4fd4d0e1fe1e4573f61aefff3783453e10baab6e182d70b25a3cb954b1d57410e7d8c0df89942900cce2ecf6a148dd234d53623cc208f3617dc6a655b640472c9885c41e9ef1bf91491d4529faa8b1269d606181fae19177afc614a5496c2b97d7e5bca866d553871970dca1a928393efefdb84257026f3285918d9fe4bb0ce89f1fd3eb2232c36c6fa599fe0dcb8b4d751873a6aab404d4a4202c53119426358f8409744eba558902681fda5ec3c42bdb029687089000e60ef69410e5c37dd07b7c4da006153969fae437c2fbdaa3696fe166ade58ea533f89f6782673cd5f30ee0f18008b9efa63403e4c41d9b6a348b3d6940a62bb6df214c6227e696d6b31f524aef97b9f69c6d8c5743a1593ad44ca9c850097cb50393897e404ebbefbed1c54aae778bc09cda059b34e19c69706c27af4843464aea00b5babede9a0e350d7af38bbb692efcd1f5b7f4da58be9dd0ffce7a91fab7263fde03a31c232f0e1f81524bb63a9aaa880035c3021447549b35bee0d6ab4197c689590133ea4fe1f07b9bb1b45d32f6ee27a6a35692d2d1aa9326950d7a7d40658caa74ed0497fb0dbe9635ef9904b08a2ee4fc660d028f0dc05ac85e964f6833725aa35666eb14567577ec11aa90a09a66528b39ffa39a94080ee617841459b84debc4c62eaed041dadd3d54cd0e9a71226b453ba20666e29943c899279852166f7366a1266b457db53431e46642d66bb9ebb7150fe605a700ae7e2d4eafff1337f9bf35b515a98776399d4827ec9d82f6a53ed8846a207d378b65172c0b7357aa5075a40380cfe567e6cf5ea5c70facc92fbbeb79b3a6b0bb0469dd6e87da4e51f92bf9246f293fe156a6583bcd259eedea9de4bdaf33c903f99868cc0c53c50851e8565b27c1de3d5956277d62723722269551f2ee913ab987e0b4bc47cfdbb82f3accfd20985b373f8fe2bf0bbc26e76371d93b3b1ff967b172f795d92a8dd461259c6ebce54d9a2fd0252bf7bb1cc670218fa78c5c88e7d5d6db3904f32edf09cb1b092ebb1190f78156271b8c5068609ac9313d305677b4ab97155222379c8309f678f3156a9fc0fcf3e94b1be788e41a74ccdce85e48aa6384a7f469e30c5f3c170e535510fd62f8a85915573b3923fca4186bb123ad05effde3db4fcb6ee9879deba81daca0a4fe8988613cb53174cedbdeef322d51f5b00fa350816aa413643736f2e271569b34c3928601562923dcb571daa27dfb5c061caf54339fa69543ac0d1ca32031bd7e947eb681af93c5690e750ae06df32719212cb6e8188eb877684b81d4c52209f3fb74d619aaeacb73b07d4abb366b63b0929c438e66b9144956638f427f80316cfc51e709a1d03dd1da078a30746f93b834eabd765587ee2bdf5bdc65f191d00c3d8f2af99e8e0e2df106fb6fd439d7268770b39002dd1ce238942a66efc3f9f260a258f8c186bfc852ee480823eefe589051d77bacd3a694c904865c2997b08336a71c779ce546de601760ea77c756fdb06cdef5927f9d39067930bd9150b245a1fa50309aef73bc0159e8a734bf155f00bd85dfb2927279de1488065d153165b4628491efc14e292144bca42457c4971d678f4d695b464b81b6ef0e62f54a27e3d606f72a63be08767eee6ffb5e8f789f085220579a487103b7ba99b7f6a29e2b0ee97fe2277d479b53489cb4ff044d03e68256a6c5f5854d59c0e086f1ae03362dbb32c5fba74603c61d0473ef3a6decb7e4ecc570fbadb9f0d0407f382bb187bf176226a7deba13f20951544ec9d9cf94bbef749ec6517166e3567b473973a8dc2f71e2a065e129534e1739d6925725b47ddeba36b15244137046d6530d098e66486769493114e18436e8cfc671f6670459edac2e789c3f6275a502bc7fbbb70c4c5f4b43c918fb8d595e74dd539333bd1f9febf8378d9104f7f82fb8c525544e7ccb5f640dadfbfaade4de7c61bde1a8d7f92fedcf399756f1d49fd6c8f9e3d7047efb0b776779455dea25b1767bee0ae446524bee484dea732e89d45b7b704a3ec835636243fa0769abb6e5f4e2a2cae806fcdd12d0b709ec971e3eb85457615a3ba467b22086b8257e14f5e3380e1104820b7cf4edd448b62c9b27f9d8ecc3e546f1ca16a50dae96e6434ad5a767a859d7283975204959c0e27d0f03b1896bbfe3261ab826bafa120f8a3d348fbcd92ef61e76a7c2dbcc05a3c2800ce6c50a0e9345cc90024afb9003e3f22822197c5856757da214c2fa7cba0313a2ddf0f6109f800798ff129319f8dbb36b03f8bf7a0ccac490d518356f9b9e65fe85a7813fc80071d9cf4cddfe5fea09876749f8901edd303b20990e60fb894ab837aa87ba93d35c6527e6da3aa498c77b538fe769ce0f25eb15f560ba850924d01feda5c1319fdcb69187c5a275e312415810157b08d8d3a36378d2e045a8ec17156fd4be18274a3cbbd218b34ef97074533e72b450550feb5e1f4c6e7e928f2750d68ccc87ee1247c684d7e3c7f7320a605682efc5525cd4adaca401ca10ba4c6ca421b9c7e1f82ec524468875810c4df340912ad01ab7e7e6dfdef1430ca1a21b6b5b118eb06242c7049bc1c212a1d8e011284fedb3e2daf213786e8dd6f64ecd485c595547091e64e2d3bfb083d7642f57920ae64befa3ea34bc159ca1c72710c8cbbf012f794a8fa1ba93e83dab847928c16c7ec4569ec9199ecb7b45bae963507919afc10438ef11d017261f653c0cee5e771ad2c5c8962a550c407211db402fc56b8d206b41c5aafbc8041cdde18f57e05a78475c244451e4f0a2c144ab765cb74384c751c5292fecddfadd9f5edee586d54bd9ad024b98a11c8bb8b94a71676c81d7edccaf55da615bed49b777b59c8dd104d60cbb28ad9faf837251b4097c44e8bdab390150939ed38cb0ec35ca143c8bb5fe1f24c69bb61373b07413af75722478a0e16e0bfa805fe7b4430a610ad89873b97737ec6066eedd69692095c63862c273757f641bebc16fd49315b19cd0efafd788e8abe211ae19c63a973a2699055f5a2aa4b35985ecf76da5dbd737ffac449787e1bfefc465dd4ce121b8b9b7189207aa36b70df00a25c9d0e9130094e173dad711139a5ad2a1962567a9eba9b48f700e1117bee904ff2709f7bc85386911b6650221f65b5a0e419ed1bfcfefd0a4dd8f937b87632ecd6b91cfb3cb4be098c0ce0ef9db37eea250cdbde6545da73a012eb0cf992f834d37ac8c4d2a2441d07880edb63fca6c53068b6c1bbea7c2180faee5ef48f7156b9b9f81692f039f1cd301b39916cea85ada5d3bd0e76ae1fc6a937d9975b2e4d16d6519bdcbaabb0d26906ddc8b6568f454fc9bfd0df82e161f515de4f9e20f08cca3ec5144ba7a496800661ecc9dc741fe62b25e71243d9705b861fd7605c9cb5f181e91d45cfdfc3de2c98ea833178fd06787db0b8dd6a62fefffecb48ef739129578477e9b9acf9debdc1055728d3cced42fa46249dc8fc14f75c79c939046f1f0ee48c7e68d2fbcf01c7b23587f4145e99d6cbf48cdc5708b5d4774e9f7b56a63ef00bf8d63aba2b6fc611aa5d4e41b8e3566b50e592f4ec4211392dd3e2e42e9f5e6e82a7e11d8ff8ffd182e5f9b95cf874057b920bf0ca9b2cadfb5f3b6149267636bfc1c0c27b9fa4a7f05e173d9382d366732e748c05ccf3a23d8a800efded6128a143ed80547c0f3b44096e136ace9fbdb3212a3b782d0ab53047edc8d5cf926c09606660683478004503ae17a350a89bf80d6854f2ce4dcb8aa29b61a0ab2e602014922f1b855053d4d70ada4a0d47b3f4f0db455d8c975c8f6a3e82167222d0e76874b9346a7ed7ab2ac1ec6a4cc851437f75fd2842d4dc79ea2b3719e8530bfb902df7f3436912f51f94f3436c07be349e5b9958e751903f5cc792e50112775d12c09c38e6931b90a2f4e89a04f869523b2a8c3c28f8d383518d889c18e97c8febae58a229629d644d728c53756a5835a5cdfe67eb86734bfba61eb77d98bfaab7594fe363c6d7136bfc20f46496e739d9d1a4708b42238c62954d06f9c0a7ed8663fb4fa308e1d219cb4a9417851584720c97628d9c174efdf456b2a3d269b5892e0fe9a44ac8fa1523b4e4dcd67bde01e672991b7f6f13bae0c660cd866f0b2c3feeade49721fb06e5becbf92714d6ca9d528c8cd2f87ef42421ab3822a63a62c1f072d0e4a591862e3b2ae247a6ba5dac86267c0b299da4ae53f389993392cd2662f20d8d092d38a289a0fdbe0cccd8257cec643deb309febbd413aca66546d9bfec9b8e141dda647c9952dc9fc2d6cce3c047fabf59a8c8b53100972945485529dbccdd31b76c2ea549a72af4354b9b7c58fdf1dbbeb74315f0feb4974335da016cb6c46fbfb63b47b98bba8c3253b626f6ef00eb5fc2568b2563024dd5b014a77890302538fd33e2f0fe7c2d9516fd2ba14202e2d7176f32ad86cd1c0d5aef500b49a063c5736901fbc3b3c2ee74d7f7bb23f94ca43427b818d72edcb6d55aadee545932b52be80577500b10950548cbfcd361e9f6d20a02f6984d28448958877c41fe009f4a75b0db9f947173d9fc8fa6143d39f24c833da7982fec42fb49e0a4710e44243e2b07c51b89e24530cb20abcc47d6f3ed991f40a3c2766c57c05f5b6a8d2cfa9dea90ec1786ff9454d30d0f1c8a6ceb74944465e0f1d51aa3395dba52e0d5c9cdc003e190d8e193c492ad315ae3a50f56de5a236e9816ce6e9cede448050920e84312e9c16e545514f3c666901474bc120acf89c9d91a8a2238cc4641b8dd7bf2e3525a52ebfdd7e6d0b5d8e3254e91feaca40b04123453f3c98554d37b8f3d50c8dab3ff34e6776ef2d3af60f4a75496305ffe4fbec26e4c0702fa81fe4275d1e45f985d176de66889556d1a7c2d5f706bd504ca48312e5ad58b6dc0d25bae0e1ccf3643c321b79cdcdce64823f9e8f14e3ddfe6edff3641d36bc26218d2b82e45dbe81e40fdf058dd65728e008e6cd18dbf193bfbde9f6e3148d2500e341020cb9082424a5c5d4ef06dc3ab2a52a244600f98614330c849effeca58f0a7d68887f22b8b9ab65d65f59f90d61cd7700f7626d6aa815138bf745f82ffb0b524ed177461c9d8e830e4792b91236f3eeb3fcb608d64eee1148d834ccb37ae4cfb110cbe65c0e3f707a29d496fe047f2600639817952bf4cc3be2bd7a916f3cfdf2479115611f1121a09c950a22795b936467d816150487aca0c96cb2e8c7b1b350fc754b6cdf249855771dfb6ad0f12f10ff54ae7e11e41f4fb218ad40b566f4281f2313f249694d605b2c740967038f5569f7708b98552da34090aab6e2ded54b0c1b0ea43d6e7dfe27ad223aa55ec0889a6cfc16400e42ed8fed50bbe1e3fef7e956df2ecb39e6e724931c39f6c49735622e194abe7bd8a6f4fa449dfde28a996cee8517277815ef24c953f4eef083c74a718642b7ed675ea39634c014cbef0b3dca46025b990d28cb3b96d582e8feb996f5901f27798111594739b35add067fb780af142e79e2216c6abb9bc14d1ebfef07e09456b6999418b7b5d579965d52f318f82aa4387ac30630b914a567af248ae87e18a2a91487fb07253d7346399b08d7012cfa41a0424501db2ce628f09c3c5e8ba049505cb450b7f96ae8b27b5f3f9b8e3a4c0e7b5a89116a7de7bfc6820d4448446f33810603119d56f0cd58cd0b46b51ff1726d0815ffc57922281df78bd8e11cedb511ab48fa1eded95334483fd5374d6fa2f29c003833ba5cc3f704e3b8971c3e6265f19075ca39a7c07c355210b58a7d4338c165b1faf77dfcd8d844d479cb95bd0171cdc08122a8a0f8ed05efc8fcf1def20eef79326ddfe48e10d2b1bea480845859daacba3f400d9375106ad0c864b5cf683a0085e653145c5bee1d706a6b1d3e5f10719a4b74fa79c436597fb06f23e34f45703c053abd8426b6bc71e2441d93f0817aca360759ce289684c63aecadac7427eec52e14f729814e5a39b18b858921b34725872e95157f3583b250e88001dc589eeb12831b60a9220e5e9d2b83cc0015686feda36ee83dc14fcb53728b389b9b7f0f6a5aed7c4524ba68a220c7300bad3daeda44426673658910d8ee49fbca2a6b2a45c59fe5c3e8941468b16c834ea8db4033f1517812f517807648f2937d602bffc7a4f212191cdbbbb72f84edf6b60db46e4bde79d25ad8601b238777c58865f3dff6767194ec8b5c42318c351c25aa7d770d8c3d80eaf94136d5893d299190b8ec42c47dbfb6908f8461a73f07f75738158276c672f917836426b62c5db5f63ee493661311ebf325a4b38a663323160dd8681419fdcae74d45ca37c33d3c46da3247a27cd92aa7ff582eeb346142f8add997d2a8a38ddfada63e30f3faa6795e5cf13da1719853e240b5862d0b86587ead992aed5a02dcedc843aa10b2c48ebfc30cd766420be061f5f9c1599c97b10007d4f14b58fe538b6282f05e4ebcbd77c40d0046348e0f7af742687042759192ec2e5e7673dbddeaa9d17adec960744d6f68536a9ce206ad1647426698b28597e7c87ef4a10b7e9c9b3c1e7f67c76f28c904050dce181262fb15ecf0632d58fc17fd6f2bff9efa6ab4db10829c9305fff55155916b264edaa60018eba546292377f3b5aa13ac650de85651a719962576969aa74ca45453522b8f31bb1ec988ef4f3d41d0f38b3298a0ec06b9b91a7f4b226737aa85fcbfe9377234ab345beb801fd8b2850b215e3884e194cd8a7d60af4378d0fe956d756fefaaa7bba59d7b625e7f347b04c53968e3d096205cfc2e651bb0da1a93f8a908414d1a986b019a427002e8a18c29bd687d6019cd9b7b007198f871d280e9afe5863997341c5955df1f4ed3671ff3c33839a2ee7a24152a105fe4be6e98baae4eafd9b7ba2ee38f24f621654bd024f29350bcb6b797f0146bedad4fa65333291c87c904c69596351e0ac3aa538b1846b46dab77f3635beccd5973599e7271e01d6c8d22bd3cc3dad5cef3934fc3ecd7bb347671dcab1827eb8d36c3c13ed7b5a468c2c9ed3003652278967ca12feac8292fd59bdf22304cdc2d82a2680dd865631f58367bac53fcca12e69d7d52531483b3759ed044286f4f4ef6c33eabb3d3f44d6221c5f1ecaf3dcecda6503c2cb0ad4a932b63f20f6667aa6519117061cf06274f50545d3f4eab1b2304e5ba8e884b15f2e1cc5ac9a6ca14f122a516351afc9341da0b3214f13f66ee186ab4e60847e47d2ae2f30300aecef766e91d9866b6abe200e680eae9fc63c01b723f041ad3657168c2b21c28a7e128ed092d1633cb79f2ede973dc6617e922251ecca49920a0e23362d30b02117b55c3c77e188fc0444fd2f213318e656f08293ee911e302cb35a322bfad646d8c246180b2b7391f462346cd7f421158eb81df90070509a4af06f6fecf77590d437f5d695997214b1ed59c5fe3d9c75a32c1391f48c169dd3556681cac360336e832bfac881044fdc06ca3cc7a38ced7b0ed493d6531f5777da11e85cd5e0dcd0256d9b8da7fbc34c533eb1d73d52037304937890a07ea985ebc109e6c125b845a34435d370c15a660d49725534fb9a6d7f241e0dc58b98e95115fc4d5fea245ae407b7c13c3e6de2fac7bf094bacb27f9fe904dffb15bfbfaea49131a000b65c729559431e6786831ac589f573593b16fc0056b2c8cb501ac3b09c0bcc4e27f6a8e0595c6362db826ada3e4cfb9bb39b7e0def7111cf7692426d5280d151154de9398cb5b86b93cac3f3c1976651f99a5fa61184561dd2115d5db385592f43ba3ae4d20e07d925c4dd523f5177a970b0634491b35876c689120aaaacf1a652c774084367c5eb07b78f248fa07b341ef619a2db94c6ea4045ccd8b7c9eba7c4439b880db72f3261e78da8de52105207d39d1e21f606ee3828ac4bfc7dd8469f23b2744237dc0d009d8d7ced0f2fbd0e74dcb2b32ca068220fb6631b92cf2e7309b5f62b5b3911eb803099c6de76205149ad29f448cd125d0352fe36ced0ea60cfa5ce788aff94412ea1bd4f72ac3732f9f15a7c9e2820734cac388c2bea8d16c6e67b6ec588b3ebfbfc7deca360bdb4caaa8fba2e84a5cf05f555c96ef2db7c8ad20e7ad680ec9cd4bbe9762021783c6467cf69c5a063cde3edca311224051c534e4ff6ede3863821c9f394e8ba3918cafad8ff04d4f763d9472d417de8aa503b9c2ae4ea22e0e22a9cf71c54b9a30c5ed9ebe79d84dc20ad1418930ce424ed8c38ae64c77876dbf3620a505981a55a9baa6a7736a6a545c65e55fc2aeaddb6f1475c22acb76998002706fd464da30e7f4e6700602eee332ddde8337fdd2f7fbe461a1253fcafa5421ae3738ea5b625f1c755527ad56fdcf47ceecb4eef10359deac18cc8c90b97a816bf7681e2c758240f47373c94bf0f3b4f059a6b738bdc06bbf406fdd72c4a4acf4c2a1af1aaa370046b74b18296ba222c9671a46896483511971f37c75030137aa30fac83e5c469ae3689516186dcc9205eb138d2ad96ddcb7c2f3a7ae2c53b421e42d93dee4ca8b972aabbac7495cc67437ddf9c841b5bf102e8efa4c39f4b3dcc244b2b92a10743df3fe0e791832109d79420af9a02733b0ab7c650262af554c917e4a34b4e6413de7632c8db323df44afe09ab67051de8ac29b14b0fa85618de3f35a09115fd6fcc3fb286792d9240fc2cd1a717df5672f5b345c87acf5095f5459c61227fbc130d8e2d4122815650f40e798a69f0cc8c12e55e552952e23c2a44323818e324fc638b1c96a890bbc251dd260fefd9a2acba3d85d54e5cd778e90b46d67a89c2be2e48f0590914dbe840394ee7ab884874818cfe15753279005a4800243958cc6861c1b1be0b5dfe482cbab72a02057a235b517380011046a1980b3b45a102631df4e7ba4c6554daafd1f0fbba8d77c23ba7e99a392cad3e5274b7418e8596d60e0143e739fd7ae701e9f0286ff9452ec6cb562358180147e3fe148689eb9df7d601b8a0ce8383e519ed056f1f20c8d6852816c285dd746e1198e22eaa028c9889eae22e74403dbb3c06b32751e3583852cb6ff9af74f308fa524f01eaa5c3648ea5d8b2e241abd884ea7023779f44bc150509043b3e577ca7223dfc8143c17d776d46b49b57b7faf18f5ecb887ca4688d773c64faf824ad36e484405994fe0c9953279125f0e1406a20b9b5c66cc3214a472c0b415fefcc76e95057defba5172307a95923ada6d7a4885dd831384e239508590dda44508bbac31563a5317e22d7df9dc4c83ec605adb6b4f25122b8e6ddefc3bc4ec99a856ba321918b66b39ffb4026b543f1d95f312e4c2e6630ed495fe9774fed7fd4c230870f140993e80eff1ddb0e3619e3e568e83c8e53f35c0b75d5ff5ad7611f19634f627fb8c2cb0b174ee4bc4eb2fe6a90ea26df17380170698b64fcddea7198999e015892260708bfb2337ba832ce6a57964587946b446fce4dc82384119d66a57f8f8e2edb8aaac20ca0d5b6bc0f751a9dc96ac39b696035181a3ff686c2f64bc8f4e1bec0d881cb3a84b5f2ff98af1701355bba1bf9e516d3fb7e873dcdab74ac5ddd7c5ec7f2f824d6b708abb22afb6095dd685ed951046fb87c5baaa90f181fba07f0bdf270f83738ebacc4b3ffc904ad30e885066167611447e7e81a36fbc68e701ce5fa9d038f452c0b759efa6f050ebe5ba3253bfd5ed9dc9fe8c24deec36c3140a7bdc44e255397317999862c09893829b429b58cc5f242d2538bd09ef492fa1c39fd51621ac8fec396a63e819aef1849df85feed98146b5990e649f2d633b141f7b348410780545a8700df4843d1cfa828ffd146a81e6224f18ee18c125f895d45981e86130499fe326b1d44fb6e48f630cc6feea5916e7c450cb452a283dd76d7b9fd85e364338b1cf921650a81c9238c342adc6e07a6adaf5114ae7634238f248259e4ed65a377f80ad38f667a9bdb0b865a27340fbebff4bf477d2eaf93ad34b9f8534ad6a4fea04c43b6c8db22f9287fdcad6a7fbf2553d509049734f97927796cbeaba94440592c3d2dd6e1e28f4881345f229982308a27f7ccb87a70e60ed4575bf7c8aa7b3dabf40986b3a03d067745c3bd1b4466205147267e8b74af44bd9231ca95e615569bec0345f8fccadeb46d4f84f0e994ad6e09da697aeadc86f6edce52294163e88631b0c6b435372895a96603eb95f6f1e2eab14e21b76d0e9acc8b47e74c3f4399d75325ab252eb867b18342d067f9bb4150404529411df3a33dae23daa801b53afa767156585156efd88dccb18ce83fb23be7cf3b1ae8cfbfbc36266d6c29e079cc4f24e56d66105acab6a2f6e539a75ceae20b2794bc05b99646fc5c70927028f1336b98c7c508ae84555af5d9e8257ce99d7836a435b0d464201d41bdfcdd3f59e5e6cce7543182c60dc909cb08692e9a9a50fe13982e0ab8a49309528827871fe3de7645f90650546aa25d7443f57a9cef4ae0455ecb5679de5a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
