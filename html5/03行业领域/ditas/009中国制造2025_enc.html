<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3e776fe0973e35202696092196ae96f37f8651415dddf789ef2b71d2ebdd61370d958e60c1f277ff02c81fd9f0abb48cab2d82b75788fed19ce7193c2ecc5ae99e498ca97bd1ded31487b80cd87301dbb3374cc5fefa6f0b11b18c12f03e36ba4cd842ec11a10fa3690b67b43a657848c93625daf587ccb2c803b895455c19390fb3107121614935aa63a9a0a75ad7ab85f78d743f3a3d750679c30d4aed8c6ccffeeca11131c604c9eb2aa074f1dac013b2bf2b51e0d78ad3d768a957001ada547b07d7de58c9112c91d89e4daf0cb649105c360c3521b8761465b2454b085056ecfee6d49fcb749ca47434b6755fbb2681476134019b354a6b663a5783a835b4f0d2fc85c20c9ea691f3440e93a564f7c4420e51239a6fe8eaf55ef4a9199fab1236fef3218d1796242299898af95f0196b738f24517f4f0c4561c61a7fde1ae225a976fa5908297dde3767165b310444d6558e2f2e2e51c107a87e32a567097d0c32769e434977167002a8f8fddce48137fe82d8b61b904e0ba88f27173abc13b8baf41f658c309e0dd106dd2c1d3ccf721b7fa8b593064f6cfeb5dc42470e9b2920b2cc22b77406798c8c8a10b4fe46349878034e05e5faef316c1e968f9639359c72348e95d6f7516dc27cb8054375afecbb5b1773227b0332d9f1075433e4d210f660720fef74dc17e5fc3448d6bc85ac56233d810d7f77b3061eda91f6b1ada304128a868daf1b38527b504b4d873bd70549eaaea54b80e99f752d6d3ff9963a547be455958f056db599d16342e355c8cdb364989ac2db71ee8800150332925d443b4fa8d22b627af9d395121450adb829f9e286322bb23ac4a2779fd2e042e48732b275cdfdcfc6aeb14443da84e203ca491ae83978a5a164ecd663d83a930529158f4c525bf0c31606ba5f6cbed92ae75a62130c568eaa0c9052192975088137efcb3874759990747be1a16fab0dff3ba3c81224f26eea435fe6f00472ddf52261d4347d24a981b19ae1a05d9d9065d00851c262ba09320611fb816d02092fee14039ab3db252417380d89b4166786ca65685499236d7074060693640aae13a25d85204ed9c6835f003b0ee4736bd0a7dcaa7854f211728e3a022e3c337cf42d35d6fd0be3a9184acbf9382587bc02acf6e2576e037dcc61779edea5e9ddee92c85de419d13b094074def28456670618e6c8fe368721e470ee5aa9bd3969fe5af8ea75135aa3912ddece5488230c82c2b106982164a9a225a2831d1246a8ce84b3206139ef0bd24a805332649b8bcc29fdf784c377ef6429a6fcef0e5c2994a8585165910cc8795f5c6058d76e4eef8607e5d040d8309eed4269f528d44c8d17139dc230daee80f98ae831bf1c84b55e90ab15f625292a9f496936824d871e13f6e7556dd6cb8e4b8b1352db5757f56a36f97ead08b84765425e09e372a6cffc8e88ca50f3c06d880f26a70b1590a51e6e834c7eedb05d8ae62eefc66e18a858356682453f19ab5d02e35a2eacbf9695868d8cfe392a61fe019ea0c286fc7c52c4730fbe5ee87260e882b2b95fe4734cc20e768ce9f349b0714d5a2f1bd20b06c680cc69764449d057dbb6a2392e2a0927ae365ee1c80d44122eb5014476bc92e33d0d03b9e4b5638bd79a50d45c300af26819555ec0d6099b92d6cac2e8081c902d5ecf9b4de24ff7a05b39ab3f3e80750410d0baeebde65ae6b4fab3aa13cc8a294ba58f5e4d04fbf6042ea8bcd2e40558f7af5bae31f16ee49d838bcdac29c5fd5c4fea1dce14dc46d12d052c8461e4587fb6c80cfe6b5d7531dfdea1557514bf675aad4e488d5a90e5e4247cb801d219f0f89e9cd36a29d1457cd4b88eecd1cb3ef8c06235813c5d5e306380cc0cd6273af991f8a8fa5b0c3f3ee6370740dc21a46f44aab90c6aab910ced40b8c762ec6685e7feabded839dbc39f8ef2443f4fd535a2e9d4ef8a10bd23b0c10ba4afb7b0b05929700796e7ac1ff87761c1e5887d3f8a767ab71e0940cf885bb83d31a32ac4b785577feacaaca31a1ef98992262cb36078ca5c6989cfe65580b1c024009f329999dc3e6ecabce62afd78a6cae90ddf8109572bb7178e1e015408fb519bd79d0f2ac071c4615db0ace21ef4b71ce76d09edb965f85b2c4c50f7b66f640e450df087bbc5c0ad205cebecc01701b6de07ef97a44c9aa1d474f7f3e58f79514220b9567707407fc79ed78a67b779340a9f5e57239336cec92a885df1c61c32b11fbe9231d73eea4019c1499000616be64e500848cd3ae52625f1d74cbee5fa2bf8026f4acb6985520a4728b4028248baa2a0c3ab4914b706b05a2031011d215a977074139ab41f35eefbc00ec0266d065b42b3d0f1cb67f9133ce5ad308cd0d1ee586cb64758c7e7b0cb81dae125ccf4a46de53e543e023c0b3dd5cf3b3eff52d7f31e3f98cf5a3ff5f4d656bf1662899218e583a210efa683751f2ce50b76c7b2e2eb9d35756f58e95e51d8cfa0be8ffc86f6d1aacfea4a07489d761f3d69c8ad0352d521175403ae7cda4491693d19e35e2a4176d6b7dd0839303d87660578ce621403db5f976616e289560845767ede7193c7a44f1a841cdd32e3c6db5996f2abc0d247b136f6989d9b6164c5e9c5ceb117f72ba6ab877016dc2fd58f37d99cc6b04b260bec3c063e93797dcd2d032457e00e133caf5c8c430d0aa9b841868ebafe39ad176ab6ea878b36720eaf9519b55a027837c00c6e56fc2b37b4688df2d2da27457440dab68f53abd7351d0f59a1191a9db658eb759a4f9d33ccaee6962a8fba16254d8d29385a13d52952cdc0b61a97f454d9b5ed571ac14ea0e52056e936a02f35e078966ded14a068379240d37920c974d7a33c726522e233ee87690586b7043c316b0338d769a61226bd1fbf77db19bff06a88a132574942f4c290740982e82407d94bfce2ef694567301179dd198b720464c05d86c5387b79d4a187f781301efc5671758cd9bf8d992e7426c0f9067a80ef59c46512f0f553ae6b1ce5196ef8461540e1b0c1628759deefc31d515070bd0b5c5a19d5c3c1fe4f5660e870d86ffbd580aaae9df65c5c4be0bd2c5121af10410280c15b79763a253e60da796de00406316a7f98b97f9bae77e73d8b89084368fc6d8dceed87cebe241edc568c3e637f27250cfc26fe06605008e89575ed4b5f3e36c49644169896de3a4fd18d1c5f288b12633b7bcbbae4bc8ec3caff59221e87c924c81a471a1094c2eac8c6f3343a583ca217f30e242f35de6a3c885964f03f98a038370f401e74773575015ea7d666397626219c2cae094973a01e112647c79ef02b146eb9370ab39c1ef110c8b016e9530b047c517632e338dadade2bdfb363f9db0c47b5dc2e0c4b72a7fcce6e31f0a02112b49851f3c4b904e7ffdef7a14882c6adda96dc1ffb570b365079365f4ef252ecab79b8b38fa8dfa1c53290594a1d69ebb737c81544f40c2ac263579b27b4c6449a07e71a96778f58216d476a5323aa86abf654c766f944b7db1e4fe6084971ada15fe119a4f82460475895a83fa5c06bb0899c967fa3f205fb12aafea5c9c1d9c4493f59bac7f302270a5b63ac9392504c91885b17fcb5d91d342f55a102d016011184d855cca56e77f176c5a54313f44e694ee2596427094b86ca1d871ef7e84826ffedbcbe5ce246f226e6e64f9fd8e7c83b537cafa2f6ac0caee9bd0b786c4c46113af2d22b63c5c4f5728a290df5df4e5a38683b495bfd12dbc3623206877c64a781f1f1a98d8a1883f3e1ff4e2fdd8924c281d288aa15e15978df46485869cad7a9a3c2a3ad573373b521711a8ca96610319e74d2ffb7e9b7521b5a68277d9eddd6e394b2bf3ad1164d395018d8c96677b50776906fe5ab499b29571d793fb2ee6ec371245b0f041e62bc0633aaf79cf6957cd81c789e655d69ffc6850d08bc3b4b2db739b8e599762bad114ce499e02b81af97de82ce9c8a53cfe236db20026eeab87d3235e840a88eb094f68a4cf8d552df0dfef8ac7db182971e066e50873741d4ee1b492b8d3f2f6fa05785633365fc2bf095c1280330b6db8b23a9ccfd1cc4266d9a75f77a3e020afdd137f7d4fd86c902d3bf97cf9d89133f9391d50446d0efda66d06e53a4e32d15f4742449331099df242963a292923b10b6917b01c249f8d53b768611c852eb980c197d6edd0e2863d568f57f1c195420426276a1c69e0a816541b539228ddad7b8696b5fc72c9fc12e447a0cae0277553365fbfc8f3263e46e9dbe9375eda5a2df3c44bf80df1db3439a79ac9f22b5265da1ef9813b3c31f6fc1504cb75474856f18f7bb26e1dc0fd285f1a431b017be8611988a81699779bcb1edff88c6a374d3a2c61fee3181af071d0f6cfda33ea52843c696a1abe8726f8e1f5e92258bb0d32eee792f113aa9bef3685621d6e24bce1e6972ad5d25c37bc8438638cbb970f63ac8038c952da55edd89d060456672293f476cd1065f3ce188da527c6f997ed36f9521e76bae6f8e57a72a4504d83fc9a136529b63e072feeda222a0b2e462c51afeaae3ede775e1ead7d6af66a5914e13971d4c913877abc7c7ca041adf920f9d987b7b4e5d4f26270774d3be45ad1f782dc4086adb7df92e2a84e2da68aa9604c5632ef7f55777f36b66884bf1b2ff51104a7e2a4ae63e2598ac68b3095c00b6bcfce1e755b2e00b7d4cee5c11273d56abec4a434d682eaf71ba6cb646d2f53672a07e6086508c43dfd3a6fd4d7a2ade0a6017bccb940958478af73f89b6577f21fdbca1678c466d760a01305a2e280f83d3f4399fd390baf91ab32ec9b2bc8a1bd56dab77eef1eaa0b441b9a0613ee83878dd38347182a8438924347751d49e09078fad3728252c49abd7854abfd43be16cb1879edba332f9b6a142db03913d277706956f2cc14326f911761b6e0a8adf8d6db1601d7b8163aa24b6fed7858bf4b468cb85b668d084a77a1af2731a22a31b8e7c2d7aaea1d53a37bf0ea797a201e7f7a03832a3a48fd2c7d47989ce51fe9dcae787aee074471cf8206f2d9289d48b7e8d3eecebbe46900455c5f8100a018ce6b17df9821555c20c40d86ee014f1cccd7a5e3c890bb5713572b01cf2e07666c176cc1d7533dfbcd7aaa299bdb854cacdf37ec909ce508d36dd8526991978d5a72a4d8fefb07dc79910e56a2ff042f3ac2e24a8dab4c34236008674593b66650174447ea49c994954716593a5cd3d8db6f5c287d440e20180207625a411403f802653d90dc70b0a60562ab62d6779926d9f4d86beea086f749820c5224eb486f3d8e7e64bcdbcfe2e686226976188a31b0dca3238b8ec5289c7f4da2249fdf83fdf51e904d5f60b6a2d44344f1c79ad573c1c08a44b9ce94ba020b5199f297decaf30d621df80a171898ae6cc299b9b53b6fa3674bdc4bf19d538beb1842c9ec63de1d787721a73bae14880f89b4a8420b67d4af5a6c6570f2f6db4a291de46faaf6e25185bce9f9be0f524fb4b0bd674585965565caa215889cf1f2dce6c46567c16714d77c3c0bc3ec1cdb2791576244a2bd52cd80072e5a053c399e08a8af7b9673116f44557588c97d5516cbdc481f11c14814086fdcaaff6fee5c3c5fa64aa3fe138072d8fc09cb2cf65a559a24748fbf735c8bacc277b537fe65ba6886204ac136eb800931676fd3fcf0ad8ef3cf8576b5fc35d5ab2f71cca4afbd7cbff8691e2be99adc9928bb7c3b39374ac8ed302bcac5791d0bf750a6283a855c605ecb7e9695febe254954799ddfc921c3887430af69ce33a023223d1760e6b5120718533104a639152567552a16e0644973ab472c05bb796c5620a3bf7551ed7a2c371f99ce65d5ccad7597446199d98190a20ae78fb28fc99d2caef8a6aee1a7f0bb717b60bb910e0fbd87910851a6565e7ab89001f0cc3e1af5f681b5cce64e6616b916eb325178ffb1e01688ccd681b290868cdd46b51d39d89cdef147c7587b3200b2d9c48029ca62bf5f2f95fd94d97cf1e7a7d55f376ddb38ce5b028f9fcb556cf0569688e414ba7d745860059307d2104d0b55ff0b78b17738c7fd40a49d14bea3cc3395aa7261058248c1b45f290aac9c8d492fce0a658700f5fd7c3ee5fd911f922b77b9ca834244d0792ddbe94719555d0da3eeeed976b7bd8edc2297380f2850b1cea2ef2260117459cdc096cbfaacdf48177a310d2bbaf45da93b80ec83d4d8a528fa7115b72ffff34c1a547f2a9838f7db86306272066c6fc75c7f022951bc5fd915f2aa743f135abcd04fe909baeada1c2fceb743dca6eb4660a0e77aadccd5b5c8a1b0cdc8178017a95e6ef8200aa9b176be1b7517a5dd49f6f557efaca0a746e0267aea3ceb2cb9e5c06be8abdf284970ee45405fa9f06004636685861d673d405626a05ba73de3f7a518f13a87cd3f1f4023734078cf98f97b8277530a83f11aea3d8d493889eac3119263bd6d3c63a1a369c96bc994ebf694dd016a74f1cc907302d04bd917f7ed8ed369c6e40e0846a905a934412d897003691bcb0bb7d132e912202a86d38e2f79f7a9a7970e33de7c50dac3c720278931ee3dd56f14a3fb851d9df8c0d0278b3cf9886140697f9282733c24d69516d6cfdfece52e56d270b22aa541bf9822240797264d9b2284debd63067354fdc8523d1c92793ff84c0b55e8560e9dad25e47b63da2069b0f92f20b8542b8a3868d706449d4476eb885a6409994a965a6fec8e0595c3a1f84a72cfce10a460ab5a9fae90831593627b539b74ed14c59eb809c8d3219937e3ebaf559610e2e2799df28c083a8f1ddccbbfc2588fb759ed2aa46fe505633b64c962ec24d06fa2151f1047d93eb11d6877c651f4ff3d1e76d0f4e8e1b6c5126a36489aff19b389e7a608d7b91c004ae2a650d9d183d63350bd401cb0b927f4dc3fce68b389c3025649b82a66d07ea310f5144bf7fbaf059e9e60fba17c09973f1764c0081e9b6074108398b055161972ab88cd96a4dc4435da1474e3dafa0f05f8d0135a19339d36e2d7b836f28bc17da4f4de3fbb6fd72198f1bec08a187e6afe93d475a83918c89ab93a6541b1376b3db0b2d8a28e7835a587d388bcf4d3559530ba04b0dda7ad5808e1d2b28a4c9e0526acc2f154fa67d1184246d861d3219eb14b7a270e45e300f5946cd052c54816de59e1c3da270ba3b8723894f983cfb6e9704ea9cfeba978ce826e9a57debd1a4e631d4f60e2ef666839a5b5884452c1df488f9a8c0402aa9923c6477e8f3e1b411ff1935ac360a0cc55b04323e32388cbe1c839c927ef6ff159043cfdb6382bf37d202b13c190b88971584d899912593faba0a85284acdf937a07b1eb705a76fc05fcebde824717067b366075cca8a8b67d1eaee028eb1d6a9e36dcb119b843f7a3a7f569928f1a411c445c89a9602597835d6385102bf28062ed139c26630023aaa319614509e6f4dd6e2558cdce3856b2673ed9bd4d609744207c3ad21a0755047f548002d03d74688bcbeb25783e1cc24eb92aa6367877a34bfea969187b13fce584789b9f329941800579012ac9d2b4ec30efd10053ccfd27b081de286dfd49b530d0e43591214ae684fae4d1d271fc08e0fe2de9d9c2546722b10b9af94d2ebebdf4976e2b4b107c56ac2edc66c016739c04e650f493186de8567148b4c3a61ff79033f88ec2feb7b634b4d5f764d813bba215299ead702b7525c22c8926159cbd6347d43c3f924e11d12953d623c0eb2bc5b9b87caaa8ef17de9f0db970a3696efb15757863f0334ac0998233e65e5f5ade55751b8847edaa99592b2cde1d57061fa13537ed3f851823817306cec18222a50dcfa0d67572c48e1f5527f94e8c167df9095b6ecf836433050a5cf185d69986584226afa5480c78b53bcc9abc0cee79d93d7a94f84c18b6a265bb6bf84bb6eb093add81e4059dd79c0d0a37bfc2bf41251d545f1b27a887f776de9f639a81429acc3e4cc71e1e6bded9689d6c71c40f4b90a1ecc6c9bdbb0a15324ce7f20f688944b975c91ced77f5612438d463210075a623cf5d4bba8b912159aad56773c27fa888737447d6a85cd593b30492ecbd4e115d8b16f294b6d8267fdbf828bcbca3fc6c922c0385a6830fab335ebcdfb8d848fc045e2b0df0ed28d97eb4e52a471492022353ba68698453a525d32d7db715fd40a1a8cbd5d155d8d42f712187bd50e15a2dd8b454e41cfbfbe673093f8476ba62713c76746d2b012f99b1b840a6579bd40f13eff82836bdc745d996e9fbcbde1be3bcd2454fb07e06d7332ab88b23a9e9dc09b61c86e976437edd83675378441e64a9e9502ab2620ff87718612b956e8db693e7755f9020f231f09422da70436cb286bfaaa4b9efe01f793a354eec7a645485f2980edfbd63e30f259e40f9bd68f106be7a2a00719bad6d1af1de4cb671f1562b5968700fc1dc28c2138514e4333a92b900e4308f65790e5029fd1b2091a80e15ee4da64b4fba93299a6acd66466ec18d373561996741046c2e2340e5996265e4bea6b4bce5125a15bd3222c6814b5736911b3da7987ad8e623e026db0f52824d4113915489229fc5980899c0dc4597d43a6aa9ab45ea6eabb4db3650e028a0fcc51e35e1ce35bb5ca52ba366bce7b668b7f1289ee88ec203bfa446c742976faa307f361c776e4e7622cbd35a1c59dd91236d1ba90d4670e43cb481d0ef9a1368d63cd7e57009cfa8a1abdf43d7c39d9bc4b1887a4624cccb0159ce659b74056b922fa9cc39100494cd7be541ae29276446330369ee1dbddc58afe9615b69bdbb5ddf8e5368e0438dc760e13896d1619f16d2c1640ed2e69a401130abf7bd1553cf4e624688964916ea087cd22beb11010ea9312d548c8c52f3a2074ef3aaaf58d5bea1cf24941d6e78dd8e5faf5ee835aa25bf15a58c3deb70ce558bb10837765d4079f59ca951e97a70b622f5097a2083422f980126c55ac8fc8a96faa8ac160b6c674b8632ab8ae6747f542efffb88b268fd4c8cfec6b9c4e029f6c0d894ee83de7ef555a1c4beeec01deeaf27eb87286ecb122dda30f461d8916423a0c4f1aa347f75a8bea71540460de43ddcba5976500a56c54ecf6c60f7d409216e377ee1fa971b510fe9657a605620d296de579a3711d64dc62052b91d843928c2a0ebdf32d2ba6e87c9273256e18df4766c284c6c93cf88a936740c2bdce3d9730a5c90e46f1c6ec393aa2a4cb81b731321818dca76a109f2be4dacf2f8b20becd9aedf0fd95ec2e1724cc83a739e5ae747438bf81eeb7f20b29fa1f90a18915c5d2efcbd1c5491fc6991e00babd74ab81a4c2bbc5c0b50f415665f96ca9736a602bd5072508ae2c44d36c8e5d313edce022fafb9a94141af8ea5653597dcb9e5013bc2a095df1d42e8cf156a0a55859b7a4190e5854d854b7e73d4c475a1981e4b8d1542d54135b7db839272c044f9e1ec07308e66c3a5e1200d269974d70a0f6422c0d96f7f5306be6d5582a5d973370446986acda61316439d9a05400165a064a0f299917934ff9875a105548c236009a256a1e96893d9b095439113008fa31d8e34108565035c39880f7c66ab71981ba535c5a1790bfbd71ea423b9490a8e0353ef63978b5fe8041c5f5e7d1e371feb25f31e992552c847d4cdb0b9a49836dd4c0774fb54d56232c0b37fab1d67a3d2ee9b9edfd98b282189384f996ecdf39aa701e0be26926d7424c07aa4e51cac4d4d7a0ff10c9fb4b40d0ae61ed5a55983ee9d6abbd66107adea993e5fc2f59c20a5e408c36dfa76e1da4306b0a866856347aa435cb9d482e9b40f1c22b2bbdb02a31f626658d311f94eb493418dfd0b280162ebd386a91bcdbb842f04819660c1b21afde95ed5fe20721d3ea148d4db9d96a7a05b01e9021b771e8f302990c7db369f2be02cc35b5e05dad36551ad2471c10b1d846b8f760d96770d7a6610b75a203ffb7cb85036a55aa32487db80256cd75370b26308199c7ba4e1b449c428a7fa5373e56ab6d55365b82fd2e74d7efcdb6354bd38afa8080d0a6cf1474019a99613513b1a06b9ddd201e62196ceafe1b2d28b7e6513ddb87535bee655692fab5c45d4388a06d6aced1852bdafef3892457b3d4d4bef3de65bb9cbde65103b37d03b64ac73c5e5762d10178795ee7f79a9603a009065950f974ec6ea67ab588ec2ae2fc19192bfac0e4202a159af0aa960944d6b2125290535ef1b497d73cb3bab3ac348b8887890a0334eaaa6c1f5661c2cc84d6c93f4ce08270b4b4f03d4e0e74a2c5fb2c2235252ad90f5052e4a4f14d76fc12a715dc11948cffae9619b7c35ab294fe674e1894b09c3bc1e872ef40c7f59c987493717a04f43d596122be0b9bad3be35f7d651f64963e1ea79875c790e0e1845c71ab4c5556554e22663a07b070f25cd7b1c6d37914b948c54efd28ad4253fc4c64213f894aed45e7796937ef3c5aed190e3505e7a8225685f830b71e3212027ea1bfb5ceb13f5d4a7316a0656656b169ad7364ace1c39c41d261ecbaf0aed5d7693fccf74182241e0aaa7a7260dceb81e2015fa38e35dc833dbc39af24cbf5dcbd131173f4feb37c0e24b130ec4ffa4c9e7b5cb567074d783e99b3c8b39938eaca90a0498b6bdc070037b6f5c01390bc6478f83abc5a9365642b2fc9e5a862b9bdf5b0d72d141384bdc549014d81b611310b617ab680cf173cdecbb0b3541d43ac81f1b2fd0da9af2064774c6876746927fe083733eb133775c98032aae7ec0b5ec0ccf7926638729ee24e798168351acd1af4bb33d7b3b3e84322fe78b993c25c8df43fee7e6fa471455b9af1323f75aa804b9b6bffad8a1aceb0bc30b390e0424d6d02d69f22848ecc5046b5f43bb84ea1af353d82881d0b3b2097ac619659017448eb869ddde309aee35b33347bf0c4e2bdfaa41086fca95345fb0f5ac9154329a9aeb527b6062005fa39a1abe74bc3841ad9c2cd7dc61fe2df612ce57a36342d125bfc4aeb69d4bf9ccaeb68b41324b3cc0c30a03e406c52ff34d760d96227169ebd996cfade785f35ff7664bd8221859466ee283b14d229c8da54e76ff1dccfc5ef99ebe03feafa1aeb2c9260f49501420850db71f17759defae3cde9614ef3937240808db16490f03521aa51821381ccf332340dd0039f51ab2ac77c774d0c35a23ae214f08086f15be0db92b8a847542b7c4a20cf42204c335282237846e0d7441f85e952079f2ea22e60c96169db5ae5524f5eb6f665a443d8d00467c254afc1abb696d0dcb8221d8da8b27b4d7b31e58d017c443d3dc1495968de227f6db519cef1edf4d3b9adfb47dbf8c5cc8cd77660a5affaf12f75ace7aa5a3da12a53cc7bac0cd985cea4ce6881780a7bc5932954099b351bdd42a8106f70b68ee6c77f264c7402487ab9de16902c97f44bd89dabe4068e4867a2aa4c19cf486d98eec5562977470a1daa473e7eb4f9b73badcef407104c750a74fa00ae40556d6a0185840c5bd6e7527707bec3fa04084c6d32ec4a3d330dd583b7786c9d298414034358f835e475bf92190ef4b8b4fd6445e99282d7418b5922490fbfb48979dbe37a6491cd9b6ece7a6c625d9e7572c9b97ddc1fd75afab693f966c47ef55cb2a411a35558ffabdf39610b3e79042d03334613c87039838fbfc2fff49c8d97cf95f6fe069d0b0737d3039ad4a9faf42522cc530bae489f01cd2e1c54f0150d2473964e83217222705847c1d60c8fcd25485c8c940e24553a713bf50e836f8afbe5e159b39a36a8f8be42d464b0df0237ffb1ef1e1ffc19a2e61969403eb621c99de1bf52082511d3367e4f082d690aae79262e1ae31cf3ea26ff0429e72a2cf70e2ee5d92c48c02d842575373a6073253bb660a43ab17d7193d1f9d3de3cd0c1d9de7e881f7564054d4bb01ecb4414e9d7b8e4ef5533252dbd54958a22c56c610ecf0cf4cb0a9c5071b6c483ae9f895ea43228ce3ea8aac50f8e687215f314f70216636c4a12e58be6f826c8ea0604bb56ae143f496d9988267d72575aa991fc2903449e75e6eec340da5f6c3fae96d60909109bf6f77508d528880c16e57ca0e7a1f5fff30bf3cc194905c096155493473cd812e8e567efe38ce190849fad8b168de994693d56a4a3dc2db9f0721867dbcbc572be42691b6d98b322592b3f09c4754a08f5d95923b895311736a06f8804e60eb87d8218dbc0584c8b088d793da754d5e298b39c819a9db77fa2b065793e437d158860b02a0a4f169b7781ac483027dd407a5f83b8db5ad2e7a3adfccee17b7cda0af9a1600772b044fc3c8e3a5c6b42e729830e6947cd649960688721991596901a8b6f04145625cad80d8961846487179845992558c1b763d99fb0741cef021dcf1701b5e0cbfa8b161129bb9578611125d876708379060ef8b720fa16faaeb8b1ece5e0aeb150413571b44d253e46f13677da921828d642248f44110a741865acec14f147ec4eb64958aff0a1eab517d57d9967470457e832c973e5fa1ab1c965b364e005b923c2b1a140200165e20533ba722a5a7e39bd82914e42b696872b9a89d626a506d3fe0da17e7763bad47d64d03d83f1fc217295feaa31e93946229bf805f5f0314996dbe57b16ee782875183d996246f310ea6d368ee7d0aeab5d9254f7464b002a2e6f01675f97170bb782e0e446ae96324dd71aa20fd3ed7af2644072b7f0450689c2a87c14306ee4d532326288c069f36a8408d444fd08268c3fed1d4dc815024ba93b9b3f696d8aacf7944bbf690fbb8f6a1980f824f417a9aea616ee1dd9421e372d0a7c6195f1a850b8b4b146837c9419de7809d1b3036d86edee8ad88c9a4af11cd85ab29e25c13a1a196b0fd3d616f28fe90737b3fd238a24ab1a5c74d856885deaeddd31271eb51621e8205cbef2a4ca0f0f26c65a42914ef418086b1db40573b096b997499f552602e863bcf29b447574e7d62f428b1d16ffd77476a2383175efb793e65d65ad690dd71bc178a0e1b47f125b75337c754391e4b452fe5722294c79537a3eba78e5ce892a65b92407d011950daccf114e30c4762a6e9a3d05e1d4648b6c59f5e38c71e91b760d4c4521fe912be49646ec9d6a5c7f53ff5d3e0dc9c03d8010c2e908eb12bec80a68a985aab414021347c68af5c22d50d6be7510d52865e60c1c0ddb9c937cac4cd23797b1f2db06c4aba3736476d51cba8b287142145ea037a62d7e2496a626bec0e7b28a9ecd1009a7e02738e26ad590eaa9ce23f4e741c63bc25e18a3a58ed756043e93d0c492057dd5797171e33126092ab7c1dfb6ca6a92ba87443e294bdc85f1d8e063a377f3084ade05333a4aafa559008ee38bd097cb03487c379121f6a6cbfc46dd7e53f35e5200aa0f1e5d2a23d8a004702ed67039953106d6e60e9af8603df986e2d7e04f7999cb4d172c4cc022af942237ca9a114868351711146fefe795406f292806afd1912c9467ef396047d500ebfd7e65609ac9e9fe80648516ec16838c71872834f7128bb7eef340b505e07134dbcb97fbe2d11dabdb1de4d600dd89da8549460d111600f02a5da2d398efdf2976ecb13d0f8796e54da967344506c65b19f64030880a8d75dfbc151a1d2e638a27341821692579d3dc9f41c2ab070b6ca2a939f598047e996b9d48f46d35dbc23f9719c30d02bdcae226c2e4c3dd2b552c01c6c7b1cb32e7847e742c36e94d0f7fc07620be788c3050ce6cc06bd598fdb156964ffafb954937b48ba8e2139596bb203f878321637480ee46c92087ea614c557b8fddb798c5dad0fc9f2c0d36dbbcde1d65f365adc8ddb3ea90b4ca5839b81eba1125e77e485ce8c08e864f1c5505b705522462c9c2e22a145b5f36e1f8a5913b7b5699e42ac1caf0779eaeacbd4d57234808759cecc6672fe0e789fa978307b1c87ae9ead50b7753a22e38cf5eef416fbf2b071fd581a0b2e0f3e703fa9e1521d2256f72c953790452ca2b10a828d20676770d5404d4a41c514f0ace2ca29ce7547e88f8af8bb159e9380ac90d6fa136ebc2f9eacded010d023d0752509edcd1eca8b659cb001a3e5518dee22106afb6c0801baa5c6dabaa82695860ed5caac6f848c6e52675270b492cb335f7afc8b3373036d262b6fc5c069249b6bb07e21f7224452045dc78b9f568afafaf955853cdd84eec49ef7ca3b561e66ac4331b31de3d33efbb0790d9e50a3f811ced0138d82eb2c99a43f92d140022ec494c2681915cbcd76c8d7787f8479251604f2c8f303b6a77547bbbcf09abc18e1b69c4ca442ead851ace34beedaacad6f6e153a5b002e3f1741a1e39568138fe76415c864feb60932fc5655eff6e131d45381ed35caf3dbcc2cc5b3a3111cf1efa385c59d893ca37dfa042d3d1df841059467c753d2b05468aaa192038f026a762dadc796b96f4437ad633f4494f937cf06b860c840d17476f27a415307b1c48d4393198f4ec8ef35df0b8243613feb2ab7ee0d7e9e5c9a33644ddaa3566fcfce84ecd1150b4db6d9bf0c7f3cee9ba3cce19469e6d1279ccbe83639086196c424c0ebc909f96897c0a2300376e18d2f4745903a798dfb96718158ce2bfd5742f0de3a9d26163a5fd8adad0ccb8072a1097c3b93f213b63a2b3ed169eb6d9710397c7d34ad02d1fd61912ec4e78adfaddcecf19c607e42ee36b3ebebdb11e2e9eccdd1d1ff3d1476ecc24b684571370816cf4b29421b5c1a9d69ad62554805f69e3e39aa497238d40739820a80367a565c69afd33934c1c02403d230a1603170f6e11a4d8b181834c30883c7e428fe01a7c80245259a5ae7122a7fbf69105813fa0b5fabe830fa3a7fa77af5b357d12b25d54c15d6024294c0b797f722b53045775df6e6a703b3eb225aa1ceb37480402aa6d4a172244dbc71dd380d28e360e5fad81d094ab325ac20319bf5b732782339917c8bf9893dabb4756b1261525bac08269533b065ac2fc8f51e1e5339c46f3d905ffc1c0fec6aeb13d8d4683f3e7a4425a4fca32a5f5653e318a8484725f1cad0226d5a3370878b44c89780a4aca7a9ca041064fdc6fab6fd6b349e93e632324f0788a8c3c62ba56f1b35533e61071f241afd50d7be08c7dd3ca79383659702bbc6e337e21434e8d91d42f65e9df96fa89c8ef4548e7bb28b95f07d082eeb0e30709b6ed247b10d908f781cdf85fa2896896dbc30fd8d635aaf3fcba4a00f3ecac8a959b730afebb830ab6dfea171cbd64c973678880dcf22e7b1e7edcf7677760110ae1c115e23892f5c1d0000488de8ff39df90abd34c1198ffb6cca5db3d6b727790ceadc8bb1de13bb895a60f1a038579439a6c0d4bf1b50691facf075e07271e561e326e3dddcbcab56fba693c8bffdaddc2a1f7612b3bbb44d155d66ef50d71e64a546ab7da0f8b7ebac14e4dcb7464ad08cddc0a8d865573762212a3fef011b0bd58f06a77b98d24bc26c2c0aa0d07c21472ecdc652b171a8131dbdd2668687bdc07a58c6ad2965232291ca3e96a5990b0b3b9553075a0c9ef4ddaa9c367cc1cdbcce2cd0c443ac6919e62b2165ce4e9a087d7b23dba2b679b36d750f08ab079449d8c5f02b9afebff6ab15e593ec6db76ad50fe6eccbddedcd6f70c0e49901c18489ff8110edb019e92d18e5c6b79575455b5b78bdc57c611bb3dd6a19867908be69ebc1a87ab5777607bca07d0bbff8f679743bbfc86b045382e32b90926a7fd73745d52e65ee57fadf23bff6b6a0ed777d61813b59ac6852328746608e1ccad33c0fddc7766f7bc828159f52677265d28b34fb30c882e358aef8d0213b25d3be727d2b584bc73feffeb515bc6bb29d7fa2df1e010b4322894c5419fac866bce6f80b060c99dbd8cfdfb50ace4e2894fd282c4dee508300bdbda1e0b93e2018e65b991ce78e59a4f1ba4aff103269725ae683a05027761af7fd7ed52d3999b2369905421d9deeb3dbe9cf43241ed88d9244d431626845cf079e1fe71d8d40593c1451f6172830faa5aa11b2464dfbe29c82e48e55ad3f379ee953fb0ede88de889a45c96cd2e14def760da72e3c66124948300fbd863d3a0e2b6af882ac745505c06a4503554e7ae143bed72f3c511604f6addf5cc56a882e6f8b12e1e0ddcef7c5198a96e68b22124db55cb20b00f18efef29278dc07a2aded72b0732ba53fc3f592dd0cf1fc66bc5f884a94353a4e1bd24ddd717c5ee070df9c4f35874292e8d45b847d1f1bb2b56e903f5c51e111d060b745a83b154a1b74406d1101b9caf9b9991cbfa40dae5202252a5fe6556622332f654d986155f47271adc75f972ca95b981d09f7283824ff799d3503e38de25b3bd08d1eb03975b111fd0c00bea117974149af60149ba2dce924bcaf66c6c66f673744af2fc3d9f23b123d730a17dfc4e80d777bacbec7e81755b2d79aa08c53c96ddcbec6af3fd591751af89a6272f93c0b2e32bd8f6982028303df1db6fefad3a99139eb86e0cef8e9b8d01fca130a627c93b913384890c59250815deed2cf3b57840f9df4bb964bd220c91805c6502598e60f21e04c189ac9cb0003b578565d2deb858a0f521cbd4d0d71e46e8bf1580ab67b80b48c663f4bf659f5f16ceeb894f92ab653456a2d20a642c32e8db5998bf6561148b10a51013a42f77dce0e5bdd5b8ac26233fd3de5483871f8d77f026979cd92f95b7f65deb1ef52d68d752194865827b95aea307f5130c0dfef2d95595333d30900c7c8d57012ff40d0680e10a8f3deb95d1e561f4c67ee7b4aff5b4165c622f285388cff80fc01bb9ff7e1548d928e01546ca9cef4e63d0217c2cd9e9c4a9092c0e90509f673660d0ca7da11d278a9b37f8a726fb7c8ecca419873a21de5e9bf59cafd2c1535aa0a09cdc20f6dfa645149e85afdeee463b2f22ce97d17a4c01c4291482b7ce17f09c28fbc5fdfedfcaba9fa308e7df3b702da112091004705c9f529c2f76e98a2cc605538da4d8c014c494cb5b2ad47fd54f99fba03a3e39675e0af1ff8e4d1b1f789e6848b7b136e2823d8fb2d6896bbdbab0173bab5e3273362b8bb5dc345545212cfd54e5bc10bbdb33f0889686eda4eb654b8b2e84f53948f00e86d079c0744c66ded1c34148a99f1b0229c8b857822b339b36057b5dab225093aefd5828adc14404e044e9e7b5070e64698185d4d3764a8b52454917c1eb8cb7c3fb36d8f7f6f6a2e2d0568911edb64b1ffa9ee2c57b46c6d718b49ce653e9d4d846edf329b416cd3c94cadb377a6ee70a77b492738c1c6da3c03e8fb1a886ade0752e5ec34eb4ffa344516bc81c84947e9fb8c4c89464a20d68f35686386b135555362008cbb8dc298a7900236671d6b155d9c9ee93009a29a5159828d5e6c6559f795a3c07ebdde85ae2bb925eade9768c34cd00e8c380c4149d973fb67f6cd8564e36302bf701d37311960f252ead79aa3c98f1e8f31863a614dc11f119d9791fdda98672cbab04fb3389d1caf5ce17f67f98829e710c7708df83734cef8c29bfa4868d673e1a827ef4f82edec684bd30edca0dafab4e4273a4c5e5990a1c0b51801da15ff99619d8d3e19c7a3674ffb94e20e155858e36f558992657ffc2671ff26221d1b7ae6b0786f1bbf458b6d3d7219f2856afed0deb4b5e54423c7d8ebbce0a6520577a2c02e75445cf9a5c5a01c2f83362f0b8f98dba34ce0a79f987b614ae2f554250b58ca987865b33a8789e871076592edac2a0f52db8db20c570c531cbddab8e9977067d3404fade9caed21300e3f8525576834de5c2303686db735da261b1640391377b8983ecf285419e382f8773e6857d412b0883baabb46a7eac92205f509eadf606c2ede7ff18ee83833c40c8447eca79a3d0ff0fb66dbc9858f16ef00f710198066898509a950f18b77c7d3fff816d1a48985dce9d7365203e93d790526287a687a3dbc68cf11c0318caa8664aaaa2289745eb56457539f26c1cf4b1a1f5549a7ee4914a9b039f41047132bf6965b5951fac1e5e1ad8745d3b62d829c8826e6e596cfb1fd2a8e8b09ab4bfe85fdd416613cb112098430a61971b310270139c9661f4f4e0839889539b840156a23979080b8da20258a5d8b81c5a284f32e16860a2c9a98647e682fc1574f0ad87ea561103b8fec0965f680b7a2ab15c8cead0a71f250ebd22dad94ca139bf4fea105c63334ab0027150d60580e61d138e7f54256ce0444a84a4372bad75c4b0ad85cf1bead2ca42905f7723e4f6c182d0dce9f340fa407e3fdd1d08f6d868d4b0e8d6310bf7228004f38469c3446515716520b7f19b97efbc22ae5616869b8fc6109b89c599f5d967617f233d3367ccb8675e53049dcf814962fac5cc301d2597f096df1d6739410e14d9f8cb9fc2cf49600db09ef6d7d61fdea82ba3c61447cc3be3f2026f0174a15edf8c72b41cf16596bf5375bad97d707813072f3bdbb978d2f9f53e0b0cb831f006ffa8a7c205533fd38e636e08c5bc20c9eced75cb9a9c97883064ad94475e7a69cb2840ee9fd6653efdad47916ba7593189a0df8f2bb75e02f74ebe4ba78808eac66e79033a36586df4b55cc3412e405562dbbf1224b878a94170cde1d3b19433a5b76d715f4f325b85490e09235f29d9fce522a218c9966bdc4d970d8d8f5edd759b6a1ca5331bdede6bf89fe9456746e7959bb6740214fc7e426645035931e3a80ebec97873fad6e00a62f3808d0fc90d8d4bbb958583bbcb97cce6ed39137d4c97776c6955d30b06f977000968e34d34b5658843551807a444edec9447df950c5a68a351a1499a4d150646e612f916341604013d8bc6963bb7997eee69b90ba7e90f3747644f9015483147a0a3f28460bbbd40b780309d8871607fed33474ddbd1439b42de53edccddd367ecd3b1f487b85400c06b1643ac74e347baec7fcc9277df8a87c66f5688a96c73b6a5e50f1cea79dae3bd41994c762c8eb8343f9638ac4fe49ad30ba3419a3d6a109f6a23180d1a29843209b587531d7ce69fc58545703a888d7b1ca429965fccc951f900b2392e246443b10d590d77776c9ee75d2c0f232cf53b0eda785e1eacbc07e535404900a36635beb7bb2dce9171d147ffeb048ae8979389628827806606a4be17084ea6f06205e7cada97faefd9564809bd8875df664ab26b4111f2b98a9835e4d6993e8b4dead7afaf0797779efdd04886cc5c5bdfcf18c912ccc5d4bc5f5d37b22058113595f6efea5dd912aacbab502831d395abe09176b25206723fe1664eda4ca2ff4d4d3202cebb9619a3f73c1fde6e34c2cee52d543d79f067f2afc353a64b473559b2209420eeaeaf4a1952e2e6cb7940ab4e2c3f91147e3d517eb7fd426c0d6198644efec09e592d54b8b9c2f6cd39f283cf6f221699751ed5c8b07467903ac3983f543fe70cc7bfe1d034d1418fb347d28acb3ab0c16b27b6ea254022164a0dcade919fc961e8af0b22f5932ae24fb18f4b5bc3b17ca39e90309c21665bab25e1b48e35c7c35b7c804510f43fe6f8d8be3d12425738491633528e9397effceec4bf4bacf92d6cd02c136269a54895d235c1a21fa766c5e6302c26dee9b9565c89619d5fed9f4d16f9bfeedfd83be0457ef43012cea5a5d21e16d31a5bc890a910d7a5adb805da1549598008fae9fb1ae8bcf6000c93d59028488ebf42af1147b88429e2dfba92f4d88b29b47c252ad1a0b1bc0cbf45c0deeb0a5aba5106473a7ae328fea5d0345e510362dfcc5df9df975f431ca074cbbfdbdef387a9be22041de2f4b08cc90899daa7e53e00a86de257b08c7df84712133f85b7aebbb8ca4b64cad38a14a469b733c46c6e475ef471b25e47bc9998034a9ffb6bd3613859772c20ca3ed8ebf5d6fc4a39e2c8d178c24509961dee7209f8241f32884bd3c8617a8d737c6b1b30f713377afc6ee3b7c954f7471dd14e663ece5c1beda4611f23a6af094be70b05d97b9cd60512387123761ba4d57abfb58c1bc7ce3479aee34a13da63a5fa6e58663b9f14183041590273cf143538f371c77458b6344f854ed11fedd0cd46485e78332938a3b6b086f9a284f771ab5f4e9c47ff8a3a7d55b3564155c0a64fffad9005546aa0761d4b455d8e0ab149b6b572fdccd30c013804e0bc794aa84c2c6e184cf3c561670548b58d53a9b97ca00c02fa63e10a758bc4c9c6bc7d4f2f9a9f6acdc1d029d4d6cf0ceddc271a36fb36660f803d57cd4fed52310f05cdf5f9ebea6471dfb19b6bc9488627c3c9ef898f76506ee0a9ecbf7defa62e7ea15cd5d62e8eb6ee7b6a8c4ae5d08594162915c91801605691cb61992a228136db855e9170542568dad3484eb57153dfeca41b383ba019b9ac4b465b37f367b3655927919b3ca5725e843058921ff808f8dba853b80b876b2113259846744d4c174c170637b83c6ee35cd9aa62eeec1ee8ba7316de6fb7d5f5f65f501d27717d8003711103052f44edeb442aca7d5227ecfa6ec01748da63e4296c82038eda2febb0545a6fb35664b236cc444b7e660a5a737f0688448245c8f520985843f08fafba1815ceaaafd0c2a0711f280f5935305334b5c7c6045b55669ed74bd52d0173e309acd97c081b48c972680a5339186a00559001da57f4e38b9938c383e6622872efcbd96e7833494525f9b967e24830574bce55a200e81f9ded40c32a1dd3f3e887d806ca0363ba5a88c5a5c43eab9b6ce3c02d232c6707308fa722d60d76ef8f19f784481dd0ca6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
