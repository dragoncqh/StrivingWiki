<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7671758238ae3571ea389ec61639c2f923f2b0c4cc240467ba0acace0ba0c730758e5e4dd6fe512fa18fe871961b49f4c3e91e36b8a3b79c447214d2741ca26215f1d88602baee69d4a28986baaf6290bd7d544007044618cc90fa2a51063cd9368204b758dcfd4b562d40a0f28a89117797ed587a948117683afc65a26f387efafae380750e979005662fe26cc3f95421b516e9dc9c55cf0713dfb44ad331551f80d869a4aacabaf117da1abd4c9190f0351c781f6d473442f532fe4edcf3502ef7df7004613c18c61b71540e6935ab3cccee251cb8daab0c3c8f0e375339f8abcf455e528a791e6307de2bd1e27ff9c41c791bcf3cff25f9420b2d2a579d67c41bed4b2477e7aa3f5912e0f6a7b5e31ec517e5256902031fe444e0eadbdd49b498c07e0aa04a6d8fd10e57755075c53091747bd6470e0f4cf746151c435437e8e5acaab28a3b1882b4bd13af4ff21a0c96eadcb37bd99e06a6a143cceb4e1d96c593e5164ff76256b869fa167215f79b5199cae70453df1f9941e5b903a6f88c08aeca4ae039caf0ce04937bc778561a24b9b3af320cbbfb383c4ce92769f97a0f7b04dbc7bd4bb95246077038381cb673d1588036b74fbbee933b9df50e51f2eea0fb710b800408f920caae442b31e0cac8d8281d4b51ee52963dd3e0266ea9ea02cb68cc865a87b36a9e1352148f6450778772f1d2baa686f06d3c75cd80ceb7f6ae3107a3262d20fb701dd64e431cf4f5d7d4715654c4a315896ecaa4245e5615ca0c9b7fcc0f9303fd5a25ee0be481c34dcedbc81f164f037034e1b24e80e18369bd673d516e17b65dddaac392b8ee0f5e2f9740dcfdab1f0786e34bdb2229c05e30de9e24f2a33ea6d5ed5d25fc784d1b82d2e484d4094c17550466607a4537e4a22b787c37b0f2e0697e95f65e681a8a10b9a5770325483cc72404c2ccf4d364d2cfdf31b755ee2154b9a9c90cca90a730417d0b7465d3c8952a381fb88b034dbb561afee44ced37483a30caaf4024b74e96692e2d90e3a5e5173e96fff8c7bb4046908f5f65952aba87f9f4ccb0d503823cdb20a8a0245853d0340e5fb16252313448a20cd57c5bdedf56eb50a14331a14238d746160364f233c3cda5a9afc156d7513eab406d4b02e4726c756cc52dce7526758aa05b04424bd2d0e09fbaa4326efede977500994732666758068d0b578f77dbf2e4334f01e551066f222679a1363c5b161adfee75d16dfef43a34593f74634fe86d305b2577a6bc47fade8b41fa99a9f08d78b5de876e7d22cf0757777113fa2b3f48b4f7713c30f328b3682758563a369becc9333f5a1a42a117e2d5ca3f39b328a89ce8c88a6ddfb77bbc90a19bdecf5af60ccfffe4d3f5ab686d97151cec152f0b86cb1f3229e79ea9a1606312e47a243fc720344ec2e1ec742ca8b73af86dca0f959caa8c20609c5af88ba5503f7737721c10520ff497ec9da355495cbfa27edc95bcf04af26a3d633e2808145d355c293d3110b73b6caf01b8151b97c86a1f0ebd250252f1bedd83a7ed61b705b098ea55e0b31481a0c807b5ffb8c94db687637e7a1fb43dcbdc7964ed8fc279dd84b9886fbe0fee2e177490bbb6891848ecd7a677cac953dd471f971765ed3e39c40abc8c7d3a97ecdcd99e543caa7d6c2bf44038df9917c56e25dd5e61eebc6c9c051574d9368a53bc7e9bf7e0733b1e1a153ae7149264dc7d9bb6cef0f38df4188d1d4f222016ecb16af019736abd17f5a776ec4a806af2b7acd899e3d262099dfcab405c69d0a21ac4a29086fc6197682a1b87f0c11493315b9029f4e3aaae7882bbf29f567b177868034149e1cf741ef27900657056674be90378cc46c9adbc9e7dc0c840e8b645d2d2f9a3e3f6b980237d0f6cc8d5e083c0aab6e1c001a13f679241c4d2b7dfab2559a5fbaac4f43a6ab2abbbda1967a7b5c3e09a982e9a07385f79079b0a79a97f3c69c7dfdfdb1cc327885330d69681fa058ec8e992359642d5faeaff6a105c97471da65ecd3f1ec63821976da4bcb636122c647db6112e9b3ed7fd2d8a459d4d0579a4af1661162f9a538f28fb6cf32cba506c964883f9a746a66e0b43690ba486ab2d463c4ce0094cd7dc837f97f1dd283ed12208b9288aa5655a05ea91563ce903b8183d2e5f2c44555d418098c1df947e4194513e480d66178b182de6eecd5518101cdfc75b69a85841edc304c03d77eb638689e84b7eb20532751a2076d6b22b604c4b0fa4aa5351acae2d9cd960a588776ba327c7bd9d2252c85fbadf079d290c30164b799bc2dd3338e6b4e227f49748d6458b8c1cc814a3de18361f27a23fcc7e819ad4801e4bcfc88f9c193d7cfa8b3942985c5f01490bdffe40fd192e157a6e34cb82f882857872c2d78e081e1b93551b7192c330ee839fe57ccce240b42d6867507efa2761fa14a6e0e7049fbac83e6bc8b31af8cf5e974fcee2f74e557b88b2aa75e092e745445477ac4a7371c984d80c1aa400b5d866961a7c148859a23c979a65b308882add16b7b9ba84e695873ede3d5ef278cdc593747946249279e6a6a0c6af4301a6a61df4ba80bef1b4d0eb0901ede0ead236e23fff9b002deee411b0ad4d2c0cafc0b2c0b4da39a0b3fb489f45a7a940ff9328ad7b749194380ce8d6dc469ca5aac40d062d7adb2f1a4d60c00cc570c6131372b8b4e125fcc03de4ce0ab37025862301b4bd3cc4b5d1482783aee541a4f0ab9d49ba738cc3e616ea3a98b635483ea6b9fa2da286a0c039f9a21ea846ea1cd0880048a19d94480c6051a65822075a29134baf0b21b39406bb8f70ce3a3e6e968659b28ea172699092b15bcb9b72c54eee41faff4f1a9efaa13a7cd794e95fd9f49ad4f1123edc366157c2c5380e05aee0e8de5a7a4b5e4ce69a0c9a6efd59bfab9d4a4df2e0eef5b343823d907ab889eb835a66040655bd716845701975db8959c497e38be4ad2e23385e6f004bc9c41b04eef83b0f51ea49804bfb9240d0ed71f95892244608e82248d4c1c7f7da2464b3b6e61c68aede8d05511385560f376a33eebebc3495afedb35d4f68da2089d11a2feef72c38529eacbaf5cbc3a82566a51d23c60a261332e6d1dd12b721d9e84996c427d1afa3c7f4381c8b0c7fae4f437e7053fe9e8dcbaa1332e07f78b506f76ec05b6a0a62a20c5f13257fb4e777245b9c2b3f30d0e729cced290d0ef985312a0d892cda52ec06402d3b0bde8043b8087ba26e34f2cbb17fe4c605e6e727edd2ec465df375ef4277da40776a90d8b1879e230712558dd406b7fba87a8be5ed5f23173b6ecf67bb7df6009a6f42dd4a19d647b70d55910604ee529f39ed2189263158b2b977ba68fe4e3a06ba3d3c1d023e35c390971121a69a5affa35d88dea09651d36e52e0458a2ff281e569eedc3ec9fe538eecf2e229796e62def8b949467fb0c63ec2a54b9d4d1544efed77b2d6b3dd4e6fb70d9e97e197e150168408f7ac0e80e361582f087f4e0fe373b530adec9a7a55260215cd742b74ddc1ee6d15808cb8e7a832654cbeb91da3ec8e0e534797355cdf987d7e48f605c11ae9b22cbd33a14369eef63fe4e9f6137af9abd73b8feb9787001f802330e43aa453b7299b008578eaf8847dfc7286b21b37d9b93bfa662598733e106c86ff6ac07d2b822e918473642e1cfd3b45553718e450f3272877e4e6f88dc230ac2b888c4714b5fd7805ce73b0f49901b30735f1c5fc00c9d110c04610becf7f2a7b5df5536e6389651beb71f64edd3cd69f7016a6ff96103e594242a36fafc2fb669313277d051297f5c95a386f15b12f8f6fddabca305e360fd921944c00612bc44a10f7945461aecef3d15ad26687520a9d0d2be8d93dd78d2901ab05057bf1db96db499349478b56beed7f518dbb27f8da3f031bac4ace2b0328dcd3b01d64c6b8c464dadef6ae1867952a61abf2b2c2bc643fe19ef26e49a56b8c7ba011de3e6cd498767bfd522e6e7c9c784bd06604fbf1dd0ce7f27093234fd4adc90f0696c5a394d4dbafa1aecfcd03998f19dd4652bc503a5e35fb4e24d91d2b5b698bad147eab6342e476718f7d01595434ce8cc75e746e8ae0efc0368248400a01cb79faba32f1de26906479fd65f27798cba84fd1941d2cd3bcc2d360afe5022d02f9620d5575c9b940f6665fa55688a64e282343526b1d092b1620b50ecf4c6af347cb45e780fed7c5351891f356f5864a371b8135f451368c632a4f30128332f784bd18bb1c759486ed2f4677c5ff947f24d8b4b35e539e75a36f2eeffd3a146b1ba94eb5a44e41f76722ae55b5d0dd98d900ca72d9c3f972cba0787fc4281e77b031445b879f5c5ea0b866e640304316a256381737758c461b65242460261ebd62d50c60101ca96322eb802d0c22c903297b11cbe5cc66253d3cec478c3824981fa7217c14961e8fd5f8eed503b319dbf39cdc9a930b6dbed2829a796a37663f7769d3d3ad21cef82fe6969856abaa67a6833e7ac071295d33e905a545c1280ba83daf80f249d606c15ace8a53e384b8fe59c618b5dc8179b9b9070b86225e9be0c98da236b3dc23109bf176eafef5c6833794d76074b5b2410781911e10903fef7d41421068088dfb5f03f740c54bc4516422866e5b95a5175a9c417c99c8f7f5b73b9a51a06b82157eed02de1db25a2dd9a9431d78261fa9633b7d7aafc9181e2fb226647aecdd3fbba97458b23f4239b0c929efae5d574ccc517d5706768a2e03d4554357b4762035a57c659d5c68e63ca07afcec0a9396eff6ea1e1a81a92cbe87b48022d25aceff457bb0a654b38c3e7eaf6c7532feeb711dd2d4655711ae857b407fc26655e362478dafdc8fdc63f8c88f4be0f808ca80cb926a6b111c6f6b6a3095968f22d80dd40aef6aa4239c90e4ffb7fad0297c3c5be02da14fe80d3c998c418341cd130e464967595d6b1bfc7cc76aa35a37fbc232e6b9a98caf9f632a6c067955864aeef440cafde5af7d4ce422e948cf83f85f7dbb55225f14f049e5576fd4c62d85db96693cb745dbfbfa697e989631125c330e4af3ac9ecc08865306a855f4b8ac8fdcc0adf26c4a2936cd1d78540ea1cde48afb1b3cdc534e19b3e1c882dc23f9894c46af54e2d26fdcefbaf05960b188e129989076251cb1e109bbbcabec7c01c778e51922aea6a467b8dfccb6dc62f887bfd5cb33f7ad590c2a61dcd682dff7b49e0930f1589f4b380a638ad88601d73b19b1cbd4b36b33dbb4e2371a2f3e585ef769c0b86c6349e5dff2cd638f54b94ec93191c1d17af457a3afa5a12969f135e36dae8bc7a380ac0054e563c912d1bca07c7ca4a53ea41f06acde524b2cb7f0ed24e48841f8590419cf2d987de79b63a23165dea642010c5a0bc8e421399966e364b4dea6cdcfc9e9776c43200dd0e09569c7e0c2a65e68de2e804a17177b7bf9366e1b844c8e0f2ff876be5472df3d6c3925ee2e10eb66634405838730a8165e6152b5a44412660f35c85aa835929e910fd2ecf64497b9956a3f744c240509ecd8d19662ba7e45a6155e5c7472d4897fe9813f4767e9b1a19523c4df87f3811d87502fcf2fdaa4f69d6fb5bbba8cfc365e5fb09e467acdc0863448a314dc057e18ab1358f2ba69d631494421480cc45b4c833ef55b57fe5f08bb37e036c0d84cd26855aef8fc61324b9ea081bfe6e4b08309d6fb09d10934bf79e5b90373951cb319c8a93ac829a0b668b9299e8c10681eb9f39c9762958610508487d096217d5e06dc102f536bd471cc595b5b701669292e8b13cb7e1f5a1b13d719c5404f1c5acc269f423bef8b7f7f717b4af7f56148c669b59d275af4a09262c9bf19039b2ac59eb4d71447eb91b4d6cd4fa112ec862de4ec3011f42a81b94fe1acedfe5d387d77d50a15b6dda1d15017ba2285da0ca33dcc4de31e17237f2b2669cea1a574111aadf741a92675f30347d24ce65f4feac2cb070b91b9ccd7389236865615eaf36c90ae0d381e4aaf91fb222a8a22f90fe05a19e3e82525be1a4278bf5a6707b44a86d922879abef000c01e307a20258fc9b4ac8b6ce2a20ac336614a0e6caf5d30759d34944cb2181f91ee4a417f646bedc9c3ab14ff501eef72701141a8af17ce0c6d785420cadc199e14f83fd62ccec2c1b8f00199985bbd32ce3b53a1d692dc140f54f98a4bdcefc31b25608036c22e2a6714d42243ea5a1e621c447c7709c1a8a03c999bef4a5a1aa13e9dccb1ba626b51af04fbc8064a58325ed4d45c6f08f41cbe6ade87d46d3a98bfc5e70f8cb29e8e38a0676f6a9c37bfb0fa942fd9877a61e433aa744c451c10ae47f41560ee78b84d1decb515774ae20ae64c94ded4f300dd2d5a52e854cad5759bc6302f065cc600558b07bc913ecf5fa1ab5aa19e044a1b78dd30594b3d3b6edee746e5f55dfd2e80457aaa23e0bdc21f7d5e452fb49a1e8e16ee1aec1cd142f8768a94e71c63b0445210789b379ff84ebdc80a66ca85dcac75d1df0c602205d947b801094a8383dbd23c6cbbbe1eaa96bb8cb0deb1268c9d79fe5c4e45cbf02cac7ffc3946a4e93d7b283249e68e4172d0ac8b8015b2448420af9b7a0a4d436dd27cd22f9f39afe2f58e8dc455904c8883a46bcac4859215c9bf4433b4f26d5aa681e504bc21c516a1f3f003211085605324f3a8d9bc6b7275530a074fc61a20b0b8d4a1250cac757a98eb4aa1c73a23ee702662d1e435b15df8031d7dfae04a8479bd09ddff43fbd884085eadc2c0ffeaaa581a386456749cb2f2b04e591cf5cec832668b51eb6d8990c83312147f29f863d89aa0941d6f7115fc56c16340a5d174d196d15d207024e2d7a9f81becf649f9edb3f6d2318310b11f986277d9fe143f23de9cd5e13b007c2cb55ef3dbbeb45cb53517189e117836a81a1327170f6e8d3483f8d53b29e35db23c17fe8bddd57d264e26afbef8da0a67c35aee157c3518a831556ce72998cb9cd11ce0f0b905237463fa86888b16d15104974bb51e7c6c230a7e9202b994a58665108e19a0c094412f6de47a9c0b8aed4f728b79753dba22b5a4a1c963e953924b4a6f6273a2adf66da912a01f57e48cc423704f19e7380eadcf6b26a01b5aac3375ac2a8810026cc596d385c0d97da2d009859d86a1649670da6f65691ef8557611b318505f7896ca55c5ac7dfbacb1b23b845d4295ce0a480b013edb34e4cfbe8f43a223f4d70a9218de406785df78a0be712e366e1965951178d4ae558f2c0f4aa94ff423d71fc5c80d5a295f271d96b52ee9d13636cad9e29fa2549509e5ef1dcc3bacfdfddefe5cefaf5bd8a9655dffe4ee8e1dea80c7936d7051ff1ed3d78cae66ce32a2017261e3892387b45d29c4c0a95d0bffb3a47b8ad4d6a68913a0fb5230495f52ef6c1d2b394008bd3edd9f92c71462b34215b1cabaf379d47156eee5b69963c26f9ccf4478c5050c3fad0cbe5463ceb8640d25a2451fa65eb86459e087c1c8b12026996ab6bb2ecd26e4a8ddce0ba8c5aeee163d604b1e9688ae605ab1a9056261c62f71cc9532e44aba8d3c82a4b4df9cf4a644d6eeb667dbecee2f910aa1e4cb04ccf0a33f10cd974e19e10b8339d6708dc7ef147eb308c58fcab494d1e9d83ff540f8de4cd4972c6bd656dd4f1a91e400083a3adf3780e1780bb04dcf8d9414cc0706b8269b6342bc2302a692cd8b297affb699ce1247ca8b93f6334327b9bb77267015564a19a0603f21513eff2bb34946fd35b7d07aeacd657cf0f6d8e7e319a51202c2e9144750e259771ce8a2ac27e2fa78c0a24fa04d9542adb8215fa5d52483a0d9a184f7f096fb1755c45ee807aafc9a0d3a03ec352125549470cc8dc7b62f4825d3075f6ab7dc25159847410ac819af7e394925f14d12bca8233e169bf64b1fd7ead78abdc89e1413eec778fdea2c8502e27cbf8df512284d90b6e0e04bbe4198e32683c22c80d6b517b38906f7ac38a1332c4a7fccea0de9b783b15e7e9d649263c3fc45d3497054539e0a4586e2adacf5ac04e065cb49ad1c681b37f0c5cf74ed0594759a7a64d9b34dbfe35f35faf5c9298f0e6ffbaecf2e3429144af8d4003dac35d594728457632946a4c55d39ede76ded4f674b2c5c8f2e808015e2130548a0ab3eb1e184fa0f9dc02da39e0782338f8973ffda9ca01ac78228372154bf0b1e4fa6d5102e5bc9a1ead52393afd1ccfc82be85b622da3b400d4d244a1812fd6ad56d70c683de240324c36e22254d299630e5d539383e2286dbb7da768ca7275521f3be2705e026f53311a96dbe91cb64f8257ec492b3f8d57e97beaaae493541f81ab7ed3e636dae68c50ad6022cec75b6f6426811f663f8345a7a1379008065b489d99e84515c29a14861295841d9a9d139060494b8f6a817b84dc070c3314bc63e80e7f4262d387300bb4d55a9c0ebb00c1b98f67c71337c36414f537e6360af4af344a5a0d8f9d8e3fd67023711e59bd8e71cc34eeeaade4b7f42ff4827616b691b202191164ffc581845edbe807e614a565a03a46e539919ac36c9c9ac0897a447fb292ee7fa723a8d07f8f7a5e9d744bcde19cb73d5ceb4221077b38a132eef7fec07a0213e2e86d53fd7c19fc9011944c2a01944ec45bbc12a7bd50f3a07a1a218daa052cf95577a1f14cc9407d28e5b3518e1b7053dbf4832c02329c12046f1efed0132ee2bdbac2d031283f5ad41b825683c58840a6e02a173f3b8bc0a6cb94417a1a71b66b2c2361d7a60e756610a39042aa6ee340491367c791fda11a690b3f9434ac9c7ade1c3c5280cce5ace66adc10136150e3327cf3c0f7773dc0e346218a25d3ecdb6fdaffa86a5c7acf5269be2df18d2f251be9e04a2d5ce2689bfd08ceb314b2f1dcd1929bcdee40b6e5714e3aab2c51fd32ccca22acd0c76398dcb605a760034d58adc8b8bfef37b62bd2c2a855943b435fab91376eb612eb6bee83b6b00b4a8d7f95064fb0adcc480b0b3cd6bb1d3a8a0104ae4e0a3ee4ab59574704a20efbec6b519c088c44f925f1fbfdd39eccf243f50a99f7a5f0f54a0019412d9a59e103e33f67e339a9b337e4f0d15c4f3806faefb1277181a27ac8ea13b21f4cb28621a5872b833886643b2cce499ebf570294b0ae2d467a283e5b43954375bcc2476739b5642d4daf437c6925888477dfd87c3b85465bd283e6abe7310cc88ef835d9a0c672cbafde5416c46ebffb0eadda621cf02e6756243c6b4d052f6737e438e5f89d0b504848","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
