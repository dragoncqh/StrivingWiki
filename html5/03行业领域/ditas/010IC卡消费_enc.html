<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e55f6b4c5f163ff9318dd29c5ff22659dfa9e563f94bdb828316d9a211335495d46ce916b67951e42fdfdf1db299292a6ec9657e3da3cc01b0764de249cdc0de71355e62b37d39ad0bc6b323ebe00e0b493e3cf9e8b73e045d2a2dbb0594116e4e28b11abf7c7e8c5ebf33904273001ad3aa0d44343c19be251e223dedcb5f3fabecddd6d54402bea04f11e8bb70da01e0d840df6b990a91e7863c34c6ab40536a8485a6943b3f6fc8ed2dbecf6ae1b67cc9f248287681c2124d708746d427fd5fe8e869d53023106d8b6c6b51a188827444ba735d81251e844477967e69cbbec847f7ee9676224c58461a6097daf53ee6093021975f3239421d984bbc1ca8828a60c445b460112558f2143c068be0a560c3a27f44ce9ba5802f787b6d61200a8b56c10dc0637d56e5a9c394f86d1567fec2bac7b5ed052faf6b878e549a537f7c876862cb5479afa74de16fe5e7cafbfdc01b2e17f5b133c73fdd3b798ca3ae796d96e042e2fd193050484cb8003ea2f53eec75a6dda98b25a4589b8e490078f7244a6d0d5f2f4a4ddec47d16566b4dedbb444af8a7f83d2d7fff2f43610b81fd40692d1a5f438472a824b380f49de3fb273d2169cc69cc7bbf644a989f67339315f0b2b71981a51f2e1f8e3a67df78685f4b148fe1bbfb831ce6e25c29a80736df346a7e2d95d78420a80943e81a22d0fad72d009058465a1f06f4423b6e9f5773d204aa8eb0c9e6560bf7dcaca61f25a61de901c13f28f90ecfd9ee0b5c17ccbc1cfaacdd6d8650af440a8d4842e8540337eace7e7f6f270a6114d47c8246e42c7abd3d956e46d7e30709fb82b2ccb9bd21c5009e9d8ce768eae3013e56b428744a9432d7c7c47e973283eeca9a1af1d7d3481a9e70b3b1636c5df977f91a4625c92b9f2cc939ceea89b53db6186965091a8b1e782949354404f30d61f3b9f4e00c5f00f007d907657fa6a8d115f15c32c743c9044b6d01635c01e315caea8248704508dc7d49dc6256ad7ee638197d96ecbbc40fbda74455d944fc71075ef81c40ed36affc4dff496dbae11c580aabf380f03eb251ab058c672076ae12ac56a49a450ed16edaeeee1e8761ce069b331e4b970910a5da9cbbd4ed5b6f7c0f84d3265dfbdf9f7bc4bb33f827a41e5e68c7f495f21a8f04ce3792f32b876094d938446253a256f036d102f60623e6775cd8b5047c5c8010668440a6be1653b05219c3f553f695ea63bae309c2d90387f3227c491a306a5cecffa669a688742599a290e8658f2da7dff91dba4b47a98b1272bde69362531826aa6d65cfc746edc950c523efa201b18e6bab641fb56b323e6faf8a34d1e323786c600ebb06e3617d5b3660142a995e1ecbff4b32ad77489aef9ff6b71927b578282aa945e1a70a1835a91da5311b4e155ddcb76cd678136f3c4ddfa8b831f230edff1046e2db1adee8c166aca7befd5d2fc6eb0bf1b6476bc7ceb19868b60c26c1a57520da93973c18234a4960028dcbdcf75882307a0cd096d178b8e6eaacc2ddcf0614b7b1d2d283e4b61d33c1dc1235a37240fff1fad13de1bf28f65c42fe75575e681e1566404deaf2e4de7ef106b8fbaac9999325911e6ebf15ae5f8de3ca7e39f6e3fe25c29e354fca5462abfe482446ca7c734b1e8a2c0f4a4480b918bfd699fa19e3111f4f5628bf74c443d65bf0c36f6ccac17ccfd6063e1092c42b150d0b5a8ebae73e8c27894a0025538fe8bdbc1f290fecf798a799f7b38f8c8a04ab479218ba1100eb4694ff9b0e75c868383bab1980dbd334bb49e13c08b6f90c8b4ce31a0f6592f9788f3e9e1bf53fac88f62c30286fe51f8a786a3e158391d83720a3841d14ed0a9404ca2b7914206e36f0b9390fa6fae04583287035fb64152067d52b9d552070d48009def435bb9b4dff8bac2a80664d5bbbce66efaaea8b379dfada2d846205df17923fb2d54ba312382afe2cb6520461e1c6739b66b0ada60996c1d7722b2c02e14a6cec575a80e8bd08887fcba0117bb105ce9a665e3b98a315e1db994913edb402570b011889c2345ad4cf52e0ff9ace773ae6087d1d1723b4b8704e6eec6a6701b4df0e6e8960e779521d8462d9dcb278a72328161bfe8f579952f0107299d74e5a03efc993269c19306341bfd606f9f871ebf539807d1614a6463c4792361b1e063bb46965fe95da8ed2d235f96a6a31fc42c7b1a1e6cc661a79561a239c1775cab1ace572eb7a7edc4e7808281179ffe87488cfd9c714b5f53e3868c45b7036700f59733378c64de1a6d08dfa6a89fbfa0aae4d7717b187407e476bf4e8cc1ce5905e029b7ce166887c2472de77502f3796d1d5bafe15ac25e6a1e45a498f4491ab75578ca92d06746bf53eadd3b8ef7199e950ad948075060534fd623b71ea9cbbafbf8daf64555b36f0a0bf25d16213ebb58d33ba1d50d7a14e00d305dae7b2a6aab63e40d3155045f2efa5fec7fcb85a4cf970ae0c6e2e5b20d9140923ff69af7dd40606ba8d086dbc4548dfa2e4cd11461a099cd4a700bd5574bcaef3edd4c5590ddec8fc0439d567cda33a7c2b93ba50bfbd91517519c64b6baf8575fcd5322bc54817322e4fb054736b9f2324982296994ceb4dbdb705343b14f540feea917db6cf2cfdb2ae0e14ed90e2e4889636d0c0886aade0e7ac2e79e28f991d8de3d09028bc9c83144aa009aa209f79854e75e75380b64de95fd0a613a9044260572182a7ef61d5d0843c2a103825fb1ebb6be70373daa1801cd8b08b5c3aee827c9cf96ddcb4e260649fe90c1ec1c6977fb9424b2e3ce95787f3587d4e067c373534f156dc5d42e2e56e49052eab00c0e235a9cc3c211bbecc88fa96583c863df38589beec7cf52f217849cc571d480aed89050fa6e0ccae1741cbea0c64e152a873fb287aab11e05f8b757e8a49899dd2e0fa0215184ba346008bb6ddf266817fe424349b60b7c3cfa7e1928eb490a191e7b44f5d272cbaec93250744a65e495d9a342024fe8186e2fd6808a7b2a063ba60967609ce9319c758a041885a309db8d1aa6fe0362b76675cc888dd28d31a130c49e9ddfb019884c6d744f2ca52af915cf94e5956560be002b667baa23f0aef0145c68188eb475d5473483bcb1ffad25b7003b04e758dbf0d72f5f1bdc774d152d53d99d9becc8f18f828a3f0d1c1a9ddb0457b958b91954e072165e34d8e2882cef40aac3d22065ec05ba243f7492e57f6faedb6f3eaf4fbdd8adf41b3719a90cbcd4362b0e7cd194053739fd29da8d060315b87d3abcd3be896129d4486a0d6f3047bd1eb283c1d7f2b45c65de261b9f8ee90aeb77d9cc9491a3b2d992a5dd6cc462c88c6f376208c30a2e5c69fb078fc4591e23f268c985e766e6103534f66cd863dfede93ca409542773ef81b9fef02ffbe608e6d3a656803157c9f458bbfe8988889983dc016d6ef6db75d2499b54df510c2db535466c952c0b9c0942713d378660daaff3e4411e50cd8c47fa2d22fbdbc18a453442cdde14083e33514aa4851ccd53b0142a80e8a90bdd05e9e83d4e2e9cba4dad11398c4eabae306ea0c5b18af046cb11100fcdf2b791e8c2d107f45de012bd35b1848dd51e91964d189a1b4a6047dd0636f8d2af8dec3422505f17dedd2895620a494a306bf18fac410b750fe67be8601c6c72afcf75ef872c33387fe9080b8a84caa41d25b77d572106a7e6016e96062bf2169cd0dd666c553d85fd12d6f62bb67b204fd64a1fa4e77537d1a5cbbddd9eb14658642f7352cd4ddf7b9fb6e5e11dacfbd1460cd471958bc190b6de78eebb29a681c8f192e01b80a93c8682d6524b575856c53a0c33aa280d5ab529d47a250b2049d361ead55a4b05e1d60ce5dd8f7698cba235fcc4698571d9a2ca7739dbd7979fb16b0494f2a3d75db5de617e8e4f148947f26b1d013b7aa54cf8d13a241ccafb613c8cf2105e7aa0ea5250c03121808e6e18bdb929d8164e632b47d133be918d74f32694b409309730d08980062f72b4ecbca1537df0684c31f1ebfc01acc7b9be73a8961f327241214422f015426f4f98cd419a96b73babd7fb7df8703054423c987ed4e91e653d2dcb45cb133808170807a4536db5382857fadf4583ca31ae6703f483ac780ae206bd6a97dba73a60dd7f85271d3294130bf41add623634ff8a60aebe8aaba1bc84e2b0d29fe9509b4d73f286a4d0c3ffa2bf4ccc8c2447e9de40ebead487a27567de1734f77c462a25c07640f0f9c7a69585a2cfa3f01e289b87e451b1c4f21514e052571b75ea6b70131ed2289f13a71cfd0010b13a76808e48fccb38b1fd54f055619f3abfd1d85ed1d5e3e82aafd4d451386e8ee4b5cd981a210a3b96eef2815101b60a893d831a8d232ed4a0ad892000fa846f35077ad5e229b2ed92ef613d31458dd2f8c074fd1b20ff03aac8c1ef58f5bbb146e1f2f1676f35b9722ef6f7626c98223f0662cde4255c0ff0fe6e4e9b811f6c84d765ddfa413c0d8d40a99f78873d184a2d9c3103bc7af1223e226b97da456d4528ef256cbdb029dbfab2cd7b809fd81ccac6f1cdaaaf6de138a677f13ddb9d5ae4b06eac88f44b96b470ade05f44ffd81e9a6bbfb6634925347173ab90004ba12eaf68ccffb37835c88b497ecbc0fae3f90c91b1d90c12504ce60f06279efb5b0db286be1a2392b4d74f28bc5c4b2883203e1abd70c870c3ef9d974db5f772b998ece87b01e7b1b39178e9f3d7159b0284d49a19b2b007398816128fc5e572520384fd9715f39ccbf1bbcef4a67918f4a430518bdf6ad12e2ccc6ec9fc7148b17338d7a804aba97d185d419d472a2557cb79de2c112b4ffb55cc3275f37a92665ad36e74a8e27ed967ab9f6c2622d2872d39a8a98029e036f5ad4c43fdae4883c1db9130d85f2c1fb2cd278e898a9e30264c191f3be391f21119fc1dda259e1be1c4dd2011842f06e15ab78580bee73f6e5b469fbd466dc3bdb3a1239df27cd5e88ed46825a28fba91dc77315b96975c59b534137287bd018e3cf4124105711a17cbd37e771abb93818b7f06b654c7eb0e0f193b7e2df31f42f3af010566e88b1d8f0690c0889ebdb7dc64b6dcdfc85a8b01a9bf0bf242bf578dc4cd9a9b49b971e2ab9181a1610075058f3e1f9c8d9e10649c122d5bd154e27fa0b1d4e43293bfe8e4533fbffa23a7e53060ee408a0cd8c372dd29e2e28e7acd23d2eb00281d6cebd38255a2cf95b460c30f71f1312ccdadf00ab163d6919d6f862d3543116126d24645774ee9fc06a637ee85bccea17892f7c8e26fea708d13a1559d98057226c4c42df9488aaaa7383cf7bec4af5b82bbd2cc31b643ff830a79792dccc84f4bc1bdbd407d7030e44ababfbcca666b29d0351560af737d91056723d902265331ee12a502e0befc81ad398e1d47e41dde32f54a9ea3112e418a18434512dbc6d4c5df7588683ea8a2d9f7650e8000853fa7c4432ced74fb0b0993c4bba206c79583877bd02b4f94ee706897d1ff892fef98c94ad4012b53bfc118f1c6054db127fdaa9e1638a0355649e1b96d1fa0a19834b9e63f4e99bdd7aa154fb2940cd9235c8a5e649ff2dffd8fa0ffce0589b41b0f12d529e3b28f08d9a0e3b777cbc0f4b668e3817876514d409db0f9aeab8d2d97610f7fcc890fd2c25ecfb27300970a4d56dfe48e7c75acf7f896d878eeddeb969130da7fa374e3944006ca5b7679393d9b24360e58724ee565137012a5a0e6dc610f149c94bf5ecc511e26654c0826bdd6d9a097bcd3e2a68f13d03b1e711a456f8683e03831958c459c3e649e945c55a82c375ec255c82934bec85f73be9647aeb7e2a8ca5c9d248c983e38e95faed66b18240c15f5146ee176347ed9e2ca52da75f21b07a1a4b4422eefeefe3a33e0bf4d2a988694a012dabe325343f368ed2832967f7ce0cf0f528a2b8c86ae153219ae234086d940a5d68e90227faacb3359fd54f44787846ea05edc21a41b84c2ce3e82ad4c8b8b36f4f041ce5016c49d0d22460124c725032f5c2462016f778adeef6c390def4dfae0c41bad2aaf5bdb4e19da8e8cc00bc94202ff89a449fd8c34beb6375e87ae75f319b0f115503d5ab5d136a8a37ccf9271de10ad9921300b9952acfcd46bdddc37ba5ac1ac14d717b6c4eaacbb707a6e21093050ae85e8fe12246d795c50f6525ec9363b304776f77a615b0494f0f2bd01d07f4566612cedd6b0afdc6f3233650222cb3a1ba0115b1735955cc8abd580c1a8041e646ae77d2418c473a93efd260108203d040182c7b4582f1a854ae9de136cccd1aa30d2ac4eaea696e3dd3bc72a915d52df98456cbaea4afb49a007eaa10a7a222b534f1e3554a063e746723e485d970dc5cf97a6dbaf37e214c908359c4194de8426d129293782c8eefd6c2d93862f457db230ae5b532a9b13dda7add3b931c71fdc36316cd6cf84879f66c34946009749e8eaaf5f3bb33ba6f72d7303ddd7fface5ded53758d6ff2369dd10ca9d7f5179b634c91048061f6229ecc578c82728d81171d576116afd6c2d67fb2054db0dc30755bb867edb53b7d9b8b7c3e4a0255665e617e577030802e74b4bb74f103a7de5d338db280d4144729291dfb717d21fcd1d3a90c33e5111383e6785d9e2a8d753bb178cecf8c0aa77bfd50cc7790366c35dbc1d1f40d9d522f2bc90778a3ecff81cdd451b38b117bce979c1c16d7967122301dc9f852706b85712a6e545baa3260046945bf3b34cc35150af3f51074b57c918f1d097b6b8e27ee0f35044afcf39c016d2f5cad41489738aeb3750d4c52584f68dff685f140467966af81d73a2e906e3d2d8f13382d7960bcb020f969a8dca46178e38af9ee4f9f94743d24e194929583fad6290e2fd18fd05d6ab9d0deed028bf913ceb679fa83f81b8ae4210c3a3da9074cbc1c4239483125239d7d7f5e5123d30457769ed34080f070e38104e86301d29a36ac648d11987df2a2c565b96bb98ec25cb33ec31285d083cdd62295fa7e0be302f33ade75f1a05a3557aeb05efb0db9f0c4b2cd6bcc94741bb9ce221f2b568b5299513a0a62b1faf19f1c232fe7338ccac919b588f04966626d54183465c54a1c9057160454eb1a3d76c3cd2116a033cd321ddc689921e0b678a12c8c597d43b1eb7e4b7e8d7061063ba173dfcf39ff52b602d733470c7f9e958365bd077f590b71537b2a59e0f1b7f9345b8a2863a91c70b911fa48c51f8888abbbdb28be2f2d1b5f5c06cd083343f3bf2961ae4e84aa27def683c25e8235d52e4e3386f7765e020e01872334126715dc124d093c9e5794e416ea5ceccea13e65d4b10d5ce552be4b18e9ed3f6eebca5a0a4ae3da375c5db8e75781f61c87631f606a6e65bc732744ef45b6e56f038faf228987995165088938fe3786e1f4b65daf00c4f1c542086c613e185ef529c30c81a1dbb4d4e164fd2b3f69242b3c882ad31ed8a37ee131547de2034ee66eeff391ebbbc4615c1c8c21f659f7d4be72c44f6a0794a860a8163336de6b8c8349277af6a1ebc4d7553363cc42d2260a67cb8723238e3c32577347544791ee8c9cf9a2e320656c29225bcef57ad20c2fb384a5d26ba68e32e8da2215b74ac8b4c858a1c414519322864da6aa113dd38da2444f1603cde71cf8f72faba6938102b84935dc7bd05e9507eb807c211843880065a8ab4e5c803f917eaefcaeec46840ca422d2e1120ed3f7a34f23568d35ba26a36e9969a7e063d38cb0f1a69be74464fc3fdd8f0be6f67f7b5bd07c60185e0746e9265bfa22074aa251d62a964440107a39dfd602103e1a3780398b09314f35bd4266794d3e9b826905f8fb9841d7d99240aa0bb72cce5fa6c32ba62374668c0b0054a23ff05e0268b82ffb2608ad6fcf22a1c3906d62746ff08b30f91e72daeca409ad8203bb3b334d331564091aa174d4193cc0ff67e3e93f17d6675dafda8c61e1bddb9eeb3e24ddcae5dd7e999d44cc33ffbd61e2861bb28495489ce2ab29edd97ff9192e475165b1f800d501f0ca5756d8486ab2b40350ce63846debbe47e3a3a7c57bdd01ece445678fd542d2ed90bb5cb9ed9af5514d0eb889073fb237300a5f95b0e082b45c89e4fb7dcf31ff250bcf135862ba2c2a571d5b33f905632613e403edca687dca5f6ef74ad56276ad70a574c920aa4bf12ed8694b65afd4d102bc441933154fed0d63a17ae1a21051509b86393b7517bb1010dcf44bb507f360e89f30015cdda0328dbaa93798fe1a0505367dfcdd53171ae2128441674bae3db7efec2012ad6d5339940fe80f16862200958367f303e775486500b3cf9d274e72166a3333a6d00992683fe4ecad06208388e1045c3cc09626db10e1efc46b7ffa1bc981b479a8b89ac4485b1b0460ae3fc5876e763bfd8560e40ea8fdb73e700271f522a6a026d5e047c8b9af9ecabec5ccbe5aa6aca4042b4c35ba99b6e8b489aa1e2223172fb29cd78478bd9bea2ab7e22b0234d46d8b8f93114308f2fb0c16e39cfc0f39db2dea3189ca623ea7722f5fe6b24af577aaef6f9ec7f38203b0849f69c9ef3651b9d293142bc4c655784a0734b420bf3f74d600fa20811e153d5ae43c5d57bfd856b0ceda664ac206ea39625ed28d9b199f781770b88fcd75d723c2460876b2dd84c0d2dd0cc67f0135cb431247b0ba6f01ba6c9967f809918fe115de03e711149ab88dad10bd067a6b548bc294b344af341928403d7f5a21b3e026e97891a8af26f37a029635ed74e04ebdf87705aa7964f54f1748db9de9e14152f3644d3bfeb0a26d95d401bc05f1523e8c64c35cd81b67652bec1419ccc42e0057f9648a50f8c52499fa75f56a767d79175ea3904f109175a47ed0393dca975e84e1b69c5708f74a9af24bb3949da846aeac9873d4955587e99e74c9ebb99fb69616a946b8dacc58437e178cc15c47086a9ac76911897dbe7f8a037aefb5fcc7efd4f82b8164ac4c9a052429ec527a8bffe687c66f421ad8f162c5ee343c9dc1f22bc8e450df7941e4d3da54e5b9173634eb4a7fb453b38ede80287cf2b4d7a5c4ed4239579585e21be0891d4c4f4302bbc251b5a9ea8306e6a61135aabfb230b6b6b34f1b6783095d3ab14a90213506f063532e0fb2869f25a9c0fd9e0a6b6dd5786d6d03a01282bf7770f95f886dd18d5a0edac47ffc6354ed56c2b677a73b18ddbb682d146f37666d663dc2086f715812b069d8521da0d9e4681331632910c2199aa6cf74c7ae3e011e6a94c2e5b804311f910ab0a9843e2359b1639fc2c5b040284db30a4c5d9f5b2bd4904f89646c7bc5abe2ddebe1216e1fbe3dd1597d75ede3b13efec9e13a4fcf1a285eed1b8a8713f0ea6453fbdeb76ba591a55678d20de0da64b3116d679850e8ac6c3bb7823bc10a7310a3ba8a7d6032305e0920f2b2ccd0485ade2dd04edc668957394396fbbdcbc08470f74d5e34f0108dae3c801cf2e3cced28a4adc4a3d65bb46ba3624c7dde4b2a916f505c1de1dd5d8df3976578d35fec002a32e160e43be0770aedcc9ba183d150841a3228142ed0f044903cefc2bab7d15bf1aadf54e2430e704e6fac4437fa599629afbeca872f01d48b5c191b1b43bbc008097b51b901f5e23408942301b11360495a8acb33e20c64c74798bfb08aff3d437001246dbee1b6bf6ec0e24edc40f783a574f77d5d3b8e7b1e2ff885dc2c8e987ab2cd20457c9816e5a89f662dc9f1bb1d0088198353fc45962a63035c474821767baee7e1549ff0603213efe6e5d36901384bf606737ae8d0a5d5910fdd2e14ad47fecb37ba4ce14ec93de0205365912a23a4f6e7055f278c857ae1b591cd1a1cecb98ffd3a27101d0f79eb70e9500f95d592c42b7722229fecd3f87308f5211c91a5a544c7a14e59586d669328b28249369b35dac6cfb62e168989a320f93937eb1f08ffa2ad80d5732beb1b19f5d0f5aaff4e7353703a630c7ca9915f3abebb22dc1a43ba5e823b52d0bf54c0c28e7c4e9809b3536f0e3e89e5cb836ebd576c6491dd18b20bca11cac8add15a9781bfdf748553a661e6c9b0a8ef764916a0c9563381a7a91b612a77f0922d868ef24c208e781a07f5aa0b473fda645606b8517ad7d6f9499fb705b08695c89ed95b3ae4f8e8ad97d24d18c259d8dc4e18fc04a4ff28dbee3458c2b64a2cd011e8e7ff9bf62a2bd57907bef2c0173b37da4e70317f5602b726336c21a58b8ee708f747bd681c37f7702dd8c957b883b2ce11806867e297e2811b859f7d6597e386977970973a2ad9a2e28839f74c1c192d97be06898725761071af7a924f374d55173dde90f94f02df1cb020d328a67291ebb21d0d6516e38326e11ffefc6441e6adb10b585f10b4cb5a193ee49d7a9e5cf4fdbb102cc6f2d145090999c47f8f0c45f7f2f9e0533b0a1ff65970cf7ffd6d9885fb4426336853d52831d0d434c2723874586abb9a20ac50262343cb2c00d297a1581becbbd8b3f707fd7ead9f9bd12ac50790847f23bbc80c29c3a1c0ee79184c01a408bfac7ae1040ce537bb4dd9150baf3e594865e913266ff83c35eca4404478ad7fc8190ebd8bd91a6fb14db1ee78a0f0c46c4998bd00981e25101718192ca8ec9f0aa4063f2a8ddca1a453407d569099d14d7e8a7fdd954bcedd5a35551c34137614bbef4b6e24590a1809e16adf6ea5063a774b67b678cf4e5ee74f51171fc252f967bb7842a68e35f67481bbca918efa0ac0302e99faf416c485a7759b19fdb0cf9dbd117829c73860ddcfb054217a874eeb816c4644a7e53b89efaea7868f6b5e448927b71473e6f6c9422c3d79bb4e1e93b9aa320525a33d186d85a2c3bfacea9be35dc543ff7b48dc2723464fdd079d5a45d6cfc07785237e2be89d25d163f8ab30cea176b764cda00faea5be7d332e15fb51789fed1dedfd3229fbe2f9e222c25161ec2a986b880c6f5e26910c2aaa22c01455d71a447dbdae97235959a68706906c64aeb0a88901e61fa70cd463c6727d192a4ea3b8e75fe06358557aeff07e1f74b365c6494ad0193ca976862db06393175eab5d333d4416025d238ba56bb299d6a7810b1fc3c95aaa0f707571662c70cd8e939f8c6f1e4ea19953f417d77dd734a24a96fa2bd5183898346c72f8673470e08956252d5497126123b61015b686c510d4de0c05cd6936e043f3c57b6870927b6724678deb13b0163696a5ab9461264b2f71509841fcdaa47e0915c71109a7eee7febbfc1bdf0f0e337b2fa90c4768a5a7fcad87f315a82baa2cce6f28b8851c83c65d7f7cbf0e0852f7740772084949558da6f84ccf4c3e990841b2b7308a5ec1ba9f1de0c881e07ef4869ce4c26e891b42691ad86931aef01a3f22404bc044001660ce463b3facafddfedeb06c2b48ba611b0e771c34bdefaa32755b200bd8563b0363830ac71aac40f5ea01a227e5bc149fd8b1e1d784ccbfd1361f5103ee82338db5843f968c723d1a9a0e884848fae6341ecdcfc49e908bf8763d0de992495ceb34d56102134b24c121121c40ef40fb377e9ef4ba1de4bf8d262ee5907b26a31d13c364fb5dc28ce173d68162d57e373ea7fc2108b87a2b77afa099cf1570804c749d3e5d30fca53c7ed5667e04ce6d3fbd2265b039fc9cd58d9543edee981a87be47961fdc7fcbec84a400a40bb084597f50b0eabcc59f5ce9a0ec170988679a8aef6fac9a781ffa2c78e13f83a6875981ed65044ff8896924704e55336eea3bd04d8ad281209f686dc21f66e9704b90c6d834520e9d7b8c893eb3425e3ff4b7f766d65bc239dad4c9e2176bb336c118842932aae0f723bfffa80e803833cf0bdcdb499c22736e3d7faf6ab76703e1aa9d515b0dff1d5bb98869bbc9cb14f0063e66a4852e693fcf144ffe7578baa1b4d2fab9b86d5e86e48846a1a90ec681d1942260c48c614a3f33f69420fc41adc879f5d52ccec03fc4f80052b5821c27b9c4cc775c858d0b74ed16d975123a57bc3c01771ce04c0b828dff62c0f8dda1df978df6f2274f2e3d2f1cc585027892fdd3ad6624e3d4784efcf621e62b81d3f84c4e2dc547c3405663d5cdb2672d7c7694a18735928e38b2f8288b004c7379b0f4259862d08e3622b0c01d8fc49422e04e845377b79c408f9b3fe201c1ed9a3bfb962408db685b0858c12bcd92824ba184415445e5910be1485c855488579495484d6d965806257d4c12d835ce62a5b3fee6d9468a3c72c886b35e0ad2a06c0c97776802a78f8bbe32acea4be8119363cd87d4ad336a54436d3e1c44d34e7318d29c28231d99f6f01062df0d18deaea832107430f7c4b348542a96b1e04f43f8e3c454a9c9ccf694e9f4815b673e282d14a960e7f693ffab8d8f3a85ed56f9f08f88739065be02f6d4fbc52584be1ff58672137cb87b46f977fd4ee44e2f1156ee6c8e9d7089e685f5d7f1e41533e38725472e2be537bb0ee30704e089a4c5c650eec2e6fdf139c96a6f16fb0ccec3b4942f936d3ca334bac39e93bccc240d01879a08713816e7261b55a1d5d43d6822f6633960047f980df17b345ec9668c34436d777acf081e3df8481e3e5d9edbd7bb2b89c164a0e4bebff422a9f2efd2604a5bd3aff572543abe40b1c5ba65f2449d1ceee43858ff10a66debf9b321bf27bf4b9729be57efcee7613402c210a9d94d896b9f9581ddde5c464288aafb212fb9b090ffe20b576d047cd25dc44a0fc4a3d69756e8fca5abb86b3e64d1460da00abc2f4209b6e3933de1ac2b5269c0e210879e05b778f2a9595cc6f85f36cb44985785b052248a9a220e430458f2c38b4e10d9fcfd42fd4f407376aca09d9c1d681ab40e7fce36af6b92d2e4866751f042782412dc59a2ad8a05e8e9f269e3e081950de5f1e72b4820ed959aa88cef1f3aa99973e3f63db47c70ed1217245ab67a5ea30ebc97de42643c53540bb35769c07b5c2405f143af4323f7d63ad78e8107e38d5f17e3869b7a327c0d0bfc10952b7bd6db787c3f6acf54d7b49fbeb1f94b0908723eb7bfede8b252540124ed46199b4491fa992162f91e92d8a1d5a432ef346863d06cf3d31e71d1d0c9d950703800c4b0d6c18d60a610f5fdedb7a8dcb9b07ecf7f038834fd44c9fc89a1fe27b9b10a4d78144e0c8bdbd9e0e17bcc8884da23de458d0704147c0bd78d605cc385822af38a4d1ebc05de0619aefc30da0f61d4b80486979de042cd6180baa5e845c162698ff4d5f1862a5078e66f4b36932893fb21baf3d3db8d3203bcd861f11c83a5a10b9b01e557404befc0facce6b6c750ad70694b77d05098a6a406b3ecbe9ca6e30ec9ee310955991ec9c2b93700f6ea5e9e657fc58e063a7ea25ec62b09202e10940f69691f7477054b8c755e05507932e1bc64cc2ea91e32063f0911b797b267ca4500aeb21f4d45b9f0235ab9b2ae859fb78d29f23f7d30f83224e21d899dc264d46be536458e422d6c6c22b3a0090d50d6ac2e1328e9816d8c420972e1c63cea8cf9940f8ed6a452c4a3ae91f7597abd4a028c38e64a3c47b86df9adfefa059be46474be063d9d2e427cd74caf5f7869ee572879ebf1f80a5b1bbf22e5f5651860b99e28031d721df85cf30c91642d8e59fdea54afbf3213d2db9ffb21ea115b79d99f7c5178bfb1d69f0b45544521877350f4b7eb52c6d92da8c10b6b2229842aa796e4220d2b2e59a90c07bdbda6e79c6e81ec5da8ae2970c12067856c990d34b3413c91d79a018179d6fab90dc1a1095585ea26709e0df6aafe25c9bcbbea5afe3f3f7e0c7cfb6cdfce6598d9a9344d51d8c560f749d5694ac21265b1bbd151ce71e1f5c397b57b4721a85b7c152f4fe1da5f913fe5e694954b2f7d0e722f1160a7bc4e2ddf8aea6edd06ddd36807e2a19560c5d996298d366e55d1ae463f848e0da2385a8a33a3fe717e07209b8c5250996a378cbcb064dbafdf50bd70b841979a1db06401a391a284202b5e0255d638cd37a5a065c9a1b7bf4ed9f2845aab3a176be5d435fd90efabcf092e9d858c28916f0efc99ce11a06e6e78f2a7594c387cb52a5d1c3945aaa2d9534bc6aa1c3b7bd4d3e18e49cf6cb9182ec908861e2301252c3dfa822975a9aca3258a42e4021dbbb0e43d80bb61708b326695ecdc684cb12fffa30b19b61cc69ba150fa3b7ba1eba7059b3e77da82eb9dbda71e237cb5c7917734460d10b7e3f2950ef6b5802278930f6aec34ef2a6ae662468ec5a3cf31dc7bec39cb80b0ef978a0a545aef29fb471098fa6faa68e3e82e53e875f15aff1b42e1c5a0021b6badf06e7173d15cc176542f07243d452f4aaa5ecfd806","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
