<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content="PHP关于应用架构、规划、数据库、安全、测试、调试和部署方面的行业标杆。"><title>PHP最佳实践</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="PHP最佳实践-DC441C82"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">PHP最佳实践</h1>


<div class="body conbody"><p class="shortdesc">PHP关于应用架构、规划、数据库、安全、测试、调试和部署方面的行业标杆。</p>
<section class="section"><h2 class="title sectiontitle">概述</h2><p class="p">3年前，我刚转做WEB开发，用PHP做了几个小网站、公众号和WEB APP以后，对PHP的印象可以用4个字形容——累觉不爱。</p><p class="p">从手动引入自己写的代码文件，到引用产品的某个函数，到记录日志，到缓存数据，到发邮件不卡住，每换一个产品，这些基础的问题都要重新解决一遍，重复开发基础的功能（比如日志），重复写机械的代码让我实在很崩溃。</p><p class="p">在我的观念里，软件开发不应该这样的，<strong class="ph b">应用层面的软件开发发展到今天，开发者应该可以做到将注意力集中在在业务问题上，而不是再陷入语言特性和基础设施上。</strong>有一段时间我很矛盾，是否该考虑转向JAVA、Python、Node试试了。</p><p class="p">现代PHP的出现，结束了这个矛盾的过程，那些前面令人饱受煎熬的问题，都得到了解决。</p><p class="p">包管理、自动加载，PSR标准，以及日志、缓存、队列、命令行作为基础设施的组件，使得这个古老的语言脱胎换骨。在有了这些现代化特征后，我才第一次感觉到自己是在关注业务，而不用像之前为了让发送邮件不卡住而专门写一个简易队列。</p><p class="p">因此，现代PHP之所以重要，就在于它将你从重复劳动中解放出来，将注意力更多地集中在具体的业务上。</p></section>
<section class="section"><h2 class="title sectiontitle">开发：关注业务</h2><p class="p">在前面“现代PHP为什么重要”其实对这个问题已经有了一定的探讨。现代PHP的包管理、自动加载、PSR标准，以及日志、缓存、队列等各种组件，都是为了让开发者可以将注意力集中在解决业务问题上。</p><p class="p">没有这些现代化特征，实际开发最容易碰到的问题就是重复开发基础功能。比如写日志时，发现没接口，于是自己实现一套简易的；发邮件不想阻塞请求，于是自己写了一个简易队列。花在写基础设施的时间比花在解决具体业务的时间都多。而且还不稳定。</p></section>
<section class="section"><h2 class="title sectiontitle">工程管理：测试、部署、分析都有标准化的工具</h2><p class="p">“在过去，常见的做法是编写一个PHP文件，使用FTP上传到生产服务器，然后祈祷它能正常运行。这种开发策略非常可怕，但又必须这么做，因为当时没有可用的本地开发环境。”WEB开发是个工程管理问题比技术问题多的领域，沿用上述的这种工程管理策略，能把自己玩吐血。</p><p class="p">现代的PHP项目的标配采用的是最佳实践的工程管理方式。</p><div class="p"><ol class="ol">
<li class="li"><p class="p">用Git做代码版本控制管理(不再使用不可靠的FTP)：帮助我们维护一个可审查的代码历史，让我们可以创建代码分支、复刻（fork）代码和合并代码。</p></li>
<li class="li"><p class="p">用虚拟化工具（例如Vagrant）以及配置工具（例如Ansible、Chef和Puppet），搭建和生产服务器一样的本地开发环境</p></li>
<li class="li"><p class="p">通过依赖管理工具Composer使用专门的PHP组件。</p></li>
<li class="li"><p class="p">在代码推送完成后通过CI/CD自动完成测试和布署。如果布署有问题，则要立刻回滚。</p></li>
<li class="li"><p class="p">在性能分析上，则通过xhprof或者new relic这样的工具去分析并改进。</p></li>
<li class="li"><p class="p">PHP代码遵循PSR，这是由PHP Framework Interop Group管理的社区标准。</p></li>
<li class="li"><p class="p">使用PHPUnit等工具彻底测试编写的代码。</p></li>
<li class="li"><p class="p">使用PHP的FastCGI进程管理器部署应用，并且放在nginx这样的Web服务器之后。</p></li>
<li class="li"><p class="p">使用操作码缓存来提升应用的性能。</p></li>
</ol></div><p class="p"></p></section>
<section class="section"><h2 class="title sectiontitle">使用接口</h2><p class="p">依赖接口，而非具体实现，可以解耦，参考 Laravel 的契约</p></section>
<section class="section"><h2 class="title sectiontitle">性状（trait）</h2><p class="p">这个特性很有意思，名字名副其实。</p><p class="p">假如现在有一个人，还有一辆车，车和人都要实现给自己定位的功能，显然车和人不适合从一个父类继承，那这个时候
trait 就排上用场了。这是一个横向复用机制，让若干不想关的类带上同样一个性状。</p><a class="xref" href="http://php.net/manual/zh/language.oop5.traits.php" target="_blank" rel="external noopener">http://php.net/manual/zh/language.oop5.tra...</a></section>
<section class="section"><h2 class="title sectiontitle">生成器（yield）</h2><p class="p">这个特性也很有用，yield 和 return 类似，区别在于
yield 只产出值，不返回值。</p><p class="p">也可以这样理解，return 是一次性全部交付给你，yield 是承诺全部交付给你，但这次先把你现在用到的东西给你，剩下的下次你再来取。</p><p class="p">显然，在迭代一个超大数据的时候（遍历超大数组），yield 可以先给你一个元素，不用生成整个数组，可以省内存。</p><p class="p">上代码：</p><pre class="pre codeblock"><code>&lt;?php
function makeRange($length){

    $arr=[];

    for($i=0;$i&lt;$length;$i++) $arr[]=$i;

    return $arr;

}

$results=makeRange(100000);

foreach($results as $i) echo $i.PHP_EOL;  </code></pre><pre class="pre codeblock"><code>&lt;?php

function makeRange($length){

    $arr=[];

    for($i=0;$i&lt;$length;$i++) yield $i;

}

foreach(makeRange(100000) as $i) echo $i.PHP_EOL;</code></pre><p class="p">第一个是先生成一整个数组再遍历，第二个是一边生成一边遍历。</p><p class="p"><a class="xref" href="http://php.net/manual/zh/language.generators.overview.php" target="_blank" rel="external noopener">http://php.net/manual/zh/language.generato...</a></p></section>
<section class="section"><h2 class="title sectiontitle">闭包，命名空间，opcache</h2></section>
<section class="section"><h2 class="title sectiontitle">PSR，组件，composer</h2><p class="p">这三个东西对现代 PHP 意义特别重大，选择可复用组件就是选择了未来，细分领域让最专业的人去做。</p><ul class="ul">
<li class="li"><p class="p"><a class="xref" href="https://link.jianshu.com/?t=https://laravel-china.org/topics/2078" target="_blank" rel="external noopener">PSR-1: 基础编码规范</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://link.jianshu.com/?t=https://phphub.org/topics/2079" target="_blank" rel="external noopener">PSR-2: 编码风格规范</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://link.jianshu.com/?t=https://phphub.org/topics/2080" target="_blank" rel="external noopener">PSR-3: 日志接口规范</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://link.jianshu.com/?t=https://phphub.org/topics/2081" target="_blank" rel="external noopener">PSR-4: 自动加载规范</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://link.jianshu.com/?t=https://phphub.org/topics/2082" target="_blank" rel="external noopener">PSR-6: 缓存接口规范</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://link.jianshu.com/?t=https://github.com/summerblue/psr.phphub.org/blob/master/psrs/%E3%80%8CPSR%20%E8%A7%84%E8%8C%83%E3%80%8DPSR-7%20HTTP%20%E6%B6%88%E6%81%AF%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83.md" target="_blank" rel="external noopener">PSR-7: HTTP 消息接口规范</a></p></li>
</ul></section>
<section class="section"><h2 class="title sectiontitle">过滤，验证，转义（防注入和防XSS）</h2><p class="p">输入和输出要过滤 html，使用 htmlentities($str,
ENT_QUOTES, "UTF-8"); 第二个参数开启转义单双引号，第三个参数指明字符集，都是必须开启的。</p><p class="p">使用 PHP
自带过滤和验证函数</p><p class="p">filter_input()</p><p class="p"><a class="xref" href="http://php.net/manual/zh/function.filter-input.php" target="_blank" rel="external noopener">http://php.net/manual/zh/function.filter-i...</a></p><p class="p">filter_var()</p><p class="p"><a class="xref" href="http://php.net/manual/zh/function.filter-var.php" target="_blank" rel="external noopener">http://php.net/manual/zh/function.filter-v...</a></p></section>
<section class="section"><h2 class="title sectiontitle">数据库</h2><p class="p">使用 PDO 和预处理</p></section>
<section class="section"><h2 class="title sectiontitle">密码</h2><p class="p">使用内置的密码函数，使用bcrypt 加密</p><p class="p">password_hash()</p><p class="p">http://php.net/manual/zh/function.password...</p><p class="p">password_verify()
http://php.net/manual/zh/function.password...</p></section>
<section class="section"><h2 class="title sectiontitle">多字节字符串</h2><p class="p">使用 mb 系列函数</p></section>
<section class="section"><h2 class="title sectiontitle">流处理，错误和异常，自动部署，持续测试</h2></section>
<section class="section"><h2 class="title sectiontitle">参见</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="https://www.monopo.cn/archives/396" target="_blank" rel="external noopener">《Modern PHP》(中文版) 高清pdf</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.jianshu.com/p/c5c205e93ad4" target="_blank" rel="external noopener">Modern PHP 笔记（一）：语言特性 </a> </p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.jianshu.com/p/eb85094ee164" target="_blank" rel="external noopener">Modern PHP 笔记（二）：良好实践 </a> </p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.jianshu.com/p/dea12c682eee" target="_blank" rel="external noopener">Modern PHP 笔记（三）：部署测试和调优</a></p></li>
</ol></section>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="PHP.html">PHP</a></div></div></nav></article></main></body></html>