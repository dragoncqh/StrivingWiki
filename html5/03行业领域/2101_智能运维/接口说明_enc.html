<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2f152569cc7f3e7447766b72c4709251307c01d060f2a47a46becd8944407ec357308f0a233514ddc4c893436032f948ca9295106de8c23da73a7dbc548a94ff7c7d99b2a3f9c998ea54306f2e1184d55387405d51b86e5376c88a90dc57cd4530325f621ff7286a2c48d19220af64b7e6a2bce50fc80a07e56b7df96577a92adc2eadecb7babb8388356c15df8187754af511e12deb84f1e41051d1ca61170cd1541ef07fac37c256db34ef1d28f1245c10ba7f479aa429a9478853e4cd0f732fbd6e15bf0197850d584778ca623cfedb37a1c3b5823caea7ac582fbdeec883437422fdac8c937b52f5dbd12409550b9430a7ee824a9e42d44fe731512a7c892e6d53b05febc0fa1c3310c69d4cf735eb64450afc7529d002831f87fff97ddababc9feab25b3631aa975920684715bf139618a11bf947d39a70a139d04d487bac53a9be2645ef7dcd8290056f80a54ff20b3940f0e30616e1618007fedb0219a0e39b198d116dfb24ce2ac10bda12274ad21e183f9635a0ecf45b4d0014ebead6f7d1dd719d180deb43bb9b77b2ad93b1cfa2278577267b35bd5f0efffba43b49ccab045027f3cf9979019e26a6c98c6176fbbdaa11cee937a5803e7237c553bb6665088ebfa76410b70fe92f572d21f03ad1068653c2b45d1eb0010a3e7d9f08c0b76734023220dcb6bb15f75d939ac54d19491290789b53e1f066c7e9d754edd6d43fda4a99b523c4fe1e993cbfaa75ed981317bdaa14fa62f27a6f2490c2d6176f802a3d96e3d0e5ef18ad0256d203adb0bc6c5e4430adac4c9b4338e5f6362636feaf85c74c8a16c3083dfedd938602150bd9956d737a0e0303004311fd811d5e19864baa06bf754551bb1440457787674f6429a3bd9a84a70d4df81df2422a19a20ec543d4db2a1bdef7106b3dbdf2703c5a91e59eb74575f22a986ddbb94481ff3ffda0cc36d1f716413f6c5233df579e9fd3af5ced06ae0cc6bb9e45e5a989f724115b738650b4e5bcd64818f73dfcdfb88166c7af05d19b28306fd10407c66ef9ee509f835ad46cdc7f7197ceec08da28c81e9b53581f81e8f799737d5e0bc816e903e83aae839c70c4941c730d83744b47d0ff654f842191be345de8d7da4c96a37fba75e983b68ea2241d631604b802590f9f02d8b4ecfa44564fc5aba96212ab71212b58cff204a182a73713fb5259238abf4c20086d7f06756cec716db06f56e8cb2de36df061b3385a809824c79d6b22793f58852707ffc7b087d2ca1556d0475c572592fa324fe036f590b8e0bcc8bf00b1e18e8aab4190346eac83abb4514343e7b63560e8553db4e81332c2cc8c14614c32487c0cd48834bc37fb627c60ee1a043d6fb8ec5f0112cfe9174f2c9c418dc884e937351286cbcd347573bb539523ad134173dc27157b5e72e5082819a245b9deb076a05a5e6a82bd841005e9b736ec3feba29a4f1fd7de653b144776ba69ae04beaf3142345545768f90f763cc9bb23c31cc92fa48584ff0f6ba948356fd87e782d90584ad1d537f4d3a8bc222e3296ce03f3111f1b08f82551ff6b181ce8591f3246a0afa54e05e02cb4fbce1d6f4ca75e030d5f384295b73c58edf397e6de502309ed415e56e326c200b9abf904d0d88a20f483dabeeeaf547717e071076b5c76c536cf719862bebe7ce456338839e9fd56652d738d53dd8a6da015a454503bee6ae23b3ad8762c4c8c1f669ae9782ad61d5d56c09e8c4986cd49b7e9df9176b963df2ea765403b1f06b4675f781ddf0344e3702819382a82d79feea35b63f288e4a2322fb21072625d05c9d9b49555325fca6fa989fafb51d3a483ad10106fd206eda9152738dc3a629c4d8c15cadec6906bab5a6d78b879de33e54fb4aac06652107f7e0be1c310e0fc6721b18b4f74bd1408e95a08a2dfc3198dbab2c6ef881dfcd6a362f8f11f533ff62d9825e27bacee6013c8a088e487d505b839f0302c3227b29f002572958d0dbecbbc080396ec1134086435fc36a687c9516ee8c522a8d5fa35bfdfebf329dfb2196ddb045dd85bb799f30d62b1e5e02df4bb73460d7f816b7df9b5d1a3f7ded5a9f244991d551ef9a348c78f9b8f575a7f9c3d6589dccbabc6255d150ed8692fec0e7f88eb0c89b85c111be22aaf23902f2163c1a16b77306f60f667c2d2b210dc7935fbe74359f9275be57efa19aa3aecd528afa027089ce8aa7b7b80854c3ac1567fdb9abde8becf11396b1560945a92e71b6d79410ac6c7d8a3bb54d7c37614a37982b9662e608df7feda0ef47667aeeeda3465cdf13a3bbeb7e3bb83be032fc936e02f0dd40b005640fccdc3797dd081aeed2b319d8e2903022ae8a9484312bba8293e4c6db18ae2d673701786bdcd077429566d057e75af9453b62d61427dc6047dccdb21781568a4a9a0a962305eda8e82bba3099d5eb6f5d15f64e4b561de38127d3cbe581ff342b8ca433a0b8b609f5d7bacd90686196ceda4d484d43cb5abaa9f6ba299c572b856666e7aa15d10aca9f013714e3a5c9fef8aa9998724fca643b9687a7e321a9ef228c92bd0e9f51563889edb5a22b6a4970842e5f5522c7a291e0d432aaee4955367ccb5df9e645b0dcab6f21a88d47e118c97e4faf368525af9835109a47a49c421d15603eff9465b44b7c2c4d6fed03bb6b67cbff183cfa04099a9005cd355f86a5705c787e89dd17b668b0c2de2a79ef3e7795aecde12bf2337e399ed138525452489700007dc1612a739bdc7771a894be51e2ecdba8c757ea5642bf7d7c16d589bf6ab66997857149d52b7a665fbde73c4d8d4a27dd63d6d78b16cbd86720977407c8d3e2378601278eeed99a1a24d96a5d0e3e96eb216580b2dbc000f730ee4c83154e984c485891b2c9efa9100208c905d619abaf5befb761e1e728d95e0e5cea7f30eb105798a515e4f5c20145fa047da7d7eaf047509b912d6ea682b6d01886944f93a7c05bddd7d5adc455bfaad98a11837ea7e44d82dde302317ff228d249f440f46b6a1a6517164aaeaadf50d80a31fe4a360d403230c20d8bffe2480dae80dccb74f5845757c7550dbaca91dfad64d4226268e26239a4e0fc236e7e56cc4970b4f278ae2eaf5ff6287e2a13884c50e75f802bc24de11ee8be812db735d6569cceffaf91076a6b5b8c0884fa57d03707cf08d900378c4a1230221cf59c1a4007a008897364e7c4d28ffecd857c3cce23a6297eacfef1482f1ebe519d7379d95c600615a6390de80ed4cb93f0c0d2e85d6670ac4f8e7ba559456eef1bf0ecd86f63c4ca35e7beaf93b7a6f5500d32a66d66c12686778d39fc22c62a48e29ebbe5fba3cb6b1b058af9aad926ed1e61b2f085db3d912ad3dcd0744c34f9646f299a4149c337912b3aba0179bfc7ccdee532d9304e1b35dceab0512de5b7af9abdb18e274035ddd50fb915960b1f9ed94ab2d399ae44ba44e733d035ec87d98b054d84fcf667440e34cfaf197d18add6f3a41e2272120c4c1f1937eea23b01dd455c7cfb0259c5c7d6367e2ce57e08717da43d525e9ebc4ed58671888f0d569de9998363d9155f5cc8cf37bea33bee98d2c25748c6764b2d70b8e63dadddd1c451e3bdbdb2ccb107910593f73b4b775ad35a22ceb92b218121c57db7ab174e9410765655d7e44fc8adc15b1ef29b8f18ce23d7de1d64e922f7b48f0380c4916ff4167fc61566c6476240767018ed720e3dc90fc828a4eab6a229929f3ac24ca8cbee4e6cc83eea67e0f94d6a888dc8b8c7ef10e2f3af6017adb9ddd77b4735c5c45f37295a86557764e8d9a2d5eb50955549172215f49bb92b6963dab29ef6e04cc6417cb252431b54820b481cec7c650cd6fa15abe382d5f0c98cae5314e38b11e6004f6a6fe4574b31a5e1f302fd4885b3a89b1c78bb260ea2fb08d328b39250561240b18794122eaa016b252bea61627a747c4115f2d6c701ece99bc1f802ad208ff3c48ac5b0dfd8ec30311ad9e23ee1be0536c505ae58ce381109ad1fc9f661deedc0995c34dc6340fc8d28f2c762c1f6daf93ececae13560d3695b39eb95cb614fe106a01d4ced02e5b476e725735d1e3647783de9f8cab3ee46dff2d1bed64205249387c3d318e52c700b7440edf80946bae7e1d42ff8b5e4244adaa7e92a4b62fe916fa3568303bd5c3aa3c85f49fa746d93ff89448806f72feb11830f6926a57f6fdf9fd8c3988a6eda3c7b4cad992a5c4df1bbe5b8d62a87166a93177826bee8e3c4ecc24207a1dcbc196ece296470e695f304806d540a86bbabd5cc7d824be136ced25c1c0638c7c7576e35607d105718655549f61712fec56d1b99366ed03369c03f6289b5cf71a98c2093d9fc57adffc74163db3c3f16f2812ea05258875027fdb47a6283e5f90091f9ec77d6edb6f36b6d834d17c66ff0598c0b7f3dd7797d41d28bce114c4147fc96a036b80624fcbc08062d077cc29cbf75e19b2ee671265820775d29364c1067b7e1f2350c314d02f4c9e4b1b04005e5c616ff4ec4d1cf1e8d3779cc64e6ca69ca17a2966fc4218d4f5f627f9a1faf84cd3cb08701b6a4afa3a033443ce0ecfdd894ffb4a307874041a06d603d7ce9bcfdc5d9e95fb71504d7a89b6a657334d5e35d654bf72b8af1de6f1bb9b4888fd456946a09f7fe9d0c167d5c552bf2fba6167bd5c47e35c7dd71a6f230afd8090251cc95ea7e949a8ebc962a5518a18e1315eed9cafafa77956e99507e77207b7662404fcef19dff16bc7949fd397c51c09661c1f69484e97affbc7bf596e7fe60a513973829a36c35db78f99b83becd107e40ee3bfa763e28df3c88220818c6f37efd5544fc7ae65869d2bad42980b3c88d7c90032d26fbc08c8803a92118efe1f284c9ad534ba9e2393b01b3e08d9041cad95852a590b0955e56aa919df0ea0cd23e35c44adda4b70fe8c173a7067b59b4cb09f3cbedaaa02d682c7e324fea834150a9c59c52692a7948b41a170eef44c2dba8da1362632f66e92ad5960a5ec1d8b485719c1dd9b9a8da4529e291825658aa73ce9a00b551835e6a7d8b14d112058713a7ea08f51737f0ac863c666276daa78743ab5954ec27208baf32d4c321266c889f529ad154f70d5a4b2493d4fcd41faa6f66b6f9c8a8da91bdc059a150bdb0c117b3f925eedd580a2fd3b680aabbfa3c7a8f5312a4928ad333a395dc5d5915953b43ff3069e787713bcf97962aa0778d9b7ddd39bce8871563632ebeaa94a2c1017ac8e611f761fb69c18b55363d0794ebcfbe152d698df73d00b0f4d5b79ebcb8a6fea655bf766cb28c199d1f5469272e23ffeec5d16c9ebdf8f7641d591af976685cd516abbe0b22c58f9a0b6354e0ff024695792e47aa4932e4400839057649f0d39ecdd92c23c5c6e8662f412f2894a4069ac7065d800b8798da1b5832b65b3744dbf1c81539c7832b245c9ddd6b69477b91cdb3ae45a23f20d22f7b6eb18296a8704056e0042f995b79a0141bd029071b724e54caec93c00d935da73f870efb6d7b0869d354949ea7fc2162fcdaf578a07c4d2c8a7726abc34508cbd6d4012fccd89b8c226a7e6a1e03b1ff2d12247378def511ad6682caf29fe61bf015888f2a7f9af8c3c3eea372a5da590bc00caf3fbfa7321dabaf8562d5cd8d839c1a78b64fb66a7e5138a922ddbc45f64862b735a39fade7be8cf97190ce59acc1043767dadd392776fc5f0c2a09b9d7b26090883ce7cbe62837410c31b681439dfb04da71e2b1320c0d6a765b1e4b69b561cccc113e83ed17a88a49daf302d25420cd6f78123239393715121432a475d093d88fa453b635194ce9cdb1b53f24183a413609bbab7182134784ca2e02fb65601ac9d6e5052738f77bb3d9db87f2e83893cdbd5b1dd386383a4e9bc014fbf7f1f2828bbb4e9c5592e29a3c70d3b8090b0cd381a895c0a51c75dd14221a0af56c77b24b1a61fb4a26c3d409d210a040a077a82617e05791f8e58152ed93240f43b0394cc42b9db90984a84a74639e0ead20dcfcc00e3cceab8d502a25aab2838576599df4cbd8895a7e9ef2bf1862b666418965e78fc79617a8477324a7f1d3925ab2a3f6ebe1fc421e5e0b6c8790649941509be72a5faffc485e6b7e07df2e76b49a8867834f2d5510de11135bcd00b8f63d643b1e9f8ff9a1b47c9ee46eb21a6696f6c0ca29cfaaf28fedc636f89a212e4dbc5a37b99f1ae982b5e35a258fc076265266b6ca41cec0d84329c853b592bd205a7d48586e0eb2f81b1402073950acee95d38cde55019b955967f53fac229c3db79ba754009495df2a11cb9bcaa69d410457fcd842766e2a45a0e54ede958bcf33e9929eebf83399e6e131c548321985ef915fe1b3f6acd1b16266adaec2ececdcce5e47483c5ec38c37cfd8a182915c540093af99b07ba7c5b138773f9a918ba54134e49d2299c6073d72001b6fb93f292d246c682e972501e221a178b476bb2329cf009fc5e00074a87449668916509c46b0bacef3f46b6c4e76d6c53fad90a709fd242e465118fcfe1038e8e6ec6043b7ea18ab00b19b383380919e11a7b1863651715d14ffc20245229f2fb53021a3ec2735befc747573ae6f057efddf0249fefe6bd0722de9db0a2c2eec669174209ff8bf5781dfb771e406e85eead2bc5bbaae005f85bd5e2c5afc1f48ccaf844fbf2c1eaaf711c8181a70a14bc59f4802c1e595ff3c81a1947c8f3e87935b9bbf4d96246a585cc26e2a1353d86a088632b4433cd14c5d2e48cdea0a00805d82f996d7e2bcbb6cb9c09315b9ce3de5917b95dfec7e897b12d29b4110b639952a2fa714142a7ddbdf36b08ba5f642052dafa3987faeb78d50ce7ec0ebcadd435ae7ecceb20336052901b7df47ee06ab8e03840626c7b4b6b59bd8e47053580ba1b93055a717727671233a7f6fb003b65e755865eb6cd146dd0679354672ec776ebec607397b333b39631b9cc4579cb45b4223ca206a5ba9ac2b2908be9853c2517cf92bd815424ef320f773022cb8a69b25006444522ddc0406c9cb4f28c3c1393156fb601d377b489b94c5b90bf179b7df19e20b4b01e79de85382cdfd35067f5c40a1740d114868cbe6811ca7d4d6358a26fea2b10c156a40fd885a73e5518f2f2a8b198b689be93213f8a65d873c58c820d773596c82798639dbae116ef600cc96788114e8b37d41db7469fef4525ed5047df2195d230dd3958f68eceda9374bf251c6863e48aa17007c8fa776b72a3911e31dde32f0984a7ef1602cacb6f41687effba87ddae2a5c5bde435754a260c79542bad57cf4a5398172c020f96a96270a50e11f7d93be3b04c0f035794f28b5d18c66d8d8a27971af9f0c75c8118a6a6412a48c286eb33644d3bc1939828b2e4e847010fd1c248c85ed583bd764ef6ef1e5689e8762926b635c00886eba862e9c48097eaa9c333ec23586917390c877453932d62f85c3befc114cdb6f8f212bb4118db4246fdf6bd7da161629b001926b6ba5f4554cae5a351fd2d17315228d227c5b7efc7a5ba88e1319bacd4b5b20c04ee30489a97bdd5ba9869b9b0c7f619103e3b02c3c065681459bd0c6d522fa5efe562f59351e302f3b2743aa90f85bac3b35dfffd767725e600f33d8dbaaaaea6e4f098bb1df2f3aa73be184f4b4c2231b178372502de57c6169ecf6035dd9f21b01d4c8e77830b99ade733af82202a5f29bc39f00c322e8b4d87f6a25ed44233e01412d0cc490f2810ba0a468733615b314205396b85abaf9830b38aa1ddeba4ac7b426f00f6ed342761012fc904a98931f06c551dd7c8993bf3186da952310980e43600b7a36f6405a59ea8dc1cf65409d0e6f16ef61c0ce5337091e4297bd0b626f607c2f5b9c8f367c1d50d928b6c7a3fd597d6b9c53530a8fb7c27fd86b817ca63a3f7a38058c1df024b7e375cdcaf16c462050b91a4f557408e7d9afb95b4d163e1e16444e2b76129b71ba54f8c8f4ca2764ec1fce7e2b076e0482928375b77b726dbd0fee838fafef94b073afd7613c97f2808e37ec6c3d7d93d80d696a5110c834c195e8f700110e41654be0dc22d8c2312d4c28d059c3f71eb5e9960ed6e4a0883a5548b8f56988d89190f74ebfd9c455c7dc1af44ed4b2d5caa1297f5b258532b107f39540a3d4bc98f35b56054b5b26d7cdc2b8ed7e04c91d92fbd20a34db845ec7df06f5a0c882cb68e29341f98435c0c89411254d27e5994eec1fb59cc1588b369f8554312b3adda5f659157d39d72d59eb83b45249e8807b31cc13cb2c9de1ae57e1e4b9f6f2028c0296087446df512c26e83e6bff652ee69bce4c1fa9553ef7d076ae367f3676b761130c16656ff8baa1e1127a07838dc9aa981e3f23192b227e9e5beb911304579a3ddb303aa780b6ee899e15da24ce32870d2017f8af4ff3960e38c487574e8328ce199fa91c9575370f47a66e46985ec8c8a167aa37da8f3a8dcc5763de43888ace794d18c76044f4f6599eba7ed2d13a6a8d89a3ee8f9d3f482329ef15ab6730d7800e4c401f45d371d3b59c9b1f4b030ddf96da3eda2407c0e2a5d67644505af52020e103ba67b7f217e7527fa1939638daf24bbb41a87fa1f5d95fa7e094e5a3256ed73d4a073ada3e5b6f1aa6fbd0455aae9c579b216251c047cf9c38e66995ef34952c19c411e48cc190f1fb9c32a00cf1ebe5546365397ce26ce7e91d5a2b73b14be66dd61e92d723fb42068fb857300f68dd54459bfc0a8f8f26112d68dbdfe54ad88e668d96941d1b47d3db089d5df6bd48f8574474b7c747f51f6f487861a4046f3acd3d6f495ce4d47c7a6c95c306d6cb45a74c1553bb7ee9a7cbd8a8331fadb50eec37c0dac89ed79c98a089f50b458b06adaed4abe44082723e1610d8dd8b7e455de12e88d459c7f7473363826cafd78edbd8dc45d45434025a58798f24d68a9c581085df4317702b802077b0a3d065a899050ca385629c4001e8bfd5348d87e5904a4d2cfa1b32d63dd31ef93620601cd733cf02284d5f0b2ea67e3e8b85dcff50159c6845f3acf2f7de55c68bca11c944bcdf1ceefd5323e5ec6e333d01bee1b1f53bad3b22da0684633bc9b720476898967660deebe0df511738579d2453ccacc21c7a7dc04f024a3d8d7163413447c1a91d22eb3d4c94b89a6452d1f945dfb88d999434bd7c71c3927e5b9ec11398d50aab2543986b30bd4f5a696ed67c266198a0901416248bcf95335c318e381c2933be5ffca6175c12182ea7fcde29bf2aa9f8113b27a3fb4aa42e2de3ba2851d9293af47dc4895c8f133e4e1274c7342eb89a4eaae439de39bb6c2c167abd06ee80a1250810924e0a599c2a52435ec2f458261f218f080980aec6e4725cb2c666ca8b9986299b9bdf16913512e54a32f08f3fb055d740d3308235804dba4801686af0a802f175192dc8efc1bcb6e72728c8c15dbcfce8fea571815c4faadbd691f558da75a2eea206df1dfa46a3d48990c2ab87837a714135956072af3a2fb4d1fa16354672c15363dde2ff671a9d250150020cb36e379d456cb417cef70ab9f8dac63bff8aae7625916121db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
