<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9155a734dbcb1daa1610b6b5f0a1bcec3615e5ae3e24db5900c2597b2fcb0aa20882b2f983464bc99356c65cc0ec537b5623a4810d6bbf50fc8a72b58b8ba84b4bcf4666e17dce99e941ea4a25a3ffd1fcef1913de7f811f11fe81975ae5d4434ce0dd830b8f42cadea9c253526e3cdae9fb253391da62470253fe31cc7be0ebe0a4ff4c9fa59dbf9e151a20997eb237507d2f87f403a0c2654edc714859b20becfaa9e2b66f5e31bed7dc1a1ff49b367a31b7b49c29325b9fdc3139fc4877f2f29b94be617414b7f29af9dc262160387ae0e46cf25feffca4fc104a63b1a8011515e17d2909d92e3cfe3263ee09278814fa1286ef7873d01d1cc9842341173b943d9397ad59f37e314dc6a618778870cb9a9c3d0c4ab48de3ebdcfc6d21a1a39533d40b7faf0c6aa6335a93b9512a047fefe8ed0cae5bf4b960139c2f27f6bc66f440f2f45f1cc1ff11a1c47b6e42e179aafedd22d698da48f874bf563415c10e68c5a0ee3e18057bc88661cae909333cb9e2612fa97aeafb313c487345b71f6b07fd8606c8d45bc4e6ac3863c64d3385b9798d86b233cf31193a3f79ba9edd806fc5b82299ad0b77c17cc28f383888288c1d96083d39cb867ae35987eef887c21f679558c41b88bf886ed2271ded67ac19b530f3a673362f4cca025b78724e28ebb03cd5c8ce25f22507c14d512672c45320e73653f98bd1cd0fb6ed64653846cad281b22f275be4b43b767d542b3674cc599daa1e3b30c3de31adb572b6a2c9953978114de65d8f00c46366a912adb3f6f83ffc04c18e9f99c8ff5b51e3212a62b348e566af5ebf9c94c30e47fcfdd85edf1e7d1cc9e0910f4051469e7de180db7160f8c7e9ad4dbc10b152e4dc52d1066cc139d11ddbf364c043271424f16f63059825ac7606c0207368469674f83807c01691e31b9357df2f6e95f1cb742583f559f3694ac1510817876777896bb6fab213d2de06fd9dc44b9b5a5bfad39ea598627226e39d87c43beb7262a2b2e4c63e00f6b216ca7ce18213911ba20c34e2cfe3a9964fad274b65b38bc0d0e9b9729acd06bfcccde59fcb71aff8144bfd22a61d3ca1ee653539b798623b2e590ce7124e9727db1d3bcd2fd2b40cf477a9718c18112725ee8312a5e04558aa0d0b6abda15b7172006f4cac80247caeefb1a00fc9342b0f4e049f46e51641b97c4ed31e699e03f5e6b4341be3435e8ec15bbdb94a02b5e5fb9dc3e6474981332bef53b0461bb815a8adce7ad3ea812194f4510fce043f01da793859fbb002410b5f30d0159c2c64ada38f51fe5ddaa5cd9862626ce1898356851cee53020ce39b3449b80cb0860720136d9109bbb0ea50a2eca352bdc2d58eb4c452d506e4d9242cdafb8e27db80c83555c841a288e721f4d760d5c1d6e1696756df9b77d21d2f945fe5111d9c9150fb4fee6243975f1dcd83adea62b941381d8056d797a00b938df2816405c598134996e95de674da653f35bbe288e9797ba7a77e12becc3020458f4c2b529f15a2e2030910f392741a9bd6759b995cb611fac31f1db350d4fe51bb5896c5a10586525ff0a2700d8de6577531f6bbe23a325ddaba40927271d108a8dd1d83cf3567b2c501a2ed9113b1981fee4b930d97289b621cbae355e1263b7933fec93315342d8162d6615322010d48063ca4e48cb5e8a03775f6493c0d5ea239818a6d690bd88889f5884783270a711cffa3b32ced9c782fb092e605226b0ac09d32a581e47685c73ad7854580d53a0cc8fdf5a6468c2556e8f3f7b878ed3502965d79046eb8d61fed6d53c418f47cdb201c20048f319ae136d64fb29477436b23e387dba5ee32813255c3e80542df3fad08453569e09decec26244d1cd74864e6e30cf568cbb21e6a6df585ce5d976004f25f14e89b310cc4b4e6cc5ff0751626d592c6bf0f9a9ca03ee76287291c65a2996b1d3ebe7a0ebb576da14114f5e6616237b797d600d6bcbcafe963469fe7a4e0b4b07578e63b185878f2767455f5b545761514316afc9703a9b4cd92c6b1d7363c01dbbe748df0db5f9cb52e03a2e960a15b1b3d3f5260ca563111ba9df5d9036a31cffe5823e19520ea0e62dc6ae735ab6038acf2a6135a097e09678bff2cf43ce7ec996b440f2c724433668ea486309d0419ffd054a98901333b5ba0ea17d917406ba61e04f5a4d966c3c910311e42e989988abbd623aff9e3d3aa921c4b1752dc178053beaab2d419101e10cad2b6a48f9996d0a866278cf36007799397197dd7d7df93ae90350c9a6e2691c15f06f9e60e19a88aeb9bad48e62d76fec7e4034605a5c9d7482e0161e4866462aaac30d313ee190395af78485efd8120d3fb3885e99bcfc14a84567b5a514e4a5c65231a66cb480ae60a761fdaaa747b15d14986eb661114035c32625dccfbbc48255a94739c0402641e904005b946de3cb9d0bc4c7ae11b385ee68b9174248ac73c9409cb7d980c549a2e92b9b51037f39ed5fbcc277a73336cddb6302851f440ec390ab2315dad9e20aa2e77c9930f71a19501111d0c690ef760660edc5d8addca56b7ceb66826e55db1e2a22006bf1ef2adaee3008e09347fe9c24df58778ff8b48a3459de2cd47f7acca654af423c8c2a5f8f891b3cffde9f20c3e19deef2e996e61fe17bf0e563621064f69f0312dfb642f119ea5a09a819939bcb1f1068752d7a62ea21a87b76c7d141abda18fa43fc4a26f5e27ae1b907ca9a0254f1a2005ab52a9303355a8cc39e1e1c50466bffdcdb155dd14a4f21b50cbe7cb424ced7bd2aca399a5045f7888d4cdd51239cf4f1441b56e2982d567d3d7508a8066be4f152c91becb73e9edd983c24de9bae85b1f99ca166023472eed06fed50e0826256455c268bd072565683c49ad7121981a3b4354dee495e9267099b7c6c162b964f68ee9dcd42691820c6198bf7c739bea671dbfa89ab46dbe0cb9a445f7e6134bf86ef7d5112c6dd729308362c943f514a0af8c4fc9d7f2088f480503b7dfa001334b8d75293ee7d6bdef53d41759ca452b54c3320a04cd2ffe528e1ca617fb9f5f9a413288e681c78450636930068b602e09c95a315e6a2709ca8982fd4d931d4112443406be29ba6d431b1600e18a990930bf71a2d4e35f5b5431e4c1dfa629dcb1d8e6595b8e0ff4731a2d845c514d69d7335d43bed9d7ff5c3acdbdc8f5ad278378fc1db3cb0c559a19deeebe30300c6d9acfb850c178cd1e42ee4c7bf14ff023642c557a8463e4a66f67756fbb77f47bc327d2efe107c42fc840752da79b755be21cf2ee9e03fb63414d12572071eee72bf13a7bcb7b44ff8f23f881c100a93f4414ceb2a888671dc47c56bccec7eb7e5c522bebda244f34772b7acb5ee458174742e163d19b9645770211bf31a78043808092ea19059974ffb9a4dfedcc63ca503b238da352acdd3705f6e35b2b09722a9e510abb8490182d90cefc521f2565df228ad4efa9d459f5b6863612424dfaf47c89d0c34dcb7f7b9ca35d8783cfe7546deb711af9fbe297c203dbe97cdcccbecee80b516593c557b4d0a055f63ccefd33163359c1e2a9f8667c3ce182304a79623cfe87fff382baa9650a57e168f115f8bc1224501b2e3658651f256b79c4999b04450ad880537524833280a2908267da5f37f6ba18e16440a391408c180b9b0a51f86843c771a08225856741b926a1a3e4d165d08d5300be12649a84cec1d8a2af7f5f458bd6b7aeb32aa4138820eb6feb8a90ab17ad591775e1d8976b34b0d806ea7a33f59c6285d900143ba0c7e618ccc2e42a048f2e900731abb6c58694daabf7b87dddfc9f613c153e6753ae83f799212a75b06ec7d7fd4db7f0a95993e2ebcf58c3f5464e2f7402ea4f9962b2f5875ae542fa9232bcaa7b2471ae3cebbf95c90570a00db49055576c74bccbe401b18dc8e6e79b7a7dcbb792bb5bcb5a06d240ee93d0970ed8efada09d226c1ec45a16bc3c66933cfe0763c60f355c1932fb1b31da74c98b833be1c96d11dccf5aa7f43a5eaf76b59965721a8f2805d15d90ade73e3a36923de321402ae51c463317b5fbb5ffb79da9514e48dfa4eae1a5f516df8b9b4a764b67c35436d90e7dbe1f4b07fc68587be217d1c3a7d9b524c2557f9900e5e9de30bd1acef352939e9803ef1bb046f530fa0dead07d0520f6b71ecf846c4b1e819b6435a6d448a056abfa26bae89e8a7711d214cd90bd3871ef91d93fa1c8b9480765321bbcd2265401f5371faa8728a5d150a83c1a1ccbe074c09122b7daab87efbb9566f618ad0adda3e16881a27ccba3094ed94a290e18d177f010390df2744e80646583ff40b0ece4287087521073952164d52b346d2f45b096716e3d6f9ae49073b64955865990ef65411ff9475846c7420bd3113da3f8c5992f31f7f54573e9d02abb9a69a21755056f1ec833f0c4da970288ff1373c21186a82b50089206037bde899ff97d350fad45ca224398368487207597ad1dd82dc67bd25c08635fde5bd7fd09be1737332c58184d10d711b00b88f849b818763f57ee4aff07947a629cec350fc87a1960a2bb351113fb7f07a8b775f36cb7d0304ba25e110d9dff7d80c17cee6bf522a1759f3331a3e88f0b5d6ebab7fbe6a2fd79ee31a9e9770df3cb6237cfcf92fb8fb6480e0a81e4fa615e5c8013715cc8de4f827741a332ffeb66b9c341c54227070bbfc7a1b679481d03bbaba22b7ae391704017450d52236142e87c63613f525f89c4a6bf216363eeeea265b0c8eace262ba6b5fe143da4ee9710900ac5e88e66a9ad78dbcc98d372b096512101256614d2160087b3eb92646dc9bf7aa66d2d726772abe3aa220d4e913ba632afdb7e2a581ac46bf71fd09a4f7ee08bb4fe867a94b5f9c1f60796a1700265dc56594df8c32cda016e2a83eb2c1e64e302d2167fda068139ad6c82adc7e8f33798aa9d6dce01d603235c85b9e1891fcbfb976b8a5d73f02c5348548cfe13e57f902b729817b0378a17206e7c8ebf9e5ebb3b42dd730b4611c1fea301059de7c7e4e17adab95e4d36567817349ff3d6e05f97707ae1a3a955556543b906ff8a814d37f84e3f5a5a02c973bbacbef86e2668ef2dd8ad678d78fd5df634f36a49104864d6071b3da019e94d776e9981cd7d9b522f1aad854910acfbd1240560b7390e22af6bee4362a94ff1817d404c8911c547b6783be5b8d252add68fc3ef5d1595f1239dcf5d4b8b5eee475085c401e21d9b027cf5484e6927bc28ed834f458cbc7ee9ae8035eec4147cd703391b8d2c0fc1cdc1a52ff3590e24faa94ffc2c78cfce479591076d9b25e89a00c385abd1e12da2a3cecf2476d339cc6d4e2a8ed4fb03276ff2c6d2f7fd119c224fc1f186eab47bdd9ee6dbe78a8d701175bec2e8903c62b53ae49ac367c37462058f85e6e3183270749ee320a0926780c5b52e4fb0138d12b2d7f48e5249684fb3f1cffe1910000f424abc3f7062f59033d011671609d41f014047b9b1084d1d7554a972c320bd5a94908d97c0082fa6785646249b2d42938a46f92aa39555e701a747aa07cab831705f2a0835b4aaaf34e6e2ef765e40d2137ebba31b6924181991dddb1ffa7dc92c5bb0654240bf7b8b3b8de74916c422e447c9472ecc76d33923b05e746d898b2c369b0aed793c00e00898452c366a17f69006f2dbca43bacdd3ed48f7aac6b7995e7de905c1d40e5b92fb97afa63b38fa4bd7c6a3f476cc2117fb1b602b5b85b5d0b51dbd365e35e12045ea1b605d88528bc2eb3994f8852de100342a17999503041e703b8aba02ada581c45e77063a1f1d5c6cdf3ac5f22ceba8a2da1a3d40a83611f386c3d8512c14ed5f6e0f4164b7979f712634b479c66dca06764f923a11f7ebb1595defc73fd562e72e7af41aecbccf198d3780d11d7271585174601d0a1f79d811efb08bfd451a6fe49d42de8f22894816580ac9f20036e1dce6399e6569fc564a9129d112a0b432cbd618118a361577d19574056d79d08c69ccee5774f827ab4653be6ab86278068dbf1d259848858167559a3af56da542359d74c529cd700e83b7bebf228e2c7d6cbd1a1587233c62455869949b3387068ae364fd8ea0c4ae1d6d1e101f02e62f52b163214157b90eb23b00ac2f9da33c16f4144491b3a1b7fbb650a2dfbecb8aafbb5c8c29923c412c7a4e22704a60b3cde3f20801df03bb9bc53ec89b83ca7a0d37311f88c218f10ea57261fbc75d2eb442124984201c9e49d756cf3adb9a086a32d767d32f44a86bfa11e413dd34f0d2bbabea3566012bd996479b228c7a0535f25eea9cf037dcc5ef5fbd6e89dbcf7dfee6cc1fc0fc5530f6e0a05298c66143f81fe6e919c737f1fa02d3d47df7faa9e0450f167aa12970ca237cde1076a2ba3d397ca42c9f3c80936c34f8e6b3ea046bb72ca5f68169c924a7fa14f8bafe8e16a1a1315654ac2180a98bf54cf1e0da0e4ed29a66eb5e7a912b49dd476c1d1b38a26307a001d204ef338f1dca73ee2d4e289c62960a29dfdbd1bf6ae0ad75569087b828fa0a6a1c1389b57993c755efec9a90167c8b0edfa6931d6cec9d76b03a2ed3b9c2170d0dc36d44f4a8812d8e9e7f843a79adfdd7226f790f6c93249e2cfa42f02a72cfba72e528f04a424dd62f4597f0a237071b13750c52c8068edbf46138ef3f78615bb138a4528ad6c30d865bcd972aa35201100fc3b63d4d2c296a4ac32cc4b9c8c1b99b44eebdf8f41a388394e926cde50a62408221401f525212d21088f7cbc3b5c87b3f9f0f3b9356ffc18a743b3a368f21f832be4475bcf974a5014813a9df8d3fa67b47a86122a2079af0fe9c315c69b87222dc93c6eaf8e40f5c3172f7956c9051b83f6e832a76fc114325ae7d0a1a77a7c7276b8172077425d41ef694dd7d236b9ae4159cf32f587fff7c1f3fc0848c30ccb8980eef731ff4eb1c6ed4aa482c75ace33274c0fc728b715a32eb5b4ecd13acfdac0588e7aded52ce943fdd90725a3816b1f1808b3ce24d68a43aaf0691877a52cd7355dcd28c99b26fec980fd2c1b2f75f1faac585f0ff80bf3d8a648f8c0aa4554d3817425af2e726c18e0aee6f835013a1a8a694e11e4bcf84f1d34690b671bf3a8e3ad0a513e9c5326d203dc44b049e01486ce7fed688eded74e8cb04ac86cb0069a9fd785f72aa903754a47e328c81a77fe9dee24aa5277473465ed5f3e4495c1454ff877530d031062be92db39ec7d2b21ca756d520c1f114a2b5a95987585dac89a33d8c4d7c6a83235ddf4859fb06279eeae23e1f7c7cf586311b951ef4316675745494429c0a6fdf4d46b9a45cb9c0c9f59e2931ddbf5431687ca7295f766e131c83b679608d8401082db187b23aa4fdd4e1e46ac68a1768d1bec31ae1c80138dd2d96c1cb4209be61d17287a52dd63b4cf2760f6c477a4ac2210f30901af8d8e7a2451ce11e28eb9326c9f0d77328dafabee2ea9402f32955367302e6d30fb7fb5c8c1808c7eb3b474fe7d2ac598a95b7ef3396859a747cb53794b02a8b8297afbec9ab650d597aa42f02d2a8b3e129c5afce8e966482cbde1bf3b00167c3fd53f914aa7383f907446786550a35e6a8baeaf4e1180de07c246a1cde8ca297ddd685dbb2d6eea12d0eee634fd9c574355ed03d72d34029a1f8c773c9e7741e5ec64b5e6b21b64b33192ab534e06136d3c2fdb8af0c0e3e124a7f14f7b00fa2a6d103dac4528095ef033373251d820fda70773cb692fb5c82f514a48f814c6afb462940be734b2d003c8b24707f40f01dd976315cd3f839ace888c00f4aa9f2cb04947928f6d275948ba622ba3ad6122cc054b394b5faa2aa97aafde42ea5c7a381bb14d06109e6d9ec3349097fb67376553292b802c3fd7e331ab698af5c01983067d4782f8855003c84abb50a80e6c4a9c2568aaf44a84d6c8c5815af34ec5065371488bb6048acb5c032dfa01a0ba90dc2f846f9066213eac528586614bc6b2aa5fe9bb616a5dd8c6d89766370bb7e00267c807c35598e6f7e03ee141643d82acdff7a940b157bfe4e922b7795d32c717751ae68c82d2c1185605ad47e67b663bd05100a0123436c7619f62e13e53699f4be5cd36cc11dcb81dd5edb310fed25ddc5cf52ab961d4a4184f94da228ab4e073262c90dd16d10971004a87599165dc4801323c25304145b87dddb8eb3f5ab9bacf874632aa5eed0da91b8eec1cdb4f806de152775ba3add5c211be90700767eed6939dbbb59daac9b8b008d7a4d220a79f33d727d63a09dd19815841dfa9d59f5609fdb21571b5271a22eb680a1c6f123f14e2c064c38fead6fd08aa2c52d40124fcbf47506f2a28558ed28893d68f0af420f52b074a6ceabf47a9b766e58d5b7c55dee642d4026259b61b2688bd3674d710ff27e429e46a6b97146b12b2a7cbf5c9b210520a06b34b580bc88edd5fa29e5fc13baae4a01b89215561a37f619ee1e882e267a6544808cebcca530a89d16d5babf42321d4250d24a173a6c2aa1e0c6e657e92c611676ed2e8d64a99d70798fa08b68a68e005e98bcc726e6897445f24521e5daf0e7eaccfd3f7ef3cd6d3b5946b774caed2dbb71285542b1632e1f42b280d08e83bbf451a728f86952e7453541b19628de3afec9af132fe0c3fedaf942536f28e40c70133728bfdb6fb5c7f0e74b2ddf853d30e41ac17681f1d02f439408dc18332b34ae6b81fbe6744bce829bd9fa13a4f86c080bf215d60a890a0b56155cce697f848b6a5c552b4d5c4b2d721b093ed05941375d2b051b47b3a5e5cac9bfa156a79824ae93c072c8ec00fb00e050cdfedffc68247581fa9c8256c7c079ac0d3fb331bb128132f28fe89e50861da3a6be7ccc278379af0ec4374c3c8237f1c9f08192dcee0260ac64a8810d2ca12337ffcd01712cf93b8540eb6882ce87643a9bef0122026b72f8c4f8c4f89c086e1a2d36d314fd97f5d703d1ebf3d60f25f0e65b9d5b19cab4a7c588e76a3df6c0089921da698e38154962d85b428f7bfc8d240072a6f967fcd632ca189cd12ee35b22eff0777b7f15b4fad189941018be2a9672b397fed7fba7e1e3025d49b60e57903c8292f1c44043745a38c1d92934564bb35461ff1d5d05256649874a36283f4cad464a40214ff46c86b828de9aa39143ffe4337ba531fda90852e883d6755e382d67e5f8d8ecfd865ebfa2f3ff472d62ae97453c16c35552dce60899db22e56322f9a6374739eaf18e90c94769d25c4099c00f27cde642974e5af07d0d301ae9bf71fe3b38b3336fb83fcdb26e98f7a3488b0159217a35b2274f1ab3eb95a420680bdc9e3bf202696ff15357fc9e182978b7232cd844c730e70ae6562a9c427da9451c0b54a4a4442e46fcd7af47e55e7ba78907ee8685aab3e4384f4e41ee4781e0d281e5810794e78b7c06f0fb159581ad4cf1f9934260f2292de7fc59c471f0b55ef7ad2499af81ba34101382ca42e1c2664da12e664e62c8c6f9cc710dbb4ddba1a4858af2cc8641c4faa07578616c2bbfb320bac8c950c24ae4bcc1ebd19aedfc0b191e24e1cce2e3f6fdf0b22e07a2bbdb3c3eb8979b2c55a6acf199156c8f9198fd811a86f8f9d84760589ceef356a4660957d26acc8c71f40111cf6b8c6492045691d7ac9c29e394a3c2b817e7dbf74b6c2d189138a36ac259b1d56d7c947610e9c7b985f607e11a7c08cf76fcf7bcfaf18eab34d77029398c1e97b704b31b881162dc3a876709b78c28b6e1e93983a107dcd98ad2153858f809af3f34a8b30a98ef660533257da7673dae0b60b16ae2862037d9e8c1930d847ef7aee6e3fc242e42e3dae9aba9c5fb46e43ca9f448e99e590f19ec77a410db3909151a838b3457a817b7e4c6671ffc20660e4667397d85b584eb6ff1d2cb1886338309cf96ddba9c4b233ba7ff7551a4538b9ecda5ca89abe13e92d37ae2b1622c81af49607e1588922f69bf6693b9934df42c0f2c50097fcb0e4b8137eb0755b3daa3ad27d34bea47a1544fad21214ead70bfb3c0a07811e1b084efa0aa69a51017dec3f66587cc6f59c59115ca27c8d52418556649d5f41edef2f811795d3299c7d8e16d911bd0f64e36b2ad7720a0edbccc0a509853e461dfc783fea8235b64a666b63653615d48f3ba96c6add5ba93aab73745dba8a5a14f42b974964a71fa35fde95bf880a9591e6461bdc6701536e1eea1f66924d0b49c2923775e497eaeb71b59199f6c47ab633e6aa3f33e0a8c5a2735f5dd3493ab145ad514f63672d12830c155f87504fdde0b9c1bad679cda9fbe809f97285b7fbd60c4b829af71e86c7f38ad8ba38ce17d58efa6ec8f49434b02b2e888c31c3f97d70f075c3055fdd800d82caa8eadcfcf181e1450e2cbc6d9ae4a4f333b3c9e8d5316ed0841bef365a8af913eddf1532824952a153b53d96549ceadb1b45a364f1e88bdbd10c90511e0447c0a102bcab670f7d63f2019cba3c440952bb7877b559c95949e3fd6c21a9a6e6d229d0421fa214a023074b63dea68c50e50f03b9f95506dfa69665cd50ee22f510487f8d7629203a9f15800588240f23071e474e2e8a2c5b9f97c9b3ce64a935a4b087f3005c3f8d1da60b99cc10272ff8ae4ea8d6d3250f2696c4a12ccba6349eac12f3dd68b65f06220dda46591d8568237cd968052ec054a5fd818b4c5ea76ee545c424fe99aa9f5773b903d7437c90ca1aae2a175fe181ad70013383002278a8790b949ea2ccf2fab95f4993da32d8890fd635a704d127f672ddb75623defb2edbb76d408f621ee748030a252db19468cd9a84226d49ef8a2f2bbd6a08bede3abb2345b73cf349218b276da6f0e18e3acc23d26f0535d7bc36e593e1852e88f0e2c4a6588767a0c5743163dd5cbcfb6ae3edf839bdaa8854d1a1a9d77a279efa678aeede7664c56afe123d42909a55445e5524588584b648e7781ebc2c9359d2a06b8eef7d6a97c8b971d5a0ef571b3ed1772e60b7110608160ae60edd9cfe528a67d78705d6fdccb355c4eba09fc5fbc703da0a498526f22b3ac81c138e3f26ae5f7bf3793da43f16704b82a504309d482ed5b27c088c0d603b1e3068c0f043542e328bbd9a7329396bfc8348f7c57b5fa536f1dcd8d78bf7ddb67c75fbd229fbee0a4acafe5fd2493661906b87600e405dbc1d5b97cadc3cc2f56439eb8365f0de81427bb568de95a6147762c415258200d6ba2e9cf3ebabe707db34d4906f51c862959815fc444fc3e24eb139d73ca32065c14392af4b4cd67d3b619150d0c1f70f9691fa4da3d8e5fee5119e5669bf17784da572bccebbc45a4911a484466321e1d42f1e6014fb936abea4deedc70e1bdaddfc61d21a821f9b954c309051480a3998a4f7a8079f64c4f2f34c47fb20cf24ac567312cffd650cce60e09f915ad334854da51626a986b72f58a5ed2f46789cf60bd2550a7c9c1850fa975b01e9f1fa1a960429c317a5608aed83bbed1f0e5ce057d83d02ee09ed3c97d4e83bd6395d8b5bce778fe3e4d65fb0ebdc4077f737e8bb024705c6c0ad0dc23877dcddf7ea7feafc482332b23ca2b35d4d2d9fbdfd091e63a1fba1754bb2afa6f76c00d9b5aa7b7c95e41629c60062a9264cba107d0b74191c0b021b45fa195f11ec9dc4b365bfebb40a90698023e2255d143ddc4f67ce9e7a706d1d8855ee4cb2cd0b48b427bcab437e9314a055913b131857fe5906b81bc2167210c4438111f9f2cc094ff9e57b13b2b3e4178d3a3e03aa91d4ebd059e290d5ffa59c5165eb7cfd444efca7c13305ae39dafc612824f3dca7103a63b2d544a40fa496a72bc7cdf87a01bad41f1bd0d5d6855c8646ace9e43866db26a2d9435b038305f27fe22cf715bd1271cac83c6b4e66c3c90110d438cd90d6f7c3407d955af9a22fce9ea864392e4404550299e9ab39bef8dd0a929966d5a87d558ae884227624be64698d44e50c50b4f0febc4eca991a37332e213d0d283cf7ca7f398bc3cf327c251c3b9910719ba81ec4c8f7fdaa977b3a2ec790c2950fd7826fc5bd61e60e8a93e649e070122bce89fadddd3b3553264d65796bc57a99844e7871679042bb2a2025909c2b68ffe38348c277856490cbf33d23765cc936b3c48d333b16e186de898f91834e902fc8cf437aee18d0e4ab6ca285fe8dabaac7a1b0084bb8e62601454ce434f181feeefd558a1799e6b04a6a4480a495e4749c030372d6164dea9320713c5c86f9d6527579d9025ca9992345c8d7e37820756f491db35cc16fb6a935ed2f97ac6ae5f3d2a973332c754a0922f23f6b7112fc365f4b0550329910896c5a88505db1cb0f40389ccc8f43bc3f3ef208aacc48d39284f4bfdcd00bffb200eb9b633251b9c75166ba439758b9856c0744edd377b9f58c9c92889f692b5b84b4ffdf01eb0310b656d6be445f18974dab6710ef04a479d4cb5835df0710d1fd5705d676d8a82dba0c3b9304b29d97a3766adf9986f470d288fc1b883e90b32e765e85a0d90b2a5f0c21190b276dc6f26c07760b156f68ec190e012ede6859533d0bc6df045759c1a24566e2b4a5041dcced11565ddb0ba7ea5068e8a318ce883f5ef1424f14704303b302c77122378fe32c91b6ae834bed02893ca2dc9f6047c9545a2e00235b3eadc901a055bdff4473ebedd86df4ea41976f566439e9ff0d59c7ac155da08bd75edc47c6ebd320276b89f6f90301b2c2f0f9c948634649a582cb0f9fb067320e505c4e5df47ed2bc6042f1a411ebaf6c69a21a47c20e3015ca993799afe177132686e77517e9b5c4c07bfe762a1eb4fb3477a776d17e2fbc67f29701300fa1cd2af0855e66d11bc733e84f3a82f6f1a84a6498ce9510ba6ca4dd656738b09ff454ddc9191fc7efe37c4725b06609776d1185ed3870cacfa95a830550bf77bbeb3ff3ccff791dc8a43972cdf3dbbf594f36400b38ba1b6539d07b0861058ecff71c218dbc69d903d9758bfd934083030e98054fc3d0bbbe4dedab29f0fd9cfd0daaa2cdafda5bf09a69ae73b160d97bf2079a51cc408888e4655b64a32dd25d01dd68974be5503174ec9a6fcd3f6a9622922c9e2d59df1aacbfba295e61b9533f068e1eb964a39fab405cca6436fd8333c0c657b8b8cebdfdd73826aeaf25afb6afe549cb89ebbdd5ff334891d47f91397cf24582b957f39a0b65dd448824c05171cb39d2c55cfe79b342d5dfcbe0581130d4d970bb61769f8f9dbed94168dfe96be0c9570a961f1c47f6cc6061a33e1ff718a5d2519a6330f297ff65da336f19fc8b943eb0a468fd3da6a4d2558b9fa52b176b730346b937ed7b39c7d84ea668c6b0457e22c669c4bba03fa0814df3063d12a7ca3e7968bcebbbfb81d83f7d187f03adf0b131c38d34a1ad7a0d04797d639d0487d8f6512067b59cc3b540f7a6bc0d35950c156de4541c98709d82aab447f3d7a9137509c5be15761de974f44bc0136ba16a69d7b2a09ca78e5204bc01ea97d2e5aef3155ec868504c1ebddbe0f3877603d73ad45d42e620a8521dba040fcb78a444d44b5f825be1b15b1afee3e9b2e88fb9b7dbb222dda64ca5cf5b40cd2ed5dcd752171d8d7d030e5f9601f6ee0d97d6833fec97e5ad2457c2ea7ee4250b3b5b8d3cb4d337d48f9000904a5d64cad512abc8ca01689a61c25791cda17575af144c737e1462f6faad883871700d4613e8ef155cb25a5864c7faec8a265ab526707a9c9e1ade5f72a6896ca25e44d7cc1aaf4dad8776c0f96cb996a2c5d231bbf51d7dd5bbb6f557e04f5fbd1fad72f7031e12eddefe4e879063c891ea815f4016cbf1aaf9513692a7f45f45684a833685e0e4f2ad8a5c5fdc6e4821f29613df49077315d2f7d1160421abfec90764cf78dae2595eeac94c6d49b0aeb563e6aaf91899cb71fac46fa89afec4c948caf8c49b0ce87bd3eb3e7394a18262e979fa62d99c3ccd88d94f032782835dc47b6ee54eb6c7dcfd46607f6acd5fe11ecb8884a101537e8a2e34a5e1ef6d758f3c941565a5c772a0d5e1296560bb6ccfd18bfa5dc82d20af3b58f357cf9ac8443be030bb134046d1ec74b20a781c7333cf13eb76e94eaf7bd14db7a9fd9b43999a36606678734fc89d8e0662a0753997160c93dd1e90a1f0aac6e39c15c97484e22594ba70e24fe321f87d9e74050c1217ab131aa055cd29083299b2bda5893ccaa98a1d1744f2b4db680f2750ab6ef20ce8719bf2e8a100ca8eb6b0947346dbc276649807635816e22fcb9979382edb9f94e5701a39c95be40c54b9ee743e096fcd5fa46f9ceecc2e437623fdee1f19e3e3867c9cf6b494f81280351beea221cc7a1fb7d336848c71f359bf24c540c05c3f022a7e42c990a082fb53d933159ad08a54017fb6b0aa09b48db468ab415a662ed5fc1b5eb2d5dac6ef1646dfa7514d3189f0c42a60ad6df68d8172bbd2b97ee41a27bc37ed4f49e4042f27fce1637de813808758a87b38743a968ea323a3967cfcad045cbea3002984d1571d60c033015053b0ef47734ff5360e5208c256c4dd9e84a5f0d9f002b83e2c3bf5934353463253d2dfc6fbee2c0be390a16edfad07b1868c214de83b104521f1fc64dec5875c7bfcc13856dbbb0b9bfbd22b58305f15205bf5ebb2bc03f562a71c130754983a978471c60f7bfe8ad9483c2feaa8b55a4cf11c5ef4b9f405c0a0353df741c864090d8547944da2ea614b91acdfd0b14e526f789ce295162ed68179af96f8c9f8b1b0ada0fb90916d251a757031e7d8e0014e90728cc46f3a83a7ccfe555489520d9893d21dcc80bc0c3f51066ede5afea0fc20004cade1081db3f03242e9bde94712c9eb4e4d282e403dce29d32efefc78ad93af548e4fafccc28b0245bc6226787e63c4a452c6eb976658b889eecf67676fd358cebd6a26da668a0bd3d78e23f95fa33f72474210ba1262290adcbc37bbce0216a81ff6e23f93217b0c9fcaf66e582dc428f1d1b4c3cf99efaf89555d5e9a917874ad4ea15e73fb4bb9b4ba6674c8a499f87d09823354974705cf39ecb2422ca57fc00598a3571e61f7229353704d8df72fda5578cd012ec12134b67f297cf053209f7981f0589217901665e3301eae8ecda0fa0aeb77c36f9cb7e594658024f9e8c6e136063ea922e105c774c0a62e46d166d51c889a099fd20b2b0d46e3c187a0ccf0809ea891169c62c108ad60ea9c1e90d14f5f52ca78c2159e420c0067aa46f4e0a199517eca75edf3a6cf2a2a65ca43beb5f4a80f3663ca282df8eb23b529f577af4d321f6a56a280ee927d5c72205d7b8d7b4d8b92b875bb39864e398b4a359d993351d2d23347ad9051080571a841f36b994bc8ddc22cef8ef68ce28bb4dd3874a0c21ab8cba82f9b73da587930eebf9c2189a708e62590c4a68a130f178acaa7ab61696da634b77023011737470b67263a3ca2226b49ea26c03c478d8eb6f091fd40645bd5a0e3fcb6954d682dc3d62717681e208cd4355d4b370fdcbb6547c7c8b95b052147d60c47ca657096665b3c56933b5f8e36a582af30d495275bb60a7490264ffe7fa2afa2d1bef0caa430a5c042bcd33abf4a889dbfc8116f7878013b025f592d6dad6e811728549bc488db1329174598ee18acf9438d12e8f09f90a332f0ac85804c088b16647e64037f5712af49ae0f05be533e1a1e2932282a8548eca6c10420f838efc5c93e011fc8a6cd5796a3b331871e67b4a3b824db6ed66f16b63c9421a611001e5b5a5954fe26841542006d1a852ccc7bba00310093daa03e2f6a90fa86e0d6b6316489c50b5b44d6fe2b5d53ccb88b265a2bfaac1ae37089142fa9064509507a2e2025b8614637789b4a716453e8ee4a2384c373877fbe3a38ababbe325e804496f02e2a22d64354e2cbb77152c2875bee34e71e2ae9cd5d3f3ee04056ccd785e21c7596a2414d54b30fc2e4d77861a616db4af979323581e61e4e229c5c27a75111603d9078cb9db4f5b58d76e3519c494639c5a5da183eb27f53ff4a88896042f4d1ee9a1eff4c447d6f32547568974d76bfbd47a84cb84e83e04eb914ff3b1ab4f084d353d93c7808f53e2769777e1fdcd09dac463fd02696bd3211a648daa1ab863c9082c939dfb1e01e40d009032c5988d7db1f45169403c1e99977d1dec4d73fae8959f4f0bd819fb88657c5b070aefb157fbd05a8772b4d3134ed54ce5d82e2b6327dbc49ae9eefaa5a16b31414b581efd8e02afb9cee96d569178bddfe0e18ea6ff33e3eacde1aaebd1542cc3f7caf15b66f75807b70d19da07dadcfe7d017caa8a2dc29c60f3e17073e0ad0c3c1bd157676b4a513391e656c83b0114303c9a466b479603a3fc7036c69b967e9181aaf0af564a7a58794a25dcd3fe4cf852a726786a93916fbcb3660fde072ff4c74d7705325fa5658230d9c2eaa81d0710ecb5dd512a3f078d2d0975240e55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
