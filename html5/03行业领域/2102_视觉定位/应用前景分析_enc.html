<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64ea0c363c38684050901b961bbea54dbc50cb63a34bac012e435afa00e5b166411fae8fdf2b6f82b1ab0039b6b670f09ccad4d447ab581b973bec4b2ab2336713d71d69fbba9ea87c418be803ce4abf1456705307c660023449167774fc3495064278ae2f45f59ca939d6f8504c21046a8ea28a6bb87da9dfeda5e597cff67ae1436d1d32524875530ec9b80ce16705b4804540ef697e661800c92575d99e006b995025d6bc9a382effe9a49a9f973ac5f7f53e31abe2d1c09a406c8bb75ef9d4ada14fbb50c0c1ad525235e1c2c1c61cd6a39800524fccaf3bfab34dd9f5ad4b8902bd10b304ffec48f0d89641c952bff0f756c6fb4e4cf3b58e9a858745eab7d3c7a693fa52036d2a0e2ac1bfde57c8e9a046e7fb90402836a6ad445738c23324650a404668c9cceff72036f02c4c5043c48988f041f9e595fd5a2e734daf9cb18c2588ae0c32da4a046f6c6eec05edce128b889110cc7e647a873124abe9b40baf22f617a4b4927496fb4387f5e7f6287788cf0aaa5d4431be9aa3a8da29136c06b72de6eb1425d390af8194c77fad9dc638b61148caf145011eb05cf5b51965db5b37654d8cfdfb0f831363091dd74121cd73d093584469a9861f309985333bd39b1e9057ac585cfa15cbf3bd956000bc94e91bf2130e25fcf278d41d0a818af037c7237dbb2f8d386eff96c7cc9ceac25e54d706c0cc25d098e60a63179cf440a8f598f39197f3e4d3bdbf4defb442168de6b7b6c63ee616e822e082e9cd67577fc0767198c116acfc54593f65d4d68c0fcf96134af0a5eccd2af352f0e3f0adf36ba2d8124a6b8184af974e1249f49d7174351db1872fc4abe3d321c94065c195a4347858fbc6e46b1d40b3785ba6f08c0d692fac2c19531529dd12817e8ea7048e01be1664ca747fb707f045000ab25e0cc2756f19f505ab5e50036a8a114b3543fcd7e4807f706b7dd06e09e621e5dd277a93109a8cd9b9b005df017e03c0f9536dbd36df84724630dd2a29796c1b12fe24e89f689c76deb31c998f60bb708afe123d819736a7caae6bbec4cabdaecd2e509b5b8463955e9086d8adacfaf1050c759a704a7c8fe35ea3113836125fc5a648aad649b117e94467eff6735823f9500b6599f7651d5b4078e0526e7352bbd494a49fb04ed033793943f103e55a01b6e7edbf7eebd74a090526d40c515d9fba826f1d84209c11f6f63b7422be803c18b69394f2a16e64ea7f58aa109d7439bfbc75acf25249c87df92a245e8f4b8cb0ab3bbfe208c85db40d828ac395c1f592016aac91efac54def46ecd8fbb42bb04db6075d76495ffc6bbaa44bea49443c1e35a28b5878c9127a014240ea06c54a24e142fdac6abedb32a15d65d77c7c660250790b4ecede863c21b9f1957fbcad970f0dc129921b4576d635c7e012d6f3978586a11abe919040a1dada7c3d53ff4035baf4b8220883fac9ebc11cc9be905e75727e5f263c87582433337178d426abae59af497b33566d7a075c1ecb67f5a92589d85a898fb342e0c1213281e3d8491900a63f19470abcc8306a446d550495837950140005d14a6b714d27abab7388ed106c331608316d056ab8dfe6711de0f8b3836456ecaef7bc9668f9ef19032a0e63c4c38213ba42e87487b87aa5d5d8057c916d45cd9abecf7c7022d3215104f5c2a712dbae6d422a8a7cda7037df85084efa3d0c361db6c4a7477cfd1c2ffe8594d2e94a10549d1258e3f5522fab7ef1493033d2236b34ad363c61209b99b216a2bd11098635d6660ec0638f38b326857dadabfa11a81a64e264d95e57c060228bb5d8a585e37832d5ff508c3dced90dd03291e98f511a6bf6b6569108f02b93c81d62f56c00a17783082bf3294aa12bc27ff6cdc8a2f66f9abeb55e543a837b8ba82ac62c59eb51c74eb24bcae816452ca1044ce285c315bc136c4100c5789952162c58c7e7d9a1db203985c65dd31579670cce430735a444a9ec8f5a6b736ae09ac41b2d573edfbdcf2177c71e22cf8836e72a80998e8d9bc4a1b74536d7cb48337694a5032b5c3424efa05f23788aea8cd6718abec3cece47aa2f674fa6271d89a78ed70c3005008c562bbd64a3ccd35b06e0984ef23c7618d4167176fa067f5c51e6731f5df6e3fe50e08587fa7c615b613e628ed762d68b5740072c4b0846ea2c97153e20ba3feb38d4ccaf54412ebcd385c3d91f7cf6b45c325b6f722f42f1967dad0d09194983f9da7ae6377ef0151c4935380dd89520c2221c6f767d70de634fbfb20b9fbe0845845a3854596d59a87e2e1fefc798b997e2b279409dc257e6e4cbf809179e0a3581f4e17a78a931438dd91ed0a3c6283b247db201a34c660983b06339f57cd8158cfac35bdd30f5132c60231c2e8a7d239d27ddbc988581648b318e73a90b66a8e3dc4f6f03b22e771d0b13623e1ce952fbad7415e1ee6bacca1bfd15c1854ff9a8522d92a2c1c98dd329e12792a20486b65f2de930c964a31c56f8560e28fcd61ba09ab51d83d0b6e179aaac15cf0023cf4ed565577a2137c05032d41081342aee15b93a3c7ce0dd9e3bbf44616fc9c81e62df7208b34db895408268beb007ff75dd7de0a19f438226fb2ffb729349ed90647b10501e228c474b804852a9c24ec61f537de366c473afa9899d3a47a3fe0dca07502aedc82a069e1cce57056bd6496cde218e89faf98babd5a28582faa790abdc0c4a2b7cf2a480ea65fc5be583e233674bd3543c618532b0543e70beeb53d0ae76b3bd81bd85f5e010cf33abf11d25eade5219e57278c69a87d12c9e69a2207d0bbd2532ac8dcac84ee2b95586d2f6cba309f2aae80795e4a22abe2721a126d080d209126fa930d15fa67492c3b317dfc2828074911b4325de69e23a81ad26a73e1cf96da85db353aa9a048684024b3060765f002998195ac116b98eab86b471edf4a2dd9d406162caa61e1a4b9fb09ad37a857e34a173038c87a6d4eed6332cf68109a7ff91889aa03699ee4f5593fbd49a4d78a8a2458a74153fc09123c914e165cf8161968a2d8547074ff47109dca253f378ced566fd3251a3bb0291907272b6a2a36322bc7ce9de09b401307e85e7f54862e22074d307240e3f2890609c4eb1ef089ea21b1f1b2e83350fe1e38830976cf1f12e62faa1a0061acaa7953a789f5274c491400b19519102a8ebd1051e7b704a6d7f4d37e39e825f2827b7cc775e7477dff3e6cad326a402e0ef079873f57d1690f7e15e90822498c038d8596e0997882d94488bd5692c28c0c69f5fc17a24e66577e0c185c0fddf6ab47b65a439902a2446a5823f7c2354ff4a01056e68dd172aec44910e0c2bd1dc64f6b0335ffce69ca0e7eda469d061b27ca50648ce3635460607ee59881eebdcc334417fa14b754a84498dbb30812680a65ccfdebb041215f593b65e4896c3ee4bcee74b6abc38a6bbbf3bad917d89b1d73b4897d1eef1cb9b48aa5e5325735120144e6495a90f6d161d406d19740d9f558377a745965a5405e1bde298abe580f96c555e79765f00b9e5837561c3b10c92efe33e8ec91c584310366af34051fec2b2db79fe70fe505f42484d4c5fffe850e1ab6db15fcc8572848358c94a1c7ddd1a91ec452b6dbf62caed1fe138585f8445b558f5202b9cdb2ef840cf1ee7b2735e1ecab571bfb654e3ee69dbedac05b91cfeb3826fe92eac18be2b8f6336d124f2bde1be29808042b2ca5f83b1dde4761e9120b58fee4bc4e60426725f26b8901471c415cca80b25fb6f5e23bb20c9e34925ab60473016f5f411e7e0331e81e95eaa6427abc36ecc3cec047b615568c070cb1e7b0187500e195b4e9467c1eb792cc94cd95082d694e7c51b3aca0865e01a595783b70801238b2d9273bbfea0ca69d904fe948f739f7c6529bff42e45c288cb2c7d250ef1e5577307f5ac785033bc6f840699a8f5e4664c4bc6dde3464f54e2ccbcee51fd7b20ceb0a34cbe7b61be5a29280514b86b4eb9afeb771aa57bfc6352a713a1b3b03fc860b87e2c3bd056aed6173c4aa8a01d1b63653470947aa9125c74f59c2bb061f2b9fbfbb3589ed86adc9c3432e22adce5ae795107e623017463292ff617bf4743c3bc047f8c06a302e0b9617bcda2263c367dd8797646523d12a5ec5c1f5cba0907906eab7b4b62a66cbc99788037a24e933822ae38cbb38e6eeed0cd0ea8625a6da754fac203900bdfeb272db24df9cdc4aadcec0b3956e826d062cc94c12eeded31354f600dbaef93c64f2f7fa28586994ddb28c613c8c91c2e22c3a1a8ccd4749777106d70b18a897bc2334fb32a0f524f85e6780071ce1a91f653e930c3f387e48708f4937d6a1fc51be98fe239f5195cf0211879a3a00e0e75b81170494d0a92553197dfdac298681cba8ef26d8b663b535cf52270b1ef931c74be772775dfc5a5f0a3555dce5d9e550514485b51f10f8762b2194879007c13653e633f3551195ea9094820cdb73cb59c601b48420026b7de4fe7947c1bc48598fd9df4648cf31b9512eb7b3cc0555453df42914e7a6d16117ea79c7b1df75d00f79638bde6e0bc859e9cff84314afc41433c4675cf2dc4bb2b51a8bba54b8362dd57be909509a948fb5a92dbbcd7f5dfa19c8a21d8695a029f6512ee60c1741a83387bb5a31fdfe94c4079dd3edbea8ca6b00f20f367909b694760211968174d5aae31bd670629434e85069e22a559445665cf8dc332496885b6037d3e7bff1ece39f41c9a2ea9ce6c6cf69e694ab7bf6bd516df4274f4e8e446d5095a5742bd3f1244f227eedfc48b3379a1d39b4554b3492566c0fb2667f621e72e4c6a97530bb4581eb19597e9f4cf6d011ad70452f52deffa2136a72543c64372a7b37905e6c93b1dbb458582ac7cb98cd0d7c1a300cc2edd00725c8b107a34ebb76272262cd15897c7d1bbbc832199de3aff345c2e01c2dbba4d394cca1f3c25307f34a6e8e350bcca5bec6d11b8598d6ced6390d42049e765b9f495b61cafecf520edcf65756c3b9853d2084da6e4d877be814b693c3e7ab9f2cce63985a85b9d4b05fb4340166b5f5aba17a4b71286bcf4b56e13738272a1a0ff0bfaea4c8e459cbc325390c03bbc721a64d418b86f30ad96f231fe2b4a9f64d2f7532397a8fe4fc778d78fb6bd0810411070245b379e5e28735b76ca7a68ad0f7ff921805f5e8ef466d5fec63d6ad5cecbb08a5a11dfbf4172ca4504687f81a21395e368aae0dd215e14e1cc459caa6e40c766ad02d0bd185c75dc2ea49f80f64d13c760440e34b5e825ff1e7fd4cb86a61ab7a732de83dde905f88b0dc57124a0d8b2ed8b52fb0dd571d3800b7ffcd7853f12e55d674e6719bef7960fd86829950168b75fc561efd7c134ae41e81b93123357fb5aeac7166f358a047e2e933bcd9f1f2a974904e5a8a01a7aa0da7b5197051c515f57a6d4ac992e5c457cbf1762c3f291df0d44f4550b11138063706b423966145938c6f400cefdde3c876733b3cc25cfa4579eb579143804417557eef40e6c136192f8be091e613767d474d61f5da4788e35e109c313aa41f100c3e4938cf8cfd9193f986a726390eabd472550a3b7063f7840e9bafa5bc1a95d8f03b03e4fb15ecc30961a859834427b2a1a2c5e196fb4cee34afe1d7834b54a90f45c130627de55aa935272cef1e4dd5d176c8af146179d792bd4391dd2008250ccef14ddddb2ea3a3bb91ff1d07ae5606fb2be708e1f234a35fbd21d751d290744501a665eb918ba4cc18ebf6f774e12ee08d4b063e7ad73c81556b3d99c5084fac5545741a1dfb664001d10460ee03fe09c3d8b5655296d194e7b99d711aa8c035066e865bcc640c228d29338e8ebfb5504e35ebeb0820dc678219a256cefeeef9c27b7e0c1e340d8828a3a19a8ce4e61cda91e866229cd9d23677743c045fc374d9e9b3bcfbf39dade764d8b65898cb1f05ef77af9227559b8f197b4eddb00a10c87d85e4a556fb588f6aad7f41c6605705b25ae9df4530e40fb5bfa393993741aea34402b4b9e234238f7c83d13bd8a0717ead2eec5d18ee7cdde6cc4c8a729e8219b3960edde673ff1c6771501cd20eff5ada7a20a3b3efd56ff79d51ad7d6caa75de9da5dd30a383774a47e6b1d547cfc58e9a7a8b4d1a7531b20c90eef537b14b5a2e4da3657e26c4a576318adc508e5e0fc02a0bb5e6ca48d4112fd1ca5b136f229e560223e6b99b69d1b9caf47a6f558d90330ef320391553ac7c42e2a44f32aec6327208de0330a67b40d7880614349621625a237fc569f55e88cc1920a8fa8fa94425fb8c4bada7b11cba0b5b13729baaa05f3460817789d85581aedb2be9d8db0db5f4213d220fa2b43f18c478a63a881a2a3fa36ccef10fce5d5c1ddf310dcf7ab85cfe55868e548ce6506284d68efa34c958e5a9649ad76f0fd37006237ed1694c33d99fd4f64d3f27235b24860c35b5d4e9f7aa06709ff4d995002e042e141f8d9cbd1703c6569d8f49210c9edd8dc8e777746713d4c64db138b94097b2cd30710b46bea8a1d8074ac15ac71aee1bb9c048313a9ea1b6b20bc622461d5ed3a03f3c74b89a0e713f4d5638c827728fdf14a71f0f69d1df67ecb129b3c9226aa319961a1287745f7f1c67cfb35b5702a4878b9fb0de9b9bb314870e275560cb08842ce7dcc74f14a455f0d17f5931e8c04ece3740cf05fa38534fc4d3b89ea154b8950bdbcee2747af9e7ad4e56de26f55a1fe61fa23b4291aa39c3be9cb272fac5126ee0d8e1ce21af0725788b45200c48ba6561b7c8b3785b1f72f30c3b74a593bccfdce6cc45e8515e2a15ca5d2d94460124a9f3852a2d1e0caa4a171a12f910485896a1cef3092703e5508ccd7737ebd003cf2ec77a341e4b9a9bf148d1a411921b14e60afc7e72a7892d7a5a6a93d6c7aa1969c11c8a95bd501ef184ae1e8a8cc32d0787270d9a4c5d9d5728f31894a89b158ff6550cfe32a98294297b18dda66d4a12f182e4952d34911bdbc65b4de8400b57b50869278481d32ab213724fedf4224b9a70e988d9ab64649c88591d2dcb30ae763946d4f81d2262a56899952bab6cb25734eb72c97b912d39486aa5fb95911ce62d2f05e5cc8cdd047f53ab86f53683cc1d6b73d4f42847cf62f93f0f80a6aab5cea9551b815d95762de7b0a3b476c6cc36b5beff1f2df8d3d7f1982ae6857c1751092a019e7fa5d46da337c3b2e48695c483cde17fba978877937e1a99150767b90d7192aedf5f1f5600d1acbb8ae7d05c1d384f50a7ac0531c7027da1f20c6430f63ea320ff22c0619213154ad18ee780b3ceebe6eb2574966e8fa2db7ffc16dd483a981ddaac8402439f2bed2049a9f16690f76f4e75d1463eba5d265e91377f8ec512d77cc5434bb2f24c9c1051c70aced6a6aa1ab801564c4ef0e096902251905fb3d86628468b2098263c2554e40f158c5a9612f91382140760efcedd2cbb0217cec240acfeb21d472ef2f20ef83f1666a74ada92f945129142b89c725a4c4fa7d38611df0421ac8bdae99fbbf488fa557e9bf3ea0a3c8de028bc15e6ec1d53a9efdacabd974dec08427571656e5c2dc80b55f0c9e9fe24e54ac8ed72be6c759c595300aa8781aed4c1ce1bb6215b1a3dcb4fb1fbaba53a7b29d847ff0098d707df093427cf9d587d27c949c7f92bcbe6ade73b82f75ce1e44cb291124e5931d0981dd200927ebbb6852e1a66f8dea587d0a1b970d5a5703cb4bdc7c4af45b3a493fdc98638ccdd49027374de3cec964881e5794d917e6a2a3ac901baa3de759342773bdef8de23952327a888631ea38d0b56bfc4dafbf3e18bdfd9734a56186b89c000155d4b80a5951249cb84c6fc5513ec7d09e6b76c8acc9e67b601c695150124b94683f680c61bbe900b6f33dbda1656d436b4a3e20d51d4a1aa97c5c36ffa9b617d82066d699b3232209142e6ce6c12465b5994035ed95b02c15bccf6054df825d983bea766e3f048560f7f43c67a55fe9e857052ec4441c5156ed69112eb1ec402ac3917dd144229e46a57d7262306f5b268df6b64ebc35da20e40df787cbc45a4a63b825a9764ceae2ca6f1d892cb944f031eefb049dad4b4170ae3fba78d2957d59964f53cbd76f2efdc1f38b7cbaccb9220716a620deaafd32158ad01f87f35e1fc16dbc5dcda7bff53261ac23db3084191655a8bfd1db12dd26266694840d50ffb053f69f32874ce6062938f09bd54667be1059145d7a4d0091ee9f748b2874f6e287a3c6f99c42de87c4606a73d83b8da6dea63cacce57374fdad6299c7d26373fc0a9e42ccb1f0e0d04b197fc8f2f79b8af544d00bcfa4e1e8803e777e4683b9a1c4b3d2c4fe10947a2c549ec9b530f4a41d8918d8aaa6386607a274b23f05ce1f5522646c42f30539d68a7d946b27e18a125af6e643a50f9ff643bc5be7c7dcd2f1436a90371da00808f73cd1abd8374ec2381ef16f08c8207f42392dbdec121061735aca6f51810e9e660c931b6bdfdd9125d745454bcb5994592b32cbc4b3009b8df9855f2225698a8e2979abffbaffac264928370f074d1e2081d76cceec38823e35f3eb589f8244a3e7ba4fda9e319f61c89424824be9a24fbc0f0db72d42c0fa00fc83db06949337d99a86dc2181c0a693571ce91d1d7cd3cdf39d43de2d7601875afd0e4c56c0a7a7d6ac11b2b86aba6e3cc992b94ecfc35e38cacfe1a526b4053adaf504e38dfe6b50dd009e131f8f88690a51521f3d308881cded6606bc23f761974ddd2a73fff24b90a0dfdacc2735429d4e7a2f16b02cd3ab111dcdb0cc4debda82055edebd7a705e1367eb5bc61f94ab266a1d594ead1547c9a3e79ac35f7caaf7376b125e53086df3925740b68ead6edeb15a627ce56705c6d47f6417ed80f5b8c7258cc0a7be405fb426e114ceb15e203335464df6bdf437b669c8ac4c6b4a9e5632392d81235f96b342db197f9002871d8ed501f3027753d60a737e94315ea3b28db66ccc87d205c5f140c0313e60a9a5cd7e2ca255400066cfecd076740af935e7d62e9509b762daf7398970fd8eca401b18ab9430cce8264fd6a6288c11c8e2a47a6dff92c353904c8c06cc959c69b44f4b7280b0f557ce0bacec83386d7467e873ceeabf430485872812d24dd498a6e5ad88a7121189b22c37cbe0191ebb3edc00b92b08ee843c319c38247c5735f33e5636b76a4fc2f741f835c7d4c89690dc32c50b9431557921833e524adc2679643003a7ee39e1ec0805eb276f43799be2a66fca0e727e8e46877c89ea8ee5129c7a88de7ae36884d0b04d6793b807c9ab6e283af15a00c5e0cf6719e8daa7719d05d02c0ad027994657f8d22052f1098db062e1a4489d610238124d7ba3c0b4c5050bcc3c2da1301aa32a56b6cff631b56c0f2b8ee694c8f2d0ad0534706c396dcf5eab1a909af52ae16890f374006b55eda3750ed03c8d68075e55d3993c464dd8a11af1dcc6bd84a99fe231aef9d8ad41af9e22fddd32880ad18a02b8a86871fdb30ad9d52f0685020bb49d16fd6e6ca8ca4891e1f43ead75f08b4863b1ee329c7df7d0f956b1641b134d9b5b13c823a2b6634a5af0511d369da66afbad2fa5cddbe6ebb06277eefa20714398a1c437bc0c4a24a7d592c346a290c0d8261cfb5b17b194d6b2ba588685b45c5fba0bf95c1860c23525af4239a00b1bd36a9fb6327786001c107618125b7355d64853b66e3d49b1ab5905bf41c8182c9df0eada7f6c7d2ef3963302ff4fbc34ad04aba5fc4425189da0e5d0873b9b63a86eb47e1624f1faa51a519bb0e172fa2c82dc003b90de82d75da5b90ef64fb43bd60149c022131bae9ba255e32d07f13a05d2eb5ba9a9be4a785f90080526f96c4dc70c09ccfce265c753cddaeda0492baddce4759a45d40b042282109d33bdd7fff8eb1d6c58d068d181c2963bb6f20c6497927a4ee1ff2daf9b3fc824529c941acb986a2cdc1093adea2756ce30172a5a57e16856d7ddde4005d960b4da925991d7b357feb0442db26feca04fd4bb6bb9d908e5f1834e1f6cb827b4542071c05d1b2c5cd29bb429f2d4922d7c05a244d7852f8dc0f2edaa566e6572b74a140c6c5570c8128d5a1a54d6dac8e9a695b790e4a092685b5605b7c167e61cde5c7ae30b4bdfa4b962786509cb87bc521ddd9c4f534f7f80eb29276f3f171ae7b346f997b85a51f6f859e3e4ddddfae849d4514587178b1c6f7d114c690cf169d4ad31dd5adceda553ba26724e65f1c19bfe77ca5ef578ff235f0b254cffe1ecaf9cbb93623dbecb028901aa888d3421a82ddd2280417927b7908caf634fd58b8468dac921301db9187b7337988465d46815c4fde26acbe1f7c0493755ce8b3b8617b9bb0ae11a5e0ff971e50c2e0cd9763a81fefdb18908ecb571681ca63f8a069f59ee5dcdf7702a4bf4045d7974f4e02b58f7cd003800fbd7cc75a29eb4f84495133810e76eafd3dbc58bc56cc982c6ae0e4df7b599e385d99243d5f7ba21144ee1621be19275ce4247d68244bb549d95942896929704d03a38a5cd3ad5df71dbc234e2ba78ccb64c7741704c39d152d2b062aea4d4249a852e36b1b25b1d590a17003f732b7a889e1745a178993fb91a51f038fc81afce10281f84b2e33d437b1137fa8504c0a9b30a61ac17ee1f2cec2080cf16b4d0fdd793a7420f47758a8720d86dc269afc3aab22aa745b700e5dcc68e647ae9a869f428f3ba1c1fcd52b6ed50fbc313fde6e892151f485c3d4979d0653961180453cc2fbac1b7ca992bd6cf4a575e3c4946bf9b242b2306dd2ec1b53d0a34a06731455446765c3c3d12137dea4a2af2bad0a7eb5ee889b749c7ead6d50725f74f48004348e0850843b6e83aecc5cbeca398786229e5bea03e0ac4ea667943940161c3fe19c45e5c2de3e255a7c22a042675487bc4c3f6510ffcaeb1db70c1fc127be7a917ae2395923c46c093fe49e0c3ac9c2e4ac814ef784e3be326d5c13fdf6be748e0b457f096052aad7aaa3a3d0653d3fc252ba9ed266d615ddad11fad69b2471c3d6d85627b88a8f1fccef09a79da46fdc71dab8109cbca112869239da08f2fe1701a52d447bd0a6bc89b115b220523394eeb073e1035369083a51a493922145b393b388a1caa29cfc275b3f13e0f8f29cb46a8004ab39a6a8e289f2e5b7fa5e34920dec38d8588c8c7e53d55afa6192b0d5dea8a8776c705b6cabe3acdb1070e9d3526a7269dc2161bcf9009457d40665cf5ecc86c1ee2e74bbbedda8eb8d2bab7aa999494ca0e5883f710a398f69003c66d65c9d72656d95abfe290bc6636a6183fdd6862ccbc3c91a2825a0365dadf9c4a0c23e6c0e4686eaf34c4109c7346f532897bcf1f427c50c0a5e8c504330cc0be76ca09775ad62e081f2498c01a85a156102f060e1b380864872680f2eaa80ed05d30b665a99306d25315ef806f824f931d7b6e99c1de323ca53a4c2c3dcb7aa7ced64a96694794f3197f9a4d31a35a82f875842efd34517596ff20b538e2c066dc8101b6f4fe6c3aac70b92c3f6c026eab0a17c497b45b3132cbf51b6f46c290886cf6bb2cbfedf6ea10dbc3a0963bcea50d715b3139035cadd1048b37d23a093aaf01482357edff8f98e66b8c4cce18b6773b7117ebb7c16e5d1626d9139e3762b836e36e2969a82bc1f335a7003b841cdd339e0cec1cea25f40c0156dd44d4309db240b2ca638fac6d1b244c0650177e0af05070fefeaa777ce0569cbd93f1a79c32074e1581b6ab2440686d4f170e86f61c911acfd3c67ecc58b746f39d0a08208a734c445df7252360ac6c9a4b4f457c377ff8009df587b628f1001ed73487de52643240d6dbf1f2acfa54ca201b192d0a01fa51944e1a93ba84b1837cf2966b6fa10604d7e4c13f029bf4e157fa37b93bfd880c8ee3ff8f9e92a21bcf3c033c5d9ef312406d8a89e9045fab3ffd8e2b06013f87d42056227f00549896a7ff913f41e3c5b0416aed4a2f666219e66d4e73ecaedbe4c70285ca45e9da3b94d19fc2aad5abd97a8d474976303f8c1aa91451e6ee467fa9b2b0005f266c75ec3d3e2339f25f47331ef0bb85aadf7bee3dda102255824ce820996b019ad51714181c23f0d84334a91c58861d772c50001dce896dbf058a1234f228fe611baa046691cb7721671f4b613954ee5fa271b4d6829550799f01ea98fd2634d9ba16640d8fd6e9dcc7ae0f342e93be0f7e2d282015a583cfb96909e1459a529b48d1cdff09367cf73ccde9764edf852c4764f48b01e82d98b70f5e90aed682c0a7faf6a6e0531778fc98705469667014fa133f3d66842543cbf84881b5bf6afe93e1263c88701a9a039f2232af6a8bf74aead30c708c34921730988b3ecd43aa112d6531bc56d44239a518fe404d6b166c37888f07f6653da07c517573d333cf8a774de989d28c8d297f4a72c3beb069fe67fc5e96eb3603971cbcde03cf69771e41defe42e297ecb26fa9f1bf8021fe9370a1cd9cf543d44ebd1d41468c5602c1eb3617d7e73b4ddb7ba8dce46ddaf1146c86c539851899ddd44856f67084b8765cc9d8d67209d3bda49c88f2e228a5cdb6701d7385eaea3f5b735246b3498c6eb8c4de9138823e142fe69731a34e20db66aacedd2cdd8cb561c23b04dc59489ea183980739670a47f3ba17ec133e34ccb5f43cf15516fa0c0ccfd64af2fe66fec0d1906e0eac649178d2298752fd4271af3407a39bf0aa22d0e9c7ccf408a596cae57475033859506602c6e0279a03311a3a17f9ad55295e3b6be603c22121789b44bcf3cb1a542ea9f9a1d8f717e7b7ceed205fdabfa75bb68e2c87825c3b30ef6b5749dcd8df2e92fcec193c3469c4e0b05bdeccafa47b80081d9499a7b17c6a6927c2dbd720038b9fecc5d07e08d47721e8e60c227b2fea02246598e7d76109b8d4e4146a578895303fec99c6f81b3230bc2613ba0a808a88c288988204a01f85c03d08865cb9779732a76904ce6f29c93d0652bccad4218fb82c8a3ab57c03496ee95e0b53c0a904ffaaf1562ae2010632fb69585b01f3c13bda4c81b820f57d2016e216070e2b8291c4efd8c077c08715190683e668325b84d330c144f98209e46e3a7cb86133c6247e357c220a81ac372a285c096b38e34e4f0242dd6a5c56ca3b4f62d13f49a339ab46122d6b5c197ec59830e4185461daf93de7e967f7057d7dae27492a75a550abd53878c21f6645ebff3fbb49f9d2a5cff07b1504a97f431bf399d59a67d4ea65c3da19d7a17a3df8c2b644e7741ff2ce3cd314871a27d76951ae8b889c2ad2555787ff0417d2a20c88b68c7deefe2a3b3a50156552bb6ea974e4ff17356dc69b050e524b7e15175413350af3c6b15dbc6fc3be81cb1f521ba1b2a990863d3836be4bbb1cfc36ec0c5815f0a72c7fea5ec51c2c8402ed61246aeb8fba84c86ea2e6247786650ed25b264e2fa1fa6f4c91727a15493e907bb0e5bd85661c65045ea70413268980a5f48b4af743380a4bbb35b6fa3a68dd21576edaf52cf3912f2c468ea1eb444669976cace000b0c9c0455a02036a1d0adf499330a26585dbc555241b53ea273609cf481b35c64f529de13027d836db0595b2d5acfcbfff5b7fa35a5ca49010e2ac3e1c120784693f6ec237d716d72de024841e177687c965759a3f8c4e9ee742aa002a1de1ea7ec78ae7382e81752749f0a7258a88e05ac44714e7b1cd642c71f6ea2bb6fa8eaf13c474aa094c6acffbcd3146fb996e2aff2a7a85426ad5912cd85b942020fd8aa35e47930183695d6104eb4dd057b293573591efe31dbf725a46ef5f4cdcc0c1cb6c6a2f0c1b53dff83ef1951899bfb6c9ee17bcba426f0ceac0b05b8611f1b2f24ccebf0a1489b198c5a86b12052cba224d3483d6ff527f3e1fb9879417d0da978b218265b5a0540f004ce87f19fe9eaf382b6164e336b296596354f0c7d61870eed6071fd2ee5f138b2a2b49e254ac8efb588329412b05746ea5ddb634be1126dc3d8f462d4b6912a919b097751c068d727f2d30be09ed969b97ea8835070ee50b9400a7695663aca2f591184b7cc30939e05448bceb6e77011330f9900000ef8deda437dfacc87f08792183d233c33a92234175c2b963c0a778618954e3eb472e40eb992dbd9cb52ee234c2addc54697b344cf6f9a52f831c830d6bd6c90e85d90ce1bbaa58a999f9c891b134b063b98d5ace9532af977e03b8cbea58f9714e21a11f56bc91f67fbf6b0490b19093bdcd13391a05eaa845d33e74f82838083633560e329535a99dd883ecaa60a7b725f78972d8bd008689863b5cc0dda573eb7fa70611d50ff5ffd12bc86ef9ff90c25d6caa30491fd8a052e8e359a041d31a2c51ef9466e4a7db59ea9dc1fdf2271c3990dc5212b3b695ae2488860e80c951198bd7fda5ae36181b738a47f0e0328f23dbfad184e79d81307f1fb4884b54d62db0a220f92ceb27520f47f465251261c013f47c48a4ba2e2ea87af2d52b5bce43dd5196863054a229db101e83a0e6c030ee57092764cfb897ae86a60d73a960fa65b0428503b376a9efba80a975d5807268aa612aed3a8e19b3174d327a8f0c6367ae2c0edd4e46bbe8f9d0b73e20be587887cad91a4b0fb06dd142353d65c08b4a703fb82cd282cad0099fc89161d436a6b2d9db759d8ea04feebbc0eaa028f18e1673d3092084a3fb2c841704f149943560b6f23b9bdea159b73d43aabf31c72fe839ef3477f1954610a7af8a6a5e1b377603d575940aca4376213663e7483c7dcd453947157b37fb05fcc922ab7126336da7dad6a2ead9bf252c67908bb1bfc250ee0f3b7e40490c1db63c3141467bfbdcb1a7c8604d1bd1da6e89d50a20e0d1335ebdec2880a602a102b35e1a32b13afeafd8d6bf969c81eb224d291559069845cbb6c64ade3061089077b9accd1be83c52628f6cbe093eb2a66602c5e38b23d603ef457d1e9fb0340475eea218cf621e49e937a583834b9de6ae24192c9b1ae5a28c1a4e38f0df13f03c44ad071190564e530ae89150f88f1f28544c71c094fad650903ebdbe5e3867a91bfc20824fe34bfb3e2787e4fff49eb6759471e06f10e847e8d32e72a00ad7205dff7587b0891bead370743cbd2380977cb0480dce1642344f448bcd57f410a3eeb182d2cb190155000945e7d2b62157122def134134a62bfa9983ef48309e5046b6eae1d5de25a47db6fc6dec8ed977fecba388a6eabdf25add47946ea930b84bd2969b5b1294de80f22a84335abf44d4fffaaf646e84326a1e53d75cca28ad37bffa984d6563ec96b9d22ea9d6dd2a6eab68e11e8fd205d954a05f58bdd1d244bff0800e8b1bcb3e69f6c6eeda8ab0ac364480639ad9bc3ca727bdea3946785275357281c8045083028bac49f6bd2031d9345eaa0e7d792ebbc61f94420ef65e472d1454e90f30f36b1d8ae19546af472971d6c0f57c1b1d0053ba4a3090cdf54f699976aa483f63d479deaace7e41934baf6ec7c3d2d50ed46b9ecb47f7661e0c8e2164e9378d9c23394ba0bc3073989dc2fc5f9dffaa40b805023498bea7c69a24afbae99427759a4dcbcb4900c0915dd279308342b24c6cca935b953be8c3801d8e1bb6b1c54737dd6dd31572e946278719092c375d69cc124eddeb89c11476be989bad9cb471e5d9ca0c9c546ef632b7b65907e7112bf97842722a0f589c4fa6d6eb7ed55ede39794020d8fe80b85d8f2b68015fee4e89ef9a337c407d0e3cea0ede6c7a1310116f506072d214c0dced2bc426b9251483ed0dde5c62aa271d4d9361a622394b2e971cc77bd8df53d321d62cdd4b914bd2869ce3b30abfcbc32c795ee7bf6aae58875e12ddc767c428ac46e5e99d6e482aa768853d76ffe936f5e0b4f124b2a5fa19c0673d27b899817a9f4be47dc79aefca28395edbe0f8fb04c8d828bbb87180824a4e8925b35bba422c6b50","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
