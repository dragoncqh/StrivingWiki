<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e27b96fc25035cc1a6240e7da63ac9aef95ace64059d4726f436ec833acb8dc22aafed22e994d9c81cf87e7b2296fa7099d86dae1f9652b12fc6969e8502a7617d566b66c84581b0a834ca34eb90b23df875582345c8bbb7c146cca755142e8923a16ab07155d403cd47ad5133a4c192973cb00673a4ac3207eeae509b04d43a1b7d64546b563d7f089ca0cf6e7bf31c2ee59e995c1bdec837b7d11c5d657550ea22df18834c70195099986609c9a054190c6fc3baab28b652fca0c04cedd169cd2185b59a9e582ac332545e29c02a754c6e9a05504e8bd2e04ccd31cf4ba33ad0c82f1847acb9c4eb088e96ae2317ba5de5dfea5853fb250a53d6593377ae1849743def411118824e24dc97c62e525f04a81ef748fb28ac33960c1cd5edacc909e5c78c17e0b63d79ba4ab914cbf88df92b649c94f310eacae44df6b98055e04ef8de73378c5491734283583f305b95fbcee7086e34961799d75b471a825da4d22b89b2ac48ace5bd3cda3b3d222fe0268aa71db102a4bfc82fe8bf83bf8d1dd82f1c7b407ba7976a0cd7afa1972b61cf98fd9b51e22e9682103ddee2cf181de931f68b8d07d62524f35394fd1e864a5d3adbc874703fd532e6bc06c77da790bdf330802aab3fe67902197f620a736284ee6b3406e9a4354a83ee65529d51768dca9bddff18c83bac781adbe84145a8fbd89f06ca189b6ea48663d3bee7d2f883d5333c157d3ddf5b8fd632f12fd314e50c79ec3b127beee8c476ab624649ddff9115f1785346b9e52f4893c4ab63a1138284058238bd92f290a5c4282e7f890a7ec044eb433f982972ef7537ef76925f818404909ed4895103ffa7a448ef9d28dcfcb2b4136ad102d0c2157cb974360bd3579fd47fb16c83516213c763bf86b6061c22403b953fd3575681707733a4b720f059df4c5da631e68f768a756ef2764d50241a444423bff579669efc9c13c15fe2f4c68a176fcbcd87f6dc9923bd37920e40856a9ac147634302f93e3d7138c7cfbc9d71f4f04d7628c4cfc46d404e638bcda8ec5d26034080e06ec8f50242bfe53fb025fd812cc79d392ee1b55684cc84987c342a3171414c3444df1e9e7b4445a74f2b657a80b79158dd8a82cd163f37627f6bcfa43365925bc23bedbd629efd8187ee147f55e111356b12e246edee49eede927f406829d02d8c8d643e8716d807d6b723c628107c81950cffde66d20f1727249f4c11dd3cab5222eebb3f718a5e46a71d680c7c38f449d07080a02dd84109b6914b5388dc8dc161356783da71c03a609df19ec2073b424e3cd9482606cb36eb98c581dec1449c03d4c3b3ad3de565c4a2494359774f2e0fae33fe5a7b941dd7c4e64082967bf81650ae6eb84de1e016893a578ec57845b024e43b787d89caead07666173c70bd2d8e6f3d0e0bddc58f78596c550d28b90201c274ee67ec593b0458a41d8e41a0c60a1ed073ed420d2adf26aad9e5f339235b0683391c47a396d6e8e822c6e735435c64e7278b4832229e37cdad976c1ba6338cec6d6680c60bb9465040a8b613cfb55c3c1c0c8be8dd3863dbfa3331f57a64d40c15bca4d540e63b773a29f32a5858975b96f7f6b23d6e758f1843401de914e179171f001e5e68b130f786b606a8ad300c11ae64adfe3eed749d32e89007e7fc61cce107b59d764bc7d72410cc30c36f568b8cbf284dc59359874019d983cb1dbe207677aaca0fda3356b7b43a7a748efec4392b96bb14990efb94697556c2040c90f93012c198773f647e6c46b6b5b74a09a2e587db49a87c6debf8b3c45945c23bbaa9f58a47650adcbaf771bd8f89e5222e0818fae2e384a458ae567a5d1605be9a152f8c683e525ee835523631688977e9001ccc526ce5b86f61fd6d7b58b804598f57bf38928ba66366633b6399f6a4fde7b2adc75af97d1104d41f48fc4daa159a4d1dbeaeda89406b71ccfe23a6266f728ed3541e09ecf2b9fc6ec43d19e83129bb6943c2bbb2ed66128d3c1c0a0bc6ef1444eef08a0a40816fc12099f147ca4a5c6363ca8db4c05149d6db569afe2f62107d4d354cbf334017626f3e5ad790f9a0bee9d0fc6aa5e8b49571226e1dee541814796cb8814097ef11bddfc72beedb6eac28b9b9f4e6823b50b3a87d49ee1f729851f5659fce787a62cf900a6d53c0595bf22c749bf1cc34053e5c1e744f3dc42d79103ffb7a457bb9e17b99267ef33957cbbb3e1fb16b4eaf7ea3d84907b0d70aa723d143f655bdf01f614eaec1943d3627771a084ff33533c822ba64505f016b97430996b3f9bc56cfd905aeefb00a501a962ed9bd96248a63f73f2937d50ddc147d1ab8e711e042ded2c8edc7982e0a0fe07b5a796e5b8321ab9a8b528fb714d9ae6fcc74d3e888c9741018d8b1ea572ff17b67f6d1815b53be7c408cdd2d4edc6864e0cb503a6b58c024d10f0fa11084a1ec48be3779864a24ff05a36c290a6c0195d9415251049d641f16a7720474f655041e6b87abaff9245ef5f5e3de3e35c6fab531a49ae814c11f6fda974d495afcb506f93e54bdaf6ad0781a4d2bb3a0a978d79bfd7153301d8ca49ddf87de30587ef7318be7adc4520aa31dc7d910d1b884bc989188ffc5e4e6ccb7b6eb4a56d86ddd779eb65229c26432399176e65158ac2db5fcf2c24bc7df7d1fe904c7b4baa6e82aa9e916e6cc98f321ce96debeebdbd9771a7c8e4b4b34f0824cbcff5cc7eb8c0d3bfe3941be28f98ca2676c5b098b3c4d1cb5b6a4d969a5d558faf31792238df449255d788242dd46abc86cbdbd5142d21a45583c576b64f8cc1e417f68fdbee9ef9eafea7fc136e8bd7a4d580bb967a014e6628c3bff347e6ae46096887a1849247f89cf0407a435c0e58011c09b7fac47aa1cd5442a4600ee08f2fcd7bcaf10ef13e13545c5b1939210a0dc91cc6ef6e1820b0b2576a341a11b6466e91b7edca87c14c291537b217dde4fafbdd41a9d02fb2de80b627e2272e9966d5516709afb01acb8918413895b4a0a1ce662024d5e48e6af945cae8c88da6e3b75760ce262c3fc3e918ccd4c1351df92719f448a6bd38d1142ac6b82e5119cf52496d95714216c53d31879851f726a4c8b03bd37d6bfe6fd6733a2163a7750c7a5c465d51050ebef3b9d66dd63dd3c9bb13317b2c378397af3c394f05b1dd08182d450143be843e296628e735321b33714cf565a5b720838b2dd26e0d0ce3ea060f9c892471efd93b76cc931d41227fac0b51c4a4963397855262cacfc495b52d31f93e8761c93ee8e87c04a6107cbf294c895cce8e2438b56e25ea2cc83bfdbef3bee3caf42d9db39eb7fac77904263af91fbb1f4ba97314daa6849b6bbd07d998327e812a2fdf0b079c6c40d56d85445922f9747aedfd6d2b5a2fddc9f26448e178f00fd449070c7e83b7153d31a105a6cc868142aa55c67c0ce206cd8f1604f8d28fcab61d588e814d31cc7faba419a8dcff3ecfcd8194026ee2c95886b6c048daf355c54b45d41c39b93728a9587435b271713821ccabc6e499a2ce74b9c59a3dba04ec76262baa5733067764b5ab8812960db8b54c795a8b45c3a1ee918dfd432b55ecba5b7073eb0f82135336b4d4a77136f200c2f96fcfbfcb396cee1ca57573e8cfdc263fb46496fa31ae6ef91fa50ae507385f0f84d37c87332bc9332051c850cd5fc6b1a28ef843d8c3f583f7dbc0a0ce5f2f47adec1726fec5b8c7c6daffe37c702054aa5defb242a18ba653228818a15c4255f1cde2ef62ab6780132ec3f929b81e735925abb7a6df9d4cc3ff417e81729e26d8d796322b8d041eaeb4b6243b386ab8a7544f2b1afc1ba9b155d0396e8cb06ac5718842cb7af078192f5f276176667a27c2724b15cdb50124acd6bb4f42c07f0999b6feb54c4f068c5f3888dc797c49e136f9299bf4b57dd090736d30bdb57e16cfcd51eb139e4aeb9d2ca9cc85f2d5b29114d9f342f466f1db9caa2e8c2b803bc62546c32930b93f5fbff71ca2fdc576d917b1433a56c7f19fb6440ec41e36c0b938e59b42c8437a5bd4024ae99971135e1d88c0a0d5b3c0018a4943bc09fa0c5566f8c1fd968163fc224e9f39ca7b812cdbd0efefa079cdbcd301e69eb7b3180a0809969cd59dfe7cca4cd3ae9a37bf38ec69a7d38c79e897c2193fd9793073553ad5d7b518f731beb2fd9267459fcf5db668ca359d3b4f49f16f50b6f315525ad238faa716115ccc0a00981aac680b0c3000a777c9e003513d3167bb4dbcf36764f15b9656c3dc463240c30951e8ff06a3c3c688e1a5e2ae33b9c146317115360d8c5bd91c4a46ca110ad42e64ec0af6944fe6cd0f67cd39ed00a2e059532f95fc26dd070621b7b5657de467c5bf27b0fcfd105031ccfc998bc7b2ba35e20e356c33726cc5ce161aac3c2cc63264678c49fa4c17030900f58908a8ecdd602af461b4af5638123eedc289b68308817b9f3707dbd4636160c3529fb4530be6e31f9b16695f3a07cfb97aec5fe7d95b7a951207c2f84d1eabfcab0a7cf4d83ae800230c9c3c92be540907592c8da59e4aecba00e552ebc39e1f5be301edfa335a0ef1cef0947f5ae24523dfcf01b1688b422e9d0c69c9150a45c2a56e26004530bb412b828c37f4528e3e5abcd865ab27fd01497c221c8f6063b8e0b5545f259b715e035e607d1e43f12f9a0a90991323f0281e67c7a5b9a288cb073759aec5ee2283f16dd38bbde163be82012c8bf6636f38932d183693249325b4e5f3e88d24d4dd8a8bcc0fc2d2baef3cce85dfbd7f29d74fa2d533827956f9d6748e667b5d535d2f6d996276e814cdbe82efa491be02558b6b2a516038da996745b155cbd55c186ba7d2ae8820adeb1120d4bc492c511b47858ae19d6f7863219cb63baf5cf14c8995709022a2434f06de03bec89c5027192bd5c38475f409358cc31528251fe0004f0474ba710753a309f070cbe5e09d4f1c78572826b333d4d30e9becffdcedccbf0c9710d894f47f2a801022aa6dff54bc6f40c984621be79189b3beec5d7264b9e4dbc089fe8d85dbc4378404f6365a36dae5283694f91366e2c40957de7fc8620b2526728f4037d5a5145b08a94acf8321dcebfe47ff2d10b761b323c29ece2fe0db17c695a43f7477c1ff983c065fb701a7072f5a9d571e79a429c76141811b6fa4d0781c568c2a98f016bdba0dffdfbef642801bf6c924fad19fb5d295b11e3561ef09a89c349ee10938323bb76d878690dcdf74ec2dd8a41e28d187798dfbf4301b3e2302b6cef3edb378b8a02ddbc5adf1e670e512effd1de09a60b9ad180b65d96d32c26367ad3a44c70692727a303f6a5c101be1107479c347467863a06f967bfdae1c6d34941d8b4131e5a3af84e2171b4716076cf1433a734e390053d2b09fec6377fd5ff4da5eeb5959bd33f8c661e8e176278277b59a17824b2477beef8057bc447c364d3218f5e6f44702f3f36f58d4524f62a6740512c6147b064f0288a844200c31cb82e940be65976abeb6b69c1b70046acfcf811f8e030700d73fcb5b0e07f89d44f38cf46d5c13461b6b964d82de90b9372b9a37b4146f211441f0524a497bc1876177ba89c0a2a113df947a0406cc3d0108fdd3ec7a13e4fcafe6b063913fb9d780ba4be6e0411cb9830f6f54b8c87564146fc0fd89780fa3f663cb1fae32cc6b11fcd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
