<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb7197df3e7839ff74e0d66d2cbaa4d615d45bfc34f2e65c1e76c198065283e057a3bb7a47bc6e7b1093b02501c6b503b381551cb408074d477a321028496d1f2be47c58581f41c32998211a1ab86a78cb20b3e7c3a8b7db06cad0997f44fe4ad4a33fdb58d0fdee690baef2115c1b0f06956f0885048521183764936e929efcf725bcd2600451577b29b89e91852e1b5f3e8e45db78d95ab40673c66cefb6a6039740f87492434dadace2026d7b9f556abd6fdbf60f32dd50b9745da61cfdab02da73ad6b74e5a7f1f15a04ca4af0e04caee0d8656d6cdc381f5e119576cef5e0ccbc26432b62c60c3262d550ea8c824a4733e7046abb3c291ecd18a477da91961e4ecf3ea56e5df40d714208aa9f8bd0548cfda6b4632aa315d569489fe18a4c90928645411ec66cd82c6a7c86e2038bd15b9f594a43dfd9fc0f56c5395f9b92c2c20a2e718227517db8006d5bd3ecc9ed9925b1eb37be115b3226824911811fb6ec42e345c699a24e86011e0f1b3351247c16c08a5d61ce35ae5e3c09a67388b50a7481461a2ca5d27fbc014077bc54e8f1b337e40eafccdafff70ea5533747f31f59dc20c1ca487d6014e8814b05aa09334e19afeeaf00340ceb4162f0ee878278413bf47f9f8555da57d1e3841a6dff02fc349ccb72b40b0fc646abc57a8b52c0f7c635789a9765f5baba4f9a5eb712438a2bb132c7fb3988a685bad55831c54a98a643fa5c339bd761d6d15cdf2f308709906af52961963e32c3577b9c611f4066fcf23bd90311b6d77d665cdc99699cdc1204a0535bed44717c94a816f050dc8c7170c4465625569799a1abb143bb69b9c78e797de06978d5201e88f06302c4a64b22dcac0aba0f6b6fbcc40c4101af75e6f97e43da2d0cc87f3af80efaad8b241ba2943262302f51c9fd2bbd7bbd9161fb993479d339563df66397d4eaf706870cedc65550ec8336f8b6fcacdd670c639b07226d6e9065a5a88831f7404d3c90c867c055a728ce017811fbe428f2b903ca089626d2bf72fed2a13f273bef0e6a8285c17fbe9b58254ff54550bffcf0eb5aaa3b7ec6ed920561825b3d14b24c132fc3e4ce8dc33d7089712f15afff9ea1fceb54bb8900a1a1ea890d36dc7ce1f5b670c3db756c0a75162867c71600cb89ed7db63fb663cee8b2d138534dd9ae53bf893e5be1a11726fd3a61c75e3b54b41df631e39f21d91d507421e27a8f7c13b86a0d2a4feb50a02e7a0f528db8af164170f781c515cc5a8b1d5c352398f69e0bb158d80872c8f990af8e3bb6a62a1484e2ccb53c0cb0707234ed9520c9db2e3b461bb5a0fda9610e5bf06c5a996475f13e0103bc20078a4f21920c464ceb006e1e90f562c79c41b050e83f1b605b2f129c120917d4226bc6df971f086e88ccb7fe4885a046c1ab04474c9bf8b0df9f0e5df433c4c9dad54ea9a9753ffc5c0bea2c004eb0742f67f2706600d29f5b0df56bc8383ba96948cb9881acd9f9b0a8815d008cd8fd9382fbde8a96b72fec3e342324220309ff7c0c5f0365700c16630c8607ab4042be8850f728f8361e4d4527b4ebe62c714596d51f67ba26b4562839abbd779526160dcda6a312049b70b261504647d47ce09eefa0be2f31ab19591a4ff34db86608d32ac19e85f838c5714587dd06d00085664139daee0b2f5837cfdb870c75abfd71037c721ffadb9c67bdf0fa3b9bc2059050f911ece3f19fc25ce42bc424b8a7c7ee44a5fc85334fc1c041f00d726025d3ba25e8c5d572608c77b12a46b4e9d30c1845272f1e3d9fac34c114892a39ded4e2224f10f1702b1708e4f85315ca85f93d81948dc8e71a1879d302b8c40e99d82e6517523410af2f7ec1384b7b2a9173717e9536e4580d1c832efab59c9ab9f0898064a6c6b6c9fdef3e23675720c4aa362bd5d75eabc0650d799036ed3fb878fb03120686daa05006a14659d6c06cdb9b727ccf5ca6884ad731128414238580ef3bbac78e8aa8f675589c71aa43facd6ba467364c0a1113916a97138d501410bf15a3579226a01bf490b2e550f7ddf298b8a6ea1d7296b6bc6bc0d41c867461fe9f8559b4c2099be575e87eaf3ce3677ec13f18be94613568639a8bffe76a55d4d800b461fae401fcd14fab73ab203b559c243fa55deefa5970f471e4cd9667477f9c871a91abb235f0096756a9018e0f4df378d37c17a2f897aabef4011cafda6957af205c72d2fd0c59a6759f94d2365510ad6dfb6f7099a1ec3b7021640ac58d09936b72066aea12e6467deccc3c8ba1f711c9087e09882af6183a7d1379ed6656d1e0d55f8135110513bcc63090b45c960b94bf09c6dd6c80283cf3b418fcda3bf660db5c656eb41ca6dcb1a42b9634ea0f1dcf8d336e4b96df40972e3625f682eb4694bbace3f01a981dfc937851136d05abdd36e409c3df9407f12b24a3ffcb09fc3d579c075c70a30444783586b2f744c7f7b376142baaca7ae43ad9c6b493c0f387ddc231495e87c6a54d9f34e912349f2d81a39d85e80e0142e805b78bc78f01b00424024822730bb467ec0da63b0e2dca54e4d14c5514151a14f80f670c15231ef7ddb107a441311956e78d1630469a7ddc17c01fca48c5bff14c898ddef97d0bcf4276124b5a4529e79fd44296c12a2e9df6a778d9a9513a28a1ba717c8fb5445750a36f86d11694be7a3b5f6312a3f6b6a74ecc305bec747e7ab919f8565310d30544c304c3d2ecac94b07fcad8ef839bae8526bb1be278f9df8565e58e448fe7396a83c6b9cbbb35f8d3f15a2b11ee8dd622d48f4cdd2fa7f8e2b9a16ae33389c0e7092fef1a78c1a831273749ae3fdf7687a55ab2bc622808ff5ba56745ce0f482427f96098b02d493d2774f5bdaf3d11bc35b295c2308a0b668c5e766a9f97f1fddeafd06a9a81942fa92bd4a1491def540999f8526e3148d1ab48b7fa3d73914d135a29c0bccd9844f7c6394aea0423319b106636215ec5eb903f0d7d3003d07d994b0eb397eb7e8c39c5177561c18fece6dec580dd678bdbe7594d816ee5d64580d57a4d239c788b4e1f45635cfdcb1b9a0f787738afd87ec1bb6b1c04b19dcd4f7e5ecf7ba2626cf629f0c0226d8aaabf484c6d08b33934241dda7dccc1342a8a0ea5a6ade59c6756c62ec5ce264ccbd81578082cb7b8ca504d7956a845167914a3d94806237feccee4791dbb63836cf01929e6d89db778494140f294c6536e576099cf3dbafab05296e8e2235f1ead3add59cd71ebedec4fa8bae4ebdc525be548acff2dfb1282b893418b5f44a332a0ede762f6e8d0dc6998d6e96ad4f5e7b7e4046ccb83c2a6a49eec9f1efc5e280f28de09520ff94fd4bb24a0bde00b9052f10cc50fd647f48e41251368c70f74641535a2b00e2b0589c0a9fbfd8c2ef079e0c5d08c0eb700c555f339fd738782b69dd7ced6a2dd4774377cd7bbb8fdb82d5e07865bbf109115f0207d3528bd301303e6c8f4f6ed3c732c71ed1cfd1182b3ff9326b81e32ef13417407c27c6238e8e893eebb639630a3d7aa4f1bf7317574d85c1557ac80e16232cde20dbc7c6833f21bf367c2fd51a258f11159991502e48825fd7640e1e129686334077ec3bf58a62430870e0888850d2838a3d4b45de84ac2a51b085cd92b6f027d900063d6c6d560982b6220a79f1a1f5d2fdb9ec5cae518c9e6e905132c18849e08c923c9f5a670ee81f0f03de85781d8eb9b86c13df3c0afabe8639d2256d2557dc14697a57655bb86058531cfdf0f67b43444f376eeb6943619bf7a5c0afcd804d91ff35027d4dc37ee27e4f39125ccf2d12e697f864cd93a906d712104cd28504368745e464c5ba4d5d20e17081650dae42a1f4e224b780650c0b24a1f286f4a418a02184a0f798e32bbda896996e94d452fa30477f0127243f962af4ed23312d0e1bf951beaa68976ed7b3e6ba4860349706a2b5218f14d342318a5bedb15f63940b5aaf01d5960c0cb72650153d5cbf4a33d250729ff6f6770036d6d6fef39866b22da95b4e76671ace2d2769d2e5bfb7ba26ddc0317582f0f27979055759ccd66d2e32df599bc4e59a1aee1d50480a1cc90fea927c15c4cd53c042bf598f5109b4ca3133802b788850f2ce39894b0698091edbc98775f468f67a6300829bdd79254aa2cf9914e795af8e902933eb8cc2ee7e3f4947e17dc5ab066c6547fa119ce1e1ffd18f49e0219c699fbe39cfa65c350b2682c238dd5cb84b4d33748cb32000d7b3c9d97e069e396ed6f22ae5ab2888181f69d9121eb934c6c8224949c0279d2991f9d177e78501b76478507a6ad4b63574281944ed19fd65f7ddc06925a0e0465ebcc177f7342f41d43769ba787a67af51fa8667ab694a68da120a6a4a8dfda190132b58e115207550da78c07a45feabec459b7d39be0bef9c2d2005ef672d0d7fc2c9681d10c89ee86498a9ab5a01e7e3480bccdfc266c19ba142af116534b433f5131825f2dd484eded508043e51faa45ae5e7a8040f4d445b07bf285ca6d07707709189d00d2db51699056903a6467246e7a885507ff067f421d757fab57c99388b3362c3233c9bde8207387970dc27aee5e3452f1879a710d39989af5828054cf7ed52a892aa98e8b6186b7497aa540b7fa0cf045523a75e2fc7229f269c0993e3674b14b1b627b08a40357daea9237e30e02dc1e233ad2ae2e767ceaa5b2df2f887c71cce663c000f43177ecd90851b939a39f4a5672a629433131f11f88656db1436c10e95ae27a1b31b6e723cfad5fdc6bd4636a5af8e38dc03895300accbcf88761b31b04d86dba7d1bf6343904d9822789be41d83d518a6e51b7526328c2d9f98731c71acec7ec891128706263d68a518f7a46b17dfeb51d9bad35a118b1eef65025b9df1beb4661abac50d5fda6a1638744f71bed310d3400efb1b880844e55d7332ea5e2f60e6eda335767819bb93c9968fec9d22ed81bef52160debed6d403bc06ad14f784baaae86b8f5063bf7ddb4eee308dcf17ee3a39e6540ec7000f32673e0c8979eda0e56ffc5457c13f2e7f65fcffeeae6f7052a222a1914f1d714c830e7c28aae9d5d0f6e4995124dc922738dc761fe5139286ab42b269e5ad62e19c5eacd48f5b8a8bb4de6513bd8d4c2773e3d0443c8d9dc9a2afd27efe197a79f1a8855a01ff30f43b0513d951584ec61e38a1e7331d6f3cfbac06391e874d45ce4ac91afbe2237f36aa4dbb9aa8ca8fb36370522c1147b446c183fd29b948acdc67ff7c0da60e30591281acf465baf58422c61d39f724e75ebaf089901ede9e7bcf53ce030028b74421b55499a9c1fa840e17631c1944dda1dfbaa129b7ecfe7486aedd1138e100c27fe189dc322b179c4d88943f41cf228d3eb35fb3f9d92a6289abeb5c365521095d2ecd4d0249e3f6c4066956e5ed15e71eb8cff0b04b676054f5f03bc4bb3a02206e62dd838668a46b5d2efe1a7eab1b08b0d54494a30ede006c1a1dbcc1b0f61c5d4314cbdfac9306f7942eaaaad3affe0742bd81adc3101b5d0c8abc6280f819c977095d26f77082f3fed1ab0aeee1ec04fd9cf2633f7294954612857428b94f726723768ead0d5aedcc1f6815aed4ac0317354ac3ce1a40b7fa5ba624e4a04f26ed067b5916489682efda6b0e7de6e4a87e255309d1280b3cc534dee0b75d33abbc96cba5d68e606c19018b6e984541bd65a8f30cf27ab8c886f1ff203d13ae92cc48cbc333a91225ee77d6e17684890cbcaf1ba8e3546f03da6bda42661962476d62bd8c6b0e417ba24d95eb3f7a2054d70b1f819aa24416dd254a6c99505ca251431774aa1bcfc7daeba44f3ab2468159c7ff54557ea6b9fb73d44a606549d62e2e09363fe1fac355710334eb00cfe001107fc0210c6490ecb24bbed8886e09a8e0783c9c6d6c9caf1500f54656169f1bb43fe612a50408064af07e6eb1bce38812dba4d62d522c5d9e71a55808d096f5c95ec56aa60e32c9ccf453fe91303e9f3282d79f2d2f5bd97fa4d40646acaccc57557003adfb1fea50af92ea0890b20693ae6f959581ab28062c0d3bfc34254ada102f846f0bdf443a0225b36491bbd9999bf795c88ac2054f730c5103815776a1e36854c0bb97db82644e04fbf0bf640e9400597193c1d92288569058475899b780a12839ca81dc3a2de038cede697e92b3c0591efc7faca3df82c44ebf237e89f03e3b8e3e1c0a4293b703d6f106892210f94efcc3fbbc11c9a359ee70aa7c388924b6d9547c5f4e09f997d1502ecf9c0f1fa4ac0f3ce55c6beb024af337fd9d6fb93c625f34b1265589ce9801f6148e9f6b38785c488d35f1bdf7d96273f5ad56fd874cc5d80214e9530e949fa52870e5c23434844ae03566eb7deb9a6c92dbcd953fe9419e1c52ab1cd1176eb7e3618e9d9e53d400b3013fc6d370f8a6042c37d944afb504e5c752415819c3deb9fc1b5823027f7fe740febf4932f1e30f6fceaba3531e288dbe081d1c9a2466c68a17f46a8c2b59b81335dd02666b1b29b6d0a63b9595fa1f5487bda04cf1fd961d00d58d65e855fc38ac9eadf306f54753dfac354f54be55fe79c693640e876f96a6f7b7565966f36876f8551ae9379aa9c929baa980984eca30fa90fe8be4c31a62af4fe5f16f30fb5d913f44d8634325216d19ba689583c1a6e5182faa652e232ed215f98650521ae4b13320f4b99d5ec63f78b7e5b19017b49afe65ee3437f9942937f3b16f4e1a3857f848fe8f52d442f97c1f66a48261a1a4308442cbb3da9e78569326c51aa90a666b74613b09405fa3735d9434446ab293ff6c98c51587c6de585b1be891acee3884e0e151e18d3de3fa351546c689cf866ddf495b269761c86f8da6bbc8fa69e977721c7d3a861c042eacb4d0fd6bf89b84123c1558f5eacfb299d0df8f347b307af1a1fc535219dc14e920e4042db6bf7a6129786bfa630866573832c13ffc890eee493573cda69c4f69ad9120d975eb06422b1337b3dbf346c9a8778e30e4f94009ec659c5b1531d6e30050be685a92b50a817ef190814ff7b0712e0838087b4e5291f89da9f02975aed3ee763a688258e555ef64d0f38644399a47be17628f463a2a3d8a16b06463cadc5b1e617c0e0f9e26a8362168b46e31f4f3d13b7c097f81776570d206509e3be48dac6873df0fdf8eaac7d719b627d46abdf4941e24ffa8e04c1d5a863b1062fb3c1f639b2b6a001ce4d1657ac3dbfbead34ed1fd212b62cb397b95936943eb7b34ba8f97e1ca0bda04427d164a9ef67afb2d724fce6ef935c8f0c9cb9768d23489b15a0c21429aefe3d0ad8ca59222306de2c3f47dc7dbef3325ee8093404b40ca0cab9bb144e7194dd3f997c1f5bd6d8f9242bd0041eed3cc5ce461088490a148701d918f3467c6773400651e38fc8cf9c14b475c03cd4d12f4924195fd87169067a60ff2c67f3de0eb8be962e9a014a274bfe5c2f1b210a15c46a1f0a40e40b5a3758277a3fe2e30b1c4a797e11beeec15d44798551b37f1380a7d3e15d2ea921942a731b90d3ae6b1d291d285243a14fe9b6f281bcdee6f9ff16fc85c1881d46f8a610e0f5f7ef14024f4178699a33171c82d3eabd3e1d46343c7c075dbce022755c17a577cfe7e2aa3fc12dcc7256e0859142a19c19d2cb16225b81ca916dc13e18e0070b0f8b41f270159c3301a3a67669a69aa34988e4890f0f5d57e85e69cf10af540ce49b4d0ccb6e9455777ccc0cb5d30e2223e14fb1107d36b96851c29a5b00db243df7192962626e15aa1253c31743fdb7ab59b19712c457ea152b757d0b71b6e7a324e3c6ecac52451bd94e8e98043802b29beffea7eb5496169535f1134a1a133f420afbfbd1c60e6ae3923df1800f4ff02a8b42cdfcb3c66cad61fec5ff72bae8d3b92bce2fff395ef3a5fe414c46222da6d53b637e87a2e48a75ef7838401509cc9aa909381583a0aefeef8ea6e81e4a60c09901d9c863a2e92fd855b539418fe7ea1ef5a2a80db5d7f82976953cdb380cc0c6619363df002a84ec8078160b6c381c2cdc837ab3cc58c42e1c230a586923be20e391b7e3094c7a53b92ce6efb6eb77deceb8e6a482c1c9c82521231a5284e51874926eaf7cdc527860b861ea2a2b7d59879cc85cfafdc94af32b966a2682aed9cdfa31b32b44acb38350ac62d415a397b98d4b1cf344350781431977a42f8eacad6a7711777e8c273eed3a0d4ee329dd8634653649b504754852500ed6783e2fef80ee7e2ab6b98d990107b7ce3f928061ffa856bb11db12e9f7e7ea849b258dd2129302d04962b897b224404fae914219b267962e79843f842fbf9e4b9d2bebe35da8b755e6ca67faece121fde533020798c1f656fe541e14dc510da602c536e07e892ab53fa2d8477bb9f554764c54912841c5c7b6f494f2c948c50a06414dbdc428c61034a7c98ab2e9fca9655e4c8e0b13cbf4471490a5a4dcddc121ef3db3a3ec204ffa693823d07b5f2be02f252a71472951545bda8b07cc609c8d07a91f017aead199304ba59b53ca1ec1172c8ca1762e392a776ed4bf1b3104f8c60e834cc8b18dfe79dc00aa340b08e0c53bbe3d08bc42876d523c4a4e8688d665c8025e964fb894c76f1f74f76b9a3fec343f2818da71a959fa8e582ae212d57c7da866eb91f5180b9301cf33c607825b5ce2ed7eca5250df0c187511d97593ffba580542bc451bac7c41b1720433e8306760b1c4cdab085037332469125d35fc085aca4072ddb557f838f881ccd17f95534f34d1fc9545f677131074f5d07a29c73543b70ce8ecf58008716ae1749b0e0a20781a45a98bbcd41c7b401864f5d1ad14077e646c24ea63c384a49fd91e1faa3272c4b123e9867a6e93b84b391256237f8a06726e5764f9266e056b83a8e561588e81175cfa24b997c5de370bc5d5bfa09a9658d31a75ceef002c7548f63d6b3a459865856fecdc6a11466d37a3b106a20a09d9d86f39a8967986ed38c81fdec88d15a80f7f9ee9faf1eb1a5314dbf3d39fc1144d05d911335c0d817df06940fca90abc62a1c62f5fe58b2496720f72ef50565c23224f7d9246fe46776db735affb74af7144ddbd3e7ffd3e8ad7fa52a63b6e6b3f6684609a65e15d106f1113af4f8010726bed653f163113ff80eaea7c6a8647a0c653058fdf48b585431620c58281fcc9e1a970ddf3b373162ad6ed95d3e5c449f346f920694a810fb7bc6858f523a94e299f4fedb4705ffeac1bc35178e48c8b124b4878055cb60f91359de4263ec245454822a2f88915737c995e0cb519958d39d386e8a3c9d0fc85202cb273ce06d0730bcf2f4852b52a25df07fb0d80930c6a377324e6fb00cbc669bed21c99da7afd7884faf0655d99dd1d95637bf2d626b4fba6ad8ccdffb01da3d3a43e1740905b7946765d95d42d2406097c223db7b33418c50aafb0370b125035ebce95a7a01cf9d92ca4377d10b464883b5580f1dc63906898a9b32e9c8c494223022fde292516d7a03abe3ec1c17f36a21d313c1c294ba977ec03fe101273db8ad4618ecc1f27698ea253f87d2dd0a0f58093203d9cf7bc9ac16eced36e13a24d390905d07c006694f36452a9b22e5ac747877caa51143555854b628f37fa87c29ac2981be8d1b75c34db1f1b55761545bf5d61525caa84ff67d7c67f59f670ff7dd8ee8835df37f593770960e3415229a6766b5cbbd18ecc9472932d0c4d8b3e91f894caf59ac7b164adfa548002279ff7f835b91ed7f506e304dd134e8ace914350202a66ebf105315aec3c8a372cedd9bfc5e5871831fe86e98f745e27011b5fec4086b5e9f337e334cd0eed7176a84392417bd06bb0c60bb44333a658677adaba1cebfd96d63c266c3b5e5bbfe2abaefccb647c306ed076e74aa2eea4fa9348cd14074f2fabad9b68fcd170a2739e578f8a08b6a3b03bb0f5ad56f18fd331f58fa2cb34f64e7b25525a95a0b02ddee37c07700d86bde5fa41341ba70800fc4314722aab12bd2dc8590c5b3a975dfb81f98a37f42909e1667547bb21620126d7a0dea1c04a5bd841d97e595e3c407ea9c11ae3dc6b58876a338a8c718d2b3e0292c6b65418a89f7ed2a28370150f219c933400d9ebd379be48bfd36b600b55360aea9ae6466d297a5a8d5be00500c41c097e029f8c93fa3d22b018cbfd53a20e63652da9bec96aaca4012fb961aa9218aea815b719b8e02e09beffe502584eef92b780a57fbdcdebfa289055727ff2b7c2448a5ee88b460acd56b0032951ff708f338dd5911c9ed8d48218f70ec5fec76fc800efc6be3e415c65bdfb19977d4615f761fd3c4e3bd5aa81aa356aedf214e3c172055a1c22c75ad5208edc12ed01566895cd1adf97bb4ff471a1c65ab8b9ce75a517334ba928f83199b7ba16f901180434b64a1b17d623e6d2c21c2d15f187d0af5ddda89c7db13ba606aff31173b40d3b163b8149632f3a620f6c8a27c1a58f00e5a542270635f0fc32c4b30c385a4f60226c10204aa9323f79f06a79b0c39a270d4d4ce64361c14bc9758bff9e91646333e20c934b7b169968b2088df62f6b6b270d2cd6f4fdde74a4e19c65a9ede9ed7e21ccfbac86edb30f9bebd180f03fa556341485e295bfb289713103fbd444f0c4832455d04edc9b69c00953aa501557736e70376b1e589bed52f35fdb40e81da3d784c0008a1c6d60ce912fbbeb06e317a8c63806e50b22924ff790afc9041bf47db2f4bd2d6103c1074caf233cd267f74eac820a0005963529bc17221071590c8fcd5b841b6bb5e8d7323c0aca8674e08fd38f897bf36393eb282df7f126924ac60c392f64ec5e2570b2af8d1efe32be86dd003dd0c3916a4cb29993598ab67068b709df67ab83662669fdddf88c9165b7781497dffd68af3023d4415d3613202d48183fef5b93b2e2d19d069dad5e084b4ad9c2be95e83c3f08a974a75ccd6a60d92112f484a94e6a86e838baa5dd051df020a3f0d762e9235ed5ad5f9e6e8e5c2eafa5c332338423331f62a51af7b248b850321a4fcc8c6d1e0cb05c43b32e2eb29d9841a6865520d27f2dd9e1e871324f7ef2df49547fdcef5b178cfef0a7c2c44186e9435407d559244c79aa435cc26473a9f1575f461549a8c63959bd027423179ecd712d2ccb37f0505df0866b26c10ef29a67e0c4d53fb8483b887b20c81d3d7995b6a580640ce0f530f10315f8f0fc204bd139f1e80c3c2cb4bd5833d39488968f56dcc3216d3059dbcee8b0613e3744a947277283013a9008ac198ce7244a3b09e183fb7c7242b65859803be7066e28d3134a453d79b3f47a0028d32b293c65c19ab4a1bdc5a2da62495a4095ca80c8e0c5ccc0315e2f490a7ffab01cb670c54708b27d076e1321ddfe4b11fd5f2e52e6e1231c7ec49a5f026550ced10b1f732bf5d0f2598ec413384f35d7dcb0b0266dfd7b5a95462fcf023b996626977e415efa1af30366f13256aa88a5f7d41b8f0fbbc8357ff1cb39cfbe34c829bbdf1a7617dff976270a9b4a5f0c3c35c235eb766aa27b325ad123cecf8d5689d26176849f115fc9363eba9c3a6ee76be30b1f05448354c748ffb8cd7ab480be1662a62789e48e80c7420b6b2ecc6ccc1d7e9a91831a17fc4c4db0d4a9c9c39d109ad359010b3c9d606de5b4868f0ba38754352a20a82a45fabb5c5ad31951e5585be34647d25a082eaec71006ac9197d9c3fe1957496337e759570ffd8ad10fdbfcd4e9a3dde64bebafc0c7c06a76f78d2a64c05cf96b64337556529f17a811ff77da1491373f575285294cbd51415d8cfb498303c5f29d498593c18b0fc3505b6260797288699432e0cb9667c9d7d4718a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
