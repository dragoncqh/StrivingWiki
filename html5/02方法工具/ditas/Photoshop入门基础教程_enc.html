<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26eaadb0a09cda8aec4d28e334bdebc92250fc41260146db427184efc0bd007cf4cb054fd60c6b1ef78962f76c83ac333351fb9fa199542c52a026942fd0d1647b9e6ebb350d21077090fbfd5b4fc0626e3ac4043054db5d6b199d9e0f2aeb1b7d031618ec75006692d6d9b22dbb00411d4101b9be42ed59e440d001c9f537c86ab4bd207309059c58582a946429361877926af96c3bdb1e4fc55442b1b727cde5d5d263967565eacb3ab8abbf5d05bd72a8043ece5d360ae907716018ae35ffe5f152b0c55689c6fcc1a4422d3723e9a7e8542a60610516c784679d089f2411ae77b4790337c2572296fefeeeb7db8a6af52398ce3a7a6ee57e623538fb7c7e59fdf38d15798aaef94166218754bc002ded3a2f966055cb4b936e5321c5062963032dc244ce266e9f123289a6331ad73915d031565380656517256339a2c645b057a02de06aa29ff32750631dde81ad70d2461ce9278495ac3dcba442c6f8b505d286b49a572ebda114811c9e3ba5444cf1f92e54aea936633c0beebec62f2e8195b966a88c067f3c5213ad37bb39fae102738a3485f22a986190af633d5a8cf7b24a2aa018077ca53b16801873cad13bb53cdfc0b3bad25c7d6677de03a94c80c125041821200385321fe098447a44987f3376fbd0dd838d99ec38b1cca791ab35b168a9670ba769a7b7102832c7b19a4512429bf46be1e36478920d21033cae3a36e7d00d1d0c6878e0d46a70ef25f34e3ae35f0af40d2e289e29f6a9a3da464fb60d79cd6374be2b3eef97173a5a5df8440ef715f38e68a947bb448530afa9813e6e19bd9fe3d415165260e857983cdb13b16c6173e208087b9eaaa98953096e02a122775b2f9c0ab19cf7fdcdb95c6431b08224315e0b786a6ab8d5a23aeea08bdacb69b888d758389203cd53b64c67d35cab7cd7a7f55b1e226c2c066429b0597d702b2899e9c6004df65c1fcb1de3fbef68f5a3787ff40327337ca9ed15db37c156d88ac35c7844fe526871a2503221270c756275cf9a752e89b8d1888db48b0e615cb7107a14a6db096df516924f0c44638d3a7206d72a54de546660b54e4d5624749b7e00c08ad061f0f57c01a1f2dc9f5f3796866a4e983ed08f28fa959f4a6428fd3da045a8bae227887f6122efebde4178fbd9f6cdcb14e3ba7980fd791dd9b4186eb32041ca9e16ec944a05a3ed76d32b578510ee1efb238a1f3442f69ab43b1dbf7d3b53797950c7c7b20caf07abea01a6cb5ff92b08d246e4670f394f62cfe724e85c74b470f46e4abebb216e896fdac4590123a8f135196970e61bcc7422598813d579f521233e8d6b8fcbaedee59303051c23adb2c330fdbe978d73de3ccaf31cc10fd08842aa4735a1ad6633763b8e7dae2abad185b1d0c812c869658f3d4b527281c84289d0a02c0ddc844aa2a93740ee1aea98eb58e0bcf2e0df48a8e70d5e52544dc61df8365e85ac8b094a1ca9745eeadd0f9516ea0932e78c77885aa44ffdeaaa7446de9ac3c9d4c0c0a2e571a1dbf7ce652341b155049d5dabeefc883466546e4e4a4a72ad5b3768312a9bb38cf950a0c35ff1695bd1bd23f2aa16f210a6ef16d4521741e2ebdf5a3636fb075aef850215fb3dec5b678124342001b1e93bb62e5ca8e8a75df98c204b8413bcf519317b9ee729d543fd425abb506d1de719f2810d48e1a9dfb0b8b1427a3e817eb6973b41c6f1db6491d86638f2162761bd30df9be57421e03b1cd8de2eafc98f66e7091094624a5a477b215f7210f8a114153b1a3f74c82de5c6ad51c9f71f9164e48439ff8558bdd1eec026378e8ddafd8454e0a13bdd11a9adb5105d3b60df72b66b719274202bf16b8a829177de0dae7150dd9deb0f67be54d52996e6d6536e8276c0ab221f0cfa1ff4b17fb5d23bd57b68008e9edec8197c92f45efb72e61bc49253760f858f4f46c17ad86c2320d09ba955fcec5fb05c440af8e779f971bef08074741434ba141173833c0ed6bdd7cb3dcad0e01609edd5e786e13b3b85809d37c2566d39ebe94c5c05112df1bd2017138c340d035a5b346368320977f40b569ba7c82f4ba8b7dff8cf60da034796ea9a8f0705e6d8663a223d5a7510e528ea975c20f5dc65e2ca997c5cd1bbf8b38a327c1ce6bca386d05aed6db3041fa59692199b4652358aad153df6d3256547b1bfcaca8a3d5356d771c8f25a87939ac9feda99562d49d08f011ac4e8b551927e0863396607a18cfedc12dd865f16e300e4aaa27c098c5367a55109ff6737b863cda0a453e4935315368d0ca55b72852dfc7a60b503b85d443d9673c492fca4c2eeb27fb67a5cf40139fe292b998dc13cf3be7e9bb4219cf3761ae67847318511cf5fe9a53cc09ab2d654101796b416939253a558c3ca92c74b6f256fc4efc7a78b30080123f6e8e94fa4ed95e4404500f2dd3fba777e41a24fb09bba8a9f641f08deb332428d76ff68e12215bfa0f03c42d20a75c836a30f88dd7944fa34f53c4b8f3a3840b33187eaac96ecf66a326e317c61af1229f23babfcf6e47385d5b7fbdac6662e58985dc25cd64d87eb41c24bc66f779b32c6bdb3a915f1566ebf87b67023e89e636bde3b880be65e5fcab95e605859635eb8b46219e19ab764bf3381846b106dd7aa25b989396a84823c5874485460e1438717b55e546aa2398036c592698654d03eaa33fafc11c8e491e95f42cb76978e4f9df49d7f3da14e2220a873ed9c943100b4d8d7c825127bc6ee3d67e1bfaa9f36045acd4c581b5be58cc849a4d93300314c5483818dbe8af0a44967c5c4a5794e2a8e06cdadde4adbceeaa87ffed2fb22afdafed51161a837d430f2a90c588ced1045627dae13c7192207da7d8170acb9d20bd33c025b093fcef84f9487c6dca6d9302eac715ff19ec361a438c7b039f1cf0c9ca409aaa662766621d88dfabb47969bbfab5460505fb288a836d2b6b5992232e70117a945189b6fe9a57ca02ae1a96296948946bb9d408a3a016d93956384ff3ec99c7f9620438b127f597e0b78bc839feba70ada189ca7ffe0bd2b5cc05657e3a35783eeb868cb4ca99501ac00c29c9901753ac76c4b520eaee56838d418e1abda9bf7b78ac630215b4c42df16429359d23429273c8ff85b9980b63fd0ecf199026b4e0f2a81166911b502daf7b3b067584e24d8cfd6367a9584a503267896933f1564998a201b38dba3aa165ee47240f3efaa98220134f62388a9b18e77261a9dab0041343e304bb2146d7124ae90a80bec29798a9fab23014a7d76f7bdb296c77076ba03a0e0deda153a89983df320b00c1c6e8555a17e45ae9ee70bfc9f3e033bd7ee13b0948df8745347c8cbc9d76fc8df340174072c0ecf60c209968ecacaa26f75b6b22c565d1748671198d3bfef1b7ce7ef309ab0f614cea833d9c808c76f239a5819035e846b9fa82409f8788b009fa4ae84823109efca476ac8acad39ddbf3cdfe733e8127040935bd64f408f056e71ab4387329bfce5edad82d299c626b4572c9eaba67b56efa233d013ea7c82fbd59506ba5543484c88d2586a2a064985f79341260077b9cf6693b615ff3bb63970d00d4fd16a2ffaa3a28e7c3ef93408c87747a6b6b2c85be6d64c96b1e5d2611d96405ee3857e71c2e1574484d5423ce10d00d6536a65a94bd4882bb847016832b2a7161a13da8eb60b79687d902d8f34200eca780163acd1b21bd1a17e8e1431416842a88baf854cb320393d8e77c259a84a071379f5fdde0c11021a72a50b06e78964d9002ab3995b369e1636e5412c1654d35e690ed4f47957e1fa924d1a6da50eefb3a65d137561ab9306a9b9619ff6a5cf8c36194b828558c349259f543016eb6249fbdf704e5a79c8e0da7bc5c6133ad7c0e1eef81a3f8cc4e9e51220b5eddbdd2ccb16b6053d41304d7d497913cbe871e1368dad32da6da55cc0ca99b26de5541334f3952490cb128bd7d962e294d9a3abb358b939fb077cd700fdc9bb77e174fb4c8ac39e495d8251745c29c0c4aa14e9caaa453086dcf4468a60f0235685b052a60dab883d93a12df5b1340913a9bde107a3207db22cd49ce5c9de40e399db83523b9b49061f340da15cb175693ff153f2690d8839cbc21cb6bd340026aba4359b4e41d86071aab1e29fc33a9dbd68a1989c2fb28e6afe70271f0edde76855690bbc6eb431c240172653ddae1757393385bacc0c41c7e762486d38908a61f0c6ed2f73269bcf0f95fb77a6f005e9f32862c563eabf235a8873fa41fd90185581b09f129ba0be870dacbbe12ea7a6d522a2a3f5f4a9e4de8a0c8837f6fbeff6e2b81cb35659db80a06831728871be89698f05b0c93fbfe35b39b93d9c6af3e4a68f96a22fadd6c9fd34c2f550217094fbb5dbd72e7680bf2194e6a4ef98850cec616591fae75e2ab4c869787059e45780bd765c476b436668b51b42f562a36a2b77fd45f9d646765a5e5faf366a44a7745e86f28777729fd3040a09fc140625213601fcf14dcca6a6ff11a5c5630373f24ed0825f62e12cc6358da2aa28ccb48b80b0a7e1077c0553b6f2a9ba1cf54973d330707d6b0f483d7448c682889782e21f14a8564025d71b131b90dbc0d69c9ad0f8d757cf88ee3464ba70cb9b8f3115a688888d48f129ec675961d281505b921161acfebcb338e3582a93101fa397ddb6353ddee782adb4ab36316d64d14ca815c710a2d0a8796350e96cf77de56f1f93201f33d386d89833fbc8dcf92d2a4ed63111e05649783e82f8f5f281adad7919c9d3ea69797aa39fc3a0abece8c290ad74b5fe2e60ad06af7f942b7d93bdd430608211819141604e2e055d8bfaaf1e4d878e025d85ae08f5ee8e8bd17b51a540ffae366790d7a24d767209d264c7d2071219a04f9a2d03bd0e378012f946145e5b4b41edfaddede9e4d6cc5dccb470ea468692bcdb04ab55d15d360487d81e0efacb71e3df0339c5b249405a594bfad991efcc769f37a6fc644ed63f50a231d61a0ce68290d2d242776cdf785805252e3c1950fa649e8eb0990f0a699452b4a7cc804a8b99cd3f1fcdb54798550711ce1ab0ed8afc91efa607c728015b1f51e5385949d40045e57d650dbf99aef3f8bf52b310b87a7cff1ed67248476acb0dbf40bb7ca696977e72adab156df3b72fdf4728b6eb9951dee7807442a61262ae403f5f38721522c47de8022e94c144f412c1096138853c662979181c15224540bea6605ac9f2fa55a70a9e68737ba83416c5e382449f32b4b57ec6b4c3b2477ff82148f548dcf673ab1c01f39e13d2106d9abfd41e213c7982530752e3acc7a638737acaad0c21d9b42114112cba693764721361dc51978be232e136c5625e30c4eb15c45e74c6b5c7f56e34724d0904da70c0a3616e56628945e21ebefe8b3733c4a9b2c6687eb87e902fa4769e28a8a0ef514d7e6e6612373f7db4a5106b2254c9318df77781b3d7c6198966a35c1e6da4c1e3d8b87baa8534818fc5f729578d675157fb1f5d4207cb2a861c91e5502235b3b4db2fe269494206eae8d42302adffdca86eff8d9f1e809da67e598b8a8e16c8dd8571adc1d074700d85a267bdb9e4dc29f6cf128ed3a7ac9d5500bd43c65c9666326022a259eb875ab772543a47e778643c83a9abae1f9c66d9e734a761a72debcd43468f9458190a763e77f3a1b6bae885002ae8cd93b670c94608e993bdd9f9becee776750b98e4e529b0b308e08b9b54ecc78531a09b7a87e2eb3a406f74a35bdd6c6d86ff093bff720f354e75f821e5386e8d4b9002b1a39f808d7c0677211ce14e077c3ce476ecd9b3ad39b02a5b8e471b7ce42f632b70ca25b97c6457b20c4432fa54ffb6c0cce8b32ed5919465dd551f012acc10221eed4f0d3cb9730a4bb6369ee9edf575089102a4791c9df65bfd6ed6d80fbde48bdeeef960fcfdab16f238fda3352972244259cafffafaceb0a03461f8d470844bb26f4167d58f9c4b9fa03a52180265e3eb12cbdd66e5e8509d5bd8559c975fcf7c7a50257599b3cda1e68635be3a1bd45b0ac0f0af20c6bcef82648a70633d29a7450f4640598a11dc20903d06f3bb944cd4ed49ccfdc3875aa496ebf8c5c99cb78bff280a195d20a432a49e046c74d6052c8b0f35c53fda60f321be43f773755936a68c4d1f839c8b8e85b59835d3ccafc629d621f9a04ec39e6a9f4cb98aa059b6e204e5d1bb1c23d15dbc37df83ba1c83ac0017578280f7b06a2fbafe955f24c8231dd7fb88558548328ceaad4e843f7014e3256fcecd93b3f599d83bcb658d68de13b571ef592c31c5004821272f064a5523562db3c0d43bc9e1bb9cdce3b566cb9c01c729da1514833106942ad339217893be385b6764f8fcd0f3d68c93ceac4b1184138ed7a2cc4cd0e1637f03a889b05a7db38bafb9a1fa432f310a5be1cd3fe00ba99c17043f57644730989e00bddaf141c3c94b7a7602faead87a83cd8f6250d72f8328b1d1bc28ae310b2944c9194289331395c4ea9a35d6207fea94453d82e206f353d5e5894756402635b7aebc9aee703dabbfb173dbb2be056c6da2d02c32d0db460d3d1895f88db470fe0fc3ec76aab9ce7f3b47a00a81cf5b8d82268cb4ea0972cfddc1cd2d30968127c2ac27efeffe029e8f3fa96b687aeaab88585ed24abbcef506cd6ca55ee6a856552d5a7f00ac4e3ce90e81e3a4c43b24d125221886face47dea7dafe9a5981647403c53e5aeebce3bed910a68890691e26320ae3073ffb3f0dc2d61f81b5b4b50d0548c67d34a7449380b693f8de598e00b86d437186f911ba59fd7805155481eaf427304cc41446bad1192fbc4eac4c23411222c9e1817e5e8d5c0c619a7e8e75d0bf9c72a84b01e4d6376f40a026dc70c5d415cb6daaae8ac375774892b9a9629a211df1c2663b8f8f3c0b7c826438d8dd4d6086a4ae4435fa7b131183c5c8902550edc6a2dbb38d6a31c04d0333ccbda2134be446ea0476ac44d20d6697c9fe0945c2a06134eaa9e718b06a0851498edbd66912f75b3c56656fb36bef79b56dd73fb7a37a01202056745492c7aa2209efa0aafadee9eb736882714601244e139843e7f2f74462168a21de662eb0fd8e4a6a543f32057339ae8e479d560be85dab5abba693ab1456097a999feb70e19e00f21b2f4c340598d089b44ee19aaf6551542944c28b3abe38d66c135cd37674234afb9561f74eea418f6e3ff10d966a8743ff57b901b231f98809b1e1854bc4622fbbfc4b5c700a1c9a5bf1dbe1e655eaeee1aa79bd04e766527d154f56ad623dcc028b9883fad2e59b6417daa28031af1bf6d6acf7ceb820a8ddb5807ccf88ae458236a0e5d9726f6d233e0c3312451053f5935170bc08bb27763819b376ad2b9ead884c0885e28f643fa0c286ff8221049257ff7daa41c55d430cc8685c7ea0fd8b5faeddf03ae1af6c718b93cea43973d5268f9d4e8fa54e9eb3d1e50e2f12b4728c748aa80e9b7007244b33e2af3bc674a4f1dd5a6e27c408e9fd2869c4ddc947f83908f9adc3e40ecfe9c6c54f683d57e37717f618d26606876658d2940af89d1fb7ad834ddf58bcb86ea290c7b22f6ef7680e4cf5651d0ffee8b0f2058ada30b39701e5b87f04d7d41e2bb6e1b869ba23cb9f73afd65280fa469aba36ffce98acd26d8f67bacea2326b9f7acff60742762c04c068e86c825279e93290955f87f2532d1c9ffaf2605e90c08548f8bd2a0ff82542ffe43d1452bba242770ee65cdfd7005bfe4998a0247154de8e4443ca67e213baa444b325761a50f112dc96d93dbac236cb2c74e6dfe64cbe3f68a54846915074d3d274bac024d27fe6fb9df0cf451fe119d69cff2534b0e045864fe6e0742eadf174b10a425f104e5cd10e0c377975074fa62fd75dc53f1fe9ab23dbb5815bde9ec1b9e5ef5cab9c4d80c93994a9569c93cf722360a2783731dff3e2eb1744a3df96976a5698a31fc97338369c54cc7108f96b0ba0a18368022c1dade15ab5b3faba582c094176f8e51074c24e5b1c0472c7604ed64b7a7dde0e83c5f4be0d77d6bd57c97076dca4d3692c0f763a9fabcc72388a7061468275573e1c43c465cde8b6484118ca64195daafd4ff08b93829adcba68c5da9c2a74b900243354110ebd1ceca372e29b839c91477458970b8f61480d07d7c287e35ee46351ad50c8e7a64f67d4a1bc74ecbfbd18fac1f65210739f2ee5f285437c9e42a13b9378f1a082cd041808a0259db241798708d33eaad7bb8ee60eeea967f35a7130f27cab0f61b2d41761270d220b955235818e884ccea30b8ff6f01472700ec15f958e8d4091fd50bbef17fde0a708ebcf4c81ecce25dcc63b96d869a9bfed62911fe9847a22754764be3c1d454a08e4febfa27127b5db329e4e7573ae2c9ad183f7474d6d7c9b224f82098a01e707c84edff6d3e3de930e0874fb87625ad4394d4079cab19d5eb4bb5b74b8aa57ec618707907385daf2407e680532a313b48ec50253f32c1120e5e1a613e18295177729fd1d943f1cc262bbf77b9aa86a7d017c0a36b57d9a2740f801cf31c28f5d57bbdb0326bd80498d39507d3ce77e47e99e3347f03ce6bcedddaf253cf50cd1edbdf1e6e096f72f5c9e4abd2eae0b464cd400da4356b45f9f4b2bb57b744c2fed3da22a06d4add5ad0cfb9a8bec11942a64f8f82bedfee1285d1aca6d67e01b5c2bc151be716bec14f3900a9afe8aaa7663018b489158be42bd86049089dc9c3e51e990c44d0afd1799e36d65c0c19fdc306db53bf07eaf7d5eb0fb1b7b5c7ff626e281b825fc2d1e43d0fd3bb7f71e01c1c98f05e31ac34ede36150aba7040a78d373197d0b6c003c4e2b1f0f097b77d61c165ba1847487c5d42e8995e19742e5baafabc7a0cbc1c0724f0d92ee7781ff571e77fab7e0c7aa425c5675efc4782cf831b1958d2ecbe49da52d50f721a7dca8b3a2e8d0b326c3714add06fe5e9c4a0af94fc351a2b69ede43a8aa63005489adb20d97d28eb6ea51e2e58ab77046eca18b83b5e04378dbc99e98b2b75c4c3362a6b08f2096903ab0ca81b6259f1a4c934f8970be6e3046260371b05503bf3ba67e7a8aa2df209f452977f1320c31a861ca002071ced59c79eb3bda4e666f2f1e7a67eedcd582c6bc9583dbccaf8f6e7fa335d5d6d3e96536ca722254f72b9719a5fce10d83efbcee29e4e24a38ae85d0fc8bbc7421a285f13237e60c6b6c28d9c851afde20bddc65b01c0df536fe76afc11414523efe4c8e6e742118f9f5b458deec542177cc555fbfcee2942a992f5e5f47114774fb21f12c100591eb53aa5b1243baed029b9c34f27fb878524a37cedbbbca922d0ef4783cba33dc94db14e52d2b0425216462cd8d5dde83c8989b9436ae711a69cafb5d9c544d9a156413938cee8395a070ef8fb2a98c8591dfe8a0c1547e8cc8faa5f49577651412449f7b67b245fc4dcd57db846ade414bcac422111df1c13fc076600dc62351b13b01f0c988062fc9ead19aeb24efa773b0ab7d0ba338c9ac5c163df5eaa211cec68042bad34991cd13203d4189f94bae2472cef36f22fe6c474e66c65abc5034838e925cf0353ddb63469591ce8e55d19d3176f0ecb14f53ce40fa86cf03aedc84c5874844928afdb14b07456ade0e436f73d6e80f6347219d502721869604088126719baaba2c98a14b0c09cf03b18c7a4075b986fb47b408c9f55747a0ad30b67e6faddf626a1b42f019e67afce7cfebc3cd10bef9fc851fc2cd68c1abfe097338e78ed8bd9733856713915f3ec1d792d7583616206795311eb82c279fa85d0d199eea4c987055b1a0e5efc15e577a52165cb935bbd890a3ae0e17d4e3e5e316938d10e672fc0d9afc5826736dfa3411bad8f1d1759e8bbd7b86381a4254e33f2f8cc7343bca044124bdb0150dab71f200b6cfc888cfddbf0a445a47242768a04d220567e8944c6a5e786ec731cff85eae595f449b062c8de4c23d1a64fb62cecfa810242d5574eeb066f894048ce0ae720b3990be49e2c6236f13a11cb1416ddce51fad2a53bbbbd833a71669920d1d38c68d9fafb312742380c9991f605b57b0a04b734d713e73d99fedf07b34e544663671a0139a908681add0623c3210b22b17f354c4270a6a44e951559aaf1e21d0aaaf4ff5728518015981efe06ea71c8196adfdce184bcf2cedb1dd0e2f2d6b019ff18103fdf2817386092f482560a4f027a1791e832fe3ff44c4d1137f903937f57e2b67465258edbdea758bc49cbcdb4fa293a7369f08b95821f83e7709e759ee2d96ccc468a6c0a9fdfa909caeddf65e8e02b4933f597c99eb344f4d99656c2205d23431ba0de5a5cc3136222a7175180446062fd76587477abc7380dfce98935b84d1d2bca9b4040108365150473f629763794d98c437cf86e3bcde11b5e9c17cdfe5cdfb954624e184becbcbcfd94a434b40ba8de74dd33d1178ab9288c5b61574f39b4ce9ce19e708f462d46fe7cc7d785ad17f59b30d4407baf1c1ffe7a98812d8273c687de78a94a7944a28461a5cd146a2d3ab0d06c581030bd642b2e55c6a2f702b6a7bbd7839c2b453c01317cdb350a435040eefb4207de7e7863acf7dbff57031375aae4c0c8e073842dddcc13f801ebd5c511d034a4330b8028b424323f308927d593c38263add744346b8f400f9247a19c922823f80331b68c45906664e0496b2152f5dd91132cb29e924bd028dfcea9b171ef8a773761e7bde11c7c19d339490795f61b4c6ed62ff42cf0a3f27ca1d670ac7d7f73cf5bb416d43bbd1b5ed2b6425436d5cfd7234b831c90590945900859431211c686c6e557212f7414f3d59c20ae2e1904ac0f061ae28d724cde562600b6e4475d00ad56bed57d9f55a85a316968ae5e64776ea1a2df9266d69cae8c082e169772cc9f637d167c1488f3166ab960393822e794b3b17756cb1425ad360ec9155fd905169a72464413ea83b835094a414ffeb840b8ad1f4f09c154bd23de400489fbcc2f1f418a55bc429f10b5054680848bb63a1429657f14f7d010b57d1208b98113f00b8ee34b3c4ae2f26dd6f1cb5ade1fdf5b5a33b18427037c02f4ad3d1b6307f9dadfc4ba788f8d6d1647184060cde402bb53171dcf221d4e0d8521095f5edb5b9a826c9ebdfc8d40ede90d3104e7195859c17488385b893b70c5e9f9b2a560377fdff723e19e8fbca630a02538aa2f08a40c2ddbee1b8ea56e2200e9da4d5802e4a7d9bf2dc724e8338a560fdfa3522e265922ee371130f787daa726efe4e7e2865c23afecdadf90b67eb38ebb0b915f98b66753cb18c004d91cb7c5725d7ef56ba67d76a397c61b8cdb1c86d051321a65a3c858959152fc6292681bd8d1602d9f694f3f7da49f3172d6c6d65145636b945b59bfcba3f1f868f814ef57acc3dfa403bf140d77b52578f0802632c1a55b915a5a25953b033ca5f79d59e47ec611009ebe4f60c711b5a77cec7e1fbd68f23dbd2f7c28e84610ab4f4699e13452d952ce9fcec7134429d484dc6c10def7388962ddd296159b9d7778f08b4366f43606935e2026c0d38dd0136c30b1301a6553ba64fccfdbb2d516a5ac766e647e60949c373e3d8f28edb44bb593e046872fb638f21a58688fbdc60338053754fe53589953bdb4840d5229283bbbc349332fac09f2a707c1ca3311e2daf1a35334f5aca7c3e19174c177d8bf331661c97edff5bae0a1ee71bb89b6c4d87e85f4110962977b8e123b4cf830f627936835669683a4406727bb7f7251812415c5faf2ce7b4e997740723a7d2e4a52cac99e0d02c7bb091a1ee62aa3089a97e15d6a47d05fec3734ae15dd9e8895bcd151d75ceb8fd8172b16f53c21ceb8469c463acc0d1e5dcc0434ce0f3dd51266f8e64a5eaea3fe460fcf3c9d9100942a65616a99d73a00c83021ffc29ce3e35a2bd25961e76a79a81881fb9e4281fb597ef90238e9208b178f942122789f47d79cdab69c005bbcc5bbc82d68e07101ceedfe4ae8134f115145f85834386d842f93381677d22d12ad6fc7b973ae337b675d5cbfb18ea8c72f8816e5d1062f51904ab8e63d8e84a2b3cc6db18f85dbe60d0625cae19626c3fd867fa26022c309151349b7053a71208cc8d8a31d1f247161ef3638e6f4c131979ad4d0525bab06ea940dd7c9da06510d342cf562e2a8af63e0229c97da7fe11c2a80fb6f2166f6f41944c5dcff1da8bb09977537a3e1e2ff04acb5105a2a98d3b8114af43112c34fa3733b3dd628e1a8918e4f1cf5bf99a470dc95689f8e2b3d1cb1b61e4c1d1e88a01b6972f25331c57df520823df94c34480c610fa6293bfa235722be900ec79a88bc483fabf4781d8415caf7c0c5d065985e7e05be117d121dce1af9c344d2795325a9c6a18d65842a4612b4de9844a8a2bf768e1464b4c8c6ecd997dd73db0e9ba8583c9691bf61bb231d7537e296579e486e09d554693c460ffc95585058a89a23379ae72acdaba0567c0ac5af4dc496c062be93061ba191df3322a9dc0866b26cf4de7dc232f62bc62d05123161bf70af014e458d1fce09042a415d8e72222760db5fbaadc452e5130e7f3080db37314507bf7215b198c7ed4b8380c396aa0b6150f1852aa81147e0a82cbe345c43543c1da347285f5241541e177323c8707dc1322b87831073f00c913807462b3e9a2829c941d21831f86c592d83b300e6c15fb1d5df0eaafde870de45ac9a00324186cb43f3d4ae762462b70c60aefac41043f4483d059ff7faf13df7bfe945a0ac35192e40b401d56d3f85c142f83f22d2989022caab223e0270438a3444f461442180b0ddef83d51fcdd83345788125951e0e09d4baff997135ff790e6be3a666352ad51c6fdf540749d383151487214ecac40b9e7d0276ef6849a20ff7eeb6d6c4a5484eb5a3b7d24f768abb24f24980985a20db7bb9b42ce0761d6f440da6d249b1e3df0b291d66fe6f2c84922e00f8d54808795cf7f16674ddc887989f06c6681df657fbccafe35cc5ab390b2fef936b62dc6acd8f316beb038b702041ce88f2eb4da8250fe28f964d4c295487e3eb4a7d4ccee020c96f462fc693146ccb2a39e483e6a74f68c235f97ebd38d6b7c56acf0a0e313f3f0fada20e0ac601fee213ef6d1bbfd9f85c698b4baac912ddf7e119a71f6a26eca5b05d4700943a46c50a487ded37d262e0281641fe2bccfea70b5e944de0993e723d647a71df493282656f8fa1598f325d3de32524076bc8d7c59e6bde8c288ff80352d99c651d5470bbf1029c8c9eddab0bdf408717a11550d95d8db3b7e870a30563d7280541defc371d2fbfa6b93f869b64ad7ae1d16b2c01aee56147962cd2db190585fffae87fc53f59f03e12b23343a25b6520e83952d5aea95784a146ebe1fbb9ccc7ae126a9e93e1d71d0e348a2fb8439ab33e72dfeda5d1542be66bb9a4911de43c26136d7c9c6de1667194109398f366a62d86aeef279b50d5274208d3b36d70b383a966df9a8d534b14b90c391ef747e442cfde23d56e1b39f3a6b0497d3e7aa97b7a520c51ea957994b2d08cc49a2d1fb91018739a4c046768d5ca7230d0ee3fe0189c20731fe704cbf353673c14e2a4b835c438cf09f5c4b7fbec9497fcaa3777878b99fcde91dd19cc0ba8c15f14fcaf01024f2ac6be1f7cdbb929fae9b01a1e69af0633b7c1abda2ae49077d54635d26b9d2f404454c29ab80f88f66f6aedb555dd17d92231d22a7837833dfbac461825c2b8f870373bc776dd56bf3e4b0b5eaceb9b17965cd65f50eb431a920479332528faeeb0b57003162c4be0896b6f82f4e1bcefb7ee1b359e627030cc315b25de746c6516dfe7cfdda9530dc575c69924b1e19029a49bbc1338fb7c35fb3a3713af420200b14a0fecbca5df909d26c5e212b64c62ed2b250931887e32289b3ad18ef1090bd1943d04e3b4a99721df318458585bc8d2bd28fab693204d43fc93dc39462733631e75e198f6b98fb9e958f9376d216fdc755a0773eabcc0efa7263cbade7747834186a6f19c300a9ad4d688bb260fc8ce87aca1bd5ed5d4980910c289acad70931a0c518cd34696f9c59b698614f697226812641a3cc92b32be98d0df656b938a79d195f9d3b7add605d085e20f214088d5b21e8d664d95a3d150ba410b1df5331ef8c807c10ac94215e0cc81ddfde9f9252bbb9a2c9747b29f365620c8d56295ad15e828af467e6189e247923c87b967875e06dbb67e087b5e6e5d37cc30e880a2843ccfde5eb5347bb1f907901d61f8acb63d9f0daa1eee161beb20694e0c9ba735c85d4ccf93408a9c547e5a0c73bf307cc4644357f73ec30390d89c2725914a731c5265d0373577f05bbd3e379294752584f45a128fed6afb6fdf6be56d550a4f9c82a72e925d7c0bace88a1255abf36375d363b6a87bfc7d30013584ff9c8a5a4cd5b9b88fa6e9255a2540c05035f8a881dc2ca8d60945a8c01c7652d0fdc1c5035fbed8cec58e6fac2bc98077c3464f62ec7c68b3a0051f91fc64a3b4305cc22a187a758bf9bbd7c2df3696d7fcba325602268122f91273b2b12774c14623cd1b284a60914ce21127ea719768361443225287c0da0b5aff7c3ab96452eaa2a19bf925246b18423ee4475ba4ef6c8772fea272311c4818c53d9ea3efe3bc0774aac7c91bdda16f38a850a23499cba29e153846ab446d9dfe0a913a26a0210b591d536f2f83756d13070b11b17fddc9d9c4b0c60ca2daf78e23d024d27dae5fdee922b453bfc1e95c9d7b5f8287a10ea919208e598720f1dc8ad310440132df39f633dbc0cc16cb44b925f334777bec2d694279a4c05708bf51ae15d1bf22396aaf3749cc1b6ad8751bf3ae84ab429338b27347af1ad8aebf4fed2e70953b30e4c511fb55c7a4835f2272895f59241ef857968239524e4cd5ede01cb25a703bfdb8cf245cc7289062558b5aeab558167ec5de5d4097f1070eb19134c64c40706a54c42733f536d1442d05080f789e7c88270de3acb016071e7169ec2558713c51868f24fe682c4dd2aa6d953a79984d5b94d9c18423f97259259620a532adfc18ca6aaa3466b83e90da9176b2a2cea11146049712ddb53552bacc2ed86c21afaa5288e9e4d899e94d6c50f521a0b9ba81e1cc1514859061203b3b50556a77aa29923f439268d409ccf45bb9de6fb70487fcd4069f5f84ff611de36531e07bc4cbe049cb5dcbd071f6003f757fd33118647deaab9344b4487e4cea1322bdd1ec62729de13b248017a20be45e1ab903047d3bbc573d90fb7a451bea514a00160dda8c76d560d79149023507036c93d768bfac6832bdb4a393162d22eb79ce9eb29f6c2bbc96bf0d3e58635c2df638cc108a6e917a62bdb799e3e65318eeba893fdf1efe33a93a07a2b38bcdb446e772134d94f1c0ff45bf3babaccce54270032a6695dfab5b028cc39cbf8efcbddd652625f1ba444b5f286e756b8cc70b4894bf11ef54a221b3be6e90c8f4872146a40d1b557aceece6cc49922dca51d20c6513c5ce8ba7f5ced3268a6374a3269f58ca84437ee19abc946354244ff118fa0e324e14049e070f4e6fb0105a93c843453956b605d72557a536f7463978ea27452556bffc74573c9925f79807d25258249998d5550011dde93e7fa0d2f66dfee7df72b54fb6ee8d4be1130d6d1a770536c186e0577ae6c165154ebaffb4a302f19ba6ce2a422f32d7333de51a5ac214874fc96dc7fe32d655842f4efc6acd0a350e93ba3209ee6f6e3940a661494a359f5447362bfaeab5b64cdfa1ded0a04545be51374ec6a74ca64a7edb80e3fba6fcfcf8f8b9630d7fbff8eb3e0c71193846b85eda6ea459f9c93f6e4b88ccb4e279e2292adfcfc7d26f212a21951bd36d68bf37cda26a374a18c9a4f0f1a42c1f3748d33d39718f8be27501fdd86bf34ad03a1d4e20c2d329d2652d99557695e9f6472d515046bf4fa0c805dcf5fdc27979c43d4c05c9cd2832274d4b43c1733e863f8445ae4ab7fddf083c42798b95da32d02a765399d8e3498e2df279286f9a368dd7e3830522eca4f8dd1eaa902e4b0ad5c5bba3aed72ada51429db1d90fb5d34e11d1844a48e81ff694f33de11ac20252ad30dd21c4fd74d21e78c690b82fd5470273f2483db52afb6557958811d418c57d5eb3e80015fa31e4b9befba85fb1480b08041c10ecdbee6492bc9fd78e58cc9e1dd6bb264f72066c8be90da9614973f1dc7cae40f85a3733b9ce7fdc1439cd2d5d33194d75c264019c22b60595bdbd719d8b3bab54727470958eaaa80c685ddadcf2406404a677a73a39f6ec44f66014ad72dd062036f216d5069092e1d62cd5f3a0f819552ee479509865b7817fe1e23dbb6779946d559ef134b98f2cd500ecd49514fc1d78b54e464ea3a4df1c3366bf511851e72680dcb83f41fc6eee1eac3eb6bf54835303365dee5383c1dcf920c8f9148301f661bd4a479fee4a35bafdff91065c0a4f996b7efce33c211abdc55a762b52718365ce60a410b8d830d69ae7b0258f93a500cd61c2badae459aea2b0db2376ed6a19b78302eb11b0e7f483d196d4560a445c28cdec8ada6bde8a123968","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
