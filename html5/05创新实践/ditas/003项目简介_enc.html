<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5538f121ef3e9b91cb91948b9a83fdb4b4327f2b9d89d7d70ae1e47c58ea6715e9328f03ce264cd44fc54a3806eeda71b51de00df45a0cfe92c2d65bb09b867e0c31111cb5be5734b2a8073827c23492a772f8d267819ab1df36ef65029f365280869d0a6c7aec22fc2351459ae3f99b0c28a08e28563039386ac32f8b23db174823cc02e3dda01f7ec6b273d5cb2d98f54a2482209c3fde8edc686c59d0a7bb8a10631de9ebbd310bd31dc81803a087235aaff712584c6aeec03f14cb2a22ac329db71501c70d269108cfc2158685aca1462004a5de66c261a7563559cfd0fadccf64b33752e504fdfcfecfb7200d9a98c574691e3a25fe7e832f680240f399b18932f7db0ca9469b28e5854e2f042557bec9017c46b7cba5fddc1904faa6aad21741a1b0864a27be1120ee08e8c5c5ae7c1d3b19249208f941b973ffc25911d1a86881af79c74cc685c3dea72b70a312a88262f53924f425c185cdf6c90e9ee4b97a81a0b5e4dda5f6750790aa61ba3d48f102fabc1014182e1e6a666b16066c8ca8cd31a06981144ca0dfe3a8d261660a019891287610b3407955ac4b670eb5775ec5049a81bd8dfdafa8568bc3db40cd53ff2a0f4852ec9992282b9a3e21efd42b5d3d897a232159a7cede74d728606e5f9b9ce19394214c31340364e60b633a7538e9289aa8f336a8c10c7ecea7eb2cc828cff058f770d66cdec774db25095a4489454d8b0d70611295b9b8cd737de3b5b5bf3a39781bd09b9b41fedc0b823519b39259145d945b3abf5ff26fb773d74894f5855f79d01632c17df9aaa6fac9c144f1611ae63f5e3dc2e284a742f4e0f0e0bd286f1900f58bc7d584f70942b9f78167821470eda685ee28ccafd95e173956ded1d4d40a41853d493c3cf6b14a0ab5e7da6c92bea4e611b8dacc6932148f1c56a3eac61799daee58884ec93503007060b2fc9497d10cb48d58582e6ce06011977af0fe4276cc87ee76bb7825fe88f49917e123295de21a00d49a2dbf7537e5f6f57556c031e2ff6fc25897206e00c18a2b5d24819fd620a5ddf88c16232938882ebb2b3f35defd8676d5e1bbb86742df133efe9f112ae5c1d78bbc289689ace2bf3bbf74a09385dae8739deef7c461844c21ab16635cc9cb76e8e2661ac93990938bc8c8dbb015d354a106e921de824f639bf4195ef42b113fa963994326ce49ee5144a38e32183fca04d714caad4ffd9c7b35c2a2b227d8a76c67529ba25e7de962309f51b57ab3c8245028ae228604b1bdf0ee56ef79547e3107fb60c3c5714fa2793fb2c04889865936db362cca4e69e4c92db30137248602d9c642b7467f615304493e5f48a89f9d5daf12e4667f84bde5c3449aeca01ed712f99cd98ecde9e5a17c1987d3ccb7ac287e9ef70e1116a3ce0a29346ab56d9b3e897ff3b1c48d2c52869eae223353ddc7c5c5a9109b8870ebf28ba08f3c30d2df3f74fe8a90e7f681db50bb1d458e6057a5632d4deff55c638b23f5ac5aeb75f7a7b4d9f2bcb4c464a09832c543d2486ef72d4845d1f77ae1e8f03cb905265931e72354659125bdb9aaf13e482a67988559fb73adf8f25be14068239710252fe293928b23f70237ce0993635c75f2ca5907826d9fa11eb4a455d51aaaf5d06aff62138c717c423c70825ba049f23a45f000cb74e7ceb66939f0e439dedba34eada427cb794b3c7bc2cc99f9f27836960722c8bb310008e76bcc42c994580a266a2c4f1437e857dd9d9f5a8a4403f83daaaf6187e307930d3c8f19b5739f4be024e1f3df06e05d0c32b23591b7b28194f33c3556f1a5c0b46deb3d8d06719da59a6e386b215ec9e75c07dfc98686108789329f8936d5351b2a0ba264c256b84e8373ecd049af8b212f11abeb8c495f241409ca89b4aa22d11c517591097400a620c993cad9e9258ced9e6651d020e99065d9f94782c6c1cc4e161a73cd65099a460eb9b799b41064db661c31df58830f2e174e71c938a31c4b1429b1df99c00e30f0007f485a6736c5c0525b5ede21825bebd8963a03741c5312d7da0ff913821263f2cf447d81e63e9eb78e57cfc407a55a4d438eb7bce21caa74a9ce0bb5c0bf5a9f8d698658a12e0659393d88d124b75d37dbf2d17bea9699e5d09fae94aa0f69a618f864c11972bdd4d8d32dbcc630b699f6e3f43809770f07304dcc3cfab7dcc53ed2c5b6f5b1b534570f11bc3bcae945fa3f81592692da7986d520b59fe5b372c2b020a3920ff8363f06e590bca1a9ab7ad19b19b0981677560da04ca4df574af97a19d84704d5f4ad69fa237c5defa782018b3e7624f2a7cefc2272bbfbd6eff70532045ed0ea8fc617ddab6db44655cea6735d0713992a72668fec4a1131d0eb03d680e59066213f5565ce335825fc5c77150f635f14b0e351ced048972b8a6de2f7f2f46baebf9323e5442fffcd54b2ea742b34e8adf0f5d477bb8cc37e54bac55e2d8bf923bff90ede1dc879cd868e0ef15787c6dd16e26f343f5a22938f2b5327e25c139fb45f9731fec4a6ad00258621c139a2b724eb43487df0824ebe71e6c18aee8e38e6f470d96695c1c50d65ee86d734cacbab962b8d3fd8ae613a342bca30abef06a8a994f63c93df71f2570a79198ce9a43d3b28465d4818f0b47a08199559d7d830e26003680d56169f82996c96729111e478a537ea040417d4e2f5b53f370e26456d8bab8a7083a300d5236e49a9caeb2a14561cee97f58b608b4e9f0b75e897134d047a7fbeba57bece96f295a875cfdf27d566347c91939d28b3a2efff8f21a08882425f5c24432d7b2f31f661d087f7baf41ed56d09d7bab0db1181edb4a7d29718c38c6880eee7f21cea29d815a47c0790dd77aaf97f6d88cd20fd8149310d38ba33a11bebbe4a5161d8da9fb6985fb6ef2a91195e8a07bc37dccb4a316f7328d794f244662abeb4a2b8acea486234cc3e178503c4962a804c90257ab0572b3133bd41e67e0d775e2e9fcf51c6bac7b05945ec03648465882df4dcd33f7cc97df15381878a3b32a203fb380942c233306b156b5d0b8189631fcb21c97090d25a74caed56516c53408c3fb4dab39a563d7671b897d411b157293ff53d84c7d48ce935b647424e0cb20f8145d15a6b974eb952f24449bdff72a16dcf58dcddd3f24ebcbf2518a9fbb9b0bdf19b8980bb1e530fc41cf333bbcec52b27da04d3e83256f3532ce4e22d1323fa8d1271b984dbc9f9a4e0912cacacb49053ec744762f2705564de9f3aadfa3e95820b55d4a8a303ab48056f99fa9abcd9931cf3185b218da781b952abcfba650814db2fa6ed8865d34c0639ded989f55f154684d1b2dab958ddfa362de4e00b098a0fa2f47a238d5efb6b1d4bc46ef45d8f372b89eb898943eb40ffd01ff2d90965cea46280e5d09bf3b62fa052e2f846e51896f059f191b08e007bde77348ef2c9daf4f98052627f5f2484a1ab377d9c9319d65bd0a79397d0235460078efde5249e6c0da735fb3bfc6dee4f3155a0262781610b3fd0dbf5406ba1701c1c9a6e15f15221f81af6a70e7ccbd426dbe517d177ae400803599e24544cdcd753ec90328ddd13ccada15f46c95adbc521588d7c7a9c8124af76d9da7261105e1a71a0a1b8a01fdc811cbab6ac3ee2d4327269dc4423172a17a5c70da5363355754d14dc2d2e2c21bec48caf6c9e0416290ec1f944bdc0a1096353bbeef3732a223151b8004c0b82d10d740b24c20cc0098b5083d4b5f7318d8dc8ae2e89c81216d0e5d37c060e1bc0f01f553c26357dfd1f99c1e482c5f37c8f1bc04cf20031e4fe5be88871eaee56837a17611a4e31e9dbb66fc66e282194d251691028b28edc4e0663f38c18dfc630587c45a33c905a3ef329822b13e8aa62f5923d35a7e22d49283b559f163b39e123f0f29d5d84590a2ef53bcd92d3451afb08ebe88ab893353726d6b20afb5827cceba0f44dcfe44a59e0df859297de9fc6e8a4b93cbed9dea219ab79a7635f11e8698357c6969eae5c3ce06c09afa8fb8b089acd5b595a4a6766a9e9029f30732377bac5491827fb11fcbd5b02a6822279f2b3b3ab5b9f965b0e6e64ba5a2f08fab31f86607b9e1c5f61b67e79920bd12e343d54f770630494b0be4efe53fea7b644cfe61e87b3eb219141b48cad82a08235612be4e71d4fb74ccfacd06faad62f4308db0dcf0b244c53fc98596ba9586465a90fac913a6f2c1079c8d918ab888d54eb49eb417e44fa4d51446e491490a43865d964206b76b909b848cc3c4be7d3cae9a4474f5e99a1b647519217481fd59a4578e95de9559414b8e85395ae53893eedc46890c84dc65b2d1ef01d7a171db8fa3eea33cfb73c0af476a4450f6026dc4fe3833eebd7d33eafd311e2ff7aff23b84d151d7a14177a1e1a51713e6ffd2b5b538ab5eb19848e25bd880d08615ab03bf8e0bb70bb8ec44967c72763bb981a8bf3b454d11fad4b7bd0e9591a8c51e9cb2b2761511fa63584bcd59fd42d357ab4b3f21049272bfa4ed643894b3296af0117fbfb09dd38a9badbcdf4618a4ff30d13af8342debe27d0de5d5433d84a8282a8108fe2cc0e684417c579ffd3200a759331a953485c39d56c0e0e8385beeb000f052685e3a09624017baf234bbc2a81c908435624439c8d6da37875d06a2472cf401dc69bb37ed52180ea651324648e1be9748b696ed3a22716ba7e9701c447ae84b3c98da8e1a9d0a5b1049abe84baf732c599cc3d55003752c08510e59dd81b17fbe7da842aae9854de87da32908f1d91c4187efc86e164e24c8cd9817464d10135c201d5cd2be1ba1a4f0f64d5543ccc2db274255b8f576de97fdfd36a9097b87ddb4262bc79642eee4ee3f3999641816c2e729853113037e62870fe7d8b8787ad097a0b529f7d37bc58d1c484a3f5d02dd7ab546ac77de7909a050ef5cb1b40a7ab2d9a64f2d116d5ceeedcfe67bd492efd8951b74e5f187a71680b4833e5a4579d51be4f44143439270eaf563c28c133d46e154b8e24e85352528a5d9136aadfb4aca164d714b16162501b39b66bfc23040d987574e27a9ac40fad629a53bff7405241d3a00cd87509d5b638341ef98ef46c61b9ba394b715ee32c0860489371a11bb7e7bfe0f6a35b39d565a98b419141d5762c3606ee90ca5d4394d612b7f515d20da94cff9fa2feea7297b8ebd98766ba9ef8368c8a13b2de4478fc58c7cd36f92270497d263c752a0af2f4716731e3f44d41c0006f8c305d76fe16a147c9946f4277527114c386cb25c7bba3c1288261f415782480d563278a931fc1b1779fa10c8136c394cddc83475f41d2f516e17105f0c088361337866bcb0297ae9823ee84d0210812d232211806e4fb995ed9a25e72aa51d8e5c137f5613edf8af7a8aa9140f4c0ebd9685fac528e68193de6ef46126889ddf255992f5b6fc0f7768a090b8494d506b8f681cccbed4a9093985012b5db342ce56802068fb4eb1cdaba10d645ecaf8ae62b5ea171042905feac07311a4de43e5a59facb89eba7a45bc1625b9eabe5fe08925f7e761cedd77b20f7eb8ce930161766e76182c0c12642c7fd315423faa19ef5f05b937120876bc894e1c24fa4848f343a600aad2467221849a27d09c933fc68ead6b70f52a5c88363a65c8061ea8211a93b59ed4f35c73792622c85f049cb53478e3c4d494ea37b883f161affdfa10667e3811ebbfeccad2ff8a0d4b4c4f7e6e3cac7ab43662bb8b2c48f3975ddc4116d59482ec8a1b85a7ea95bd67c502919c1e40dfc056ea115f7a6353bc3cf87d45252be8ec1840e3afffdcc3694ee85ed041387b34ee4e17e280499752968680049069e76061173aeff767597f9f6b807b86c6c73a3a47c703af1e466170b35103f940747ce302fbac3c70a6a171afa197fbb7ac71671b99eb1b169d2de6a40988ff61b2e4f8a456148800d95cd6762b2189a165c1b154b15d4663ec5257479a1ce43d03c563cf871b991a49390188eabe8563430bb45f9cfe9d9d7efd4dd7d70df07ed656f62bfde1aa55d7351da47d90cf9d8d65893b845aa5eda27218d0ee3bf8b10339931f730ae01fc3ee8bd13b4750bc54d8490e408fe864b88dd3947fd528c9f6dd4bb10ea5d336d9ffb53be689f20a0642452fbffa67a0553f3711f7ce3a3902b7beaff4df3aeaf00ab3cac05eda73562180ea9031c5c795a824d7ef0526dfe13c196d4bbdd35db2ad2b70e7c9b9fd2c2d3c02c5c430aee2c7b2b3c0aec6a2d971f2e31d47070d2b9cf05a15023421daca725bab23bc38128ae44e49661c6f4a84c10750baf448699e68e0be370a1ba8fd61b80be9249d93a4b8e2d690b15409da051eff540847fa4cf2e587116eaddf214853dfb311ce1c05ab865253d740ae08852b75799bea25c05cabf411262ce3594647a8c40b2edccd59a7a8a6bf21730936536cee8f577a3cc3f5d887262a31eaa653ba34256d8f465508b11c010a0830cc0ed1460a81cde11582004817581496e8b82b79506fadf08d4f19920f5a5fb313956750a21c1366ea0a7b00aaf30b21a1f0e709fbeb9a3035d95171e4ead2f78500d0846841414e81863d63ca53410380fd111400a7f38fbe6b5c5ef6550db4ef900e2ce66fd59225e9dc5963c8a222d4a7b52e6648359c161e2fa84e1b0b1ba9832574ec63a3d7af34753e698c50cd19c591bccf95dc1987944088c704d8e8c44da934653e3f368ecc67e89e2ca4669501d57d7b8765fd6f72f8b21efb92bc58ff74cd8488a7ed83248ca62ba129c665952a9dce57fa708ce62bc439d61cfc098402d72c90ccb698befec6251bc2e02b1db32a663d3f105fb907485289196eac858a060325bf5e0c8793af96396741a7186c122503095d90f11117e2ba35d6cb5b412b394d6dbf841121b1f83eea6073a06de51f7cebd922e6065eacf01412f60cba1754ff27e56b217ee69c0182d1e32e263a6c65c6ff65db38a410269cba3a45b6c4b5aa825c8f68c5f588b1b9eca80a982abf0fe6538fe8616f1f94e614d789c4b308567a716f144196172e841751ff890c6d4e0bfc238a163e7b46fa9bd6a8dd4cd19c5e9ff826d3bbcfa181107899fee1af768001b281d123af0a4d4f22401ef76c77d6f3342598f25abc62cc705a21ad60370d313d8de3acdd760f12b5776df42d6cb3d5df63d4ce23d10cf515e5cf84108f373c0cffd135c7bf16ffea8aa865e2de1f8ea3a7d549ecf54516ca44ca954c607c716131cb39951b9c01ce63faa739cf45aa20670a46a1cdbfd4e89be785abd8fa5749edfa40c4529356cf4de7b7479f45c37d09797541e9ae476cb7cf4471b3ca767848c80d179345fb4f0bef916f2c5e8324dde0ae2c8024f1b4818f6b6fac9afafde50d74c1295642aac24eb144ec695e2c9af7ac2f2424dff751bf2b0f300fa4a2f43d4396d5d01011b1c26235b398d08e2835e5d7ae5a7ff6ab121c9476fa7a59815e7a55b149236bcfb0f1895f232490b5c2255143cc72ce0bfaf9e1e8302f5b61c2fec6f4da63dfeb73e76ae825bb7dd825fe74e4a86854b1dee8de9ca17b7ecbaec4aa745c8270bb03fca2564040d7dcb3afa581d24df0b2325960723bd293aaa59997536c981dabbec6a07466b072c5a52b84519bb605ba37c43ae185ad68ede6ba1292198c794265281be964cbd6af75ec70fcf53f2ae5b8f7e6114a2c22f980d6b41c7a7356a93f0cb8dce736ff444ab46c9d2326551636b3a2978477ed6e37972bd30ed5edb640baec2405ae2debad96cbf39fd4db1017a4c3c5b19e2d2fa595e6480827bac1ba5afb464092cca459e6e8c862bb2b19c308742d67ae92aa53d210abc2f10ed60ca3d955a18579679e21b7023868d641b924ae381af272deeea0d193a758f3e8e714e27b6199a32e10eb4372870abab4ebb900a1ed98769b64109e274952543736db2e3a814e3f7349ff5d3932f7250c2e357bd591fa801240b6ed75bcd3c98607691a2ef19615537d7cf109245574cc985973cd466552db160be05a8e1b5bb7aaa8521b6dfdcf128224bbf076593da6b3c93e91374d2ed11f4dcf565cb87b11663be1b60228dffa6f0db6f5ab3999b4d5d844d9864ca9e3a9211ca5fc23f264e7ea539dc5ad99712abcc07976f9618e7108b61be4e714e70b3a2506809af8d0b21ae6785f4182ac1feb51f7f9ea318b8f57698317c6a585d5b3bff772b3a80c609ee13e2a0027081f6e4be75fc42d3566cbfe6bdd813791ec3104ad71cae2e7009f40972e3cbcbe9bfd8164f640125ed6d7fb556e9309965eba5dc7e94f98d59b3c92f6554b51fd89e1bbda17d6ad8a5afb0fd64925a9e12eb2ec2b49d8bbe81334c36855fc75b74aa995e2782dad432b3b89d5af5727c8859831574c17b7be329770acb96b7243289dbd3707b1ad96db67ddbcce31cc4137dfb6a5c09bcad36e5fa40d7fd5a79f27b35382cf7631d5790f201bec0fb11f4b3f2fb5dbb7707ee0e7edf36794d5910969a3d245757f83fb38adb575ce88f4ee849dccb680609a2b87f58698577db9632dbe3bb78d88f9cd276625577c0bf88e61d19291d8bf5f9f100518f2b8b5835ddaf7a18fa92463b5c65dc8b53fb2ce22676f0c454e7998b0cd83b6bb5b07972985edfa1c8445922e09f1fd7af49cd7d13feb108e83fd0c123165a89e365ef4f91b67097faebb49dd3085f392c90a76f01b806e6761be9e996d4e92a9a24ad658135eab54f27ddcf1a43417449da07e5fb7a3ad6e0472d5dceff9dbab5e44d7fdd2b1b54e4776323bf868c6bf95e8b556d7a18a21195091f3cc9552fa744616347621718069573477b722d3a3a2a303e1d48333c03ebfe0fad2056e285e9bfda248528bbd86222b9b993ddb9808e3a894f3abb4417bdf9c01ea237b35990e76267f2c7b73a63ef835402b9dcffa41f6ab93f45b8229403fa9459887675cffe7c5fa1961b94e6fbe82ed47d840000a8d65ed10edc7a74952c2d5a60e5d9571b5d5ebbb4160ae849ffb2eb567f1cc6aeb9d2686448634f199d031ba1f03c8d4699dc696873d6114156fe7dfea290a7d4797a9752478f1487ddd90028dc57de4a2883c65badf506c7ac4b81ec3a7bf4eec8fe192e04d23f57eec7d91fef39d669e17bca1bc34b1b2f261691d5763913085b3179c3ae0801addea9343dfcbe24e2d481617eedbb347a3edba36f0672c2a7b071c23d2c90163b467d1a7047d1beece454357d5b969b69abeb2d00fd8fab16174a65329669d2b041adea9e9fa78fdf42a4f15570fc9e6a62bc6e2ece7bfcd6c98f8c5d482f75a57ef5eda352150eb3ca2991ab82c9a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
