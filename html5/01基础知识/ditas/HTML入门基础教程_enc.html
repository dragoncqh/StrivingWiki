<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b0aebff2a59ab8c74cfdec11da897fe28428aa0d78c8aad0297291950d1a32115ed8eff6b6f4dac583b797e550bfbcbd600da35928d49106a5b7f6129404397a05e4b0e8e73b9da77b6435042547d7d50af5bd4b0de986640f135401e7d62fa64aa61bf93aba8d4a2ce13b80cfe0d7204c7c955ee5caa52aeb5620e53add8a679b937cb5b5847e99d6ee744d3726b3bf17625a1cefef421a4000b8b29d82557d277645fa38b05d9f4fd1dfdb158afd1417aa59a6a486d69fb17ce4a8919f1ce81288117fec286eb1e696c7d36180bc050684c2ac521fb7a16f50b005d476bdd95acbd9df3455839636ed623b29b3ae8947ff08bcc0379b8c87f3f7d1cee340ff4500896fd867090781ed09a4087027a0242cf7054a80d71f747286f92c968eb159d4c8eddcccc758ad0959a2f8105e628561e9469ab312cf4b8bddb41df6bbe530731f1979fd7005d8c3e00b8f1cb42f9b4a2e48132c1d41d9e72967a9b5cbbf26ad7070d6687b758b4c38c251c86962fd5f5de47f9dde24679813b76cc4328ef5229f3bab871f1d23f1afa5bef1527ec9973aaff1f94ac2daee36211122c791865f5a9f4a6987b1e903cef3d965526024423b45a56383875433cdb892d5d9b2a8a3686565e0c7ab2ab2e8d5614e6cad2be5de03451d3df33388acad08bb46b87538d5ba87b1ba729b9c0cdc4d8d69312a3b497d190269a4aa02b8bb63d6c617a083d839922bc6a3dd96cf4d079dbeb73b6d8d85fece6987b1f920926f039333475a8d3e0f3bbfb8aed8595bc5a6e1377dd5a676930b7dbcfa81f9f655fcf846d7d4cbf4c21cb9525c6aef09d8d436a421a0f0a09de0057264cf9798656da1551d221bc45d961f95debe403cc3dbdebef7d088e045946932c735467078e492bb0bc4b7819f998550b4f4880931e8cbe0b00983710e7557540cf0f6a38d26975e0f086e8ba12fcf542601ed76447ca02b594cd48b70e2e0943fc527a08a8c6af03cf8276cfe5dca3f676c0aca94c46c6ed7af258483207c7ecfeafd581b49ce6675ddfc51c1a38c4dd23bc41b9e31f981f75464ff9975ff290af6bf5cbce9a4d42be4cce23d52cff83b03095ee38f9d6c2c1c0bfb97949d8bf52265215719015080455e6a7c4edc7c9b9b52cf8ddcb22e8dfd9eda6c1b5e965f3fc7680c1c714ee4b20da9f89771e98742948e2e66f054084767f74869c7ab2109116edbda3ce7409ace19a8c549bca4cf87c37900d1a2a9f3834ab21a6e2469921371bd1b64adcb7128a4c96b31c92a1b48fe74661be8bbf1eb3f35de0d713f3f6511e1654a5ed6e97bb0ebbf4a890861dee6d72265082142a7f34f88874f53b5fe0de0e7b19809045d48ec21bc195de89fb7d10b697b17389d672cccdb6fa8b2ed711f8c1c81bdb26e327f27b6aafa1831e2484984d344155ed1d9bf73696e265d1c5d9ffe3cde6bdd1254c7c7b32a130799c8bda48367e5c1ca0eae72bd1557abbbec6fa167f78ebe029eeeaa7df5a9670877201295bdc0b7d9ab0ce65633ec40bd839e36831116db553c9630b2f4ad309997821aab7ab0fcb598701c0506fb11ac38c98448ed09d2bf69adbc5c6cadaf23b284430712672be4dcf7ff5a21c348a510c5155259d3d1e2fd806add0d28c6977153d01f1138fd8b564194efdf897d0c6efc6eb2ee41647fd7f620bf36d5d627d2357763b59c9896c2bd0c0755da7a018adce01f19fe9baa1a9013e5fa87f232e8fdfa6ca9779b11622579b048ed80eb55571e7a076e70d235dc90c23af5a06732d1f237029fdaffdc6e6e039d94c100fb6aa6316e3f784277a53c672ae36f472695d2acb08f960af1c1eb4158024f234d6cc0c021cf9a34d033a6140cf2be3ffeb9de76696eb1eb258a55a9e433d8613cc3dc3274e90e3480ccb91a89c010be5fad24a0ad57cf2170fafc53f19b3efd93df922f002539092d7f247445f0afeab085e784d2292b124bbbc3ed620cb95fb0c127515ca7b7b09f26dd65af12ad5a1144eac1b796a27dff3ab31f95c2e960f9ed5456bebcfad41c78eef655706c1946fda410dff59d091b0de8932d371b372bbdc397e6bdcb4c7b5a4c4d61f1962c2afb8093e867d59fa9f5f21cc26c935250e6f55e6a9afc09eaf0ec181ce904a618665f3715d7732f3c09544c48d0ee7049c2564fe3269280ade2bd2c7df9d52a6493deb78111c042d638be4fad6735fd19e7db7f62502292f20004c39285cf6589dc1211c69856855f901c402a2907e4fc06a9dfaf9715bf7ae87136cac555e51f92508ee74b39fde2b59d018aa0fb99f36c7f81195b3cc894741dc9dc63ffd00684a9326750f0830ce5af50cd63f8e67b6a30869c1374f5c18fe9236e13fc8200d5d0a9bc38c8e07a62dcea253a89c3b06f0d400c699a48f17e50e74ebc2feff6aec2be0e8d5118544fef6e35b27c4e5a710c5344ba61451cb9037fb593e673573093b90b98ce3ab183255b962a87c98341fd0ddfaa38689497cd5d0277b8c16cdb5f1fd0d9a30e27fadab1d56d1eec33a15e5afa949fbe5217d9abd5144b6ad2e60842343ecb705227e61333799b285c0b163263686d47268b735f5096209a048bee036e4d69e4fae2bddbccc0a55a61dbf12518c4c8935e73b92aae357a0bd063c3b7b3f1df9030bee7da8d63510082155818f03eac1e271bced5a8b33f207435f22c15c1c72d49706856726cd1153754ee3d1e08c72b996217716f402159cae82be8a294db45db809b7b5435486983b394e0dee600d1d562adc00d6feb90c8dfdd9eae2e7ffe681d5a4c79e02f0088814b7ac4c8e3c76bb67539a8f409263c7d126ab97ac3478e18347e281ac79deb76198e363e30ffda26508b9719fdd2c6929a8fe1f5b7b3da5c375e54099bdeffc51768332fcce761b5bf0618738825b5e5270bb744efb83ac92c1dd6a6b8a47049d5247940b450350f8ddb177a9a6037a888b7e567219dde8649b51551f9afd6a44e145df6b87bbbc87b54ffb92bb1a6093eed7824b0dbc637778621856742025de69b914e1d4b51c6d953d01f9806705c959c2f0f3d91d27c6d669ed8a2ac82b8f4bf00df4a78627a9e2c94ae56334027330da818ed728882f9c85fc2cfab021ad664effc8213dc875295b15dce853906118a5de94cce6c5a374343dbf80806cbd2584a21d8248a3924ae6374878cd82add06f86c3077856a84a50c7716af48427a8dbfc076be2c1a621bd6b74758d6b0cf96b95341e419aab4b1915c2dcd133f60099417fadfaaf215a8743cbc6b2ec3b408e995c6141776cd6cce04cc78ec3ff56bd6e30698ad7d0f557fb8251a83d9ff8739f073895e669a6158f8252efced127fbb4fd26b243f9b5eaed786433e84a0d76592673084bca5a102d1c0b27f22cf4d06f676cc14bbef4561504de7e5cdf3a3845ef8d7cca6b09259be5d1b319052e4b81efd688a83a25c4a58c02571884a64cd2b24c3070d06ae8b8a731835c882174df07920c8fb445e93b6d9bff91bb876e6487ee4da1af8181586fdcf576e1370cea4a42b77803b6cfb0790643112aead121e27540718223309d4f3120c4eba248a3a23bf1a540859408c380e6d6a904cafd1d0293ce4972b4d704daf42be5b2a9346ceea2ccb85306655613e5e414c6f0252ac36b66ad200b4680f99369efa27f615df84b892fda0964f30e5463c0881b1184a7c1243fa060ddd4ff4510bc9e4051bd71846ac4cc56652f3bb0db70c2117c94e387197c4443d6e35fda8f980e51efacd0133b5fd635e65dc3683c1b4e0c4722b3d9978c1388cb5f119ec4372b6a484cb2be50d57c7ff9615b1ff0ef89cff961c5ba7beb59d1da229d387be550f11bad870ccf83f6878bb73dc82b0b1a32c1d4c6232611e6ae2383f65e441f590b7c495803c472c83b153ac44be0491ae7ee47adc788875c60a0aee7deba3ae0b66a36c623d27befe1df6be0c377bc3353c4bd3b3839da243226325f7387b245651ca5d68d2f6fa8320e6f546efa6d169d9811cf1f6460328cb06130fc394bec55c2ab21ff64159789c1f3dd1bc17343f4ed9da2a52ce6556ed4dd3e5dfd5dfba101b1cdfccf94d99566ed95e53a6002262f93c532f74e6e7a6d375dd0901b1f29f0e4763a3ffc27f053b66fb043ff6f73aaba0b8de468ee295a51417ac4e68272908e7aff13e4510085dad2e61af7332a6bb4c9ec0439988afac2c703c765642b15005cd7e6c14efec9b73c199bf0d5ae5524570d882572a78b2e708c9a454b929ca33967c467a6255c8def8cc315a9ee6854e576042c694bcac5490b732852a37686f313e1d6bd897e34c924a225001fbf238551b478d859d6a9258902f739b7660e47fff6afc137f0557d1eb0ede2423bb678f9b6d56eeb3ac0781f3eba29a603916cbb45802e56f7c8f6e229c6900dc55cd914d57282b34f34b4b5458bdaadcd2de71c2aa9f13fca22866252e4e0e183bfac877b80768fc6482b69a01d62a1848273de89bb13b2dd34e74e34d3bbfcbc85048b2a356b4ccd13bbce5d17d6fd3ae6b1e54754a0bbab9f7251abc032939e357028429b7935b4f3fed3edb456a42fd24d9f6ec7155ef6e0e95a1409de09585db6cb433edd580cdc345f6b088fc817ac7f66e2c4d87fc78be031e8ffeb7ee5e47e924e43ae5029d7290cbf2058e647e4549ef9e053969e361e04f00425b3508a38679122b084a4c80e3f4f266638158d9355520faaeb0451467381183a389bd9f29d7c545dae48920ade88675f49899b24a8963cc977be4268eb960211e9d28744ed4c533ee68d9a3881de025a71f8a0af840c9f824a80b61c7ae6f85539dc4e247a69f87e8603fffbe45ad1f4e7fc920c4343de044f0f794cf13660ed567d4bf92ef0eab47223ce684cbc2420652c162d63a4a9f65411838da112ea00b6f7e87e75b4be0062c3d3e5349a5e70698e7191847bf45a8844531962d4aa747124f578fbe70a1ba3af4fac3c9317b9e24203f93f7042dc95c940a9e10ac27db9f366e009b248a8cdfdae85013260c51cbe5e2d35219d6fbd5e716274be31dd3453e7469886a0fce22e42c2a4ddd8c53fb4ec4e9d0d26d2baa578c5dafdcaefd4e9a11c788e6785b2e8966bc792cf6e141024cf7370188bc1cfd01d63562dc1eeb44f6f30d1e183cc1130d82ac2181bcc76714dfc716680869dc6f2fbb29eaf45ead0ef88dee3b06bee4cf3e1d23a5692be0f2ab6cf3275668821544a327c8f70151cbe61fe8628de8cd1ffde10e38818395317feadb3e5264a479d16d40d0143c3d32a75e43319ac822cbb1c8460c07107791acbe75041d3c00066aa25395241be9d0aa7feb54d73b449c8616f7d720df5101840f4930056e1ecca31487db7ffb95a2dac4bccd22c063700383dd8b4e2b9f4b18399e140c4c912c5ce0e53ca0f60aca39320e34551e6e9348900189bb093110dda9f2ffd561ffa117a01409ac639165fd57c4ab92cf93f296f5776a5e9abed9b392eafdd255f489d07ac1b0087050a56a700e717e7a4160cc171cb6050dd90b33f6da6b3485ecc78363db3583e401e5460307761428d4ec69bf77966397828b806bc968d76b0ae46eaf000d0d2683f7d4afc4a0a5cdbca6d96cb3bb242f1446781734b8b7e437cb188d5c0464a2b7d16bc4bf42d6b3381924d37ae42b876d5dff3239d3adaec2f73917e18f2adea1cbd997653079f071366837e4d9687dd6e4bc2ad004ee43982ee5fd641936313789d592d1f8ef13df11bec5c57ae7af8463c0929d59f27067feca558b4f888e9da2648344701959a5697e8bf44cdfc05353dc6f5f66f878f165e0f8cd077b1aecc7f2134453541624084fb8391589a96cd3a72845f3e075966a55a42cc156bed1ce49b8e893dc4d03d5ca462c33c949ce70c744e3c6eee1595c928d54de5fac702c35e296e7a5c6a683378752d3aa33be9454fb1e67469efe3f92c3ad6643a651476a2ad3487e26aad819d980ff0ab03782cc1c7295c58e294d6731046edc09cdf498b586aa3537bc32d0eae86cf49be31f8ba7d7e11e2b5140022f68180980a3800ef615a84f87149cc14adcd279992ceab80396adec694cb00238c4490abbd807aeb06f2a6f6506c3b44e70b3118e30220d993f6e525075c1510aff3b64ced97bd8847f3107ffb295861ee0b6de514065516618bc1f4635bc38cb2c76aac8d87acdb9e794d71f3821da97c336e97ff07d8d457415e6a4eb67a43d259f6e838262308ffedaf7d57ad216e549ad0206b22b5e17bd071e23294d055ea8a43d91f008ffcc74d637755e62eb6e86a48725eace39fa3afc7e86d23097d6c2a9d1b48e79d03c345566a141cc6d7a0e34361abf2d2014178d9a8a3049df1df6b7939ad96f5953d2fe89d7d71a8690e78a2434ef4299b99ec13b8e5c0079aecce0b6fef3bc0d6becf74112549ee435a4c99a037fc8f91778d6c6a8368b72d1fc66c19c9f28bc563b44864cdfdc4c03a8f006c10f5fc8872722b1051fdf4de3fef7cf1a6e01fa70901a6adb677abd7e838b8e4ec2ebb3e6884cc83f7cb821472c0a56cd8fb07485181c32cf07212679c25053ca3e3efc9500d6b5b4550595a79cfbbd73668ddbe92a65cd35f1c9c4be6268a61daceca332f6be39cddb258e98f21ecf23ca5faf8383894cae38cdbf2e795bfaaaddbc564ab8ae126fe59e4dcddd1aaab006e09afa934d5cca91db0b62547716818ac73076ccb172adcbc3ad1323e7de1aeea4aeafab3d53e9c14225adc397beed6a10af4a162ad787714f0bf782a3fec1dc7416a1c516e7f38d95401e09577206d2d61ffafe09b742e77e6be7f3b8229bd5ba906ba6249e80f5395b59a2ae5dbf7ab3910cd282d90ef8dfd1a0c03cfe51f53b2cbe7415a3bf7845786125efca3b184332deaae93ac816108c34e62080cec360631f3c5fcbea6d2c4de4c9577d74a1cd01446651a70896341527f860efedefea1cca203cacb6c1034c812f11f0c9941d46da0d9738a40bc34a3129cebdafa15e0ffe47b654400d9bc976a6fd1311f057dd4d889cbf926398b9017d09f43992e1619ee7f14030ed3ffbdae5b564f73b147ee61df072f7b876cab6d29db16334c36d7d37636647e661395cff659d089c69961e1dccbfc007e721e38bc44d603547a88c63085f4dce4f71c3c1704aeb754c7c738f69af47106f4cb69adf33ef20d68dbb04cca1e72fb1e29a89849e7d201ec38be0613d12c2b9ccf088680e4b794b67bbecac1e220f8c1ffa893fb453fae9cdb40606d8cc4ffe2ade45e775d9afc56bd152e996426d8f11f5a8aa9967ba2fbd48bc0d23fd58dd710e709d1cf3f4c7e7f0668fbbb204f3634e60b85a3800a58721962c6e9e9d3763f0672df4b7a07d77e109d5b02904c2c50a54ce489748eee14d18a1f25c2994e4938907b2bc6c2e2d4920d73098253e51b12560bffbe62f06247c392218c210d875958703a66bff41b1749f425293c7ed1bf81f5b20a1f0147e70bc2f690faa7f823f315cfbbe8c33ecb92167bdd57cab5d8dc28a842423a8647dafd13b8b427bea5bbb602aa357dad68e4d2470a637338b50d1963750020fd304ca0182004352a284a9c8dae2bbc888a5a87db127fca1c7aea5b1b1e847e1c87d4851ca789429b8088a54c3dcc1cccdab6987dd186447788ce1f7783129db0b1feee9631ef5a70322c7e71f979e8cb65cbb939343ec1158b9c4d8e88bb2ccbe9fc249d4b3fbfaa577254e523be0ba0df45b23f01c184ccaaf0a3417fe061774794c5b2436cc71f9ecf05e5b1f46313531eb218f82f5f9c2e6d80870ce9687935999bd9d627524e03d474a8ab17918f311eb32aa0f8e88676aa1175f61809e3afa898fef434914ecfcb6390f7cf13eaacffe9c7558297339eb7ef707fd492691516d481a1da6628ec076415203bc54e5da49368fdb2317d813d7ef70e6394a5e2c61611fe22e9144587a88499662c5e3b3e4d00d620f829c430c3fc49d2ccd63b03ea70792aebb2954581a9fd373ed82a61f13ff00503cea3d16d025b3f2b5094100374552bbbb63391ea240ddb85a7304667e91eb8d4a51d1d721bc70daa3db90b5e4df39935ce0051c5076404c908ebc42365dd2a8a0f26416482452f3484f9c33b3cf108d482a92c63ff302d4722afa2b2f2fb5ceacf60ad9605c83d5ee32ff91e0c24ac4bb046b1ec846982efb8d1c5edb2a917abf3b699af63402ceebaaabe574a537015df949ad2c3099b4a2ed32ed2ec5cf6868dc1ef4fa5e0c2f3605058a15568aaea9f678303edb61eb536c2f3b17e4ac599074cf8486d192c807918c780da7dfdb04c2ac463eb70ab6409660a1f89eb5e0a0f8acc22b5ad0d28d1f25604d9e48f0691bc36e9f623cd7c694b7e8ba9695ac3770cf4386b40e498343310d1c2fe9e325b9fe342b83cde6de89ad227c5acbacb1f559f8c8e09d3c15b111164355cf89853640ed61f60d2d7f05ecad45640177e7635ee19e18dfbb501f0dc72fc47953f6221a3ebb28e96ddf868ecab3ce6622157157d06d9d0715240cdf9c0f644622359c9107a7c7f4697a281a88ec6d1aa81f08d1ff6a3709c45986bfa2ee7bf83058b4a0e60fcff0f9ff053c26c019022c3ae06ddd8f6571945e25c5498389b9426aaf4bfe9033cf885ad2b2558410113b444a5733aa09923941ae514f44c3cf76fd76ae937706dc54b81b6d2b5812084ae4d90e51ba10e5ac001744a111d56d515ed250cb1e72079516fe30dd6214d17de2a35ba45de7ac88f7cf3607daae4a5bc5ecc8374b9e26be81e7eb1bc24af14507e8178b121e05d63c7c995a4f3732c86ed5b6d3b9b3ac7a4f72453f130e01253947ac171353bd6ac25062e53cc09f5b232f7fb3cb3e1c59ea6623c3fd93380faa2ec909276ccf46d1ce7bbe2d65c63c1af4fa2a9ac298cfced2496abb847d4b7df75b0f1aebf256967ef4a5e73d19fd458927b5c25747a0a9b5b8586030c677b647233519cc353002ae18465f85b7042ba388461372a798ab03079ee3929f5f74923479ab4142daddd36b5ef2002f09ab0e3fd1c61fba55002b399499ef82976775cd159bc0eae3d299ea39320b88f22de9755705fdc3f41934660fb76ff08414f62b40a8f731d9365ed8bbaaf0ed6e46f4abdf1cc2c388c7f64c30621e7b475cc300840001b3eb5b3d0e6255aba3835eea3b31c712cae256061738f641429d33ebdde927e5766726b17ecedcba306ee2a9fab4d6a483b12a9f90f4f0e1d795158101fe42f6349bd3a95f09bd082c7b1373d07191ca0a29180f30bf61fc0aab6cb2ffa6485ca162622e8cd6d5b467cf5544447717858e676b3ea337e5942c7c0689d2460b7231c23101fe59d96d12e2945eb45aff6cc5099145a02f8b26ba94b9780788ac50995cfdfbf8280c1ed3535dc61c80d2a6bc609ed775ee8bcaa635f2f306aeb91804577de43c27f117eba3b8ce691526ae51faa9a816aac66f3098b2ddc4b6b4b090337d6811865499cd13fc1a6a8c4efef3abd59dedd54cd323308e50d053e58905ca4fecc74168ab86001bfacf9bca4e1138e4b82cec93a6432518bb896e8d7c3a2483dd133b8aaff0dd546f4f78c4aba98b82de767adab9bf250f2954a43ed3a61e88f9b0c6ef85b54b2420be781e470068dd79347f4065a3631809d80bcef48368ac2efad7d58ed424ace5b27826c4f05fe912c67c8f64628397acf2d6c43bd21f9c25f295dfd94471cc5734441a6dc1a91ddd0f80b9691198974c419535326699b24cbb2965cfa037bc1f8abdcfb83f86847cab23b849811378a74a3c7d28d8dcb6dffe23b4bef59168170fbf69f599a220120b59af2b48c9cfb1df0a03ca9e604a71aa94209d54dd646912c8a106cd327e77c25e0258b2ea7a9e5583bba676a6b6eb68bd3a59d374d3ba2f4ecbf071fd5b3c91b163bdc547d4c2dce91f6df8afa9f82223eb10359eeeda9e738361a4294c7dfda38379f6372689abe29edf3302cd1de3cb23cd13e08421212608e38e63640f83bfddc808d80e7fcbec68b709dbd2e90d8d958f36c0d44381af880244165819abd8a70cd6839a91d9101c071673922444b2fedfe910e431184dda8b1e1750d5dc08089b13543080976ee5d00991aa4451eec7e07f5437ac81efbd97141a73a94fc9648a746525e866ed2c6cd16cca3c497c8042110bb0a001081eeb0292578d2507c49221787d89fbf40f9b80e15b68c9be3262ee3bf9e60e1a2e06b013617d282882e42f18d4971e7305981e46d6215e9e43a5f85011a19759ff8d4010c7b4720c05ad9952ca45c1b688b9815b0c4cc9e877b19b624508da5487e003e0eb5409beaf5ee5a8f0416cc68f3f8934f4cd9f6aa9f83cfafdc6cb35d707365d4ff5c321ff713583c3440d0bd2e8da17ef01751dd80998fe8f82cd51b889d9a50f90d8aacde214135efbcdbc9982eecdc32c10fe6c190054d86e3f104ad25709cf7119944373e6d48d3a2f1f6147984cc927bc303d1daf61c14e2f77b6360ec230a5baf82c97d244aa23979afdf5395aad56fd1e5031d8f94c77a2449bdfaded8f0b449766c1ba77e03093ae7b4601ce7d4970f6e9180cf2ed4260164733d951a86a6cea0b8a577f7176612a6b3a4a709a0a56628caf44401c8f7a896f93a8ac6b90c5bd27b7e079c754efbba8e4e0306033b94966a2b50708dcd285eece72ae4ee755eeb4226a01b7a15391342a010cf76936189f17354daf8b54bc7762fab67bbd1c8bc2bd0f5b615319823d0399e99ba0c1f0934180ab3afec3d0afd0c351612ec7d69a0e5b298618dbf6c02ad0c8255ba7affe9a295209ebb1fd166e7296b57e4792e05dcecaeb78fa6f82855a707b85537dad6b6707c6b433001d4c2f0b43bd4c8d065c1b2a06c4e5ebe95b2cf763f53b8333d7209a7d2c23d8d13f2c443309a7beb275d7caf6aa8fc50e3ebbe1dd7fde04d2775a309b3bcc9f0e0ba7957dc53f51307a044e6338517e35bf180e688dcb0171b0faf79a5b878135de802d5b3fdc6935a3b411c4288d6fbda9a96dad636dce512b5f8c381439bc42970824d32634738b78a6c0d13efa02ac365cadfb904c76e496b3399e1df9fa0aab7d70b3ebd451d76ebcf2cf078edcba31c501c86f007816404421d5b17436117b2d092374cec101d2fb879b5f09a57d8a053d8f198c58d36804091f238a21bad25eea064e43971f27cbe7d0d01f8b063426926329d0475dd359e2824f8d84c012e3f23c67e4fe4cd030b9a5196328e12a0d278c5469be9711c27c31ad5cb549e3e56b10afa13bbf573296b7cd77fc8f66b4364f4cf049af5a39b595c13eb6644732446cf750418ebeb836bee53012f7d69366801ea902255954579c7f0dee74d74517707ee86533454002fadc4e81e09de1f381abda4f1415d0f7902682e8900896f1828e85aa7b6435ed258783e1b07d6584a659c1de17a0d16b78f8d39b7cb87771f7fbf0d438c188d908fd0fc8f7ca5f594cf6bec3c5dc8a82ed55ee54269393a0c78ad9236e56790247b4468dcb6296fa2710233c343d5b39152626d482c824209427e598a53262c018b080f20503d09f9a66c09ffd875426cf25960c76eb2fe2cdd707a953703000485c27899c6b2a992f150e35ea4c1427e38f280225a1cac39d15a867e668b5ff0d85f0f105236c6f0a48f650077c560492a69101547ba903a347c5fec3743bcd22fadb80a31dc7c3c3b4311155ec2504dddab24475f9276a77332e50f4d41e2fc93fab6a757dd68d9a66817e0dcf6b69feabd4bf660dc1cdde83ba171d784f89750b90bf1c12fccc041afe772728bc86326b04476b7a35e135c533c19dcb0b06e49484544520863c6b12504452d41fd1666300886f8fb9dc1ce1d7edc8e7ac77cf063f1319cb8d14a5df92c34fc07988c54b4ef7c1afdc7fc3c71bcbfd25b1a93c6a2600e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
