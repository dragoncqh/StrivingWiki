<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a96ed2160aeb55e831a618ddca29a5a660fe2002e712d827e7dff5a9a692f660812325cdf7cead5aa2f4372cbe4a4df1906367a15bd498e2c9687f769818e38d6a981ba367d99ba7f6941a009177158243f889397b150afc7b565149bd66b8f85454994f8f031347239b78ff0143499942879ed3418619ab4c106b9232d1c45edcc8d2d29fd21e928ca2c835a8e6c42554d418f7254da7a6f21270968abea0126c783df22697ae6eb9b0f0e9cfa006fb7af5bbc6e372ef2074236c4aa5ceca35b823d1a76f03d79cb76bbb2b25d1cc845783f4541793875f606fcffaafa03b7e13fe574e0ccaf2b9c132f48c3095cf35b4411f16eb71a271a36b11e157b0d9602a8468b81bb7ce24cb04dae486feb0f1a2dcf2fa990e8aeb5c7473bf97dd3192f7e432dff5b2cd5146572ebc204a051a3aa4c143ec2eb03a644d4ee3ee75ac87dc3a644e64ec6c2360c7622147b2550165c095f7c124fb6ec150ac05b3fd1dbbdfce55ff4064d7a506cb66e21b859efae80b8c683c352af477f28c41dbd3b6eaf07d2c5030213dbb31b8e28f7c5f002271b29d607764fcbe7fb025e5f8e90ddbc35552c5bb7f6639fc8350a9c842282b2674f040f40a6d6145ea42a8cf7c49ea2d857c12005c6f709c61ef1be6f5118bd7298cf3a4f526cde096647c3b820931dac1e736d2adcd26771338922250a317db5d877a236345c7f6a8e19f0c2e536e135cb5297c69b724b102db4aadf4dddb693aa7cfbc2f64caaf343f66f1ed6e4a8e630f7b20b670d0f4fe663fb01cd7cc021b21bbfb99f5af100737b4a9c11f218dc60eacafaf13d541119cb4a76851c368312d83d86071a57133297540ca97b9f7a6841ae002fa160d7a367d68574929a71e1b6c03165c5f47795d75954da3aa37370fc8526305b782298c7ab35dad28f7bb44a79f5209a311d0d93edd220fab00097a1991cc31289cdc6fca5eff554cdaf5996846e961bb610d960fc74d392c95d403e6fe043e2ccee490e97b9be5ab84fd9dabc98e2924cbbbd112c466b3f34409a06df252893edc0bee9ff2e90ae48a676fc9147f0df96c549c641640b9029aa51505eaa506b7797cd08d611b9a50dd4557173aa1649ee695f170d81d5ac68faac4b12444908a15a3b981159fcabfd2c450f7085504b33f7d5076fee7f508a9bb96e6b198689526763bd8d20f240aee239b2c4289277a4f966c44c481164d1e4a424105fe39662ac4997f73afcd1f97bb56bf88b014e6beb0dbce94ed9551debba163e08ab144699bd03346b120adc079b78d6f35fe9f40f8d396547a4f2d8284f866f68aa9c2e967249aaa848a828420a37bf84b7eecae348df7b17ac4c37bf684299e2e664e969d55d92935279f97901a6f6787e043b3df190a8edfd55594f5de98dd2cf6a03d03f0955ebcfd4d14417c788a67f7a409b607f73a827bd79c5bac5348c528e0acb3714aa5cdba0d1a14efbd8c82d7aa477cc9cff81ad1996275204f089a048b1d808c1fcf194a95911b75003c8a54089bcf6ab3f34c25821b25033587d9309212f9dfa3d12dbbc1b1f455955b3d620dc48611ebfc658731ad8307aeed4dc7ab2dd2940c7c5100ef19b9d6e2ca143085997a9baafb91eb0e2ab789ef36e9f92c31b29081be315f86db3a036640937fc123da468dcdbe006a8c0e1a7796035b6b72dbe1dacaf4e432f47a33e232ca78df567a3b477a75b7e34391c2fb64700cd251097ddb5a1e1a35fc9a33a75f2afe2c1f5cbf66a3adbdb1078ca55e3470e8589f99d7d7e17abfef40e162d691a93bfa9b671d3a02edea6977e468302a415e07bb10422d873c85d01d48d427ae3e48a2fc6e8c0d1e75b3cbc7b9c3f2ec1feba4f8ad8571c3f59980faf5c173b4e4c020416691a7c88883f960192acbebc5638505b9f68bfbb75b80d5b5ddd127b66d0a75fd452d65837371ca77305067665f4cd7a81e183e243ed7c607592fd4f9c26791479f10579fefeddb4874506e785697f28d2b212eabb60c00d1928c55d412bce880e5210df73834b57f218dc1065049013fa1d81a965c7202bd051fc8620911142fe03019b64e91ac344b9a0141e963ea81e60f3dbd6de3c0ad37a17250ebd62a6ca783cf8e84a742c9889da78770cbac949a5611a6216db6dc27439a2b02ba1796f8c8b9cac22448f2f17f7abdc1ef03c2e32e2affb2f520ca4bdeb4a3274cbe8633cf0fa829e7cb6b3db6802fb2612092bc7b864016e968cdd7ca958e848b7b021558ce457a0b77f0de277d4ff12478007b47ec01206be4b2f1f908c4a26701e59ee044f637ed8af6c528c2052271f4fc2ab87fe3929e2a77331a1c623d7fa6f830ba324ced720e9c0d0b4b0571d2b4fb9b8de2c1cff49d85d0b7e4c55a7b215c9dada32403198e64263bf781c7df432f4f0c89cbda1114344ea1057c54e51fd614b251b904d73ff622fc05459ce01135e51b9b3a802bc61d81a567e4f167da2afffce4775f397f56c5f6c912e50fe657103133ab543e4907dcb3cfb53aa0ee2ed9c9ca65338c9af3cd5c4f0e7d1da67ecaeccccc359678589ba68ab298e0791283c33b4d15214e23e8acd4f264c1400a4e87e27065fb45edde1768f9cc4cc9b12e791695c3f9e086b7fdafa0ef82b630bc0235464d6cacccc66f50f6852e9a7abde746d9b16018dc9f9f4abc57d18de454a927e6a434394a5431cb477293378315273f635eeaef77ce86057fe8ce395ea825f9e2df7869bfe5d1f6d42ede0f0af273c14f5d43056c4278358cd3b782e31e9905575d862d9a43c4c472646cd420af57c0e78a32f87289ce5cea275da75177ee8fb1e3f315f10d74f9a1ebc50229b173a346a9a5ef3ae5561ee3176995602e957abb94ba60284571bee885522c80f93858a8f457d1191947befc8a34b93a1fec0e7d63dc1b5ffe43df1e6f767407aa9394a2e31a1f84a6f15121a9969a67cd0f9ac97d534b441c51b4b9abc6a98332c68a1066fa8c9d56efbd4dab9dfc2b67f6a7d312eee94b8215ecdeca925c8a1b74205519186c019c2b4a1417c3d499bc28ab708418a53f243d1244e256869a06e829abafc3ceb0333d7a7665a4109b0b19a359bc69742f3be49db4069f919af21a5de48eb35519821f4e0ad8aa0953a057e512b979f4d7edd0df0c49af0dd68c5bb1dffd8abb4573d061c1baf1739865f1072f7f999fc4b8594a7e12f1195a82ebaed8b462084b05911ff57df0522af2b1a34a22ad1b2abe4b9c826feabfb563e893802c5ca8d14e2ca8a3813993982867f5355ff7357e79bd8161cb5bec01dad51a162129735cef7a988dcf35c03d25a78535fa163dbe08e028dddec1c67f01e3b9b2cb071e6bb53c052239a8ddf6ad5473c6e1f097b642c70a9d43b3a90de48f4f22e2ae7d4f09a9b83211c6b04914a771c792d1c9dcf2f15a26aeda82664405823f411d979f461508a3dba420d96b8caf33980e8cc0dcfec125e904564c7bb82b1248400f55995b94ceb85e078266a82aa2b0e3ce4d258e4fe95aa2f21254702c7123ea64b5fa2b5352b2c1e54ef59eaab599e9c3bcc4e0a8b5f47eae79f4c571ac73cbc8e5dec7d1831a69e0edc555eaaa3e650d0b7084358854c33b4feaabcc9472825f85e914288a25bf81d7859225a8f5f952f122282d38021ab6e5c9a527dbf7c0304c4ef8ecf0124cabd152380946ee6ac86c3d64c18c1827a7dbb3d28b03d0f9c066e09677d6f0abbf2c4680fc86517a6443ba156ef6e8b93a43166dbe709a89c48c235cd5904225b18940868b1792a6d7706b97bb038b39828af8451222dcaf9736a4021f892fd5557dbcdb218423f8bf4184b7600db8b8ea2a07db9b3d4b8b8ebc03d7e4fc303bd42be91742aa2ab1042741a8263eb363fd7f496b5694b13858fbccadebade4fd7750d9f97beef5f5e3a1e9a93a6b80b28e2d62f47552a3d5b71657d47877a632d348dc6a7d4d33e6138a9939a1e9d65d79c2773bc53c6921fd640443775bd72e3b14c3cd2ac10ffab16c6905bdf539851f6cd4d8e86dae9e853bb7e8d46620e0c1178b8a3653b89b647fcbc532d86fcd70cdbe29ced3d722c24577fe7f249714c8be1d3815e4a609322f761a234e0369258a9badd6aac8b84ced5282e3014a4c479154c8a01e40a228a14ad12eea8177e2634819cfcc04054ee6c87db94909fbc1625abc3fc58348459e9dcbb97baa78df3d44e9c44028d565614731302e21df36eac05607e546087c3bb24d453f32f26a9f785d7a3991c8a3baf8bef857262967bce34e6f56265063c1ef8c7d4f1803dfdc000d3c81c7f953f5473cbef5e793abdaa38cb32bab0cd375766dc48399971a87f7dcedfee5ca33e131326a155949e74fd1b3194183f4ce82afa0f0627d64fe4e3f1d73b7e89e735aad4eff48b61506df1ca9551f3650fdccc39febd7a1ebfd84fd68b97ec33cc7bbe20827a137a38fdf15412e1bc2a78f45fc0e8d7a3fa4975381e2598ec325f6904d1854eec692c874d30fe7d37aae0d2806000d96d26bcec61a5aba98ad31dbeec0e596778930863bbda91b9a8602136644fefeffdcc6c3b57c2fc06ff88c31e23d6ca188a9914e0967b0117363fbf98cb112496c37e9553439c913d569e87e9663984017e551fa2756769ea7f8a5a596aa798f67233f0aa4146371e664c2a5f01f4487a487a251394fc39346a82f44d295b80932e0ab2d399d34269e687f2280b1336df28d57c85e1ccf226d68e8dc06e46f41967d2186d6eb966dc3525cd8f6b03e6d9abc92d1e3828778a47612dda0d89ddc73d5a1411b9c82240e199ef863b1a80d724a2c2e0793b053243ee0bc32130584caefc51a2ff9eb587ac4689b8d0749744872c83ad732317596652e13a002d32d962fe249228a7e410b3937624a362b5c1f265a7ca0f5d9e8e4cdbbeb6ebe686ab87992f9e6aaeff6f68fb515e698cf971684a95200e7fe5ea5e04d1b0204bd449f7379100fdec70e633d51c85cfef4f94cd51c338dd52fdf51b0ceeaf294d4aadbb3f64c7545cedd590ec6015f947a271c1691d770747c2fb9451b379bfac78e6be0d67b00de6a25665f5a3a0943102dab5045915c7bf55dd426ff05ae229e9715f0680bb8365aa2a3216883d605de75416f975489bfbf6cc69da50ba37e269450068fbed116f0155593b80795d433bed5f9a4d69aa1fbe5dead72136aa3f208f4a24b3333ed4444268cdcc1de391eb51bb290a03924a77d9ea5ad000466a684ca1a4a5451c3f2516a70bdb51dbb8f050f2dcd0f95d913e51e67b439fb0e258294c74152ffacc7cde0b5a11fbf08369f4958c232f57c598761c0f0f3dfdec6840e06a4d50e36636ba06dd0d03de046b7edbe220f3f8320a03bcd9435c4c1eb42a09e9cdfa9f93115e46e148313e22dbd5053b46de4d66248515ac393135ffaecc37b00fab36529dd208e672132634e2a3afa920a595908f7a50829f24eeece5809ea27578feae0a388a29433beacf68fe167eaf96e5d189c1589f9f1ae4e3f106fd345ec1cf043b8ca8b4108d0a9c411e7d6b380d166a21721ba84319ed3a8a96cd8d9ebb8b02018ac92628120eaee4daad54cabfe9cb6e73f082fb9827cc4a6fadf3bb9184025143277a4ed0d576e0f469b66e493662124a36324c5a508620385d2c7659c06d62671b7019b2669367d90cb55ecb05e49e02c0b046db710e1b3cdab8cc8ab9e3dacfae131ca11ef40823626552928cae3c3ddb741d441c0720605d78144096fd4b96e45b7b2357a5d8d1c714dc2620785b82295bc1427e306ad35be5b00c374d985bfab2e9b5baf21c0f5574d9cf467e7699ffaf8c2d2a252ab6c6565d9cd068fea7c7550b764f5ac1469af29595fd59cf2ea43750e8f7238d9fc15bbe85d93bb521e1b1cbcedb7725753d5034e7aad06415f4560d7ca505067d2f5653ba96b204b6511cf26b84edcdf2d84393e432bd7b480c79905cef71291a23af48b3564f2fd79e41f52bed5e8fa8ff63d2b0209e27151b31dc62f7cfc5680700b4f6dae9a2b79a51c439ff6cd8317f40d9073e8c31d8c2188be130e935a819715aa6e55db241b3c60af999920b2d89d1db14ea83d0a741b0e91f25fe7bbe4a89cfafeffe4ee21fa6a7911f6c5e486f4aa7f952cacb3b44fc0f4d198746f09ea483da8ebe5731568d6686d94132a918d064dbcbf15f5385d4bce99a7608601589605e7af806beeeb13e38546d992322d4c1086927ecb550048c1a8fdc9bc47f1087313e046d4baa5a100fa9106178b162663c03b288209b067d0196e29049076207ba280eb76c1be2843a6dd09c217f8c5d069803fc06e0b454676a37cd05077497b8ae8bd2959b03f200978b220af5b445d25c9f1bcdde41151c8cc5f2c041317f302f7875a3a8506c05a759678178fad81b6d2ca73f732f09e1c3fac9fda7ebb043b7571eedb6c2c7bffba6bcd1ddf6f7c86184e21f63bc6e14bfaf253c847e3655235e7c23450c5e0f9b2333ed9737d56cb4274afb254bf341ee2ce37e6932d7591b55d4ccef556bb2cb9529b6961b57c79a85c5b5d40a55f449a95ebf2ad2b6e758b3e03ec316084338b76e394e9cb03a4c556d0aded9eea207664657f6eb33a3cb24d4b114140eab9b375ca46f34306dd43561e1eb8055a538090d7ca246f029145c96f60ca790a40d26a2c2892c21bba57c7a36d4791683c82b34053e36aff89e6b853e949d40baeda2747433780cee3698936c656b21f053e41b24f377ac2c9f8fe89da9772","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
