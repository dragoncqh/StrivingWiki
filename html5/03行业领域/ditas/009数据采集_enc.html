<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f811d45a533371147a4bf38e5775b53bb23a76a1659a619c6882bb8df89f012625d3acf5ff916ff81f167966166fcf158bd52d8eafa830bf3d9e706150a0dbc126f4a9e8dc73d8928f022cc1d456da519cb32b82ec5529326066ff34de4a555606c8a9d02812615794234b4dd11a9f6d5837ab0ed367a933fde2baeee197aff96e44ad355008b17424cb0e6dedb48c1b139e28092013e18e870727929e45494bf17162013482d54c67c0cde2b285d4e5e76d7b886966a714961cdcfa3853186a34af8c3737a432703212b209e0a739139a55c1ed02fa0781e86af7c6e2cdaf3ac4e30b8c51578d7212b02013096a8a5a93a26d94cd358cbf518e9dc793a1f13c1518e309729d7ee099df34216c2498aaa19eb81db4b829a4eaee3d74ca8f816c81f50842cc2386ad734526b6bea3ac36382614e2d23f17bfad72d1059b277de49408df6d2f7e29cb5a447a130930f646c1ca21d91a6860f6d6925d0a4f0f61d82ff96232ce87a72aec67f7e25672dad3da5820729b893d79f7c1deafd19732cf64d755f9029e99e5975e961d4acebe6ab3b14fa92fdd3845f5cccbe23a380d806bab28e9a0158c1a2689021d5e3f2916828d727acbb6397365ed49da369b584581d1c6a3d0178bb3a1a750dbcb5f72e21fa0491ad8a020e1a3addac63cb2670dd7bc2a6e1d9d22df9e9699c84e0860789e1532cafbc2eaa9b89cd72fcb7d4b27c594cb289c408788ce948c6e75b1b228b62b3f5473d02885dd3cea4d9eda78814343852e7d2c2a44a72ede2b0f7fc2653be231fe47c4ca37f7a3abc6d802aa028ae953dcba47566f3f4aa56b650be04e5054f065d851920e7cf69df7d1ac0fae24ce1414df8c6056bcdb79b175e58b43c15d04c256e57d9d0228326134168ddd8c2c0a8b67ccdfad18ffbfe5c59c0f939b0db4816547eeb3a8720466e3ce7ac1abdb48ac187d37c6b4355e8c69b7ae681e39cfbb2a0917dd162ab5adcbfc0b11f6aafed2d10327a7610158f5e1500aa6ff6d7398575de013cbf431035ebd3cadfbd341f66e1f66e3e3916c4a95b3b8d7f7c402b7f0012ff277ed68ae9f3b70a8b99fb559a561d26a017e4ba1c2815222319ccbbd2c36244f722d2eed71c3b0c0e1f15fc0ad8cbdd6f3777e9e26b7cab08a4686af250da0c3cc30eaf2d83932f31d1680c34b26ecba0a78529f2f097780419d72f74963ce4844b2148c4139a16185a158d50c1e6f0d48708bc93ef31119de35381069b9bf6a621ccc35811ffde3a79e14e4214e1b116b41bb42394e76ea55ef6dc36d96327320542b6577005c2cd31256511365e608e9564032bf085801096f9d889f8b716ec9bd5877c999eb2a9b203a573daf3e72993bd7a3742eb809a372a4b26a7d25312861d34f56407579139b46c72542a9619ffb4d344d26e4658dcceadcecdcba6dcb106cb9265a5dbd82c16a9a7dd9c3902710f362fa8571b927897d840f5ec1594a5d23ad87adf227e54709ac436832107098940582d55c183dad2e9609f118d40465aa7c5792013baa5014874b447b2e5a7d0f427d6ff8747dc14364e36f8f2c09b40d8e99ba809b2efed4bf4c8009fa09b3585fe91545c7d10852a7367458c15b0dad7845cba6a4adce201a24fc286f782a0f9d4104aaa33d2a507e80c8a61022f1e8a532fb96b063697bd5b545aade69d8e6310d8ad147ee396e0485a8c54feda0bdbfc5963d8728e9f04edc0c65fec8959758b102812852fa120d4fce97ac56e80acc8967bfbac18d3ddb292947a6e64284c9a9dc907795d73bde2f246a2140b2e7d470a32f7279694647bbcbb574dc692106b06cce305b7f11287da44d21ee1bffa613fd51f1a20920576a409f5dd4096a2b70c3ba6f2ef58280ae822b5dd617c2a81c56845bc0d3d5a34763fb3f234a068e236a5316980d6c0f15187272bf277aaa0de6388cb7e4b6e64eb2b0adb16a3d04ab1a44d8412862e71879853e017e9e7c531b1c5cd1c57eb285593934159da840da3a72bc59b5ce3b6a08062a83c34b83de4691d78bbebdd2d2e9733ae47cfafd13e88982f575ec8572a154aecd2ecbaea9ef2ca5964ee0a63e6f22efbbe2819317779a875db5e1c59317a732b5c1382bae68b7d5384935577485ba5fb48151a57f41a9c81b76286a8af1153516e1d0b1d7b4a807defc26830dac66cd5838396609191fba41b3744b7b36eb121bd2f48a3b8562b26503f8e47f53c9935633853030bd921ca23dcad0ce854f9de442b4734493f189562fbc2dc373f0c9e4468fd2d7c2a40f2c2a1aebe33fb28c380bdc2096b03bb16a838dcf4fc5720b9a45870ef1c4e2523159256d075883d9dd65c5345c26e1c7e20a407bb81086df9929e9e0fbc4a593a238adb81fd187cba5688320bb20ab3446aad766a7b07d1889f9299ba9b44a0c44be0fddcfe860b9b48419562729cdc19fea19868bed0271dfa67eefaadb115007757cf41723df1d0dfc0e3536a23bdfd47048dfb6df422325cfae10294ae5f976d3a51de8ceecf7f0aed45397607a633c6174bb0a00a5f63bea5b2faee90ca6a8b7d97dbd0c0a464a0bb4a461b80b2810d22124b9a2cabfcd59de4df15532bea3403c22ac9bf9d035c7e56064c175d308b2aa295233d43036bd80583d8014a012b4d46348225e6d5ae34e4357004d46e216b96a73df52b063293a8a1f59a50b5fb54aae0ffce962ece7499d1be390a06413cf0edfcedae40c5a5380075d6aeef08ec0298492f689ce7621e5315ae28f0047818419c8e0758ee8c1d41a8f3149e69dbd2c68becca0b524c17af5633adfe3dd3e424c5278d8fef6466abcd6a8fc4fe98aefcfc0aab915d3f12d0a4e3b780ef8163295caec19e439f166045a638ff7f7a67482d203a9f721e7b6ea5b6840c6b305481d659180622acadbcca5e95659563e9b60d8b025f54d3c1a346e40ef23db77c003fddd2fa593b28dfed94677a9a918e114ca1494d80e4912b52343cd70315633ddb0a4abf70b735fa79f822434873e06d80cc5b601a08ba720feadc9078adb62a89bc85eccaabfda65f4142fee60f3d8c1a7d69093472bfa292486b8d9506a8a2775953effb2fb8aada328ff513f3ecc16a8bfe22757f111f0f06dead052cad0503baeff5e77d0d1a24f3e4e9fa947a20cce0f300213a4e5bae27f75f80268963440d1e5b66a44f49c0eaac1bf2c84728e76323d3090f5c1b3611dd057c9649de0634371bf15faefb2ecc6862f1862dda9a8029d7eb1faa45f1f15dbdea4b252981ab97e49244ae0399c93473620fe4b2a5320c30a83af8f4e928b2a5e3fdcd0a7a4e94eac86a49a847f4f33601dc3eb71724dd95b12dfa47bfd776cf8c650fc86889e7ebccde520e71db78643625d7cf02d052bea87a3b5b247c705e7199f5b7b462fa772418be294bdc720df6602f39cab293b87bfc6e22af7d265f08167f772cae8cfe4dab021f0dde72f4ca2e10a146bd29bd71ed741da9d135bffd46de6f148784fbf49138374b9d1a4804c592aa7735ae31cdde8a52cbd11b99c0ae70f779b133b99c331681fa063c8a38c583240417ccfdd6890769c6462c6822cbdf495f815e57cba7c332259a8179718d3bec93305e1cc8b75839d5c49eac9f5aff29faa3197c101dcd8876636e468a136493e476bbd541a71c7fe09c15ed3fc450f071f459f20e94a3cb3c4fb6c9e8ded7ad6f633c9276fc72c9150f14e80d7d2864109de50469cf883a69a9ad33b4f2f5fd51d3fcd82bf74fe722c55019767d6a15da79a528b0a60e5736c04366f1d453aecf6b723cf9a15ddcabbab6b5d6cd0e8db34223be40094d1b16453915b715ce3d38586e30595f4f0ac3d961c535170142592b649a92f829a7c7f6037e863a8de9d8cb342cba14c58cbf8e802fdc877ef2adcf1ce024f9b8891401d84de27d2a83ebbf41dc1a7486ba37a1ab5706a54e26a461928bc2084f7eade8d260c5ed66cbfde717b21579bafbd33d1768bc966fe22a69d404dd13e9159e577a9281793f0f2d2f690cc286bdc6812c748604200664e9d75a4a5f79636e5720bd6e38713e693f65f11c1788b660c5a924fb81782746a0dfbc43b23b2ec5833b8c039c4ed46547ead17e4c86f30193a3c48a54204335ac6839f43ca56e0760721d8e55ba4565680460967b9cb69c6c61e957a41821d15acbb4575ce0678b854ba27debb779170ecfc075c98b089b34ebc5c38f606d5f3eb235675d86d22a938a91febf35560e0c4b3990647d66c65b92bc5709ce7f1d1b8c9a0cf7364fed508332d519a091a0414f02f3747951498f9b91685b26463cec2a3d25f1b6b318bfa10f358756c1983974bb46b490ae0007ed5cd50e3bc275660e7bd97ee82f20f466ed5bcbeef6b1c4c081113cda108075947a1be552e528d4685eef8a02857f5faebac32a9490c4430da7cf910d8a4318bca43af9beccd4855cc6c5f34b1d67e9f9656235f88b79cb59f5a203a91cd494ff9b1d3b93b3688e4567cf9b53b041c98a72948a301216de2df6d209d2f7f9bab65524bb00ec69b9abc5a4d8af18c87a304d7f5cbb0aadf7820d5ca249d7d1d652cce5e85379937639749f44fc260db06182c8d5d95067eed35f1c5a9639f780623607143afd5f1bc249a8897f43b3afe580e4a127a8aa09a3bfba04acc4e3d6765bf5fffc27ac5f38bc3c72643cc81f8c73ff08f6c2f70a76d31cb5917f7f9442c20328de1ad1471e9c29272c1f6c8144aceece68b421f5a90f7c9a3c5ddd57dba253adf2265a35e79163cd1d65d15a30280b210cfc6f05f487ffb2df38d37b86f7bd61f2dea40f9bdb2b7f479c1d3dd07b5ed6bd3cccafbab8d382ddb434535c13e2a0c66b1be1d69fc822b9249d6012604d365558c80179e6e3b2cec1d19ebf693c161c25fbb15d238d5e6a447d015588bfa6d0cbed3509df65e9641641a951af9c33c808a308b4d1273a537cc83f0f7149911b1c02232b9b0b70241e70f831396b42a488d6e2029b9eaa5044a1288388b9b1864e105fd83850a98b29a64e5d7e589eccb94212f4bd49a7dfaf73086dc1db2973bb3fe1e6aca6113abfd366843e620eafd3ea51cb766d601ebac9128dc3d5f552f1ea44fdd1b48b07629e76cda7d5b8328eb2e8c495cb1a5de237b18db345395ecee9e0fc40f54693c5d305c7e15f3da97d93f9c1c9bffb2888641627ce4db3e4d5474cd351c28b43cb57ca72c2eb5d6d121a6e4c509325f342875c21a42a44afa60b58e3a39cd200f49620e91eab9af3c38b03d949348081587e4dc9c487552fd00995a3e8863bc24844d2b27fd0ed5ae13340cefee37f4c00cf01fef7cde309bc364386b53cabe9e5cd027f08e6658ffd64c4049d3014c7673ff7188d18c3bea2b18f786cbb83145c684fb44a29f6a05011612a221dffa90768ef64479f33cb2e17e4710fc053021bbae113a5ebb774258d518f72073944e908cc3d0c233b09801bee1995945f255acecbb58814adb129b8db7d592229f0cc8b8c96a0815b425020ea37f71194aaab539c0feb63c2f68542646af5cb0c60d968c06a848032e427a45ee92c20c8d7e70d8a702098aafc37859efe968b8a3b98c1acb245347c2adfc682226d85381d88d4467570ef8cbcac9a32d2c034fe7c60ba878c9fbcecb0cb88d9bb35805823af8b14bc88ec55bbad70ed863f539a0fd494db457c1b9ce6ae2f6613ad1020217d2483919993525023c5a2e7da535c18303b03560e1ba55dcfdde49d51ab9f76326187348aa18051a141beffdf99c93c288f3ab139a7f8afa75a60b5c0e0af8e52afac65a35611667424b9365832e6f35c4a7f43063c5bf7da7063a1ac53ea5a8c2a3f7c27787e662c7df2d0f67a26b722b013e8ff487ba7452ce24b66fbc435cf68edf96a8ac052f06ed7133c303da5485524210d4dbe96ad5ed5cf2240a30cd3321780302eab040d7db9b7b75bdd5006e248ca9691d158768673746f0cbd836b996aea00f5f805f5e772d8bb2e8f3df0552b0dc42283a7e4c33692e207f7f6cff3dcfefa37477a956dc795bc0ea90a626fd822dbeab3287ae4cd4c589d230da9b6b304c344b61b7dc0e411269621fd61543a6d363e7df04cfd2c10047a94378eefc5147059a98595f736029c21abc7abfa57853c094a4f44032fcf5495337e0168371fbb27e89827d5b5b1422a6b84647320b643ff85859a8c84f4a2a3cdb7acd828a1e5b02fadf80021c307abebe2551cdf606dc45aed9e688c0152d10c5e7195213909726f15526bbde76ebfee227ec6aac436c84e8639da9eea88a652ca91a5afb991edc9a10927afc521b8f4437aab918a765807ce141825e296379af30c64f95a87e7dbe902c907359c0e3bcf39172a4f7780e1f4105700268e896d17f018bbd3605474867176268e6f8fb722d0b0da367593e437e9bf311bb2b5889df31733ac7a76193a062604c03a39ac31ef62963d7a53ebddb17b1f3a0ebb4f950a8f7b32c1738dde05cc784e3a246f6a97bdfbb58b7d2e01182f9043e57d798202c99ada18de6dda8d95c54ad2b2ed7d0cf92c4da75509de33adc3218d6f2bc95340451a3eb8f90ae224e425c3d634add3ccc8028037bbaad754d12e7cb7db75333f3a76b12db05d50a896d28533a0e13269cde06fc8c84ba1fe526d519989bcbefe25b2c635365bfe9b68816473a2a58bc976fa636ddf2c21500da3e82f947140d9c2314d3050d46885d4d15a231083ddd98edf7140053746e30fbc9e7f7f41a5c1d7b01c8b8781d75e1efb45e6123f73436bcaffd04eb7e8ca821071f1eb2ca934051ef6c51a4bea9c044e267b86ed2f539585b94bb2da6345536453f739b13931974251df43d45021c05c6c09ce3a4e9f2c98f73741853700fd21baca3ef36021749d470b31c0043766b8c42d0892fdded821e1c4d9fb055d5ba29a1dd324a1fd7b2f6cc2f41120984e5885e2f338770915ff570e20f5b7f1b068fcca1255e5101e29f73675847a2d038d9bf7da66a13bfdf0483b965745a03127253e07ccaf252e3ba1f1dfd84ecbfcf572fec5fead0886481d60319d56850fac2b1f12cb6273367dcd03bf638ffb9e043df84e70addc9c5052eb216a8df9f49451c8816f48680b91beae924254ba55be863d0e4fb48e3ee80299e4f7ff65ba322f654c8f11dada258d2339dd7c4350f78cf38ad65477f34a6e1c6db8ce3129f2338cfd39c554b4dfb8f175e932b38c112603838b13f2804f11555484c35a8a65abb82d2d43830896f1e1b5ed29120022ea504d748e5b9740e5ec819326b41f08120235c68831affc6ae9734a1f10468e9d65507c91d20bde15ba2588e31c5f0fec7d1126410e35c0dcd31ab125dd21b70d26258614f220ddfd858fecd11e878b23aced3af903c8870eb562b9140d7da180f058433e115f7c03fc4068c6a18cdd9d228d79d1b9cd8f64a216f1053cd92528a4823a5cd971b0ff6505054b5c32251ecaee2fce2b4e104d0400c98f5b14c39e89731ebab81e9b0a5cedcbb4b160f1cb4a12690136c583505439b436b0daa2043bb32a1edb56cc67b5bb7ceaa435e4f97d502f1081fb7e0d8db3d1ec93afee4a13a9def38dd17878e825f390e66072939d69b4537f8fcd591ac903a6d3b7d05989c1b5f3a2faec59fa3164e093ade2717672a97252dab75e10e98bd3e7cdd6abd27db08ae200d13b90d70052204d3827b801e1e9e09b1685519af725da1ac27b5dbdefc92fe15cf3af748e21ac4518b10f5a2052f5674fa763f51014b1e8c9ab857e31a9eba916bda375c4d5efd39ebc1cefcd2fc1cdc645a28f982e6c3bebf6455559b15dd44250bf039e949b6efc245504d92a8625b049b2402e64567da1c6e4835adc7f5d90d074bc23dff18193c3c067fd8005ad79b51425e7c5cb283cad66e2229b566a1c2612c69f8eea8ab191b514a5594b51646a7d4e2965a73d28d5ddbd4c6a8fa4cb0cc475083a8d9ab361ed3cd8f2ef68b237b1815b59a6b057c1a2de528bd6447ca2181e0d7c5478ec7eb2c7fe66d52dbfd9cb208b77d769164dee0a3a3868ba6a8c97e98f383a6ecbab567f78b15fd6d81241fad219119d8ddbc31f21928191c0a8dbc65214b1f81f0f7401f0b406d30c40efbcea74e53b613bd0d895a3b6a40499e2be8e48799b60c15aee312d517744a9e01b27dac54cf7468f42700979977dbc54dd5ac0dfa81a13ff4cd5acbad1c39db43172f5d380f3dff8ca4730d9c13de2af1c60f6f422122ee1b1e3967ed147b9ce0e6873abad53d8d79fcafb342440b02ef964360f594734f7934c067a6068e200141ce6ca2b2120049f1fa2063c5515d6633578a7a2fe2f008f6b95878f73f27ac045597afde4f07c147c8dbf5821daa061477566196df6267dde8e1ca34499bae8c567804326947d0cbd29899dff687efa16e3ce35c85229a6465827710cf43e6b72437c87dc702547d715c93bbeab6018e63e39bb80438ecfbe55aac51d28f5b773a15af2a906f227b5f270e2b8b95284dec488daee86fb73e61fab49c8b432ebd96026e4b5f92521bbcdcd14e3ad78b69eaffaaafb1cc872f369206b8046a3f17e60a2f166ad72db5ee2c8035764741d2090a1f70583e13057b93091b026c27d4329c51da4f14d8bc783f4e2c0874032f24f2861f0c122ad70d5903b24338719c8b5edede0d2816c32daf84a67c852852265291884ffb925a934c2b96331cff20bb47b2b1842b1f27fb65256e2a24433ea00e3163bd43c361dfb33ce90e59bc75e2b9970d6b49904efbfa72474a40e39a99bb2d9a5ee9f716a690900179a7e5e1f300bbe180c87cb045bb4cc3807beae6e8dc5479eadb1435bba490f6489f36be6b476a88b7ab325a293e0d80a5e70999c031beda604b8971def410092eebcb7e16bf3420805d02c5c443039887dbb9a8059114b7d731ffccea4442bd8d0e323db95e53b1957e1ffe342fab9d57046fce85dc527be612707d134151e673d56e76258e7f8b17a94539873244f6810649bc8f304417aaf5a75b9f235e2212129a46f85f443f3b86d21ed064cf220d92e4dc4154622bf4d7c003098766c97f0c6efe0eec6c2727c7e65e8a11c93bb27bcf6528cc1f099435402588929cfa0b56dd6e3c9eed087443314534be9049fb62ecfb008e5990fd9ac5e0122a7ca9c193e7b947c3c1a2e67f7332bc5a2de2ab310250b05c0220cfdb2e4eafd8cb924555de7e704307530b533208b67394a2e5fc508da59f737583a22e25fe3f36311324449afae85730eb74b292875a46bb90eff95fe1c026970fd33051a8505bdf275570e99d9acc89e87df94114207d9674f8a14d831d5d7f13a5aac022e98e1fed486e143ba29ff69de05ee7072ce2de3e2fcbb59c89692ae9c0c66cc8adea560d70af86d806d1c5d20d7fda6348e0614bbc44d5e67a67a504cba108e147c5d3989aaad6744e5856c0fc19102f3295802d394073c145acb2198dc6850d95add05136526e5f1d5efaba88977b8f5a65a7f6af0d642ad040770c1730f76fd0871be870d908baa34b8f21ab178ec755f5be0afac6ca864b0801443ef075102aa1849f94215b71d17d61f94f70567714cef975ba6e781f93f87153b98b8156428d42c51091d6ed6f214a8d4c643caa0d3f9d1803170023704418d7ac1e8ee444e680dcb8b1fc7fb25ae5fc0af9ad0405d724efd26dab8724d3a6012b78853a6a97b65c196de1667f3d0f2a94c518f433c392abd8ae503d13712b8e073d9b46b31a5ee3f22c4b59653dea055b1effaa290ce4cf4e5cc252593012de63572875d43d07ad0c6238941beee7f443478b144a1d7e619be04b6d65a48512d226f8492497e2740867b7e68a416ca5f64345f38dc00d6f14daa3d3f6459ebd7714ed1c304fbae1cd63ab8eefde323b1acd242a2714d2afa301534518422e80cc590487d7c4edc2f582bf6b4a076833c6fcbdbbb697af430fb63871e91ead355cab5f14351d3b03b35d89e589c9cb1430fa0438d11aef343b1048994abf04424fb8adb23b542af36a5771e0df7f3708ff152842ac24e7ad9e74eae68430ec723449ecdef1ca74d6385cfc26bb8a07247be23b56e806851bdf962c0dfb4690bd3ce361c08a2e32d3a485683d801fb9cfefb0b35ebab88e0623fa989c22d2e338769ad00f7d3bd5319eb8b191302eb302954f43bc12909881ca1e9d68f78e7960f68e9cdc77960e85fc7d3b999bae6b1eef6ed251ade8ad959707a281a45a68de2604ded62aa3ee7edd63d42094bdbc55fc8ba16ab865a064d5e81e953c1af7e16102c808827ab9537423d82275e82492fc71534bb2a20097d4706db5485d84f70b878e3d9ca8de4b66a56d09c85c6e876b5cb5b83855b9b643e7d7ca84caaadcfa831c0a92832227bceebd43e393ba83fa828cbcaa07573bd0837fa0e86680f790287ba16ebe4c3b72d413738293b12d36f3146d4352384cd112697c6562e2a17ed33c633c7485a004dd1082fae9f093e3d82e9f53ed899a6dcb6ec26f8527e9fc7d64cc946b5b10b34f7737d053cbdd2f83572ba97999e3d5d9ebc259b65844b9a21d8f9d5ee2c92baf94dc396edb0dd86c5bdfda3e5e26a1c80fa77f26c33b620f5155322c2748394733adec03f15d7169c3708b31b998a0b2b7de63a87da6876bee4384001352a979d2e4a04504b6330cfa58b80c119dcec726ec0d7ce65020eb9e4796df89067261e9cbdbf7a7b6f0640404ff192e003cc5f58c7767e89e8a9ff39bb92dc9f5b74bfcfadea98d3fcdea8e059552d4cf9c383bbdab166965a4a98e691ec95025945cbab4b37349381cb269a26ed302858120bad3c6a6c073f82f3c1404c87db1175e3e7e4ffeda39cd700fb3cabb76665919d75631fa1bbf6f797bf32efcdc758ac5a050d40e491b57dbdfa16d385abf3dfd689ca36871ac81d1a55c5b0666a78b071400cccfdef65835950da1ce890c0fd00d9b48aab8328acaa745714dc2ebf00a3269da52a8e8ab16dcc8bbce8274fb56fe97fc3f285fbb470754d281e3df9076d5040e07a79cc4a44e181bf3b731efa02b2d3dc004a782bfdf0fcde734855e72b55b827accd90fc3b6832324d08016520b388446d924874dc1b981cbc7025b23d23869e4cf44986ff85d6800bc0e89f6c018492f46b879bb9c1e80f8b74f9c89fef05f456821c9bc812970ec851527ca432d860efddeb7b8a0e89d28e01d474617e3593a974b2600d2f480b763a0f672e301b1a70eadec03fc4b81fe379761d2004fa0725042f427929fcf871bd1802542df2de419f84ad9333e3768cd8df6c8c8b3ba58153f9a0004cb3b1983f64aeb4fbff8ed2c6bca8d7805250e2b50f89d7e64f19096488783416def7279f1333ead8575fabe414c417eccf90f2c1d491bf6c7057d18d3aebce76f0d192a09414a64a47bb486f34b2ce2f8ee8e175a63bdcbc43c956129e45f0c41e2872b4b6618db11fda754595d57208d3e7b089e412c3b59ed4cfb68245c171ccab9870ead9edb7b1d416806cd0979098ee03ec990a930579191743881339901a30a636505c36a524f4be7752d09ececf50fa69311ffcd9976210b41270744840480eb8fdd131b006ffe7a4557fa2016c68b857ba0df9b369bbc1105d44cbb5d4d697d1835512f53a3eb341ba235ce90e7b29617ddb37f0d4fb562e16af7b9a11a3e73d7f7b02183d69e68faf1938ef6adf6b68f3fc4e89f3df1254d4739efac59953cf1b1cf3628c29174e8616bc303272d14d5065d249ebebe9343b65b82340c23395f329be34da0027be2f6ec383d1bfd70a5d82928977e9c7c023bbf9efcbaa42c8e8890a66ccb3b16ad6462c633fb33ad6484a3537b7035141ccea878d4c232170013e41ce957ac6571fcb7fc3943fc7c92601ea856cd158640c9aaa037a026dfbd7269936189c45e53eb1044552c9d092e1bada4bdc3279cfaa7c02ee67b699fd5cc0a6c2a1de0460af0e95643f7de0b21598bfa03f2f252953347fa4492a56400c74ecda6f9e99343a93d806697640943048da16f455e590556c0093b8f4e8e7e31212e7918f8cb108e0268087d31ba03e62dbb1738d4b06af76a3f3e3f2b9d835bd2dfa94ad7f8a6c8c0f4f2003685efa4a797f08127be66131f9067f547b8a5992eab3e16d56921e79a7a35456bc6f59c428015d40aafdc62b5748c613b1076cb04db30a7ef2ec1d68ce001fb8b537d893b33329925a74d085dc1259a772f1d42a9449afc0fe5dfe4e2c31934c0d1234d2d0aeecc185907b1941ee7d4c7c223a4e241750c22cd2bdb846b6c3db815e9d1e622048e60ca5a73347a74ad81c82f3915a1d1180dc493fa1931ac7b86bf8174e242e27857584eb95c2844dde760b56d9070a2a61d84743437310d8f3bc64a0c47018afe2ec4068abd964038814bc84d7f7897a9cc4a06049a46afe8808d3d50b660f226e9abdc7c62980c4c97fb3327b19cadbdf105d1f305c2aabc5aebf8adac6aae055e41dd51182442bad27afe040287cdcc76456cf3db33bf3cb85a087379b7d4949f464823fb5e7e4cd1f41a5a9092e947b1c3513662e23bd71db8aaf80ac4e793e3fd51a29697548047a94a3716116b154fc3dcb34990e0de56d94d1cf5f8836448273855efbbcfb608d3aeebc7fa79b9755fd267abbe224f697924ad15947ac660a35cbf19175a9d41cedeba78d5f5d3092357f446005765ba7beb05b4457319890e4d059281236358f2d2e0fc1ec9fefa77cfefac93d17357009090247acf9b601600c2d0e596e67da6e7be90fb5d9711f680007dfddeb832f0b37ed84b1482f5e2b6e5d0339bf453dc13f33a190d432c61eacd8a4658210fe275e7fc2d64da8a930b7459065fb3e573e10509d68be2be576f8ceaccf5f109991681a3bb9fe2e2958ee911a9eea9fd614443ea02617e5ffee592d766696c12686ec5c53f7971f171e3288ced737cad9bafb1dfe94e06626a7c0546ef831a7680ce84e5adcbc49d2fb41e849ea5cb6a90378ff641cc684df15ef4ca3c415136dd60f63c6c966fa5884dfa59dd491b264567cde6ae3351f1e0782b05f025564e0c39f3995431e229e27c05768aca7b04671b4a88b267767d45c128f7f258fb31623b5a69641b0d993dc63fbb2aa08b2c7753839a2b548d1ca0ba6a17e987f6c4c185df9a23e36e3cbdef04870cd35637deea9bef896dbde328b0e20ea1007e2820b960577f23794e435f3af512277f2babb68d27c09aeb0e43d1e3f92173f286594bbb9fd78aea0e41cb8086ca153e6b4868ab97ebb15b183bb6b4e59bfee9896ef2b0d693ae737d3acf2e5f4dad99f06d7830c26959ffe3fae340ca7ca091a60d01b2d8bfb46a7dc4433d360c0a0c8e06a696d94228da8c4a5d34917d451a156f5e431379b0bba3fc38cc7f9504c5cf9902359f70259a195391dfe75004fc1a5cc3bbb6c3a0b85c7bef735a7bbb1df59742dcfe9f50d5fbecfaa2fa01dc2695eace6b99e18dbcb2a0bee1c1c8ac2df8a6be37484b509ca53ec129b4d54368e9d5a4c09cf9812c794aa33b44e03c3f9d4255c051440a2db1511ad38a1e7e508042d6c0a0978ac42ea6a9ea663db1d00af15a33526ddda9fc4be09e9e56a989f380d833dd2f9fbebaad0aa3797df822c435006d8534e45118a46b96b49ce0cfa39397096be55a73d75f740b62f6637bb522de96767595435804c199f70a2df1868a2b93887ddfa94d88b652eb271238e47c7f2c7252d6b0506799a24b174a1ed8f2255dff9e511d6bf2b983b3ebae8f8654ded4c4cc34b971bef8f0d751a2792d908d41edd983fcf02ac13f78ef7d1f1ffcf6dedf566d2d028e36309f88a7e5288cd403d275655e3806a39eb099b9bcf90ca44e5f2e844f6f88b5cd98fd32169c200b2a26e928013c5040e9415c6f508fbd61d739f74c169aea978d96832085e8479be24acc528f8e9b07943c73e5e89fc59b551380f67e78632ebadeba2925ee493a6bee44fe0b755ea7b117f46de238eee3e4f759d590abf6186f35f2e10e2779db38529c1c1b1dcddab0787d8f12594e7609eec14e7717d2a2444a9caf15d09dcccffc46e0e03541fa6e90fbfa300a58bc7a6d7a11c320110c4af8ef169233dd226fa75dc01fc831373b131402fe73cef16023c4e481e199890323b51c4c3bee1a5644ceed07283f2c75bdf8d4560471e909ee39c6909e2648a2d7bee678954801ba4bfd102e55e11d8c8ea4616bbc943a2f892fb4d7eee40178e337e4e87362e301585bb8c8ae610efc24a2b366852005632a252dd4bd668ef4b9a4b9640bbc72c583e7ed1cad517f342bede4c5960047db6715b568c7f917b53276a1948174328ff1c61c9c5ba224e05c9012e651b76cbe7467cb6db615a6c7e7ccfd9b10d21a715edcea3c0bc27d7642fcd6bd112295b71211900e333d2a1ece754cf3ff17800a6faec614e719b70b82165a3a02e109b2b0943fbf267b0e77124f8744e8cf84bec0ef00151f3d1a3d70ae59d943bf869e97f26a69d7fb76eeb9effbcfe2577fe8f754ce0a0ce8259302f9482f2b01a3499dd672246a7f71b265ab25410cc1c735b72d6b408ebd829c76c4fd82f490598f933041978134f051bf6823e417d90ea5e74f5153674eab1f380b2c17d32047905c1c62782cadc7a36f6132f2509487677514cf91fa7d2a89cf116a8468b05c8c6b98564e810793f07e8c062d9c64bf423c6a092e2a3111d25a85857d240dd10817c6c23175b189b500522202eb0778f73793b062c3807542f0267f4761f479cc4d3a54711c778feaac8040f3125034a59dbc4a5609816f53bf2217a9ce6d9b6abc7d412df3ea134d7edc3113d9eaf8b9b7acfeca22f5c0b32f731060ff8d06031bbc5e53d9d2f2ccc978db69aff30aa9e5db534631516be6757bd7d56e0944269d37340d2f4313abb029247f44f6e6fd77ce863be7b8d0dfe130ff348b9859e6e3bd2cbe4fb5d7dea2ec68031dda3bb94e4ac978846675c58efd27df569179288dae8b2655393edb018f44e5ce4be16dd71060c20daf69d3c4476075823b5eb2eb10e73452445a8fbbc2b3f54bbbcc1245f6f67d51cd9bd431a0819f68fdb7318a2664314c43744f12e36155a287e0b290195784154362e9bd99b31d6f5909bcafc0b287859bc4b14762dec7d74ab24bbbf84510e35896dbd46b834e30ba1397b52471ae19e3e6f8a49f2d1d5f9240fa7dfd61ef0bfea308c9bce711134e584090b8fa845ba41e6b85ceae40dc35f1d4ef1ad13d66fc5e85dd639488d45c2877afbc597ca78cd0c72f11b9c7287d57aeaec775b4cb4090701b4585bab4fd367b65d132ad8f90e924e2586452fffe16f26ba6060003c047b596c5bb331504cef4ef669ea351aa6c193c198c63bbd9bf4471baa43035334762a12455bf3648ba6de46b92cdab87f83706385183d5f0ba89d071f2cf251fbbe4f5b5d7cb20856fb179f878562fd243b2ab899dcfc9d4aef35fed18db6a2b772b25757c263cd22f195ae9bee9a299fd7900e040a9c5c191325b90bebf69e57a89beab9a422d4b915d866b57fe1d7dad38d78964be9f8a5b0ac1b272b61eb40a46649bcb97138cd454ec40f1b313170d19eb01434fa4cea045fc0fc26c913a82d47ee7ac7c0581dfd3ebd86e86b57f5fb1209a587753f30c2fe1b165bc41e708a9510f79b211983b9c86778c1c42d6df1f04eb7609b12c5646cf345d4ca001390ebbac9cf34b0a97c1ec7b080954c0c9382e81d7ca0ca42b561cc3cbe0e08877ce1737b1bb2c40086d0fb0ab1b76f5d189c3825c0f4e479bfcd63b5b1e4c80278fc7c781a9c032d87578953119d8625e2db2f7d2280c8877dc6d5164593d107558b257bec5184f812ade3b0e840b0a6d7f61b2ed751cf71fe0ddbac5c54ce8ea2869de61508831b3772e89f60ccb41e63b749353c79a72f5edf67f61248daafc76d67118ab351f03001f267d7505a5c21c24e6a81297a56aa474025f9b1046f524669941c9cbf24918eb931470e00784c88fb8f0aef10088902387cfa5f00acafb18a92ccce84c9354fa4f3844407348435b40d7268faf19d1a29a717a4e0a9d67e78831882841a00a2a839ad2c1c3b8d784b2750d3e93148b859ab6947b7ce571092830d404f9bd1c77f7b6e3e5882eea40da6677329c55d8ebb8f0c0ba8a26a332f4ffd6d623b5157e76833d92dae70d1472406fb1828959f3307fb480fccc60a0f6928266cc512cd60e2c0798475f966a53ed7509af93790520dd8e75a5f009dc15368fcd5d671b6a32ead7cc2a901a0e0ba36b43b4744e069a1f8deb64e137a708084aa9ebeafc51d927f3547c0b2ba92e7b6a1ebbb4d2a824b07cfc5fc731ab34aa7efa633eeae8533527521a52a83693472a3271dbf60ad5dfffdc19b9c6e6532471c851eeba1cb19d119032a8ad811b90663a0f0a768590411d1bbd98ba4b312611593bef27dce29c1dc3eb31e9d61c1330715c864413b765fe788ffcdef3d17461d0fe4c8edf69a02b8707fe9e936831ed3535534fb417fc7aa06ca9f69eef280d80d41a9e53e5496d672dcc95fe0e57fb71fcd2305d81feb7643a044f84cce0a7511f01287ab73002dfa4bd0e131cff50fa1f31de66d314e385800843b9bc711fae4cfae4b4f5d21969f6eec6e8cdf02c5046b492db361cfa7255ae67f7c2a3fe0257dc0fb536e59f57f262b27a113afb9e03abc8d1109112d70e7c1d0776aac7e2d8cc5df3122463846ecde37d735750d7f61ac2e3b112ad85ca98bf165cdc88fd1d2edf83960e0556d53181e970af22b843bdb0394cd043b08317e58a6085b374fbe8b734d6cdf955167730dc4826886bbd9995901237cd0d361da3d9b5604e2a3e825cc0ca5770b75a1d54248a45c5ac711dc78e24f3a5788ab32d831f47b635bdd101abeaebd7dd638bb5657cc932ac278725021aacce4566cef831dab7b7f070faf5a45e276cd450c94f4af4778ccc3b19aeb2736eab42a42bb8fc85439ddd6eccdc5ce84f29f0c29c8f414ba3bcb48e39b4579cecc7c561e3bcb32a29af47e1d453e2f3b7af231ec0c7ee96e27d55fb510b4d78a5c792bb80c84e44104177331a8b9e15a1a5f6b414633992d565e17ee94ff0573313f330029d2f5ef5c7bdadf5b2cb29ae953d27b583c1d6b9f11cb1aa6edea9cc7b2fdfd6bc7cc81f50fcfc085ab5d4f2583b791b673915d71d0450052e5172bb555a415ac1302d0e7941cfd448651eff7d4cd669e8527126f80681056bb63df910331a5b5ea38b68c7deea1df10664fa5b749e88e43ca37a31ab9ba6d21b22f7ccf878e721ffc8185c50910af66cc2924a00699a2966277127262216602c73c10464c494553293e504dbcdfe06a124d4032bef5cd7ad9f5709f341a09c57b384c70f2264a3fecff3ac88bdd9c102f93f40799499fe5320dc50d338bef88d9be49d3a4f5e4346516c0e35b5e253","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
