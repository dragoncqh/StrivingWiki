<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf9bae8ebad58d7612a9eba63918001b8b5e666f1b49c2e772b8108e7ceeaa180aa0c84ad3789c95931c53bd7843786dc097e675992dd7894af9cc200f3267ed91463ec21a80e8b87c4dccf0778bbe9abcd83f5e8ad49670ce119ef8f07ed1c5397ea3d7de96333592b1419085eab43251fbea11c226dea4448ede0f0b658562295f8e56d4dfcadba4654ca0290ff8151886ca42b27b7f275bca15a9419c267bc29f5891261759647eb6b46173c939142109e36d9182a4ea952f75bcb1b9664ce6cb17ef6a572663d875837fc443f8c916d311ceb8c87ce3aea0c30ab2d868453ad1d02426c15e867d8c291f68dcbe1eb29bef5934a43dfc4451e8dfc26c4d39fa89664c01e9ed20eb2b4fe3200a524f40522e66cf4baa6c5c04eabdd27cd3299d4bffd22109891193dbb46c9a209409e5c8486b540dfbea2663ce8325a458a9728538d2a89e4751b7eb82cbc08861b91bb8b3ec2633e1b469fd0543a16a18200c21f782097cb479e4727682b341fc9042b5f75ef861f8d7affb3819c54d14378390648013da72f01fcd90938e1a815639f15cdff8f153d1a68a42f1dfd172e00d82f08f7b3e1d8fe893f98f79843577e50e04d449133871646d8fcd8c97bfbb2289cb2b54bc781c3e99f57e4ce5cd7fcc11bb446624843f72d2bc6ee46831f57c2aadb1b098e186c5ec45c1682d48c310556def9b7b7cc1eddfcd88405d40b64f4cffd54e3ce0739fd580ff95443db9356bc14a8a2a9fbe987d231a6d061edcb728c71bcbd0ea52cc78bfd8ea644ae73009fd8442107dc330275bf15160505b45ef28e150188bc19a2d599800aef7a06d273f34316c6460e62ad61b5872ed6d567310cf8f8d46b253416aa6da328552195782ae7df6280b6ef3c7998f94c246eead6fef54a64739116cd8732327c932133d102a235c2e39a3664ff7343481e44f537727eb804c02597922f0d136975459aaf0c9be10b5d52ecf78e2b3157f3b0d18da20027fe7b644c5e18941a64f8bd592ef674f4de06b62f31e364d8a120df36c30274497dad9c982fb2dfaf890fa7e099a01b29868d65bc99bce3506c92ffc9b95ed134387f8e91fe728dd4bb396de534c7e70e3c110ba4d1a2458ecf4d1d9f801abb0ab137634ff361ea029e94aae139a1b15fce4a29c08430037bab58612ac448f75a748d995f381a619edf9b0fe9cd5b988c0ee50d05cb3aae16807c8e9c852b7687d6ffd400500ab1b115c0f9326f8a689915e5247dea1e5d12b7b4e622e03de566036dc6e59097ef31f2c31b7cf67c2e2aed093dba33dae8ccff341f1838a6e793b0de097cf2a4e9fa75f0ee3147eacc87abb31cc81513b0d2228af2363a1c697f55ef9d99311a51a935f3ba51c60a74abc00124d26e615b2d8a6a224f2dd2ebd26a1622ec8258ba709f9bf7d8c76a57d1677acbe4451df66b986c172455787a22a9f5aa175e2f033fe1ee9fc6c34f02fce797cf38bae4dd640f01f228297097fca5535c4fd3e977127890c92070bb8c486a827308be1c8e27cd3314060022d011a37687639fd0265ae881acb0689b7140d311054645d7d77da89af5089a0714aecece11557b7cef1556697b0828a60f4e3ee5a997fb7ca59133bfbe426c6e865909adc9a1d028803101ffeca4334fd6827304da48df7d37fc2322918063bef6f05d30c861a7112caa15e5d1822d41d6a16df01c70a4d5efaf918439a097c6a4e534b34a0efb5480da5a8bedcce339f5bc80e495c09776904bc0057f45b926cf37625aad2f0cc195993aa48cbf12f826f2e372057460af479764b5b3bc7d47aceb92ff3fdd68f1d93faef1ef5b79fcdfc1f5b98ca7b1889dd12970e754692533cb6520c484877801a4f79e9d1479ca1220969932194cba16259cb5df465452210eecd9456a767e8b8c0cf0777f42085bae281c6ebf6116ce232e3cb136226dda39cadbf2e36190c5029303ecaf5ec0fcc7079153a494f218686d5c2bbf25f35a55712e536ea2a763a3bb7e8b00ecebc8097d31c839726d9374981e7fc63a8731590945672065745614b86e6a216f864a3e324a3c73a8c28ced902b7945aef1b97add461df933b6c343a02035f6d4c1556ed841f02b6381c7a37077809246ff317156a2da10b278cedbcdf6d7a68cd5613db5d1be21e3241e98384d651de15342c026219c7be1b8fa161c3ac1e553df78ed6086aa8e577705f1eb5ce4166393cca6963b5646f5009efdf13a0e8c021130503ee850e2cab9340ebcbe0f60a19e1c86f1c336d52b1c62baefa9e5e28c44532661d8b13d54c052f21bbc8985c485f9b932fa01db4fd804bd588be72ed2f81808ec1a02923699c84ff3653183ec60007ef99a933975d3d2f0917e117367570161cd80a33b576c44bf582b6da1b7bf1236b3ae98f5c8c83654b7ec0f4db564829c7393f61821923bc8295b4f2cccaa5bfd88b24b3d219a38458d064167137c919878c48aae8da3a66971752e27410d91187d33caafeefdb5bf3ca14a8a024a28859decd22ef9a76f4c70cb6aba887b35903068303f1ad462e5c981f7665e7701845d905d37360574634fb4fdc8c97a592fa013225c566ea932ed700fe8a211552a08aec22cf72bf73b495ab24323bd32ade35e298944acae56063aa34f279eadd8b54b3abf42e78a05ef6c54301d26d094cf43730d5847061e66e921c58d29d85a24deff0ffaa89424914fc54c3e780e0392dce4e4ce82fff258fb60db734132f21cd8b1d5da98a25469540ef82ac43643f0e82957d18cdd7900c24fa1ceb3fb140efc7ceabaa08412bf02685d61a0b931c32c2b0e8a8405aecd2bb19482feb5758ae3e56e6395dc274a8a0a3e792bcaef0eea328866ac1929b7c102d121a48af059be5c6ba2714683b422a6b1d001d01645aa9ef7f28f4809320bc5f581bd86d7fefd6b3d3b4b4ab07dd4a992063e86f5c13a51caa74566d1ea011e929580b5c02bfbad02f10ec50beb5378d15e3b54be36605ca1916f467312262840be39a83ba20319aa002ed263f3cdbfedb793a0a10c8689e070e8815aed3442b3533daecdf7fda6ce3778467e483e989f40e0fefd8c253a68b862169985f6004ac025203a0adf4e23ff937379a3218c1eff07f98cf0ab3328ce9706c1711a64ab9f9932d7dce09859fd82804d26f705374a724159dc67204cf26bbb3afc1e1fb407f4220911a869a019f0ff5e629751aeae7b84230c28121c7505442416bc9dc93be3b0fc063a9ec0d1529722dbdaeb401a342d9d1ec308d6273e323f7d401aabae45242f6d3a267389a69670152923ef0f74e4cb157caad2853d23afb5766885773cfb8f06fc82d83b4d1ec4e9e155f3e354c30f2167153f0b1614b39c6285fc17765dffb9eda9579ecca7f29f3b60c2463931bcea45d11e8e2a98b7ff1ea5c8f6ed1649ce2ace3e1214bea36d40742deb4c4fca19ef3c62bba604e6ad723854a570b88cfd4953d91f15e54de1c35e062f700e27780920ef86a9d404f874d1480d7bdc63f1fd92545d067f9689657c20c93775969501b42c7d19c792e11531e60ac6bb736da6637ade3771fdc0d6dd02d79ad2a5dc51b7f335ee1b1a8934e93cae1b9b7348396915c2ad46242a4c2c5ff4c90f3d36550f616622ba7350fcc625aed295b7272667dd4c1240c6380641582ee50ec167f640a3d07a135e41ccdd03485f32fb7fce805168b6de04086f57361d45b30ede0832cef60d899245443778ab7514b11b6a5caba986be68e3ad891621b3ffeb16cfef8b14e7ef2f4928aa4210ca88a81df09a5dd13b90c91b0f3e0270c062d9f5fe51728d4af2f15e3e022a6787318571c97d61b3a5900dd4445c5bca34a798b3539e90cc15f2cc2e0f68d46c4fb084aefd9165d7054746571562127d4d2c40371e0d6ddf3d114053b61d031824e9d0424f602ced5cf3ef8fd3268f93f022bca03fe03ecc3818b69c40c34f2d8bcbf307bad8dab68ac71724a87ddf37bbf7d92b9577b53395657bb5a4299903a0342faad863c53c4f39b00238c503c55687b0f4075a1483a5471507a31c6009cb82f98887e9bc7f0f7786608189d1da71cac79108b599de0b262507da8d86316eb0e6152a6b60d11f3efe3b0377408653eb0aa186b310170eee846dfa6d6633275151345a2454c50b0483616f120066bb0bb1a534a41e36315ba7ef3929dafae0390d895069983b0e8da1e426b7f879965c54c06873ede1dfb8d4bccd355e9b450b7f0e7025a4d92267cc641d6483d8531c5a8dbcdc4d78de9a7ef3f26df33c1fe8599ee4fbaa9b43ba194e4920ef71f700607e66bb12f99df2147863a8beaebe1ba7911b328d3a9d3d0dc7ea5e23a6ef2e524a4f0ce25357dfd6b827259ca3b0c8223349178c3e97192e6ff5e578345bf14cecac7a23ded3a0da7641f26a5572e74b85193cf60441b47641ce216a2a67ea001fc4f40fdde8f6d5b1687767ee7f252776a89dec7291bcf6d5b7e8dcd0272a6d0e1ecbecd5bef14587911c594970cf89ea70703f15289f68de78dd27ce9ab3b52f3a4fd7b76b3c1700d825eb4f4bccc024956b8535bc8d7a0639254149f458634484f358acf5387e9261324e177a58b3a214db1005169858776140cfd3cd605651615c6a0652af0532090b8dc31cc5d920c92a85ff22b5297a14fa4ac54654c0965d8ddb13295c3ec689227475e185a7e3a62fc4783bf7bc743f1a6744f7176cb0efceaca9af89a0e324efd295c02de8fd439b595c29cb44d93fff833c67b703a505ef0e23a336abaca4ba9cb305fc0a65728557b0afb98c25a5e323c37944263f215f0fc2fb49a8a539b018661c5d439ea057035fb05c130a8ded4f015cf7a90f907483713f0b903e373970efa1ad7ffebed8bdcc81982ef7e11b810e4fd85554c0e935e0f0de59b7155a087a8bf9efedbb34066a15d0393183affb9655309ab1bf08c6355399032ad5ebdce9ac52a41c202682a4de5e52d45030a415da10a758fa21a396d3e4084e14d4940d79f135f91d9076f3ade8a9c942cdf29010c2f277421e6fe9c5a2d393306dd5a5b5d73cb65dccf850cbb7e689eff0d992e64616dd43f85b60c9239410595734daf3cd8ff8017f178b1afca1b7e3892d5d09e9ce273c7896e6fe732dc39798bcbfe6a1b311666332d86d97cd2c575007b1950d8e73697180ac3de9af4246246f6f49e35e28b004d9448fb6e781bb6088450d9ef6b579b168d4543325733c79ba23ded3f93256b359334c501b60f33464ae2b825d2257f3cb25e6582267ddca7b0d3feae837c7611f98a9d0907a0aaf4d4307b4b221e610f6ca85f6536a6c2a621971d8d4b2af930dcdc1f8a677949a958c75253e9032d3afbaf34038e030938ee89d48186d731289364b326b9b9114c6e9320c36276a2ca4b5aa155f62c3907dd4f95fc56593bb1f0367201165162a3e81695b4504ea19c806e8eedcabebb3f3408a39d034b8b120159910f5937aef9ccc053f43624a5f400f393f67080ed8fd8fa656783f4519adaf4fb3d91b54d24263a2ee8cb4e9c56b05e29f48f34aab48ce2d8749a63fe0db113b92bb5a809979a563c7682f5eff3626ca334e66633c24b23011855d43e6a45a05bc188ebe755d5a2a228143384a31a64696a004f65e17c7b3d74c774d7cd13141eae5cf717a35bec0130f5d0a44013e582425bc28d35aba686f3b01714a8c94b9ec83b1f76053c269d7bab19d378f58a7c8925ef3da33ff4b3822b7304232b96331ffa4eb5e78c8cf6213f1fc3ac30eb96d779dbe25b38cd8924e63612941a1bce28b435cf184efcde054b4e42d9105e68d6ae4a9850e5b78affa93c0a3b3587a57ace8a23d12414e1c9b4bae0ab08cff677465fa4f94e9708e3c6433be8086bf38cbf1bd4115f7188a322ea9b7b64ae972b524898b380ec2fd605b33de3fa890c8fb5f0fa9032f715d523c89a43ba80dfb0aaba997e9b04d9b094bec84def225d2b22ad5d35ae61c3a562828fcad23962756b9abbdee8edc4a05647d555d623fdb368538443597bf5a937093499e628e634b54dd7ce8c5432fa56d57027052a0161ed4e76666d4cdb1cf9d847eafa44ecaea6fcfcb2e9d353a3faed156c89bc29d50e03ed6b20729fb7e20d9cf2e1910e6ff52f97c363f9d4dd9ada16a110ad6d39940f6b66aea0235242b7dd390812e721166a3af510161cfb51cd31bc9c392e45b77e260ebc6c32d3e9562295ffbab01053461d3f41a5898c552c7e6c2c5a2720114b587341d1c7dfbf05876d3e57c170124f77acf428d0b1a733ee5313c06ad5f4b328a948a8e803ae6bfbe95488b385856e767f9e85c6d6fc04b8d03ce69afe20775117f97ea559b3814541498ee7f8d7689f30b4100a919320365aea3254d606c904190b852089d9e3ef8e6b1dad07fef7c68e822576cd30bb0ed1b8931913e57c9b30545db43709a179e21f21b40ec60629dc22c730fc57807814e5b136a289de4014e85cf1862fd22b33899800ce1e7bae4026241e898c85d0b4722e18e2cc903709cc12537aff871b34a089170609ee76f79a48e3027f6d3645169f9a208c0e1175eb4c2f67e1267a0cdde1b0d9136be9f0c8e09645d04e7dcc04707a7f7908d5cb6d21d59855b015f45968f78bf59111f48b7c86019ee24beec2bb684b8f611479e235cd7d350b0a8187de9c27a2aad98fcb4007ad13c0ec919aed3ca7e0df36631e9824c4244b51c201c89521c4a5158dfb50037d18b03c3ad07ec3a9e7ac0f60dac200372597ade2032e3a7ba1e9cbc30729ae353069daa5e744af767b5b364bab31de1c899ef405b8cafae38d46aa9e5b755341ec8eb271bb907eefed4a157bfd33785e2c19a4174c1d712ad705cb712056afe803a2364dc8a8e04e2dc2748538f1a69d90d7f9740f01fea0776d8fabfada2f4e007518aef1e4e95b9c2be1374dd71ec307b3a7dcb02578b5a9d8adea7ffabe27a09277a81548d760a05b0f83182796924d64cdd3b25091cdce23fe7dad0e2ab32ffeb03286d8ecd78cc11f8fbebc18e3cb54871ef0f624b220cba37299d488f220b029dfc4501ad14439a230959b96252d1d04512e48b73c3f4201655fb9aec68920ce7d340877371f6b4bb9bb750d8feaefe4030a30180c7ebd0ce3731863eae58a6d36c778a66ef8a40cdaa2e9bdc03fe6b7887893a7f72310c96e308317e74bf7acdc69ed1617f93199974639566eb785d8fabce4c30e1b936ea23b1b96f6eb52d978dffb5d85be05e2eddc7f6c05721974aec3d984801c15db740ebcb7676d3a41e7d9129ff86c212343e12a79ba70743a9fae1b2b3b1eae0f1833a09133378555669f0a506d9ee9e52eff60c21912881a6e14cd6ca9fab45e2d4f04c0a806b23530078052c85a042c84d1457e7337fc2c8a88b070c64e25834ba67781311ac477d7a672290e601efccc93928e3a1af8adc6ad1a99e426c75b328a4243a94b6489cca0b20be26cb7744d35ad8a5f7cb6966b5215131796fff35110bca6ef376c3477a6102cd7fb4e1142315dc4cce615385d6fcdb15fa14e4547b17bb7f3aa5e9720a21e9d35a0ef313b9de92e768b773ad9529befd11a617c32e4b7db7c411e6537e84e1c1ee18ddd464d27e814ad257fe8a7b7fcba187fa22212c560b71eba4aa617b52c9409139ab01a1872bb1818d38287a56c386c53b0123e1dcde9abe824dbf2c7da343c7fc8a31a130df2604ff7423097304a58ddff4c72b7fd18f3bab95345e52a8fa0e54f65c2893ba10f68706916946279d78b3b4fcb9717474f70c92cfacacbe86b30f6c78c01e22049b163e23868812a77f1aa9157443c89a2705b11b1610e79d3b3b105c4362f1876f39b0a11d0ba7dbb42be1e9bd476e186f00ce594e07408f521898ed2df9f957a3e8e1fbef1c2ab0abaf531d30bcf96d1ce54135227b539dd154458bd25b8a503f386addb682c8e1bd6bd0a84e3eab29b7c8ad4d584912b4b4add87b73a5cc84288378b6a632ab69a1f8ee889e36b70c16b536a8cd3edecccad654947fa815c90d64e795db5b9611ab72d3176313afe1944d28b55fdc24c5721c2bb6106d7a6986b6be4708287480c198ed5ab3ef70731879f2635de60caa0dd19ef6d9ed78b9a2eebec949d85816c18583e2b804bc16ec1f3efeb090a53f7d25d539a2d8d9ce58fd265592fd070557f2e4367eaa12d243a3598008f90ee7230e71b0b4405b08c4ea250ab948235a83bd74de5c4a5f70dfd3de514f12223dc5fbd6c5f7d9a3aa7966f82ae319c053c31c23f8bd314e6ad2f820b7f447adcea8ab55af93c8dd74479e34d28844db4b3fc443c683a75f39cedeaf8a3258cebaa71ae4bf46ab1372e6851c6bdf374b552e344f7b17ba9eb28223cba6f05345f34f63ac748482351b8f32deb2d6dbb0e3c00cd2eb6062374b9f00b4cf8f656597d6646e9c38feee680b0f52e50ab2ff14338f6775bdd542887ac3ba5a2e923837231fff89d0be7daf7d24cab15ae5fb1aec7920596faaab64478eac7c340e57376acdc2f3ad492ce14ea824caccc5c8ef1107332f8ecb3cffdcdeccbeb310a55d140e73be8d65a25fea3f750465eb363d2f37a629bdb10afb12df6addc80683904f4e8acaeb92531699530e07f86326cfbfb8ef12363c17fbabd75b6a67f8ba89687abb84b849cc00c63ceb5227f701f25f6580959df82431c5b231abe5e3496d848e03b9361c176b8dd033db6e35d83f5440fe9350610a8370c5f8e066a72314279cf06c24538bca9c146f3f9f3a54facf9a623d3d5b33835462d1e621fe2d36f89e2182414b794b77af2c67eb1ee02771af8b0f9366ddbf9be3e188935cc2e5189f687ca35e9fff1d3897fbf70824a8022b208fd27334dde18b6e7a14fbf94dece7f3369c2e9cb22709cf2dd56b3dc79b68893e47845f1cdbd7f328e745e1160a17277f9eca53c9790be24439323ea240f1bceafad1c2eda444c99ceeeb1cc08b69233ed22b3fd7077f1cf8c08ca4c4ed4ba2066297a2e9861efc5bece530162de8a63ffda00c03bba08fce7cc84662649fe8b0a127f929ba7c5058c9d2b6d95888d3fdd932817990476a86a81d26417c5c7378dc772f2a37298c4826dc49f67dd989116f599986d990436c4c6b1c3ca24273f111e3cd963cafcabb43a4ed89a79b06e022af023140b34c04838acb49a34c4feb5dc557f68823b38bcef86caabd25e84712f626bc61d21dbd38f1330cc5ff2944dc10c01d797ba24b92e23aa0edbd8bd966761f3d477aa1bab5749257e9ff5bb4aecfbc5034fe205ecea592a3b826400c402bc42ca873110c9cafb36300901860ac5ae552995658d387ce698b4ea55614992cc8314569aae54eef3ade870fab84a28ad5492dfed47b6bdb46c1fa3653707649bd1b38036abd1a1f00a6c7ccb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
