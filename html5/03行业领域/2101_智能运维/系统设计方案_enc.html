<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33d127e7bc88df715d7cede1238a5efc480ecbdea2b9db9dac567ad230c416331ead10ae6226b56a856a6ac51a2bf95863b73bc4a7b1b3834448bf85ee868055dab4e7b90ebe34c9bff30dfe5a2e68a05117ac251c7f795da108385ec227dde2aa6f9b74e03a3555e606c05733cb7bcc3730552c13592710df5b330a684ad9ec72bbc8c163a5b8f9a3fc5d3fbeffc2e70d4722fe89151395734f7f35e2df208ed025ee9e68557fdc01fdc9f168fd074181c7f8dd601b65ccffd379cc55c4927243fe5e90507e27d7d0f32e9f0267cb5e4a960277e19c573b9ce852893f34bd17cf4740128f1163239ccadd1b4ebd10d10345c7304f23dd53c4cde3567f486f06f743c6b35a55add6894ddfdd63eb9a0f6e4162c1b82fcbe72ca7c19b28f7389023320ef8e25aa45c81e09e26403c4f292924d3832e5524b0c500a775c51e8645330edd3f050d5a663a5ca30e298c94e470f90f58db9822539661bd6fc4a1f241268755e825553e3b0ef4af7801f31bf5722e2543f7384ff1b93b82299b97f989e59caaae4bdfa612e59f1977e60e62ed018edd01d291b1fa8202dfb66d17bf9ce4101eeca283010e18b3c5f33f61ba80521da7ccbf62d90ececa93dde087f85ce6dcfadbae201b6cc782508505d682ccf497f64fb4882529ca02d3c5271ac13bfb66527d20fe144934ac335a8fde99969218344f6809772ac1984ef22be432b9e3477c2b21c6c11bb82285eeaabbd87d1fdf5d3ef33c7e0f0e4e1bd0794a0da38fce6d674105dd0c5abd83fb4fb535e772dec529ed27d2d02946f28b4d1fff836a6c3f94cb2f08be1cc53f6c56515ed6166224205540499485b0cadd59deaba5d8fc58f759114d8e19d5b6234c560c0625544a39e6631c51d47cbb9e48fea2913f66e0f0229d5254728fba1c83eed81c5095e04f0500dbc4af6df3356cfdc9bafa1aff46bc94790a1815b35be99c311054808b57f19897ced598804b6d395035b26b182ef7f36742017b3c797604a0c8a8d3a39f2ff774bfdbec55c867bd44341740aa549095a307892430385148cdf02765d72308a04b7ac66e48a7949c091c472c4810c0a6adba46a7943c42d093493b5af7c5ae0ccd6a6b9d40c3a61399ed09a402677a6874bb72df13f6e8760ef5863bcc3f7f0d8e4652c397a2c1dcb4878498ccbd95b991ff620b072960f715a3386f0a5c04ecc6f9d00cc8fc2954fa1c316b2f00d1028bbfee1cfdf4e737925401d79dc1ff83ae41e473f8dc6a341f8585e85d0007841009fb5183b70276d81eba432abb5becf4eac48653fdf8181a33b6ba301f35dca009c8e9e28341e95558eefb6839d0018a139f14251d6fe7abfcd7ae82d3746d93ca9cbba7b3d8beb4ffc418a2977d89e5c90c5bf88c1ee639adb5fc3531dc01e41bf7d091de300e3291027d09d368738c52faab123683f83e03a696b9ccaa43558bf411b7b033235dce542feff5c9ceef32c28f9b25838493af3c5dcce5abcc49ba947cb4f2762ef4738c59005f95c445be8f33fe97b90b807c685539574243f8f6e6dd6c366d90b211d36b81db5a03965f4ca0837914a2f463789db38dd65738e619edd43781392f89eedb2a5740b548b7a548ecd8e69e1357272085b8ed3ebcd4c87cd483e7acc7b96245cdada98bc8b757ca29b69d390d9385a6853b7bbe2b1e70b88f1ae1811d49b3eb2ccc7f0902f7210b6012e6a0707fb899e14051a11c2633de2acf87aa6296557f4e419a4e6821bccd8ed3705111d4673b45e2def55b81218c7fd0ae2f89a26eb256d45004821b1b592f4b89bc551fd02eb539f02a212ba234e9a4a5d93c58ff4bba7fdbec1956e0b696c47bdcd59af82222c3368ef6befd20778c8440e271ceb20a4bc9805f65a3f7c4b708bb20c9cd4b5c6e9125b0ea6cfaa9066e1ca2e9b3568d2ffc88ae3c1e3fd35126ead82de327a85f93e104d41368f6fbc235ad230d08b1f8e294e2bd4692f292205a258714fed46ad9cfcdb3e07c5424693ba527964c6dd49f872ac2c63a27fa0ab6476a12c0196e76418c7ccbd77c722c951f247a2f023c75f5903dfcfef7bf2d204d9e0bc17d4fe8ec8d7968cc0f860abddcd2bb8a3826a9438cb72a9370096e9a99c33634cd04b7c54c19779f0d12a7db432adb24093961bbee388da7e0f5fe6da75610d54ded590a6b55cd84a4c26d5f5c0e6ff0f792689a772c2eb70d14967de77b1bbfc8502fad7303d37c88ca41723d49463577ce9787638f9913b5e9835136996b1cbfbaadb5b9b5603c7212f4048b5edab99cbf54ff02ec95319fdd54f31f3ba51b994ac4c2900615682846a4522a7922db9841db7c53a21f62d37527c50f86ab9436ba65e9cb4905674b2cfb6b8c6e150388c36fd1d41d80afcf6890f87db5b093f4495ae18f8234208980624d3bafa8be19f7ee2ddf93e0501de8726f7cb1d8793df13741fcd0ae9590c0534e15a29cb1c3830301482e4cbc7413d5e3eeed42433ec781fd1288a81ad5a6604d75ac7da059e6e11518bf4a0964a1ca9d5bdfdd6c63e7187dd23f0681c7df4fc522af2dcbbfb5d459becb553a33978f2591383a7a012ebba57269c715e5d08080119523fc8ef4cbc56dc46f7f351fd698da1f8051d2a20769d23551898ba79747d29858e65be30609d996e1ed21c0e57a1bf85e0a79b7e8a1eadad177b9dad497589a6ced34317969901de9b14c2e783f31a49b7082c1baf6ebb2c312ca71fed1720aa818ea950213569be41f48f7606e8a134932e2dad2835b41e75d567bcc0de9840c6635721e05e6326e91c082accc9f4534812e509aea177a940295d02806d15ebcae780000d6836fc8ddda3e07fc696f6695c8ccca2227ecb412ae05ab7f4e3d1beeec819c1d01a2d08d8ff111962d789336945d26c7401fcd4b385e32c7b37ca8f0b9892a1eb711cf2aa1d7a7ec10b744ff2db9703e3da2eb1e02e0f3b01bef127005772a9740781fc920cd6c8c8cce81f12610ef2d55c808f1fb6a172d243781b143fbe6bf7b3700075c048212e073b8f3e236cd4821461bce3199e495f079125f478c6375fc6f6d54d6c87fdfaa99838fe9fece5e317fab84083e8cd5fda102d37b6c87c3c0637102f20de14c583f023f1e98417d5d1f47aba1919dea68e18de3a6bd641ea1610d55fa355514e3f1096a971aa2a28c69fdf9141f4f031f1e3473e4ac28d710f2e2619fd4984526210d9d3a8e58664c4e46177b2bfce5f7a12c9b9bdfb3db45ad784dcf3f33a71b6912ab1265efea3b4df358ce47e79798646caa56a6b2ef09d2c87eea43aa9a175317e52135165ff5764d72d4db23a6fd3d3fe5bb28d6b2e59f5f023ea00ba1849c9b7b08e78d29a5d3d6449458b817433e264cf97538cf138d09427b33fdfd89f00bc81302f1320a28f60d98e8ea4022bee4b6ab6233f026805efd5927590987e06fea3f461c34c5678eb6752ca58a87c5f6aa44594fea5c6677b5e16fc21198855f45e06df9ab5957631336753650f0d050ed4f713e071a7a1fed7687620197e33e4c18e7c755e506dbace32cc9b9aacf7c377a821b2deda02e0c0f1f759036463ea1b236cba0972d350f9362fb19f062493e8483548f4cd0569149cf27be5c42df00dd6af326e99a1be4dd999b2108a2a0521ff08373a45150878a9d2c9f54b8457a138824dbd541898a09cce663fb3970e966fe0a4ef0b8edc7ff828504d72c7a36960a620ab7684a2f0c9a9d0f2daccc03d4c6056ac0098644ff5a551d18a11104b4c749d31f0f440fa86ffbe78964cf8337b3a93b5921b51a82b577bba4db6867d9965d3fedcbda1d815e5827a3f36739983a34a5aa91b6963d09affffe7f7811fa84b6ee05babf40ca7b31858fbfd00dd228b60d4ff727f28aa027c1234f1d0a6b467e10d06d2b9b3c8ffd9efcd129d57c6745dd48c2397935fe0f83c0e6ca3df5a53097dcb4a88a4825aab5f00d1d5293d7311226928e67bc36a76ba34662cfd5a935e30f298e71decbe6f00e8728a111dd91dfc4bc2cb2db490edb030acbe593b876f70f06459cb3c342e5259d479a10b08b85b1d285cf2353386a1b76d312a1d83aff89b9356f4c9d705aa67614e3d8616fd018abb8e6af86d1ff490b71679e4f7e15a002ce8e077e9e8bf75fcee10a2d0b19b88b1f1a554047c6639318705957243ddd433b98661a88eaffb0680b527e14106e7e14bbac70e6b313b948d7429030043e97dc87ff30f74b6319aa1599643fd392850dde242cfda55437ab1d9ac4f99852a0ae417f70d91fc5498061d4e6c323ba8b5e79c840faaa66495060fb1b30db9968ff14f07a275c57903a71500e56f685585616898d25f508d2190c7d6faf04db7f7527810d909c19171d31b8d93b5c1117a30d176c15a7fbf5453ef722818bea4538f200653bd5c9a05e80334c7bea59ffdb846339d08325f33ff57f2bcb6c9ab65d9b1e0637df30d489453be68ee2e3705530a84c359644a1d50a0058a05bbb7509dfd4b598a77a9e5cb252f819018b4cfbea7d09a5fa075007c7c70b53b5b44286e7d6dd870dbe246a4796a697b7fc522c861f6028c0e6954856511220cac6eef6e879dcb7d094814cd23ba1944d29685133d7f1d47449254d8b673f16f1e2ff1f2a4a10ed07b769b91b86a06502bb626f171fe8afac822df7e2714c9ab737630f2ecb9c5a0273677b03db962cf3731224e3971965c219f48cad6d07e252139868db856a28079867ee78c30e7adbd9be67bdcc699ca776c9e226b1d6f9b953b7ab1065afd0f9920b35fcbb31af338ee132fc96cb892ddb5131dde992e2dea5aac0acf5afc412bac6eacf510b638639e7453806a774bc559d7a004e1a3262030aec05f99fb3e7acf75b029cf16bdf2da4f3152228e8aa765b7f119a910c7f6c9d3ef6155d18bc9ace56f7f57f0a506cd87a59b0e183eb29577054db6a8437b3afdacbdc31ff2d601dca694e40f11e764246d8b11ee996d508c11b53b1e583914d571b7d376a6355d9b29e5b4179756e5716665f88d000fcd5f68573445c0b3581cfbd94f01337cae49f8fdc9a629b3d076d5b2d821702455d7c4e5cf143ced358a1cc9c267272bb290cde1edb43e4ee0b7862d2690e2a4b0be6fe1b859cceed4a729806c161ddebe887e87a63ee9a6b5ca8b904f709e67b37c0844093915ffaec6f5d16ee48381b89ba63352d1cf94d238121d4c4f51ed79d8e2aafea626dc2bd2503e8e04f7cd77b70b29bb49a5357d96c5c36b6e336d995d92b4f38ddf3e649cab1c68c6ef51d7112c057010e533d1de46e265328e8956aa2998b331896c76b88f90c998d6365f06354cce3381dae5c91ff34eb31b56bb9474da7d9c553a3a4d0080f0c18d9d89d5e769d734ea19f12deff69a2e830d9f3ba79ebc9c92b3a08ae401a0d4ce79c0fac3a6ca3428ed2a4af78dc9a9ad6fa06647916b76f5a6949b97d3a8e8c175c4688d7314161a88aaafa7b8d242facaa2e5bcd4e7c7ec24752a932a70b4e4b9bd507521acd107806f0052b9fbad6dec67196033209e99d387fc151c716a9910283baf8f707cdd4e39520df8d510d0e8d38cb9dadbde4d606812f6431418b844a4c22afd2bb49194b1197083bf163ea5648076d4b58ea45215d32fcea840a1052fb55785661400e2fe2122708cdb920149d5b978f42676a880419cb1c8e0952e7f20fd8b3a4b7c25f284d9169784cf647b3fe5a4db05cef81e9f70a031b929448d13e3069635098cc16944424b928bb17dc4b7ed16c1ac24472317d8de72bf2f811dc872a30a298cdd70aca77912056f838e28a81e1672452f62761f5f1eeb357d6573c387b613f86397a4033d3b9f371603d193ec6ac8351ee7706addc1af230556da0220d9d9b65483b6081d8663318757f04516d09a375dc4b284c3996959a113cab827827639aa0ddc3466d9e91245c6b783f03244461c91f93a6527ee7f514310ab9adf19adda7bad28b9d995b8516e55b4cdd0c36e854a9dc79868a917cc2c35193b5c60dd2c325501d392d0db24b6052ab0b4f5fd3ffef660056f1e8044e734291b3f6428fd39b62d50cfbbc7a64fe87c7b23957420f38b610a886dc5fb77b5c17ea7898e5d08bee60b11385b219b3e6c1be00fc7cdf6ef09a1b2b8e729efe0c70859966c75d723eca5f4e4918b4803bb70cb2f42a34392d1cc328e39db057a04d201296e1f2af4a230ab2fc674e3513d3d1131809e7c81317fdbf16fb477fc57d4500dcc7bc722d7c66f9d8aeb7ffcf3e69f8e6561aad087131887562b90a345b723ff0e536dff67d5e1e978d2e04ed2f95c0ca87f858c095390b243d18b3627ae39254f0186cd603845a4d631c87eaf019bee31be6323876245c84f766a0bbba8f6e9378c488b42662e44fb65ab25db77aacd89d0206757245ff94661c1588c2ddf6124146ea41fcceb078c1c15534eb3d4a84fb4fda40c5e8793d68146064ac44614510d4c7249e95f62647358e910039dd020505f19152e1d59429b595c3bf3accc59ceb3dc1c2aa47d8b4d2048d63620ba9ab5ffb0d4d05ab6f6ce0af06c6a35262673f934c50d142e21cfe5b50bbfcb7bdd23024bf18909adfa5239c51794e6d0f00ff540f767f97e5819d2eb7b09e2a593a3d09702b76662754cf011e48bb2901e097cd1565d626bf2628f58fce551976aaf2fb4a79d99d2342457b73fcd7ccaa788cbd31a1fe669d60a38611c762882dc0bb633ec625935715c04be2409234c04466421b532fa7e16353cf6f1267984a654135ef74c8e01b93338aee9a05509d5fcc8aed7d17166e20398ee664f34fe1252c034a4f42ea8dad9bdcd740fdb521c98d8c31eb6f1069b0a1c0e628a40bab201202cc033385ba17ef8159bb4c2ecd2b0bac437f8f276d2dc6621333186c7d6a6ef73d25325a05da707bc0f6a0513e5809d99792824ce81e53fe3565a0724daa6f93c6a06ee3086de8e4db25264d858176cfd84bce6b98b984c69c96dae0a485afeb14797787191522d1bb75244faf27355c6d984204d797f41ad60b5448979170a362c2fed2eecd7caa92c5923a1856a75d428c58189fde8e2e811f521f7628c262d673b7d3571bc283979b09596660c0d80eb6d7d509f5588f987f47695e01da7653dab6622ffdfcc26b47284d96da5a87c78ce16240ea52358882cc5334a499d87cad7a1b2efc6a4ea409291a447fdeff82f5a0c9e7b43f32096f176197eea5cf4512dc0ccf9350a24c6c12b5941e3137674d5e638a647dd9ac246c1deb9d80fe0b744fd785fea9bc8ea10238c0ef356e5b00104f92f344240f1510d5974b22c602867150dcd4714b56a6603bfa81224022e957f1dbe2c70f9c63a9e28ac94d98ebf16dfc2eec1426045d972a13304a688e4930f9b40c85cdeded3619cee4df8d67ec8fff58964deb1b5b82f8654fa54c60a615e3d972dc1c1e727dd14bd008f11ac793cdf4461effe14522da6d7bf94315a828593e232c42d2f1f8f31deae1edad862311f4d39a5a3aa244c484f91a5d884b7c5704a5d514f97fb5ac30894d60cf05cdce8317adccf4817565c0801e2835e1a9e50eea0ce1e3d0f3eca7f8c60c6bf61eabf690253ce557f44d7ad5e55d94dbb79ce60141369600eec0b29e058430938e3ab5931b63cdb34486a5f6ed46509db3f05bd9787691e70b24f55c605fb4880cb1b1b9fc7b5d417da014abef6c5ddfc5ca74d459e26877543f2a500be26644f651ff6bbe1477eefa9e5178eabb53231db6e0e33e401a88d1ed49adc5495ecd7778e7ec036a00648fcfab5af2b88202be73260c51a79971c731e620cc898fcc6a4377f9a00e78f994e7029dbf79389dab0d8ec3ef00419495901705f2711fdbcad6f7744accf46351d08a5089b91e2a3ab0e612c6dd872c6c0ba4e63e7f649084a994a3d413b0ce2b349c99fdd3e3d3c9a93e9d6be67c647e7b3df3ab91e7cdd07751a6334083e2602ce617865c52f50655d4528fd3da1052108ab5937ca91fc8500e9e4c1c9de2b61d198fe76df5bcfa7184b45f19a0e7d766cfddb9ef5722aa7aa14e72e8eb9d5423c11dbd3cbf8cf8fa8eeaa8aa67ebcc413d1727d8e398a3c766de0b21efc4a6f8cfe5c3c1f394464ca347fd86c3807a545a6210cf1a84f6fc64699d3a7d6b5c191fc5d026fdc99957435c7fc00d4a1644b85245d84d84640b585aa306b40ba18a8fec8a4c2f240276d2ba4b66dbb741d620cfe67ee18125e8102b38322b744aeebe5f8a4674e622232d8d9964c77525a6180e549ec96a8ef91c3c712ececac5b5fbaaa4663251866486570438f5f50ab8f381e3aed4abb08e42c9d722d40b4440f95aa19a8b3a1650547fbef99b805cd42eec23a0f3b2ae694ac96e5c54421cc64d0bcc3d7a74a7b951eec2d1fb541718300b2883f0f0151c62b4553618e87c183d2da1f43fdc4736a5bda31504f696cc2820f53e9da7cc886e402d26314e15bea35105464d39b1c810b190c8860c8ce8a9c0b1dc51faf2cb844b9c6cd50b9e99ee35b18c63044361bb79b2f68ae8ab4458294d5959f98b2e917c60e9bacd80eddbeb02584808fc7a2ecad00711cffe5a3149307fcc58e9ca9bfd107bad5ff66626539672839ce16301dad2b6369981d40bed14e4ce61dd890ce70e451367ce008a9927038021113f352ea83adaff6158d21ad013ba8263394c693a463465636dc5b9e7022ec74157ff9871f9fd105f31670892dd4e21e013187a755db5c0ab1c15acc9f6a1e4047023989ac42da3ea87938dbcb8f418a0214621d853932bbc7894098f801a3ca585b6d1e89c2e8877000aaeb0cf9c8e924516480681b3732bfff9833f62834fefe6b11477ba24024c4ec5778b8109718cde4c39a611cafbd961a02081c9c79092eb1f60e5674805b75ca7da9c59fd1f469a08f6c0a6df1a93dc07a3024c0ad69558b742f090b75aa7662add1746f261409aca8de9517834ec3249a5255dde331a0354ba10cc78ac0f91ba45cb938e28b0dd2ab6687876cd322b43b4f25d3adb99b027cc45a9f4e732a508dd846263f1a29f82467ee75fc655ae695d16e1766c002eb7bfdf5a9855051b7f2bd6f13e38124088319bbafca2884e26d3447aba721f1179534ead5b1938b47121075353cb56fe4fbef94940cd16c965f59137cfbb2b322e0d08ad259387965ec7e47f7944770e3bb728e0289f36ed4fe19de06839e6902d7b7d646c3a61ad9def11bad22628f9ff685c258c55e73a103172b566c61e212b23c507a1d6150dc07cced9a5e9db3775ed468ae708f68db893d40db790af13c9156600c8b0a1ad474877e72aed5b5c104a645991557f0aa7135b57ad0a97a0367f90f9b0a9a3eaf6e4b2eb591c32cc0c4f6c85d5e619cf992aee8101daea905cfef26481ebed4b23f73e17061d09af3acf42a5e956e0c2bc96b0ad8c7edb6b05b2dae005c2ff18d2d1db02286d77931423a2547a1624c6b807c2fc6bc6016b8214068b2ff04179fa68a9a8d1a29520109a6d96c20157476dae03ed2bca1c88c26867fd572fbb8702c9720c7e78de070cce92445bf54baf516885946a8ebb828989ee8234575d77277cf8f88a8f3a85b376f93d404230498b1b14abac3ae8e3784544cdaf3107e082610861742d797921be21ec272b314b40f8a244fccab7758bb51f7a304f4afb35fdc28c0dc7b95d6f2fc8ed1f3cff9d51003f1ca7204ce23f974a1d136c1b946cd1874605b378e60caf371fa09e06c739f35ed56bb1315c5dacbbeb0a17c4f3ee3820bb328debb009d3d02a7f1f59449e7979fb983455102eb469c11dd0a01f9b54a792d1f5ebc479eb0667b90ae35a24ba568936036b33b51aa8095b2882815fb0f806a3e155dea883bf198e82de30cc4d76ae011d8a40ab495c458b7ab3b3a1195af10688003f8fe7116af1c465a0bb994d705b46d769c810530975673a2bc12d70ad64f8842275b02b5090439a4444dbef7740ec79c619668173bc7509608b19b92ec1b0449f6e46cb9c40f914571930f7bd72c9e4ac9f06556361980d01bf87837eb5209dfd4a0460e48e721329b7f83150b556ae89eac0b66f6ee629c39fd4f8106125fbafe4ebdb0fbcc9808f1e07f47d5649c06e75dab00beee147eca3afca77bf0b0174b67e6e6cbb62481f40a05fdeae49db41820b7b22d7571514202ca9fd7d9ab08ee3ad4220da1eebe7008835397bfd78d38246804a8cdfebab312c194c1e3112d3d168a6dad77454a015654e0d87de46dcd44b86bbe3d5e5364f984228f63716709aae08ebf5b299a6fb8b92f31d3be291875e28cd8fffd1ca142075c44d978f25259ebf5fd1e2a08c0f0fa6f9a5d9c346216f5cc5b56ce046f0946b64ab27e80ccf86829a5b68f27326c10c9c20bbc921d9aedea5d76b1174b77c87bad16d784745cfba33f87f0cf97f1a7f901534f288faa96853299f52e4b350cf64a6bb1b37bf4877b5594b90543744234e6760c5903ab40abb1c7303113df03408b0044c5fb62177b6f2a94bbf1385b3efaac4926495a5554f94ce8903627f1186bf473db59cd6bcc05a66782ab5a09f82464a14eae0a2652ce8bde82838801a7ac1bf22c0cb8fecf56dbc0dce326cf9cb6c127b58b42bc56a0a1d5bd9002b6ded0aa86457c6faa9800f7ade56403e853ffb691f29a2c47985744144a3857d1412384c8d25503d683483b0f0386e5d28dfd16cee8556e448f1f9e748cf428fc2e3ce56fccf89ba10444a849c4ad3d227686e9ed22635db53c8537829247a7ff5eb3cc0348bda4af6fcc148f52e9a359386f6009a374dcafd22e2a316a673d26b510c3e2f04ec3d0f1e94a77c65c6bd8a64b3ff853cf60b36a1d3b31026c2bbf2acd68e008361b0426a531c3380ef0d9221c406836e3c31abf66957afe4ebd661c2ffb77b9e553bcb4e41b14199c948323a9fe817ccba9084b83df12b1f53c730108d34939b7506fa4130b7c0c512c32db14b94515d1bbe01526864040bebb92fc732504072862f83f13b2016d011fb54cbe0d8654435912262242a74541e4a93bb0d5fbc9101026a3641565b3c1a95cd86b3bc4283f96ee6f4b28a509e09942e5c853cd8f4a48ea39836580f3d8e1ed2d4e57e417e92c09dd158877d8da15b538c317b087d7ff7f12cd5202e03602db7e1da471a75d496c5ac359eaa04f1193f19eb2542ad58072758ffc0b1e1cfb807eebe905141edfad2568e55513ddec457e3cdc41be9b3e08822ea26f87966df35a265c928f620a77f6757cb37cc9e9cb8211582b7ee374796b70c530686d71a8c1205feaeb7c2448dd307084d93ad8a56b6470151ac72d3601095feb4cbfabefe6214ac2ffb6b8d1cc8c8b94e6669e9f2608d43abaf246019d97068cd9787eee56aa124339ddb00c166b0ff42d07a4239612683befa587470a87356c81bc33c6c88a152bf5e9f50527daabb10b88988a534730c543cfa7f99da9aadb527723718696e831a2db4dd82eed5c38938f6af1189f3cfeabdf7ba5d817c80f459678759ceb4c171df590c616be9cc1589829fa94e6fb9541d78143dcc9f28b719a6affb230098796ea934b90bac26541d3b2f38ed11a75444f3d1d65b71ec0e8e9d9dd6b4c5915eb3d789145f9d40384209b576413832b4ea56f43f963ea250a0f29ca60983f1041ef727cc7cafe3a6f5bfbbd0ad24997db3b48f8100be91d5fd5fe4d4caa444159b32c439eeefa34ef00012bdf619ff2d6d5124a8a36c527fcbc85d8b14c7ee46d8fbc7cde6f255e3cb7377f2f1795ccde61ac81bd0043b920ba7e50e018b2860da631d7f6c8569339ada4659b5e42ab14a8ef47bf5e506ee76967b01885618cf3404044e8d6a34f59c1e682fb2cbb76dac1b9fef793080d89f81da3d086b160757d8811d5600a9a338e63a923c45779b6ca39a351b4720108fe669e9d98c144f5eb15b1d1c8c4bc155163f7dfe2ef7219cd17457abf760def3af52a14f68515bc664054c784fecd4909a25253fd7b99f7f7aadff9285d9c2087025abb5f24bed72be44fba0c9d2c0c3d229529aeb178bbbe3965887e911993dd4e78a6d671fce3b51a05a4a3e95ca710abb8cf8d42d3c2225bbd1315c89946cf0ad0ba9f97ed5c65817b7093376dc25a3ebeb19d527823e3f1735f968ab640e2f6279f6e41b618854152b5c6e691c5b45ee4460dae8e35473c39dc349e06944cd90e5ccede52c5fa5c6592c220a8aabf2ab45b07ceb29653b643cab4df6b6ec6cbec2ba3075f5069ee96d11cb304d1a794f43ac5c1b18030a50e00b8a78393a9842f55a4ef55931d2e181711af57a7f5b780e3bbbfac97cb21c8e1e5d09dd8ff76fbdba4863e168523968798494a1b1fde323d44333b0d643ea104df4a0baf9e5bf8b60cd3e688d2c3d34d05943005b4d0d86eb362aed573dcc3dd5de37b287c43ab13f5c10897d24be6e8a05a1dc02c5dd6276e037b86d6fa36993015489df25d9b00749b3bab809310f5aa53cb1fd179a065aa4713b6c62e8b31ac695e7075fe3f6881a3839c016c7e90bfc392a42e29bdf06d08df3062659a22c2e83b8928e2a3c333ab78c37bcee85c0da0452e6b4a616f7b31bd46bfca9542e0c5d019a0b5c8c2894e0088ef079c20dac34e5742008dcd9957c441294562246ba96d8004407378e0db2569ac4a1e77bf7f1694a44522c67d5f1dcc44de5096149ff2165761dda86d7ed758709e9d0805be6e83e2fa67692ed8796ce77c4a33b1ff5ccb0a1ec0f98a885d24f60071b966ca2c1b4ecb5461a2040f3e0f91cb27d78b5fa3ae7b3b7d9cf5dad563b88d2ce27de09f69d150fb025ca62e8d97c302e8cc915ab9465b4d2dda199c1046164a4cf08b2b1e870eb5d580adee7500ff61bba50718c490cd55c7e937d78c9282ea226ca38eeef0445ee0e3c08323b30dfadb9d275e2a1eeb14080e4ddda0dd408373f8a546fcd0bc14099a84e8f5fd9116f6443c3719992bf3dd81952a43d6e4d8f378e631871dfb89395b25c392b501e64d510d502eabc2424901587ecd4845db4b83b54b337eecb62982d909f703fe2bda80703ed135b57a7f1075224af8275f7873a42c476b62d495c947bbe167ab51e3bab81868ccec663ce2be40327aedad88050aa105bc80c063bdb51376a6e743be35dac382e12951c8013ab63c66df2c4c3172625849a43399885831523b8d8e52d4fe2aed69bc472e34df08f2ac31fb1881e0d308bdb326c0c378deda5040b24efe79b3f334fb12628a5b7ef3804b2e213f947bc8a553ac2524a3219479f251499843643dba01c7b131d75175d531348c0dbfa0ded67046f73a9308a6666259ad8e628b9497a60984aed07644607dac4823332b82b91e4deef4264f5676207f22afa705d56a9f3f80bfa3b393b34c4c216babcf6e0cf2658983269119d68760c7c5b3ad59d6346963b02e6cc62f1525c913e117dacdbbd3997fc1726734d84","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
