<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43bec6ef36cb48524c3c4209e11999be96b4293b8b7bda586c74fe0e8e440438a102d2dbde9ac0cce857618a092d186386d275f36f624f5c4d60e8c73e8d4c1bb85738030eaa8da6b73ae1e82a4db381c1eb10404d47253af0862cc91d7b7b7edf59f19ba05779fef02c06e85d7966c7661ab565dc4ec3c09efdc7c2fdc9c1a1f52b05e638c88a9e920ec2c4eb6a3d3567f3f16906cd7bbbd6e021933e37ec38450931a029296fe4aebf11c3ffe699cebffadf9a16f7a26b987726b882521a3356a30b2efd53e2d1c9a3955915240d0c0761a46ebab638b068b1d161746d812b9434d6976c32aac0fc5b65fceb6f087626ceb2b63c0f2e2f64b01f9800fd4b9680a47063d00cbae7299b69e68f3c02ff49b553eac9b6659e594e47caffdb87aa0119128bacd23a81aca58d5ec8719db3cc0b57700350a3647af7484b9986af66ab51ec0a4b02c03f55b47601b717df09ef9338a8a1c40a878ad7d526ac7caa48b61a88216b140b6bb16683c53e36167d339d0e1b14a506a485c8345f7e3a70d8bdba9d2fe3f1df4897abdaa8e9e8ffaa363f9e7353b903d30ba669ecb68b6b66ebf34ea8df4289c686a25843130d61043f2ccdb89901f0a976d0a3485c9a388867f1c32b1854c5f507341fb200f1ec9cebf9832d17ef1ab637e912f3dd59aad9037fc8ee857526127d76b80f4be0323617f0c06a9e653f49cdf38aa0778d4e5dc8ccc7881129d77aa1f53d98765b0ade70b23369ec3374ac03a535896708d5affa77c5f2eea357cfa62b0a1451cc75f4df21b384bd8b3a145f6ec7d0378ded683ee8e2f834236e46bc8dcaf008e09a707e080b7193c7b34bd163e541dc8116f197d917bee90a632d0c615e557f433b4b5e5e3ab96624fb688ad1965c842fdc3c6651ecc0330dc3078c2a37cc0a154b05753b2c42b65433f3c711b3f6682a7ea7b93be465eb55670befec1a53e8ecb9d60dfc2563ef09c3e1c2a3065a070f104307fa374362bbe50196aa427e1685da99a069fe1af7c06f59e06436672ca42e95d23a18a89f5ae9c4aef93b1408f880aa42410a65da11eac3a3ac9ec1059599d10351556243f32d5a0170fa34d16f240d6647acea03b3c19e923065d0d8584e8bf6506db9abefb7e8d4fac99a481edbc28c40a41b9379ed31c52fce6d79dd33bde41b4a6c5a5a2a152b17ce76c2deda548cb4255dbe2e4f6cbf7c8a5444d722563a399ce41b78107458c65f28ffa35af55d8bab955653bd01d8184e38e680c90f1564e01a367f1bf1e070695413f22ca05f3b7dc120ac6adc2ef727a0f1504efd890933933f204c06e7a34396b0ba4ad0b96de961e711ca672bf9342c51c4c38d9a0e469f76e64e4f3a9381d0b8eec7179d175385531b043c96c11fd853e7b1f9e89b5863bef733ce34f3c2c752c128139926b6d8420f5beda9e8cfb2e6e4c9032a82806144528bf219a46e405fd200c8c3292c2066c8cbb87f5903695f6ed84dd9ebbd77e526e752cd0eafe7beef1d205c9279a5d6159ba88c866098ce7d65b4c1fc61fdf1fe3bfb301de94f3f49b34edfefb71495ff499f890298503d84421fef11bba5b3d40f28fd46e06a170108a18cf047c55323834e8ebe1b3ca54c8837c423758b1d5093eec457d561ef975173e27059bcab3ad23d0859b1d81614e50f8258f0397ecf8c2de1b2047e25fc46a6b564162897a7e8140791ba3f9e68c2b8ded843dafdaed31390265eb9f918bc6ac620f7c7747e8db8184223a5c2fbaa5334377a045231990d7c57dbb2d98a1ee840f939096484726703a667903aff70921164bd14fcdcd30fed2face19f10bac1ec7432d39d0dd4e6127961d9fb0e0fcc17526de5e37384c51c07b7dc7ce29990193726ee9a5894b1eafcf61dd3b998a734f8d2ccc9c47aa6cacd7235a6df6efe8e2a6e9f66a885f52bb52a330a82e6f358fe7c16b29c1c7ecd45628c1149abea5fb8d6a5ca76684e7252b7cd622e199ab03f09d5a7189b173c86c6af18443abdf8a3483d48290d7c4c4191c5add8afd08604a9c780b5ef4fdd035064ea828abc3967beb299f8d8611822daaa8ebc142f1cdcc39cf0dbccacec63bc973d55f97ecc9e157133804da37f02f37d66fcf225d83440e40f945edf9efc8db254eaa6ae760086200d29dce380a1d59de69913324a616da6259a8165689747352ea5e905e8fd50d5ffab7a61c860da792f5d8239f6fc4c3253a234e0a6b0297c9f2282f32971b24e38dd419638f559698fba96590c38b8e503d413bc77fe93965bc64333326a684b4bc123271cc10b66c0ba4842388bdefd1a5f160b13ac98f3e7538737b440f5a973074d3a53880befe7fdd477affdabc65c0b5701add5441b3eb60c99725e005cc7b4b8f5293acabb9cc18405ab6b21ce6f558117266bb71d427867581de3d85df706acfe7699db92cba111c35b9be4aa7478e2e2d3dbd07786eff4e1e8daa0c95f5b170f698d83cc32ff52a44beba7078733491eb7160f912d94c7efd1845e0b09d59c0cde04b09b8cf5ecc9b1bebb7a35f52a46b7c1762510b7b2befada868d943b80b824589197c8267a3e0f59e4b3681a7ea899ff09699f7d25fedfd0cfe77e0d3e83ed611795094ca65e932661d6f2f480ea9daaa708e2f3ad015814a3614ab2ea1ad1f1b01438bf59ce1240d8298970574e832d855272ba67c8ff9225d8a594947a405597332563b7fc483a715bc053b2789fd9b028f1ccc29bb5373475de0cae04b6839412f477c28216e83a2480fdf386c9dfdf43ac0154badbe88ba5f484f39ea3cd5e8ebf1a91cbf8befaf421f5be4dfe24caf3c326bccbf62cd15d496f51e288172c13df26d8aa862b6ede92805c8d19b88ef5f0c11fb0d0750bfc51847f654e7d6e570e631a7fc6b1ea705c8d07072451da8a69cb0a83ee15093465f91462320aea67bc66ae26de00bf808f250839bf17f81794da3fc9450ba8ba15c7b9161e955651e86e15c80a8a295d37fa35880feec042b7ec2c4c2c296f220993c98bb86853443ce822ab259362301e70da414c16916e4f10a35f8e1c9a7bd1ae99e3149de54e60b78afd5fe3f0fefa2ce51a206966d72fcc61a29c53e2fe805ced0bc6560f0fbca9863d9e46b7ef3edb1ca01ae39b428b3d4e89c4ae65f47e92fdbc31a36a90750a6c9d9abfe11574e437ba894763c9a2266a6cccb43155948f2d030638ec17a0a0860d61686b2217304fdbe8cca2c50c6c0b5d86daea24234da59371fb2bf5928751e9c4b58faba466b9d42f93dc0f2ec2882e04caac199be396d570ca5a8b3f82c22c3fa541d037f466c7592893a7f05896e02a98cb1d5210d6fe6b8c47ec0dcaa7cf8cee9e06e12858dca84bb796b59463a378415d8bc5f4a354e864cc21e19ea9d6900948eae0f8fde4e4aafe4021f9f08c70b4d20ecb5b0440bbb83c8c4865a06d8c865c80bf3c7886f654f963242fcaeeecfea4329660533dcc426d58e6a37d06a97af4f23b1030256ed3bf76eee6193ad8ce5b12e08c9df0cfac3be50f3612a76daf27888404c1a0a7156bac8be83885e523e3b929318b3ca41be60404fa7d0b0fa33b2c0ae58128a5eed8623338d0c9c9d0880b1313fe6ef89594b90e8601c99437226bf5e3ab6f086727eab2dfab1a62686556492a2c62d6e2663daf899759796f8ae35cb8086c9644951a3cf3243b2cedf7c628b0902154ce77df6b0a39b24e89c18abf66686225aa05be3def327f392866964ef6fe1c070cff6ff570ac19aa92083a43455b0859a056cdce8b5649ce709a053627ba48380a399f91dea45f411bcdbd8e471d8bc626ec5c8fab28cdafbd03c435ee020870b94597cabed683fc93f342c93632076692e072783c28eabfe0e77504ae5fac95ae1e901ef9258b428aafd5e30b470e962d4995bef13dd13399ba6a759d8ac0082aeb0c0994bd533d7c3647fceefae01bad2c2f36aa05054a747cccd41b5a61134a37d4206df25496edd11366f03378b543ceb7d805b7a992e5c7d5eb5c8572e5550c010ff0dd57194ab4b41eaa9e814628e27178d45c94b1121503ba35fde2c1ce0da3c866253519f90516ba10dc71c20d109fc72fa9b107c6decae5feef7c78e2d94d79e524387c820e9dd468ce444ef1feaf00da6290d76d46fcd1e874d0d117e97e5c2a50f3cc6088b21e0d2ab3b5fb57ecba7b99619756321734b6699da6cb04c23f97ed40c84a5234853a770837c119bb292731840b4a3dc7bada41a14cf2b59152937579ac2d9808f4685f36907072e88135e0bd5a04cc6ce32d5aa6fe5195d9b4f330be56f079b6968be3bd0acac5976e7cc405347dcd07245e7713f2bf488d6e06b52a4214d36952369afa935521740ff1ef33896d3c3e884003136e27296403811740f17adba9a667dcc75b4474e784cef42c553311c31f85c0f367be85179f7c6c860a076c9bc649f5f59f45bc8a73d5eb425cfc51a49d0b1a9d3fbe4cc62f02ac2aa61b571024def651ed1306a62ceefce643ec711b38a3f7b1bbae93779331843ceca8b748e6250f93041fbc87723c56aed4c24c37b1ada0e83f0b57358678fe0a70c6d8a78fd6d641313cebed67c829a571a6274ff5758af1288605b35137d89dd0bda2e972cc300b0dcc44fdfa47022c680d767d50fa4da79300c133d465ddafb6e3433891eb8e830af666ad767bf7202e72db2cf62cac06c22d66849d3e7072c6cb767e2d41d0838a482479bf2f0573b4bb77f7496dd23e8c831c4a9ba41285327802dccfcedd1ebeb45712349f50423179098f8e47da078d466c3e70b552537ef7802c1aebe7e418ff87dbe69c470d56abf667f2422f7bed9296f0924a615625f56c562460da063fd15cd22209f2592656ce7f7fb6bdac46995744a4c1970144d7bee3c8fceaa704efabf8c6b69ba17dfae822638a30199e34c5bcedd191ed23c6d1199795fca0b24d6bc25cc19d9f4fa74899f7a7494bf61675eabe38df20a8ba884bb6f696a8ba54315727dfad62d6b6c0584a73ca3b275139ee27c5ed4201335f9bf8bd3b370fbbb57a08843794e3e26266dd09d4b72dd90d498404be0fd0ee3b63bddcdd5ef81c1d4453d6e274932a4f7f994f6ef8881e4dc3b591f84c846a6a02ba146cfd6a003cefd70a45d7e84a2010247bf75ebb76062ee129387f269ce5381b35c2b7d0af3c5d8b29dbf703226e830e3b2740b24b696d940f446e883cedb3de2c7829eb59b662d5d5c64fcddb44edf473a7c70ef3d33c764fc47668fb5ca94a92633e08ca1475afc7face88f14c299164128d9b7689e202ad1d794015dfd51ca46280dc5b75e3c39e3cf68a73a2be1590946554ffed8a4c304b99a7bdc79bbb32fa58b73d96704e1a2ce76c3419b3b753d564e44b8626227228054b664fc23c4d0525f80360cdcbfce8881ab3070972975d71e36cdae37a39714e8f6f774aac4489966eb6b4b21b83e89afcb9c2fb3c952757fc144753feae34db2390773a685cc0367f85a5ac91683f065c5660b330974909a1f7ed18b6bf0d2b38703664d88a8ec7ad1aaaf2d67e8d0c162750ed9ed7fead3f5498ccc4155875394737e2ed08c9495bdc3a9fe4e10c0a523ddc8d5f6c05c6e43957f64bdc0af9d6cfcef3400630b3f05b772dfc453123b6f265d9a12e02d6ff57d7c8d3c45bc9c7524f9a36edb30df4793f723e029c3640b73ed97bb1008f35f09962151423c80194de7ed18de217c9e802fc7658951c1a0666710181dcdce5d655ce5d263fb5baed9f7601ed59ad2917f6552cd4a323df68b910bb96f1069676aea3ba7d600d159d57a1355b18969536b0e287a9fe1b60959c119d4c038b6705b257812214082f2c9e5fb3388bce7dc5f602e6628ae86bad68bfbfd8d350f6a863f1a5f79eb94092b8b66f0d20bf5e1de903e8e6fd4d4c899e0b53456b7e7ba274e3c0dc1a90d031421125409c8673b7d0717536ab5c471874b3b4f4884aa15e24f27a3efcc398f85b22192b95bfda4e8ac045ad91e0e51d023805feb58fb8359464b3065d44254c046433e717adfe9efdfec84e7f522dc760494e22fc870508a9856869dfd98bbb8d4077d3eaa558cae3859e5d0f8eba4175a55194b5705eb9d5ba6d4d3ef4ecac4673e5badc64e95bb758fe7f2665c0c47952362ef9288f4b8ba519a838b8ddbaf4a948a2917412818bf2e276378d01dcb97ce6acefa8a3569ce52a7a54bab0c7dc0dc7d190b292231f96c97c65ba84def2f3db36e8f3567edb5ca278338f6fe70426d71b527b5b79954d3514139b5e99a6f85de71cd4cecdc6af612cfc3941b96b6f625ddb2664cffd1fd69af8cd9d8e15fc8f8263b1e4f4fb1d9d7dc7cf18cf5603d8f9261fdb5c31ec548e9591ee3965a17a72049e2acfe909b804f6544501fac51ffb63d7fd2b28f0559ecd864b8842d7e71ce6adfbecb171e1077d0a1119b1575198b8d84d0f4a4c6be6a10682efe870ab2a32ca787115d5c4d913a3abc91322f6259588f4e95b2668b3769bbefb183d33134d575edafc8b4b78cbfbb46bf05d2832438878c56bd64acc3e6edeaeac4bcf53df803f416ee23cae6a14c9f6c55ec75edd178af1355d3e4a9db4606dcc2dd6fc380cab3a19da53f4e790a9f3a9234cc19948262d78a3a4e25ba59006ad280ba705c9a11d1f3a87f629d39f2cdd22bfc5aab7f6a4f49c67994f5772f4d5722ccf286fd7de2d00841f449d90d9a8329c12017a75bf68b0362d6536f977553d4460bc08c3516a8d8035070332037d85b78d22afe91313d21885fad0b76e024ea500a8b0a295323be5e881fd921e7b07a71a4bf6791a5c3360c23cac981176852cb11db4bb37079a36e0f82d8cb5310ecf11ae752f9e31705d24ce722e1e0d4103735bc4a75fdc4ae2042b57e176d436ad58fd500941b80b5c39a69efff3a90ef31d5f839402519991b534de1e01a8e49ca8821dd1299a7ac9e82e6f34624e5b72adef81e0a331c4e850b54eedf9ccdac5c19640c484a1a1b0272684a2167d84d5a1e508ca505767249a9a1959fd89c56d63d56d40b927529ed7ae5024f7afa8c28ebf4bc739d26812e7964553f3f86a9d8b52c382d5c589a080b53638188f526778a4c361425c171197a2e70bcbf4f03800d891b0a3e002767e7b9a29d3ce79a76191c073290c61a520324667e567bcd220754c46f2845f1d2d5fadd9cb79c634cbc28b14f89776bf2a09369c25c288c138fd77b091e7a7c4893793d2c89ce05ce603230353801d1dfb752bb2d67235a37a54430a797f9753cb90556c5afaf23866a887231b70f2d95f7bfc3098c1003a9e25c16a0aec8c04bf544452228beb4b865feba5d0830205c0c2aedba380fca675b49fa54b5b466769d905358653503c466c44b003614b32215e0ebbcf13427e18b3585858189fdb451ba88d37b001716d8f1212802da87e9bb69e517d3a3549a8476d0b913f211a295c5ac1aca54ba3578eedceafaba9a238e3fa17a1603fdd0e0f63d52c94d7002acbabc35efa19441b63a7cb8ddfbda6000059770f10583c79ffa32136e3aaddba0ed909fed4f6915b55ce4197c88c30f4d0def0d66bcc17af8707f2a3d630a0dac75fa5dc132394d8d2e4c5cd24b198ca7a6afa370f1c6883464b82197c575c4c2678b6689a3a98d16204fa4cb41d9507f6222e0f425e05b7cb5a444dff0358eda8643ee724930a7072ca076e9ec878aa87b5ea20975d84cc53ee73fee0c6282f1df0ed9de323c38acb0d599085991eb6b963288cc455873e9fc605565030307ca79286566914249d0580882b8db103f0e67ebb76b16c19de0afc068421e09d6f447a9bfcbf2b10221246744c31cea54ef36483e88616b59026a7820e2be4a4e50eb83f8ef493717abc97749cef58437c0f4f80ba67ee009e024f6dfda694a1b9cc9682fa37ff93047d101922029e7a12dc0b1a06375c9112abbf9d9332a01352ac68a72cf4e14758fec7f233b754e152c5f7cd5366b899e6eb4f9524e1ef3231711d35fa3f598ff8c28f601eb73d224dbf0b515c28e6c158b7d33ee8c0254deb62eaef94675b092902f7ceed497fdafbd4f27b8e72b5991df9f0c20b4e6e2a9f545acf922a10b20cc7be997f4c3d3d7cef543585b027742020a24d37a34399184e3fe2ebab531d81dc223b15b88d144f374cecd50c886b56423d54f6b83c10217baaeb4c3ab9851dbbc43ecd5b1b76f7ee7a107b54c3f0f5e14722aaa8b810a56e58c2e7a66120ccc77af2b2f13d4b426bcf9c9b762c42665b91810989b7142beb2f4d1ca42e4e6a43786e8df7db50c1e1690135b4cfb0d7af7754b5474d45ee49ca9a34a32fab5ab6abfe297739d9df73e3982b617a2e14f093c9af0cdeed13981fc8eec705eba6bfd020a91143232d099042ecc5360e507fb363f3e6889168407d21219769dafc6ca039d862372ab4452baa2364beaea9607839f032c3317456434b20b23e7b38f2725dad84211faeacaf13d24cfa69f46ce41c81875719fac1f98c87b9bb337ca4525055781c8fc79551289aea99ee70c43821c93b76068abac6017ac84dcd44473bde864a3f94546509af1b860fce0d226360d64103e49a9bd09ae6822cc1a96e3ce2827d1c9fb06cb993888c58ecc98c50ff62a71d33680d89fd100fe033746d3865e62a7240c6665cc189b63219c5fdc3c570999f256623e1e6a462232e7ceb72ef29f773a55ec96bb2898dd400b24fa1082dd5a414e3f69d4247e8e89ac2111aa7c44fa9db3a16581ecfecffe78ed0cb743abf2bc66d4e6b1b33f7cfb5c3e374bffad89ef73400af5b9e260178487449a04adc668630f23b12eb5708942b7c78ea623ad2ede8ff81672694c854da69797ba29a5a4f33ad480c8e0896aacda6210b69a8199d91921dab8b6f8f00aa93e0d2f78713c53901f5002f1b36bbcb60b6a1f83993a02cd8bba2d13c62af8f1bbbf37b9c3258b8c04643ff721a9e20d0a9b4a2f7a2d2540eeeabf0c9cffe510a001a2828b4c60338c14963516e026a85f2b81ae12895576a0ea84b7f6cde8c796e49f219ded642b15b757dba41a098974e17a225af5a8f1d518d17cab257923353a31002ad8598639b7f87ecc04347638047d9259b0e13db3899062d4ef62cea6de3977c9f3a0a504462fe0b11f70a617cd03a7f8ad1b2ed2d8578a1c94148dc0a5709d074a910405b9ff94d0a1d0e00c645db19b1fcde7489cb12d49d8cb4ba6c73293f8cb3e06113bbcdfe99976af41f158e2c4eb176ad62c00307984129997e89234aa2c20477dd3f79ce974475131b4d3f12debb74328aa13f55e91e24441b0805980ceca14997eec729301585bfed28fdcaaf6ce49c84abb7ee0a0e11e4691814158b8161681a1471ff1457a04a94fcf8131d75cdfb118a417438625aeed76d29b665512318aec0b2ff4bb58937dc3eb71a0dd3d7dc79408970001dadb56ea36f42cde7969af21adcb9e8d9b8be4b8304a94eaf4bca6169d619d592b9fab315de13001e63a2a803a5e48589c9b04affe203d6d3f865699a68143e91ab8f296733b77c5fdd2de0e16c4b49202ef4b298d74840f6ff6ca4e46ac51ee15417dd1de144b30613a6d81b013638eb2661f8eaec22c2ac53fe57fd3c71fb6a657da55106978ce0a3355ffa818f052ba62a9eb13f3bf26029fbe6d474b79e7933534298e12df3c0fda03e7db91d70a6be9c095179c0943641779212e23344ff298a1ff0186e69d53644c641f2e8267a7622e090661babaa7d4ecf6879794b91fbd0db134721b9ebd1c377589f01ae0c9c02817b9814e4b6c8b016225682529da648409d71ff38fbcc105e8765639a595654c08fb6d9128398a17a2435e1663206c116488cdb20d53a30c43bf661a25095a6cb328d63cfce73b7f2337bae9a2f6f0c6ff1bda6f1818c47f21db28d1963c0dde167e2e6ef6464febfd7c304dd4f6b397c6e76984bd3d85f4ef98b4c5699313593b22ecfa59570cb496b3ad6ff15da58ae7a4f52c0fa17ec674faa8fd5bfb0f97070e4f9f4fad5de3e05438ac2f5b85807ee50aef3f65a04302f16f213f49a46c21e8b2ceb68a0827a79e02aa484a37f57e545fe6c869a07b5e439ba0d3445715fa229cb3d3a621f90f727a6f88b721129da292a003be1a9a10b3a4c33308978d8f6f0489462e88d036a596d9e96570342f73fde792afa04c79f7a25457d66ea310f8a06d82434472eabcacc8f7b7618852c8e8c4ac38497a8d439b44a2e0f6bcd2413a3aae24fc3a1a6c310a043b7a9eaba9718c4c674d48fdcc3e141e9a181e720abf726932663e06e9d0b360bb1d05da5b5ccc27cbac3437be9d50ebe463efc156b542900b1bcb8685a63294ae95ba1c97b98bf7575e3fa1e7834b66f0efe7c51ce568edda07350b2d3542fef8dc4a79f75dfbbdd570a27bc4aee08188a411d3f02957c4e510eb458c199d067ab35c7c5793dd03d8643ec6bfb4487f8fc75e5a67a85f5558d4e6badec940aaec56ca79670340c80a93e84ccc10bb157dba15248064a956ebb455809f26de9e7cb89e3ba391f6d26fd668f743c8b5bc26bc69123e83202613cfdeff1f8377a0355122ddcf39e3aa46e0d9327c3c973ae82f5c5d1b254d8ef5d116f8db37f4e3002936a94d6cbb35fe1a14269fc9e06df0fa2b548a8b8206b873fe29ad4e8653a92f80506773c6c14c766efcef59814e1645ead4d81573b9f2294d389eb35e8d409f33631cecc37e54280a51ea2c399755e65d1b7609d309564c1e5ff32dee1483aa729095db63bb78d26c62b67f4eb12b71b3f943d9deaecd22b2dff4fff2a319dd8f567fb19acfc0fbd1934a0b6ca8b3c26d059beb12c5bf10f288f5cb3e1d920fbd1eef27d2d78d02ea0ba7ddb3f4f47db0205846893b2235baac581f3f696b8d9b44e333a4558542b96b2c7e8161ebc0ca28ed0434b7d6cdff1b020a15100e351ebcfb3baf8f60beace414c4e5cb399ab05472e3f1cda56cb57ffec7338524a5c7b30acc00ebf182f613b10d8091db7d9e7507a033a784a452896a0b696e941e8bc693c43f4526c6c26d9ab5ef5dfe601ad1f74786e47504caf0bf20d1f4f76a05c3f6e30e66afbc546aa65f578c624938f4df825298ac7f5ff178bce9be312b5fdaeed2272fbc31b64ea0f1ef671273a45a5c1f2b7e3b74a7e7ce82dafdd7bc2f49b1f87614326e766bd89e553d4225440cb40ba0f6d714a42af3d6889027568bb7729a99f4565c74b11c430533b7d455d8254a89fca74b9e50c680f6d804f71d5bc1c026105dee0d7a75fd695215d89cfe36b304185d1404f858f94fab556ac8e21ce5d46209c2c35cb7af64eaa645f3a819c0decbd1f875f347c21070d944f4295fef1ff8df2e217f2ab506f8d5363af207f6f0e2464c2f87b1cafce2a899adb9be5cf34fb287a99b8ec645290dfb0e2d8bcac2596d47d32c322fb126bdb0ec51490ddfda8fc885dc2ad0628e855d55432f8494092ec2c8cd99795b3489efcb0e1ff7323c3ad6d5202ad4e609939312cf435525f85ff74fe597b3cba8382438926d4e29dae5e117cd92c7165c3ad70f07581b5e42870c6cb81af5a19f662e0636ffbcd35960d0a40360e4d2b62c71b0039caacfee45889bd162b2462dc03600c9d9d4a746e148ded2429175cddfd85ccb084ab5c4aed0fbeeab1134ffc4f730d7ea3dc593483f8ed32597e7455f68dab9ee96be58d3b50249f8e5258c44880b7158ee19319183ee8c719ca74cc854b12cf3dd5de2ef3f1ff977a2a8bf56ad95f164416d4416d024673983b47fa28c5aab9db35272c4ca51bb92fba922ee02cfb96ad0d4392dabc93d267e1b7327731c1a4c8458c2d0844838871b532e30d64db036d41d7fc5cc2aa9d17a71efae07bdc1dfbb910cf2c8057985c44199de3518d76f99d69a9f63247a1fe320374aaa919b531a5daa2d34988e39a8f723cdb880aa86486e38d04b68fa81f985d26b9ad07e086a31b5f678b1d63c2d29d5ad00c847fb1abf16f0738bdde2dccec1ad1c4a85b7c5986948f2b82738a7d959955fbdc1bd68923392aab0b7ada175476af15840f5999af3974364e05335c0d076d19a55dfc4567b9dac7b582f19a6eab0dba368a88e3463c37a0c928b06e2c84ca51facca28bd3c1daba588d902b020c52267c03d53ba97d33e10aa946eda44817d93e0ccf182c8909bbe95fc01cd1ab64cc3f8c5721bad20778f13e1d3e978fbf2b6cd7759f6c5629243369749f9553a9c974af232f228a059a720e4bea43bdec03599c92f49e8b61a9836834fabcda4bd2f9460d0398f8424753164babecac684b0d71d6e7be91e408aad8d274a932275a01a98b7a90434ce9436f48d0a18c931b7883343eb682858659e5961c5277c35100606cb3059232011044de105081c2d1f04f754ed84ba9bef16ec377e5380f4ed4f321f15fec667c1c786430b43b5dc35fb43fa431fbabdf4db49d4a26e5277b1907dee7dd2c11c39b47ff52f736252fd13affa1daa35d70d80071fe2cfabca25bba1e47a243072e78b354283b131dff9da03a73585dd11921d697c24c6019e34742c50f962c5c962a84b546f2161d6e832e641b336073da6495439d474aecd07713caccbc759cad7984074b426c1a383ff76351f6877fb7b2d1885a5dd941dfb0004bf45e3c8a1ce5d462b9ab5a0ac5a042c0aae893cd8e7d9692fd82757b05126d9f7815d41c73f28ed259800ae57854bb1660e90b7046411dee04f7ee26c655a43cfa94db7128e34bab611a29e28ab0f87d324c4e36c9d7b8d5fe507cb1cbb2b17e3ba22066c24a7b9a78b475049e269bcb0e633f28eb93d146bcce5d16f79cf0898087938e7583364518da82639ca9d9d518c8474e2f52bf1345c231684c80169c13cbd125ef315a5eb973e87572430e061cb1e00974d53717a387415e689ae8d65115aae835bfd9cc98859dcd83643e2f983bf7788d856da1ccdd0d7ebc2da3db304dae23ea5b4067b132eee9e966cdb1ad37b77cc1d43fc3165ec9df9638deb24034e2b69b1375ae9ce3d14c6e03abe1cfc8bf1f6f02bf8a63a3751d9da2345f745adc0d7054a1c5d2422b724e178f6de325f36f0dd3e9c2a3f3f4e2306328486ce96d31755c0af4995fe734ec919fc0c890dde5fc31d4c33651fd96cd6c5c14cdb9c1e0222a76d3e16bb85a5e273b3d5f22206636fbb87c7e3bfebb9ed9b1a98b1261c439243e371203292d54fbc071db6b23b056a436255b2906b8f47d3e5e1c813b7491a60199ee9e7c5df2428dbdef602b6a613adc98ef0516092847714da1988333e56fdcb2d804c59d981b4c83da71ae780159e55b1b3663f08ef1ada6b51e72dd468cf7e087925c6e96aedc99051a09d9d6b4585292407eb28d0f2bfef93dc0367e2cd94228799505235117bb470eb10d1193358a5f8054fbc43bb4c7360b6cc8b4d7c2ae48ce31c1d18fea862dbda66a551c6ee26aa379d3fe1b253b91b821e327accb26809717de00347f7959a972169f3f5cb027d6c8c2daa987294ade37095b4e468fa32e75b6b067f08dc93d66f1d4e6c31c19d98b76178355eeba67b9bede764f4a401e779ad73acfe133459a2ae77976dc7f43fbb805276b361710081602cda495eed875edd1b6c5a2cc0a5e8d9c29bd921925c8d1877b6be48fe6b2b4b796b05c139476aaa918ad43ed324f6865ac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
