<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be274341d89320dd9045970e49443af16ce42f2f5dc9c8d45e2b8cd0e34b4b4d36da9c62691a75bdbea286544c5394ff74307753bc744ed654ca66574d2c592a10527038ebfe116b31c9e80ff5d6e8ff4c279462c41d57b89762e0a282cff37c455564fc943ec62d56c911fd81c2f8490e1b911574c11c1be69a55f1d6e685ffb9f1b9006a2f78aa3d1f7c5371f35ca46dced77fec7a086ab7f7a83afc9407f5ef01b2a1894830d768b736ae926c33b012374926a9d063f44e7b82f1e7e4b0086acdf4d3c25314360e778ce5b34859dc697a78fa10756c49209a33f395e43fb37093eb34681cc8f1e5e3f1ae5f6340e8b89da0254b2a90ede7661cd7f8aac3d73635fcd42116b60d005efe60d591a0fb73152068e0bdfc093affd6d4122be5c44e990d2197e6937d3f2d9c8ade9f93979e07a7988780f7bf0e06cca1dbcee861c2b9e84d467845b5290903a91bf5479ac5f18a8b126a85544416f754a94c11693863fff3fe3a7cdc028bfa18f0e9c9218456788c680c01b72824c27fe2dcf751f8d821a910062610da6597dbc1143134e049110b5a481bca2cc79bf9c7dea69d954446cb1b37373593159ec0866b5413c7569bc085bd818bed58d3835a63f1bad0c80e3f25492b9bf43b904eb1ceaa91e55d15eeda3d5bde481a6996967a83565d5701520db4b6154b82f210629f6773f5a49ecce7d3de25003c9704f1a90901c6f4dcecdff8bcaca2700058b194416df515a07d38179694192335fd21df4b16d12e47ea2c2b66d72d01d2840c52663b649b97a73b9e3f27f949e1d2d7f3f5da265fcd69f558176c3c732a1341a0d5abf994bd33af6d5d767926e5ba9e23c6cb6ecfcf5de47131014186a6f7540f86f5f0dc4df76b7596b30222c0892140898c2ca6b971b80eaa593d5a677f81fba86daec3f29af21adda2cb5c98149add89d5cdb0ff80ca6f4f8c259ef0b9c18659a773e83cc7cb30020cd81a045cc33b190de2861a55832e1420ae318e664bab03531205a5b3332606e16d78a8f20ba1d5e59bf38122999e3241da22ef5c46172715e9ff415cfc9620f12a23b77b5a94feb16ff50aa89d299a4bc5209e3dd88a303014c83be655758e0e4e4491f05241ca1f797e31f8bfa07e63c52aeb2d698869c69ab34e6c9d7f8835901119d8599184f7d072cabe52e7bb5ff76922abaf372ce51a6c42092c5e1b1e2309baa2f85a419f98fce26188675110d774135b53d755325b604eecb5e36f8fd2a4c093351d163771bee4e1690dc07cb2776d2de68352acb15f696b15d011721f32eb55aa3936bd3309bbbc64c1d17bf8941b821146800199b40867ee63d874d367e27b2d030448157420a3ac495b2be67fa1b200881518955eba52e13aa16838a82cc8d36c26da81109b3ad2f42b28ca6ab9a51f438236afc4829e0a3e38514401d89c9cfdd1cdfbfa63fbec3652b1cd05938bf8666a5d06b9a8a6d9da761dbd77d3576ae5dd0a8b2475f86d2b99b056d7d306662be2a94f0bddef8dade8fcff7a04ee1c4d44d190cd0140ac750d8aede37f4bd6d5e750bae6b529e8ff25270aac0fe884624863f4c9ed163cbd3008df9202a81546266f8a0fe166b1a1b68a006e8619caf4bf498aabd23181a38ce2552a24cb3d62afc5a636b145ec1b09e57b8aea4a6fd34d1d8506f7e05d21e7023a7606b419e91e6ecc16dd259e3438cee21c4b8306626b495d500fbb9bf88b1364e5a5436432552b880c095a34c6173fb01669cb412f6aee72943a8bc9a211df8a610fb16a4f160b686ee22a45593319dee156a626fbfbb28eb154fa605bd18c6bcfd5a27dfc274f8a9a02faac18eb523a0d08508b0bcc4dec16abebddb6c8873ac5d7f4fbb30ecf268113ad44a9298cc134e919a2a2b7194ee418ee4437acf3744d2e1043fad5a27d8173a8fcf0ed185b29e18b651ca14c67ee5316ea05e26b3897f6760d825b6793a99f6bce2341e7684f0db6c63fdc13a68f7e5cc7d981b43fbd2e17b991cb5d18df0850c6a5b68429068fdca12b07bf452323cfa84efd85bd7a9a352273a0195bda7ee52f4ffc0c03c57247230a898dfce35134a40d7205e512a7553e5e5195cff0602c2ef008ca4f43d99969001a5e2ac073a5f2efd1adca802dccf048ea74d8f60d0cc7604e02ed8d15b5cada626c63f3a56aeef91d583f4bec35d834e72dc43af2af6941e484b91daf2dce34cb934931c9c5acbe0e027d92ef2b6bcd51de0b2af195673a789241a6454a302357b879bbd3db388d7cd70de2f2a74a5ca2dd8fcc87dad232559db849c9a39eb1b28621cb17fc90205f7b4133845a23821c4e27dcf669a14502e5e9d52cae90206afabf9a67940abf7e81c896602c5a6c6b29967b5aeef21ab644aee93bb4105fec0d198a869237fccc35481d60628c7c6ac3e4de69be530c34409e88b097ac63da2bc9335e596b4d81ebff148f638085acfa9428361ddeb260d5d6fd755f093ac9384646fff9ebecdb4c75ab6a2a35e140c36e238674e5deabed61d229983d405762b6e145c53e70b55965996bbd3340e0caa18f9dbc4e71e6ede679e20ed5a85b27a0f238b772baf5ded58b808dc40d823dca833efd34206d5a1c22d5176d05bc6a2867c3af741f38767228bdce2951e849e4ecad21a3a30c5da50bc6ae10b717f594fa9c23351b50e3cefd799b3c5ff68cfa3776ccdae35a33a498eac2ad26f3fbf2cf8367d5476e1c39b29bbc1f6b5b395f7a0cb96cdef2884fe5be17472ed5244d3231047e2a43ca9578be26f4f83dae1696dd7e9bddd6195cf021c2d076fd08057980d466c700962d32b3773873a1784c518cc7815379b2ce878bfdde960bd0a34c6b336dc3fe6e5057ae939fdbed59c99257f5fcfb8d5c1172841aea45eecae2598c0babe5149042cdf15478202b84d0f6a01bd0e37672ad73b6c5c54c72f59889c03036c1eec7be309d370dec27f9af0d502dc94a9f9b56c31e902cc4697df611c96cc11d74a93f9563ebffa3a228b497d0ee5891c2eee46505b7804046b549e9d6a1337f2c13329b02d06c3ff2430e48653167126cc6a459ee12414b50dfd7228597bcfbfe1ba3c7e1fbe5768ab4e209f7ced2a4c9edf8f19d62402772cb630868d8e7ebfcd7a76bc4132ccd58ea3f277f1e34d93c3b7aca31a2fe76220838017bac25995e31109fc5ac0abdda91e98bd6fd99efa96ed05df11459b6eb3819878379a94e1e2c95f464c19d2325717a135f69253356d8df5418b6c095d21f4a72e8655239e9d623ee77c6902ee8637f533b27d668c77345dd166246b4080a490c80cbc50d1915fd02ad0d82df48b8ddd4acf5f4747fae7d9cb26ff96f3978b3d0c483594df6b2a9235ecc04fdf3cb80a8668a521c28d5ee814ad42481e285285cd372b7d3c0f855d8620dd1ae44aa7908d83c10cb108299c88dfce430c60c4ba0fabe2aa72ccdd9cd3031a2fb78db0d04adcb01dfcca5077a5118936a2f02b1acce0e902bb45ce0886260caff53423dde83411f6cfa9da5d46307e5bd6d3c829085ed8a17bb6c3ccb8787856311ad1a389cbefd1c9b226cc421b0717b5fb967fe2ac46a0c3c349104bde114be65ff6b2ed9b1b5cc43acdc52fcac18cfd0af6adea4ae0d77540822b691656f64b6b3cd5343518e6774898f652f6e363ab7336d553d804cceedb080ec85d19381076e001c0f85d8a4e5b8b83ff0b6e1e8da09a1f607c916e95203f03534b6ffcbfd33462a85e725176a2c0556e9332bf7094e3c4618bce7b8bba4d65784d68cd75675bd549f54a65539563594776f118b59eab0e1c5e8940eb35378317ce30d17e07d2e959e1f1144508ca3db733f545059a7a445e665dcd7cdb1e6ce487722e6a473bcb82ce93f229cea0ecd5b4abd2ca240eeffa2f8a58d3024b7bdd1ffc9888df5ff92d6b304209def3d90fdba4ffc70f780a50fd7d1d5fa9162ddf580facd021a5cffe4f1f57184882a66259a1182b21f9f1014bdc7d2e1be35502849e439a11a261464250b80bf3b4eaaf211522cdb7bd84214b23d50f6fb167fc9db69f802384626e6ffc73c4a825fafc6798c03008402e5c1bd0b82917775021f3d7a3fdcb8e6190d8146445cde254d87a88cc2831241c5d37fb7f997378cb46927563c50c611d9669ec5f0b91db5ed5565371d3cab427d802eef83b2659c285870cd67fc116b40195dfd3fc004d58c97c9dcbae6adf4cc3c69a52d79d3614a7c72cb3ef7a2dfff8d37ba74e0d97af15bf7bcabefee3819971e28b0f9b011d58493b2c0d637fe1004eb3978ba226b3f8a54c8302030627d0cde7edca9d2fb1658b015e7157f61bbd0449696ecfa957f7b69b614bdc3e26e59afd2be7c17aa80bb475b5165fcaac795d4f0f4c1504977de071236e40e10369320a51d30c3a2eff7c256213976870db9813c5e4c03250fba75b372cf91fe9c4adbc5d5438306a8bacb14056b2c152bc9219c31aaea7918d97629a970dd5d8024591b1570dc31771399ae335da1a09f269c5dee633cc2a27fc9153d35966a508ca2533fd8d5677740cced18485b01bce7e04b5644e95d3c864e2b09ca7e4865909782beabcc93ad2f761021f62d402c8f7dfd51b3e32463c5bd571ba954b1c722594eb4a511c8eb4f2a49cf5df0ac5de2ba7c0dc23962e28f7e271eaf6b0e4a539591653472b91d4b9c4c5cec6bfe65ad3179fd3472ff30e3bcf5b6a59b2fa1e921730487c1bf1a77b493634100299482e84b8989dc7cb3ad14b7bf92a055fa7b1ef3e22043e610cd682dc98079b0c8762d3cb0970a0b93daeb5f486b04b4330d704eb3b412fc06c2ff4671bafca8153399df5c1ddbc5249bd4a1611819d8743cb5ba7145a7180fc29015f68a1ff905936fc731e278b3b1a4d9fdde470e3c09cad332ef69cbef53e53c8e240c0bddc5f58b9f784105531a43e01ae671aaf5449ff03ad746031843563a1d799fecfc1a06b4c3baf2d26c6efac589a629ca7b90776a41a598693eeb790b0d06ec811599d169f83ce5d56074ba7f6a51a4dc183e791628157dca1295b02cdf90dd0523d19871621ebbcfa6f2e7c75e7c856d74ccc1109f1973d9c542bd2aa77f2da2a7d64e5841947310e23f024fdf68cf0865a18691119d3e7c2da6864f7bebe06106bb77e0cae0e834794181d0e74732aa4316f92c0608b755226145e22d48db2a3fc9ab13b614756fb083deb82ef0506ab35c71e20064497ee8fa50f0ac6023696aa1e051c5c49d5f351c88490b6cb2edc83c033da12e687b95ab5898b0e7161b18efabbf91a95ac5a0aca4eaf1d43478342c30130b57f153b24e19c714435de50b8a6f6a9d105e8ee832572e90048944104a38593ab1d7b9fd2c55e0e8f9709cf7a09374f93c7c360850f6865986953a5edd9ad594b23f70e81b093b08d8b97eb54ffeebb20db3fced74c59e482a1e9eab0a0ff5de9dc6aaef15c8a794dd7ff7308f95b0eae23c5a5db8fe5d52acd986a7aeae779c513e4cf46ab38b5b8c342527d42043b43a306b9869fd1246dbb2792cec1a2fdf482b918034fbc8ebb6a1b3778150b16d59ed41831a47307c591759e45874264c5d5a8014f42361d204667c7155b74a0db6274787a510f1bb9cdfbbba21fea488174668e4450d0cc8c7eea14817cc8aa53517ad687b6c30cbf11f0218b3e57818dcd051cb417c1362dd1f47e87b5237ad7781ccf29f8b7453e9363b1307bf91fde19994f8702d306c5618700bb71e02985342d3a5f062d3faec73b724a5aeb342602a9dcd01d021e5c387b79b79caa17960ff6987fa5e6b1891cee0cee1bc4ec5a105ff70850f5a94afff0923917c61d895ac7b3b7afbab213fae0500fc7429b1a43378c235d8d5028106ff8d8c9bc5ef291c94835df5db10c263744c9bbe17e55b31d271e9bde03d8955bf24217acf2d331ecffcc5dd7741bc883662364e839813a2f7fa20414fa38ec5bde8fc4f3724f47605b4d70b59986ebab619d2ae3d895bbcd58585846e2c257f9d150ec76f833f1d57801889029395922a6ac185eef8cfa4942112995b5bf6084599cb0171e2a772abdd64e7936a69f05998dd1140099289f5a2113f810740e5f401ede634e7abfbb405bf6d94ac86038c235716b6facda54dcdeb8d64be6f8b22e39f12f3a096e14440460ea7cd060738eb0f3ad9a9d9e1f62dfcffc14bcc91e5e1faf1d60cb78d02c2fef518962d7a63ae5b8dac9afc41164a473d1f22354e21017e2eb05a087a5cf9a06865ee0e9b921829f8537d0b261a0216dcb01b9eb30963decb37affe25fc06b1d1b19bbe280c6ffc035d2ee207bfe2a9c966d14379547d4bb1232038a7e17ff2ceb0419d586ec2c5d653e0948acacebfd823ad03154ba3744d417df5b27f40b42d9505d2b6dc3d413ebf2f54ebaef3e1baab36f0ffa5af77e4dd3f3a78f5fc0241c17030252779fce73bb91f9f460a8ab0b67510e72a7afcdc908bd33658fcfda5c5a1f56f666fec84d18cf8d457e75c0d9a3f7c2612998ba9cacfeb50be2907325699c4d844aa5b0d994674f42dc8ba080ab2119d1ca6c5a90acbbe68fd4655c264b8e0e000233316e6f20ec795d5beb68ef93b2c83d2fee2d30b0ea8ba45043c2c7d0e25b65ce1d58b754404b4f2ae0e8bbc37cbab024d8b62e9f85ad827f8c25fae1dc30f72944897d86b43cc000508a3e4009ee7c1df50ebb202e5e16d836eef02be64267de1cab264ffe78700774f4590553dd59cc2bd209c2020777cd66643ab2d85e1df5cf9b65e13618716a4cf7d1a64ca77872c4dcf48f7340bef65e10456cfab3495c344c54d2891af9569d08e23a9cf1724a68fe6fdc983dd9fca514156b19aded5fe121d01298f4fb632d530dcee83e7b09fcb7654ca496e37a30457f17bcadcf1551c5be8d2f0c50389fdeb2b276b930c131476ce5dceb59af9143fce8581becf05dd91eb7e2a400a7f4034a282df7b250898996cc3ed1291ee86a394f96534dc14121870c711cddc60659aff562a2ad7002133822581f6a3ade53b46eaa2de250a97237c7740f6a9e3337296b950afac56d4622df065fc8604e0b440f87aa6a26b82122ba0326d3466018d9393d28f6df9a53b23bd0683ff9a8692656e4b1908d1cee29677c598ec2b8e08bd3111ea582ed98f511b4b277ecedeb33d64cfa84c11147377432ddcf1d00474439e212b7e8992a776369e733715f9b69a9006cb867bf4c416c224c136d3d2dedccd286d80b1480fdcc6bf6f8ded8521cad0ede5697bed760db7c37eedca17664e45e6b3266a94b36457ace8831ee5b497d62cf106f088ea16c0875c3b1df0c6be4fa36b442c214dd8f0c53b76de4e587cf11b4d0eea44e75dcd88b3e99a35672e5cc5d20c4f2b6da09589a8c091d2dbb5a4c9e27cccccf05905bc31667abbdb511bd4736a29b7120c4560addfbe947382f8b2b9bfeb0d2cb024d063160071c6aad8e17cff59d8c8d47595b9b6b958aa937fad39bce5faf9202803009a5ed37d5cf1e0ad814a233af32ff5aab80977e04934f65014375c759b0f8e241076da530fa79331403144210524879879f6f7497f8d3a4a90cd5ff2f2239c1c944e760073649afefc170181f704e588915433de5211a16810a94346d9300101a8b5910352e006c4ccaef28cb726963a538864d2fcf9c15e61c8d01a5e0cdf9819c4f31770f886d99aec4777e56265ab2cadae7d9c1cd3acae6e0f55432104f0498abc7aaaee6ea76fe5d60aca304e4f7acb217dd9a56acc322624ba6b035335aa838cb483dfd48623bc9bab2244de5bed9b56e4da99a37b3737492dd4e4f97058bf90f979ba96437c65ffdef309496d39212e3cc31a35cbc075dfb3e8dc214371e8badd172ad045952286bb46ff3f2b670a4706c24ee6eb9c479cc22b8f3db2507453903abde78d7c8d440a590e79c04e1b7ce51a6819a36a6acbe9b7ab16fc5b68e63567d01bfa240a1eb3ec93d2559407bacc9698c107f8fc03b284c6bba0bd94c0bf6e39b426450c0f16358d67666e871ee74f08cf1185f3f2a6a3cc0b32fdc2669275ea446a0ab75a32181840d398d1e1b14ce61435078924b93b0b2380a8160b45da429ee9f9ff645fa663e85dcaf5c2335b4c9c0bbaafdb9d840b8b84c0785fabbb386a8c390c61ccf44e73ea4eff525d65dc5d6509f4d12af1e88c9d34216359caf00dab2236aabb1699a0fe34b50ea69d9f661fe436ca58caf3a53eb1c82169d258aea9c05aba8fc3ca8a199c9fe033931db2e489f57f1f08e099622a82500f2b97366ba59e9857dcabce167fdce09fa076067ffa35706f46e811a0f10707cdc837cef9ba22426dbe16bda9b58d50557bcfffb8861205de381ad7c4e705ea4ddec0849b28345dfae000630d6a8a5824244747cd4522228268a37a0b9dffdb3f04db874ef36f3d9a4dbec50fd48d4c69be173b9addf40c8454cc7c21858809f9fbdfd646c8349b8945122e99904915abad98b450d6775ddb595bd037557fb9381fabba8b07aecbeb575207aca3593945f23f6b3c71d386ca4d422b714f7989f69f427f582a006bc4bf7546cbb57471a977cb9feb54e87f4dd1c750623979045506750bebd30b8072a4d893b71f9499680d53d79e3f8914834cf9d10f92202ab46ba3834bfcff2846c21f443d0376be6c95b476d6782e9181a2bb880affe1ee0b1071cb3122056adc3ee5c64aee822e754254e8dd2d18f62f1aaa0095180e20f0d389a196d5013879d1ab89446a379c7852036e1f2cd82c582c8923364db3e67b7c75c70722e36e6a2c893755caf2ace6f2608796f12d3a1385a4bcb640227fd899cdd4b3132dea3911db9e604550d1b566036294ecdf3d866d2a3e7ff0c01f41980c90cad0f5c3beb9b5395b4e73d758bccac76fdf94d97af26665f39a94ca72cf24d2bde1a4f5d50e9dd77a9b83d20d2a4eae9a3c15b1dd101ac0ea1ba3807bb2346ddd38e6e7f7b59976527b1ff0857e1cd37aa14261d1a2961a1c8c709dbc22206c83458d682fb04588fb8503f902c833b1ef38d89df3f495465ed0501c85a9a81dea20f55515ad9d81e2a4bc6698216d82af368143af8253b1d51a5d553990047980d9c5683db74a28fc4e0db70c1296e5962b84469f7fe7dd9d9aed4bc19b2a2f0bef65828b7f91d5224d1a56315d356d21b24f9e923e320cea506b1c33bff5ef1cafe1bf8f4bf3e22bdb077307d1779ea4f862f838682024737677fc77e3af5639cb377f88c01806e355ef26f30d62dd9e7465d36e25db8e2e443b4b3e36cee922fb9a7a795b87f4da473b99b4995e6d5d4a5b495f75f75b5cb206020e45225858209e0d487eae95b2d7f929715349c2974a2aa5e214f005a68e44fa90e7e1423842fe7e023d86d185a7cc6c94012f3542bdeb90a5aa3d3e3c307a76a0548bd5ddda13238f04ace9583cdde9c0cdc097c414da0b746232afa4eb461086a1fcff9b8beb67b6918a66cbb9d00c70a82fd70fd3b79c929ef4a64b448115b5c5807ebf1270bcafbcd02d8ad34ccce99604e91e4996554b3d81ff0a9b7feac53b14d235610fe6e05274f0dce7601cb2cc17c1a55a9b00b6b187c7e173a698d4068acb8ba137c539efc7d1e1dc0409a67f103d59020eafe4c7ba5ba4d697f5bbfe96661b6f2114e9cc6e7a907aa089bbe56a6b2e717354e438357b2b8d6ed9b7b9c6ae439bddd8529cf5ecc66389dc2538b4c09b8c8fca7c069ee93aba6cd742dc9fd2826240dd1ef7f55070ae770b4b62774dabd3fe9ffcc70f16cd1745a1a1d02578f55e74a6698921b729cd0a04f81a3069e0851f34dc61df5785e0649dc6ac98e2ae69e4d774e2b9453fb4f5dd8b2d710cf6b3483b3b192c0a80a0a01cdfdaeaf27a22ae0a0005fffa8bf92936b622623247227089c9006df81f54bffdc8b3de05666cf3d8bd3bd5f32ec72735c9358a35bbd94a80550db8fdf3c1667b7a9576c07cea907815de9decc0d2c0a33e6b09abf641c18a6d9e485783f0693b82338c43d1b1433522ea60d86ac8ac9b39805d1a9c107d8b936bb3fe3c7f208262bab75f34c6c056ce79142ffaaabcb92973fe87874f4e00c9ab8015febabf9826e3dd6131b1a9e5c9a3cc3218b030c216716e26a205facdc54ddcdad5f22b780ab812823c42cf0e33151341df99d92a467a1c6a2f42663efc83e4c44d150b7e483ee93da05719b1cc4b527081ff56366d91811297578ca4df5d6b6f76665e1859061c8289d0d3e5607871b3baab74bca4f4be4e86f39f83ad6c6f2b42f8b89d9a35c52a7eedbc8a681b979efeb841b3607408faff6aeb93bc187ed425bfa0275d7b12f30b75fe636c8eca37c50cc486e7aa1b216c41c6678c53995b4a8ef1962843e5a39e96c7ec38a9cb09200c896d7274bb41d68fac5f55a56bf1b42d0a47bf641b4eb135fe567db7468ce55bbb8bf8f0539e61b80309a1e2442fa6a568ee4c07e1c5176e7047435ef541262433792d9686041dd49fbec3108a807f9d6939b0d8b6cf280273418e69858ed0b80d28a822def361dc35bbd1d1da29755bde8b226f845f9d43a85cb69c35b3b7ad9664d5aeb6a024fded2cb07ef2e223b9b02acb4d6f717e76db55cef44503629a590412d44a0a9b0ae1593e436ac80a11cca9b8e6a8847acb515041e3098e8775bb8a7b2f806a8c6062234381366a8eb37965a21ad463202fa20b559a40d15cebaa06f817a9785ba3cb943625e1e2703233150ee26a3fb1795d10447b310acbc8094139c63ba54d2afe1714219bb7bee7f2e93b5826218853d16df61c8f419bf58e7c7cb6b7baf045618ace378ae5b893ffceb9d576f3e23ace228a06075ed07747a02ead296c279392b45ccefb6eca3ce2b98ad6f214958db15c1cedaa9c0bd51b2a678a555bedba5f7e26c9fb14f43a9d40f874d4416ab271fbebbfd457658d5331bc5d98125d1e7ee156922dced7e80c7846a67afd597d1bf63f4daf40a7fad4001c366a17ea15d0d25ee513ae3b289c935c42690c8eba2d79363786e4a11cd64bb9ccf09d36245a0b4df852f697bdef1183818287946bf0ef977863542ea1bb213c50912e433166a8024c1bab93b8376ea8c3249b0f9eb7fba77c8657348d4707aa0522c2e1a7ca54b545c04c9c665772eb0af543718fbb264a5245061c8f5fbe864f12c0153108af184e96e6dd7b4126412119f033bf33cfcaa41d6f7c3d7063fda8a1a0d02426cf44936203c71f02204f48a643fb67a7215af3557c55cad55c60509d4debfe455a2e4a58ed0f3165d80acdc106467c22378e7a054bd492575144bff3a6de99a4374dc0cd84f719692d305402fd7364cbed66eeb5a3b7548e0cea7b01a37a98af033930384d8ff4a152604dd15b25eecb90d4e9dfa48cdfe14f335bc8d2fecfb173c753007819704bb8947f72b472e8ebaabe01fee7aba940c0f76f1657b5c057bbf38d012f0793e9835bba13cab78f3bb9fcc894712c5e5b0a3bcfde2c6cf8d4a61168ca425cabb03c4dec6859c763df316ab15474ed6b4808978f2d7c7c33296f4f967e6ff6fb7579d0d66962f8dac8dd862496b83205792e6911b8faf96676d7b0d6be904d69a00c1b95a2c3bd12b6c57a1f11ddf300c361a55cb0da7d073748e74871b75fa1aa3d1d0948fe88332ccad7b96b4f30d9da8bc1c81454415a56022bfe5f9251dbe01c2f9f82751db12806013c0b2f05a134e6a1160e1b5c0c951c40ea622d29d2897487d674cb46d840e1f8faa06e8f7351f64ddccd62c4c30c22f554811ada8b17c8aeab0e6657b27c8dbd1580ad72f5ff5169a9d27aecc2eb81217c43b4efff273f9af1d665e662750f841c75c641f3dd7d5f7872abe24030ea635169f245fa235e13d672b129d8a584c8de810916e8a3a2aa7b4260f03dbe1bc69bd872a51a552127d04de71b32bf8f5f41749464cb2ba6909ea461f500e4c08c1bf677299bf39c582a192c6bdbbf80e4e07e475e52cc8ab412ce515c962c81c0d7a20aefa7251a38f41634a6acf1cfe7f788f4342cacd42f2ea983fd6dfe8b641a0b1a6cdfc156bfd3a4504c998af8acdd9b5f88c722f99d9ebaebb796e155166c207b01ebadf52349ca4b5941decb51eb571293eaf31796e883f0481086ace62e424454aece2c21f7f8d00703a7d9949562af1adf61913d9e96dc1de3b88cbaaaccf1a8e4a228c16648aee2ba4f12d843f57d4e64684f9572f9d0c1201afb4f5e2b9ac1472eaacc4bbb24bc4eff805a1e20e8a494c8d226fd419fe92797d0c426972913b7890eae77ce36a7882e440810d17b1ae38a6b6e15990c28587df2012dad5771a00adb6ef3004054c32249d71a076569da999087979a22d08d499df655392771900daaa4f4c86e1132be30e810250dc6a635cd10fadd1d7d909004788a0f72b7c04291047782f78f43f7f3df271cc0e0e7aefaa1a3d36bf68d4f9db35f5449169cbcd39dd8eceec1f940551881df9016dcbaf38189cb82c5ca2cd96fe8c6c4a8d25a70981fdc275ca78363886795fdb23e1ce3460b9b64ddd372aaab602a32fffec1a3b6a9b39b7108d4c54d5291ab316cd5ecadd6737b3cc577239fb20882bcaccdcbc4ba92df61f61c57ab2e4cb1d613e5b99a7e90e5f469c00e705547e24a4d5b72c143eff9a9dd73b1b399aa34bc86041657744e8bd404401ab223bc209d5ebfb580038ec2793b46d9717fa9257eee8309bceee4fc5ed1bee516671856caf9b609f3b6e87e460007c1e17f03f747cdfd57368111f0b5d23a1e5b66d897c0b53406bd0f303a6d42587fde78b303e7f6fc1befec732164f6a2f206b2ef32c836ab400b3242e52504e49bebe30341b42efe26044cd6fa5cfd779de4757ee37c07612dbb09c45c43f3c362d4d3d11c7aa585168c38b6c2edc74ec1c201714da80bafa187f3b3f89caf4454e5ac53bcd1d145c7f7d4f067a88f3941b6f3af5eddb2e6abb77be7bce1f0d290963c5d9648c1dca704418a2458ec7b2c730d22b6efd7f98210668aa9431d46c1c17139ec122913e0b1a43b1cd79d4ff181f81feca91ad1f6a1eba4ecb4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
