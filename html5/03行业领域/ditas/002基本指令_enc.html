<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5896e7c8c49e4c4e4e25c73b9f50bd46117e1ce5fd80f6409e5d4fbfab8ba9aedb718479c2c26b773064218c247dce0f4d75bb0078173cbb44dd7d8391b4cfec5acde4adc7634dd5ad129e32c0253d52094428884036dd8141f7a7a1493fc8c61479f30282a52856665ca9519df3e0d0162119b7a2dcdf30aea519ace22f218c10e102f1aae97372c5e83f7829a93a8b6ed4617e1ad5bc3b49a87fcea79bc44d298142c914ac9f0c132450945c85886f2d1d826ffd349c9195ca222affc68c46158a54593c923a4dc6134e6175233244b74b8bbae73ad4fcaceb703a81cf0cbb9313e996fecef14c907c91e2e8986846ed97e0f84dcbffe57ecf303336e8c849a68ffdcbf59ff0155bf3045b6759ba442416f151ea3c8299111e1203eb07d582268d0b74e4c02162fc192f1641079c6225c6e499c12a5757f6ee4e35fe4d56e31b63f97d2e3ad4962a9a16708619714780d2e6ff73d5358823749451459f737315a5277034a3abef6b7f2d6863658390e1823ac0bd89b1e2807e71e67214d69a17101d0fa3796583951f4890d869dd6ca80a303540bba117b25a177adb0e946d3723d2b613498259438c0a50d8f8775efe0bd80f876f26f205dbeb172e1c3d035391eabeb32bada8579010d1a9295cd6c11a181346c1111ca0c023a352f8c8464f4913f1caeb0bdc4170f9a9acf6584309855c3750e75198ca97ade320d174234d55df5493e9ce9b476d7c91606c9a25fac739781ef141d1eac98e409f1d8cdde04fc123e1a045879ff244fffc000ee1ae6d43d2681dfac2141240ef5ebca6125ad048af9965651b6f7457fbd040badf5534ca8299c43e4ab9327147786bfa344c1b887bd86437cb92447f183e6368bcf9641ea5839b441fa607291d048b71b28b4c052ca16689bc33bd4f19394e97ea8b4bd84d43d551c739e83f065cbbd78e58350b0422094507f96b3cfe3ce28f12f48275efbaa6b4cfbe3ec1a22a17462887c45ab8b42dba4e88e947b9f9a71e9c7ea6671756fbd3d2906cf4fcc368688e88de259bbdf7a503b13f6f8fb5eaefff0f386d2af3ff66453872deb9c76fd05298fed914c0cb8c8ea5b951e17fd28b341c2398639c8f864a6a488cd75ebc3c1dd7ce442c839cad2aa720a1a7f222d3ac9fad13fc6e3cb8aae2aa2955616c5b94a5dc9372f248c33ba63463b64420c3e84b12721c002200d9d8d09f24faaa799ec9d06866c294adbae83634a5843d7515e5a5ddcaed4e2a7fdcac3169ba0f5a3a879af505173f336e7e6b674cf3f9cb5ea86704dd4c4b09eb15baeea3579acb9405455233521bf337185924c5cb6772c52b468affceafac100b6f7604459ee9617042b3420db0dfa7881d1459e7ac928ca4164d0838f1f765022b5b15643997d5fbd972ef8acd0c0d21eceac37b09d068816075dc83aed53572a149ed0f77bd26a7bd4b1afcde9b1b57d9c40faec8ad9456a614bbaacfe11559776a798b1942bb3a9bb6cd6befa854ab7ebc7803d7128c85638ddb841427ebf1d3d9309d07b4bd2cd59ea9d06369bdc2091444c451b71403d5deeba763b6f43415ca803882cc5cf78ed26f6dcc78769aaa82ae47aa376780dc896d605970fed588c9e2ce0849aa3364726c3e99c99011e2687a48c40a55890e69a51279280e5abd7b5903224b9638953a5d828a9a5fcbd09eac8452ce2fadef65a8b6f772c8f9d2d0a8e1a3b9acbc34383589483cc1ee786186ba2a27f388e5881a2716ab054a97c9ecb13cf76457e6e1ea8dcefbc08c34b82ee3bbe2e06156dffbe0cee55e9b9baec7da068c38bae99318fde161866a03427178487415c55281f5f305d49b80fe8c6f45dec0b7c12231756414bbdb2902afdeb735a04839a7ed6f5e8a9f60f88afaa1d04d70b19e7f294656d0e8bf16a2ab75e5de116a418368fc551026f6ae00604fb940c80757b31047accdc8d599160f76ce6b7c793e375d69cd306bb5f993e342b0896e8284ead256ad1464d5af7c0b54deb90f7946104d66aad5556fcca13ff3500a3e91fa55419c893fe8ee5d8d3ec3bb5492d46045f9f652555a4c5ecd0bc20af74dd637b75764de14942831a4306cc886f045d5d017638bc875d2bcb27acd35ab4cc09775225c3d45344e346524b1b3d5d98dd9e36feec53150a42e3487d5167414ea32e8c372e9b481f33551a18465266af41019e60e9d790ee09d582e5368246640369eb7c7cc4818249af514fbddecf5ff39eb1e9a7c925c13f25e8139d377d4ff1ae4cb49ca1e31f4b50652e8751a078def4af221801ba1bf692377ab90a4e085acba3a4d4e89b7b35d945ea49ed96b7f6a84491a6e2c4be6aac198a03bd0b064596ef50709ff210b83e2fcba7e82267d7d3ccb81f7c4f7b8157a9d304b1b1ab0032be8d32460107e844a5a37427fa1d4e97492f2f2c90d165dfabc66f6e8b5601083be1d53750e479d3ea78e5f93d8137205c04c5154acbe17bd37af51ee0bc9e97e6309f4b99311b2fd04fbd00c05964c3d43966cdb08d7d056b2ff2c6100997739a56863772298fdccbae76a8d72ba0f7f7094621ef0fe31664c998eb6fb3a6801f5a13d0e7327fd25658644a2b9a34bc4e9aef9d3826e763024cb948805832678e1b56d9bfa89e175eac87809327879e004011d84aabfd5a46c3d40854662ba85a96b19c110d953812a10f4024aeaaa968031f22e48caadaa322c06c4e939d901f81e1a88dbd989423ac1471b3eee6f3acf5a35cefffa16df10f3eb10c1939e0d418230c3dae8512fd7c0dc878b3a2e89aba6f6bb4c2bcb5c41b7fa5872d5dd472f412a91b7ac05e47203a5b4dcc3a831de26a527bf2449664418699f4f83441b0a88eae8c1399d8506215a48a9b26416a9ec5d55a290d09cb808660175304be86970db5a90b4f4dead7ca6840c3e1ece31ff7c390bce28781c18f68f41b58e04d94ad8fef9ddc686bf6074b475bb8b8a35256304f3607ec8e5de6738b8ede5069c28d832c2486f206aa3d773c41ee4db4dfc44d7d2aa04bea6df023358f3271a2428fe233219f8868ac4bc58a7c14925747bb9c6269cbbfe033bb49a45cdeb5263cf5d957b10a8816ba13042932c4c9093a88560ab7b5f808d0f1677f3254b62894ce8bb83ee47e21409db424ec89775d9f70b2d04728e07e6f83d0f0cca1482068add2604c0ba622655757ab34b5a1f4bca4549f49a42c265e26fa2c45cdbcbe29b397c6a33ac8cc590eacf3ebe7d35738b95eb594d645d3678bf920d131155d5670393b0d7cded05a02456c366e70e8f780a25b99d14b5552c8e9d5c6855f5ec0a9f923f95646b262ac2b4545990959f6631eaa126b2d7405fca66617fcb46323e3c4cee92b9bb45e6fe6ed9405df68cfbc844c9b8d8f9ad98e90e01c77ad4d8c3df89cdca86f0866e1e33c5181aa6b188b10566c03c61d4d889e29340573d5765440b21ee65cc61b3a7c049d2e34fa80c1b66aca765068617b6956856439a6f609f28f68aac51124d5decbd6b4f532a16efac203e1392b9c0bcd074cab6562a08dbe433572b8f417668fc8d7045ab9b812e740dc1614f23759588daff196eecad166f8d00bbb2344be4cb0cbd9562172599bf0b66ca58d8027187693734cd0f9bff4041815594127c88ef7a79ba4e2d8be6fd67cf3512d8e2c36419671e791354b9dac3ffbf1a8d319a8a81f9cb61e848ef8a78e98fa2446913a02f0e209f53b96761fc6fd50ea2cf55c4c11c14eac76810598e70d8d6f70d0ad5245987c7d176fd7d67173ccdf3d9b53fdca682afbd17386876f900941204a9fe5d1b6b7a7521ce0e431923cd38bf2a559299aeea5ab064b8a8a4456f5a5a367f363307cf0fa07cc76af3a1e0d6809f6cbab101643ef952b04770faf55c1bca1a2ec6ff97ff3e843cca8d0211e7c7be613e4d8ac63538ff5d2e0445575fc6eee1067346436a1ff6309c505a2bc6c85ea78d6f95aeaaa4e35e5eb0b82bdd993253292a89c6c4d783dec28aa64e265b4dea125d0d4cf6029918ebee10c5a9350e524bf3fd443c41a855e84c531a287cf165fc251ed1b0c15bde22bee3293180fd6ebd9012e5ed0ac200c03cb725a2aaaf5615079f59e88ba28e48d9d2773cd3115d144200823c8958d6531de841aaeacdc8e418fbfa94d14f325608d157dca5ff118762c7903ad31f9cc87e26a1f6b13a52d79b909b8f6d6eebb25a80a62629dec2b0c7a35409daa90b13a7bed8270b602833864f30d24b7f7a6c3009bbca460f1c93e0c73b89ab382257f9d751deb3b34bf2169c4c1877a5869e71bac27c494a26dfbce15e840eacff551d4a426f0bd8027fe4eb1ac6b3dbd47de1c6ea27c32484f78ac53194d1be95bea256ea55408aedc9f392e806ab19b48f77ccbb141771241dec6e47c0cb873ee3edb7b36967849a1243b936dce9bb60124b5558c786e0cbb207904b24fe6ccfe2aba0490eec05c5dda5744c54014c8bdfe861b64219bd29ccfc29916724ace9e2bfcaee54ba667994addf0f4bd63e9442edd7449019347185448fdca7e7ab73e4afe3c4e7dee912e874ba5787054cfaac59ecc1023ffa61c5293292e26ac414d43c70385efff06857c72a27be2652ee3273e9c222dd1989b4319b88cd7fcb0400e041ed2f6771074db39332165c2863186bd19e9cb4cabb86b346f45c2dea1ad0eddcd1802734938a5e5acfbc1b89982325b1d300be385ff0e819f755bb2c5fcbf49cb155343b121ee25891a24a84573a7d9f151f515cde189c73263065dff371682c54bb337ec03574dd3b886b2241f974e7cb30efe7234d41d2e1c999ae5123456bb6c98dab7aa376f4b50f818709084afe5478b33b70a4c0042d77132f2edc21411f2f9093e8ab2e181325c9b8491db55c9a8b2b1fed9080886989eee86ec1c9e3f1c634b914d327c74049e0e976b0e86fd314829934e7ae8aaa8996809fb068dad29850f6847564bc644f9a7fa9c598e392fa84ab53c68c6975da193f4e99cc74d066a43d2c84d3b5537d2dc9cc112ad419082d2d29fc27eaaee6ffc20d18e128e957e25ecac179d23cc49c8ee0001d6968369c7d1cceb9b99f26d7a5e545adb5aaccf1a325f661ab9fb2cd4980a8818eae27b201978c1eb51417cd5842027ffe2b9ef69148e149112b60b9f06a378ae4c8f8a4152a89851a0a04cf2671fab987df9b445618d7d2d05686db6ef23244e419fa9e348a837786ab8148745de5c3d1a95552f731d525f357739db2502f016d8d672cfc2bdba5abfdf90527143f905b7bcc299ffc7231b23151b949910a8edb56e4a0ef2934a2ca3c167ba1ca24fd1204f91809680ceb6bd70bf1b1bf30672802e8d5e9ccdf7e860ac5227eb5b87fed614547a8220b22607b955a84f3c23ca8120a312729312d738ce97009d0533d6306c9223a9ebd30bf31b819f8e27873e102ad25cc9f0316e8d7ce89f6b1d9be5b313eebb6ddcdc0ff4becf509f46b34f9c87c2581033e7d4ef0240632b8594e1dc6991018f3b4cf7415379366cf6a74c8de27827330fb6975eae46833d2a3f1f026ff0af7520da0c8a1480b79392faf464ff52465de5f890392c46a8e047d2f37ebdad3fd5de97ea79542555de86afeb95e335f9795dce77e3b2cbb7cd429b84af47c2f926004acc5f734394acae5017e8e14a31cb7cc2704ffdc57797a737cf8a29933a1d6babc446aab1b0e43d8f7d0a171d2e099bf736d9f26186216f03c884af882689df9f90944bb2c6aa5a80851535856d6a53e42963f13bc03cd9483af2d4fd09c9f7b9971b8b7d3663d739fecc6253feec5fd7da8fe23edeafe535ef657fefba45b68057a772cd941f7a3cbdd5082bd13d400fb0184136dcd84b82e8b6000593bff94473ed57e91e508a467fc15439be7b84ae57af54491fe71c9c6bb763df001c3840592ba23595ea965a154ed255491a6dc08b604b99a30618e120a4485d62d9c056b85b567a324f0c1827351161bdddc67da22afcf990e20c973675d21eee7b9d84546615bd2063149c974a51a4fc8d32f5fa05d9cc5d909d8ff33a089830580894373b6102ed445cf3bae7d90779f51eaeaa6711509cf57247bc3f0b7238e5879104eca0b3adda38f8481429aee7aba0b17a157d185cdb33c53de34630fc72e2bd66f641b12caf21ac629ef7ab63509ad1880cc1c73f6d8b14562d33749231c196a9f39ac25a166b7a40ed9680358bafa30c37f4c38c46e4da7a96d8de2af90690415a8dc4dd819ece71f851abd38890432c01cd295ce2afb3fa3b0b0dde601ed02418e3c7f8133dd754933eada6a4c606a354eeacbe928018e7d19b0a5269128bfd0b4eb66f530bafe9dbd95f6c2b6bb1cfa6bbf14433cc432403107e70dbcfc37badd5a4907c156ce053c0d90edff1acfb5c28a1e92c9fabf1654341b69e707507ed0ed23c512e4f7b0da423f4ee39a3dad67bfde290152982c590ffa2160bc85466367024993e64be952f526215664bbd99db310b7fd1519bdfb80135112d2451ca957403c4da0cccbd47274a8d4f171c2dce50a4e2a9aa3d81f0dc21037c9e88571dffaaee7a675d028b4e39c620a97796ea8058b62fc46f70323fbaec472034d7abf8df0dd9cdfb17995bd78961e2604ddd5bfb228499bc15e6ffade12a6255c91a61b01dc7f4525ab263cd5b653c326c28a2b8269758fb5526cc3d82d1bf4c5f56199eee78de40670aa47392e480e3457ef36921e5e6ab4ff6745ed5495f3ac41ac56868da8c88a7f332b42d1a80da8ffa55af468ac4fa62a78cdaaeef18a7ca64d15719b76379d6da4cf93b1d002ca292f947a67aa8f702dc5fd7541286ebd622ba2b3a2bb656117e6348076cf8d8895d2d003d90cdc35889a40fd71edab9530e906dd1dd86966029b502141f7d1457220ed0437168f1dd88f3570cd877ac92e3db58ed491007c24a947bb8890c3925f061f1f90d5cf1c89514eb97178ddffb54d2cef5a1407498e50440e0e0b9e4e91eeef1993503f1bb3f6650ffb9aba423c2bd8f589bb9ab6ce39f52a1be6bf41b955550ce3a72367ea20482ed3e7be09b19b19db249fc86f5118a233938df3317e604045f6345c246c54afcce10c8a88a3dc8ca131795f86cbca0bed813c638bdc8e8035c105620c7ed26ddcfdf59e5e171bed9a36d7c6a2e89e348d862f02e20b718e263a2bab07fdcb780d10fbe0ce9e5abe0186265b216eb6d8e59dbe61f01e703841b846a0fc03a0d21d70057f23a962d9d5deef375c9d7ea7f6b2e5dd85d0a39245755f3ef79d4a21ae9a43dcc07b2464fbaeed25bf1daa3e2269220b2b36e412c26558d226c41d3650065f3ff6af5fda09c358d9d8f32fb70549ce5a121121fe948c0a4ae6a15083cfe9b534d2c4e2fb1c79881daf2fd02fc9d91cf2ba34d3edc41ca14c9288db9e8494ae4d53fe447e9c3720feae1ab307e19a0d77be87fa3a6a33cca2e04f785089d84088d54f8a9fdcf12a12f6acbda349ea8fc3c55b0f079a2eb14445c6d315b96c84db878bb9011439053135be5b469111be8a72715ce016c821c40bfd52a624852ab4a336ba7886a0f8479770c4841bb6e048abe6eacf1bcaf96900c945c381d4292accc8e712c987674bae7b3823ef37fd30601fcdfaf104f39f57d60e3d59982f45cc8c01506cf2eaa3fb1edb9fe6d83568603eec8e17472e5a21f2a3cd5151ddf8d0c4efe8542a03290e64c5dc578319c1d0eb71c121166580c8233c3dcd1dceec20022d604836bc6ce4e68c809ab1a6f51de94a70bf23ba3ab4e2da8b5ef0ffa0abe152b36f2b65929a376a83d651770a19caea0464d8651067a5fd3cdb003054086b342388e4fc1e1864e9d493366aea8dd25072b83bbf195520203adce93729fb690d76560f0d826e4d392400b1b6a7cc0b8012b36bc2a547e606df94a07390a3d4fc12293134712bb01154dfd4f282a7ca49e9e9543c5b84dd0544cab836cd9d864f585936044d2559a5acc10e66f42b224c964764fc743dbacad6c92b36dcc1ce25dd2db09c2ec639eb10aac99da3b1959b44554531223f8f82872a066d10a1737c2fadc1f3fbe812aaae4f5d9ef6bbc951f521a3c17d14ac7e9982814d72284d17cc088de5703da1537d900e7941a4c441e29dfc532f6b14831a7fb123ca669727d417ef1eddc217e3a6cc8767359161e6a18aa2ccccb0aa460dbe6bb1b81c6375299eb07ee0507691d9c37ee1ccf094a253fae4834fd72ba88d1aa6f09041afaff37f65f5e7b05651574edc7b3e5ee8d728f9c2dc9ce1e3a6adccb355665d0c87f25a353aa74cc1387661e026881d080519c153a617696069fe85ba361373565550efecc67c80afefba8f71331ca345be2cdd2a30e2c5b6cf3d92bbe83d6cea09ce454e2a8ab7c0d4c8bda2fc2368d0bba70e2973bc730452abcb48dec170e538110d901ed1ef5dc667ec68568c029f0c2224f72be60e938ce5139d3ad5f222af88c041870e6ae928a0cb295e2b421f00392f72b4f37c6c8b10842584f8ce8ee64f6160e6a15538bfb0349454a5c12ba7cd2dc9ba46851fff498c2938ac393433e2571f585090a2b315c6711622650a2fcac80e61161b8afb2692201b84a80d4e219524e8fa7436ca4267c408d7afb21e043e214ac3d45a586201bff44700cc4fbaeff231c7da6e23ba75b967eea51d5788da1a42e569a0a717330e8dd84cfec55731efd8aa24d53c4ad9a5e53cbac03ddb96ae7ae24ae7508a6f327d82db5cbea90b21743876419d61bd4d0ab233537e7cc879f3744acb09e7ae81753357d387568800a0b1da14d386b4021805764a637aa36d3c07d23b98b9b7ec6145a9e71be2d6f7f47105f4ade7ec0d6023874ebd3633a16fba6c52df449df2c19cfac5fd979b820b4842dc2fa640ca080b4d9980a0243878a110b4a323f0b9b147725932bc01204d613b3c91daeaaee6149a216595517820b8f22ae084c2ca85b1e2f07a4b1a948f32e5aeb67fe3feb9a3671850aeaf710a3b4dea3b93844db7d8d4f62033266b118ab11509720d71ccb41421282d929104ba5e0ac140311a77055c5c1cfc7758b17c8e915deb494bf44e815ffd0ae19f6a041f0bfc900ff5e4349f9104948953a7dfe4aa15472b17eaa518c02401363fba8312f6b79cea77c8f0cfc5793feab4d6409f33357c8e54faea27486070d08c1d666368ed32a88ed2cd9610b7294a5456a06570964b667877a85924cce1af9a7bcb2fe09a07156af93d52821d386997a2b802078bd8dfd3090a35083769bb0fbae2ec184fd10e3bf9017ec3c07e05f53d1df0cfc4dadf9546af7cc03764e9fc764cf69ee3fd9457c7f484f1dea67f47b00ca69a7be301f38ce92399f4fa943c37177a07ede8c971264c860250059538f2aa1932d5630bef1787063f8a2ba63c3cb7df4b6d93b94aadb801cff096bec30dda238037058a244d0c2d179f70529452c2e377e3385c425953c8404c9ae4076144529d70aec8dbec2a5df326afb454ed040829510eeb8fcfeefe964179f4313f29125a0c5324156519f6ddb3111475559042b9e252afe9c1c94bd6a834def8cd73fccf581810a94b173bbd9e833f549c645b05bcec346ad9e8fdcb50a36bfe94f2ad4429868a8756fb2a5791af2f6dc2030c2f160bb6ba56ff92d92258c88935a36a9af5dcd5d136ce256e74124b8e56db39fbef480a6fafe5cadd48e72aafa9b064cfa86507ac686dc242b3fc9482d5a79d9d75747812e4b04234777ca76382ebdacc59d675cbaed2cc0aac8a69a6b46093a48711bfb2a46615a8ecec563462ed7965a7b2261850e39fb434f3e68ac951cb6d1481d3aa5290c49402579a1a96f017fea3f30e5997ef9dc3d1dbe65df45760c4a93982f6e0d29b44268eb51b8c31d8a2ca9fc19be85252cb853e7cfbe2ef8f6ac6546286abce77cac4f70d617762175a65959d6ad50360b3c23151df5329151d7067c9c5250667033bf5472e9dfa6e6452858bf023aa31c9e08b6805eecc392c0a46cddb6685179ae877563a1e4065498a7a5803ce02d468425ad0929cc702467d843c34f339ec2d1219edcaa2aeea3c929cf53ae9e75cc9d39ad6d41a57bb28db313570423146ce36ed65373882777f532964055386375dc3a7d66d48693e5efb9c16ceadd3fae5884d14fc4fbcd20871bcc580b565318c8499afc3d4c792381b9c9aca8a8344eb1f28c0397fdf11be8a54d2cb1e50dd1dcfcfa5ec26967e9f541bac2998fb1d6bbc202c82a4a37c7ade95c2a44d7d83451a650ba5a26dc0633ffe4513d91a0e385f12b427f1fb51d95246bedcf2c303e0e3e066fec3870dac45f0a094c7e9eb97a9c4a69346dc9305cb370431ac396e2fd67e909a6ed7862d96411aa27f667a309846d92d3b7a6d7ac74542506de1924c43ae0a0020287c3f85d1b2f855d0cabe6c6e9db3c8a82aef7dfa5e84d4a4af51adfe47f63bae00cf628f193bde80359e2a7c0c56651f006520e98e9acab52ea531702a3e777d9783420769a6fdced61b9f32ed6b5b2ac4bf36d687e28c289ab37b9a7f8b82aa5b1bdc539c6f94490e3bb733a9a4f67beb5cdc3e15dfad798e34c7d1c673ce5583472c90ba1f2994646af9eed2f72c0bdc88b97c9ad9f314233fb10ea5575490fa64a3b243273f3e790ff5c784bacc533f1add27dc389df129d253105b992757058063ab6341ff7cae4c36523db7ad10c175180b1594878f1483de98f3b4d10340cb5ea28d9d0512a6dba6cfdf1bf87796c9d732cbd60df2ed5c4c60047197f05283157b67e1ba016fb9d3e6826d5379f684fb21c4a0f91d18799742f26b75e36a7b009f605f63a31bf9b81c0502dbc5451d2af70b8782e5cd54196b3eb454807465616f01374b93f84bc24c7c60e17d88c64f86d3ca27f991d66993b391108bbbb60002ee091d01b226f9feab5e6641704c9ae94152320f6dd71395f5a23d8465a3b783a2a3016d48c718d630f3ce036ad870e1fd5f45b9a7cb2dcdcfbc7904acf53e32092d959db3c7f2db1ccdae7426ca5331d4f4c6f09c6032f14208c7b9c465df0d7eb7909df29b84d95b9804f041c3ba1ecbd01d2bc6f9d76515966c829fba2f5affab33940b1dc2e71fd59e28cae1d479f25678da86c2ed85734345126706269057e7510fcbd800a72e86e51ac7c3a21b92c260c037b36bf9b29a5ce3dcd423993a881dc37d007a7a777d81983e40d9afe088953f8b4936e6b5c8752616bba9f3ac18bb6e0f956f859a95f7b41333ca62c33f80288b82b47a539e38d259d72e296777abe3d459b5df4e303e6d77563f1e5296b856f7130f6d282328cf2953bafbd49a691c003a234d3fbfd3496aa605e6f5c1da390fdb3fc066ab5b2f26cc4beee1ae5138021cbd236293d680e030799f047a8963d68ff2f74f13c2e7723c179eff3412959d2848d746570b8567aa7cb295f85a67390f13ab05b986795cd8ae36e2cf7b831a50979b41ed71e7976926ca9ec7bbca6a363ca49ffdf76a38ec34ccaf0c2a659e5a47e5e9fff9fa4a4aa9d34692c050f74828d0984ca8f0c4faad926f6388564d3826421a9261d6c88a7b87c77169413cb7fc4dac97c25c9f0ea7a5b44ca7d9de2af7699aa07d25715f9f46a4477370","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
