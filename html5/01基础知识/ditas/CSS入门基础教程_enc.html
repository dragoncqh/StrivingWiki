<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9c8c09a40d45f0afe1c35ade2e98975a9abb97a8d49d53d590a129d8b07236787a36c833ba8b7147d30e7334dcefcf5cd91b28e9e4a44a0c21ca633b8790806548a06ad3650a7f7292ecfd14e5f82fadea8db3baba433b97fa8436750e71c6ed5f9685ccc971e90ee22cc5f6d9a8455b6f294936bbe9bc835f7340748281b408c51d2622f76fe4e12726557c955b443f7101e0485bbe79265a33f8ed716be09f91f0b53f65e5a871191ce75f83242a9be29bd2476191788e25e187330e29dd86130f9e80ea065e31097c4c54b5d9ded9b1c9910c88d4ee8a9f3c17c2ce5b8e05c10baceb4ce05c6e1a4f03a778d293c25091c5b108b7ab478adef8faf28a7f5d5946802de178527f289bbdf60061fa37aad908b0102cb047d8af7e779b307d8105fe3ed8f789f9079cfd234fa57d87a106a6fe61e8ecd7fa544cfc12ff964aecf441717b78c5a07053cd286a62ed2ccdc3742d80e3c570f97c74f9b985231d2448b4ca68c17db745c152f93562572bd673eb6f4a36a93da69141a3a31d00692edf9b875be373ac876de49783e14ac8459634399a16ba9924d9c08c20df6b3d315851814e31a7036f09558c4d262d50d3df5070884e6c84e49a862d623d745e94faf3a541d11db724baab973f03911014ab9abfe0c5c12a20e13592e60c306aa13b21993093ee708e554ed8008f583e4331f489c77c2f6536a9c465b145d23dc16c86e55edc932fbc76fa876bf18db59285c016a937e926666bdaa48642fa4c5d91b2ab5827e7030c84201d7d8cfbe8da409adaaa1163c7a19b6530619c1067aa845958d338547a2bc1ad34333c73c0b582c1c0b54a9145f7a42dc50b4221465b0404e7479fe2e88a37a5ac24dcc8cef7c5120c05d831d7c3d28c3c8fc0bcc623df2568c5a5e8a5c59696d7083e8de4ac26d68cdfa3862e5f191ce3b769f3686513c5ad84156f844ea603f157daa2f4dafaede36405fc5365a587df5c0095fa8c8b73e1fda12973314d0ae47ca05db744c38554ce143d14ec73dea923ea21b5032304fa6508d2d793d5d9b262ce702083472643ad4d0058e88c33ebac44c9872b85aca223263b22e5e542e4bd26ea4636ce700ba8f08599322c2d0d4d3b4745298f86c0dbff66d145aba386d2e62f76efcdce9ffa411ba4ae125f0e58bc862394276291fbd26c145f2bdba78f4840f79e09152da9b7babd0df8dde5ef437f18f696f19b4135bba54113adbbc038c2d18adcc7eec99cfe9f6fd3042d1634f08a3f87b84b040034ec862e0a38417189a4e6f3082cc0bb75485cde383c76f0389a1fec69bf22ab4ecfb100cff1346a0c2ac797b87ac77b33c0e7a53e55776b6bb055475ea15c2251402edae2acecbc7605bb311ac6d50d91aee3492d2fba7b8ca6a2480e2b832ed57bfdabf7794a5320f916ddc7ba2bd7640726a5e17376de843581c7a53610c0383eabd3b0be61dfe2bf819d2220afe0063c70e2eeb9ee5616717e2c802dd43243256163d08391d609accc0d11034ff328cf2d52923b7871caf7cdbe3f20b5c79e776e1c7ba11f5c973609387db9f50fb549645944dca533d690051e2649e514b29d2a0c6cb1ac441de5453e515165cb02ddb6e832fe1379e488650a14ddf0dd97c9c904a25acfe5a9e4c22bd281a0dad305037cd58d7c9100f8e8bdc6ed4a7ee127e877569b1f51cf8eedf0c886a73d48d46ffc0427b8b5bdcf0165ab35ff938a9610ddd2677a028892da5d1a0c25986c69729b6872e8b3bffcaaeff5d201d02a425418cf0bc3f7d3227ca9b48bb25f5c3d8defa53610bd0129eec046ebae87e4850d084ed8d9ca2947ba7e035cd77069ab2dcb8e89e8a54f5f1ca499b931afd441cbd7b78c487dd94c7f59ef000fcf66768db69b56b922345e62e5119446358f8937ff6b62731d8b8bfb4c2f3691463199402d6c4a00bab4d0ef2e45518c8802327fd14cd2e788c903c24e014494a70207494254c98652314cad529f5fbce6675fb73540e896d7ee0b1711497f36d28f688adc4eb4a9a9065fa597413e3d8749ea9f71ea37fad0177992c5c88be4943f64f88f5a7712657dc3219b3c2f719ffa0a5d45cddc8eaac95ec745965f661fdbd7a9e8658693b194981a3eb96776371e914367d0cfd2465410f725814b32606bdad5de58aa688d3b300a62c86e96084e0cc46b4c3b43940adb94d0a43015c1ce1bfae0e788864a324e374da72c5efd92e1742d37a753f7eb474ff47a6f675678a2effadbd26be2a7dd0f60b08d105d5e3606c40644634ac5c232d644a7505a99b0fac5ba7b703e92bfe958d1424b5072d7305192ea706b3580a7752beede0b254543ff52ce1c9e77333c95721bc9332c3f5a244d8b25a357338d271a2913a1bbdaa3482accbdf4ce3e502eade9222e2340370a6756c9d4181ec19f3378a5ec097550be83bae466140c3c717c802a174d8684c02991fdf1907f544c5e3b395dd244cb4fabeed3db487a4cfd19353ef1fe1dd443d55215628fef0ea8dda75a47a597a811676f1f277d2425a594c1aa649cba59c074a3d168d8c8e6ca00844b636dc1e4c54f8d9cf0433ae00391734a7b7b86c1c6abe9e371c0defbfa2ac2cd7ac6a6f619efcb5663fe817997e1d783cc5f0c9f79d7f02643ac0ba433d42f06081f8425357d2ac23953f7920648b317e09fa4b8b5cfcd492c18ab171103feb8aa5eb60a8e75416059516bc8d4b84227e7cc131422afad87000dcb51447902520675c2d3e517fe7a95b5f3d0bb8e6780e4b1f520c28c308eff059ca31b9f5a24d701774f3a8b6d3efe2bbd916de68bed15f4c68b51c75caa6e9872ceee30c4b7448919c3ae3f508cdf4062593b93535eb7333ce64c6c5df537390d670a79e59784797385db33cc988fceb57303f4eedd3e9e41b1d4c206f4bc4dbe5d05685571d14a61b88f486447ce609f6d58ee56b1c61374504e23dfe17006852a579e15b4a3518aa5b697ed5c119207c16e73f99c9e09d5dc086a6a3320adce42da239e9318fa9a4c514369287a8c2be12ddd785b910b54372e8d1647f4e4910979d3724e0d607af2e7f367448a7ef6a691cf338aab3c913b3222f9d488f4c8396de2ab41024362a8fe9c1334ef6cbef08b3dd3a3e19ee8c490e2c3f3b00aefe7a445db77a9fe20f3d971080f512d34a5ef64b7a81c65720692eaee8cc22ba259972c300e5b6b47d0fe0885c6b2df338ffb76786d0e545c2032728061cff9263394fc684d2879c08d2467fa7507a50391eee375c918fd76d436415d8c4c9d6505f18d4f183e4dd872454de3bb4c3a9e7128bd1951137e851e23ac8ab0b6c797a623e72adfac5856ff57971638edd5a53abd264e0705cfd0833b6132847d9c2a9f3541231a00d2f06b3e3e539379461964eea6b87531e3caeb38b4ffd6622bd7387950582b8aa1ac13d1c3e333c72e9c8f79796c0b094ad0d2288eb4d93e2fd35e643e175ef4d29b29b63caaeebe26c18c3f64038f3e26809408d907286d02663ecb405b4e92dd36995da04d4173e7b453d17d95b1329ef603bbcddc260630f29918c3b5d64fa5dfdc19975c4ab6103c8776774aea3deeb6149cb4e525352fc31a70ac4bc4be14b9da7f4cba9b3fa1c605d23a30e83f6ad9aee2eafc3d4e5742e82fbf1cf9df625fac4d9bb6d76c7a7610a49c901535ec62de57336f31009e24fb2267012e01edc18e241717ee9018b06daef275c87c2c92b86f85f50edb5959aa885bf5075a98dbb5209ec01967eed09acc18b349c1d1845540611d35910e7e173f722bb807685abb9dd56729797b37f3fb859e7bfa74088930c5b13ab5ad389eb1ba440e54273888e43e335bfed71f37513352ac4eef3751dad743d338cc300a77cbf723973a98d11df9955a69714802c4b054a99d0e6359d55448dd100fe3a8c4a8e33cb59a3940f2fe0179d77aae64b2a3c4f705c5b9fe20e2b769373918f134740847f07d9326c66195c331014846a3b445d01d4fb3eaa99d7ae0d06afe99210dfbbd5959fca488fd04fbc39b754258d01b1f1b72964c5dcd51626751018a6d18ea7e8de8b393e4c4da0d7e5f59269626922f23e401cd13ca7fc9469cc1dbd6a301276b54175f3f0ff0c27f492ce67394d555f440947a921898dd3d0273c1cbc9f3aaa58ba9878f6e8cabb6ef8c6bd36f0c170197e9ca1da24ba81c068fe8e9a3451fee06483a29f38d0cd16cb526f4b8372fff48aeba66942da6e2353a1f0141e8d0cd13e8cd06e70b43cf4c2fe2f608ef33c2d5a18c07562b37cfbb951e49e60d454ca62630f58ccc1077069e2fe3b819ec6a0be1161a331ba241fcb6c82312be0a84610a6ca521d97fde00ec581668096165b198cf1b5be83c4ebe6170ac8fdee929e24a9030f848118cef343caddc056b99d916864ca394026d557d4f1ee104d9973092eb744472e743be5ce01b8deb45ee980eadaa065c3af56844f8dc732c7ea799f90a4dfff81ed6e94f6f6cc963a19b8680208b60d281e8c1e1f09e51e8e180f315f6db33a02dc9808835f113adf3b0dd73f0b71f5bd09af12e013187c2ce9e24c0c3eb6e1387cb276dd46513e5ff80950412c7cf80477ca1e46fac976febe8f5347754f63515fc563ac9ae1242c98fb3c884f374f640909b15908d90f05d364093d550e47a212d62eb19ad5efdc1dc20cc625d8c8668a6d02ca19282beeca4b91e83cdd144616e5f0c8d641137ccefeba72bafa5fb78a2a8f9bee10f5cf91514e7cdeaa7f7fba0bd1593459cb5d161bdcf1436dea29885cee4f4847fc136319c704c288f25226527502b6225274336e84c7f52b6ec091ce38cc7a382050840144381d9124e50faeb658d791ef3289de2232ff651caa634ebe82cbedf819977a980a7df42cb05ed7161714074ed11cd7a7af6d69fef02a5c83e7552af4b5bcce496fe8bed73f3adf235dd75e6dd20d18b5d90565ea93d2703170d393087d1e45709f9e4f73661f525b3f7e722f1d727422919028f7af92105f3599c2d5b6a9e580e0949ee943061e2ea0524420ca083bb16d6d02d6f9efbbe1d95a0d9c6709827d998c82f25c8801b7b4bb83a7a67a3b630894c65a9a24f895f370aabe275f718499a8e796116ebf05ebd7335d29f19d06aa1d9b6c252cff196f2b5bcf839d78a6267b22e09a6ff62afa2ce3e8409b8c3702a669888a6fcad717b116fb0f2f69cce6611efa82eb76624b4eadcd4fcd192975f5971dd5129d7d141c4214c1d964faae2c78943f970281219a247f789c4067d4bd2d0446d5b1df792b39ee91f3a68e442bdcab60c0ffb59a6360d0a6cc0f11355d566217dc1c377f99d8d7108237f05b59869f20162ec1a7c99421cb2fb8a54d665c12138c73cf8e754bbe63592718b28a9c37829c873dcd6f65ac271b24beeca321387266b253c904fb8e19099b8db3b1923c27d41389bdd26a406b0e407afdeb0048e1d6755eff40f35ee2588ef3a281be111b48324f555af4c770667d2767ea79d4ddceeaae93cd97e9b325e3f2ee29444a69637b6c5dccbc64c09bbb30c8751a41c0fbf6ce4c4fb5676a837fa77b6be7f15839f00797d56dc94fef0f2c326877d38f43248516c95c67495fee365a3f167a9e04220d9fba7257f0811477acd0ba7758be8d1068cdc0140d0b7e8da29d132bc91886393c6bbf926dbd7671519b5ee789c8e4b311ffd00d023bbe08ffe7cfcf4e7a8e568be0a2f85c67e68beea67a8360744f811a43d1cf1ff165cadf3f668193d295d2266a6cb5338431c0a6769f2f7b41a5e2dedec5e8b5a0a2831cc1fe003841a786e2938b8f6064969565df9263fd16a8d319e8ae97bc197a01188b06054f6847b85be628211af1496fe42ad7490176794471822605be97d63a7515707e3cb7ce20d4491c0c29be590dd5c9a420544ba66e04499d16f64d3ec5d0a79b72b3e3a4e5071444e3fdb31f96e79c728631d23c904f5335e4161c4b30e6b34b80d44e8ad3b0082f8364b72c8b87d5d1385f69c7c82c2a4692d66d4c4c1e45b522c672569ac8b9cc1b3caae9a929002ae118ae7b3fc6e8bdbca9ddf17da162ba2644d132166013d57119bc016c981962769e581cad2a6a08bed0e0d37b8181a70183cecef150139b80ffd49924d5c9db54230798161eb8e32fdd1bb8f4f1a9f8e8e7cfead32c82780eedf7e69cbdf61940a7e98ead693cfe9623981b75261d8187be5ea8f8cd41e115603d24044ed01bf3668f170c6c41e3b7f311be808d02082b21ea8366b36fff4d28911ec047217eb2c707f369159d7582f7524a64ad9e76cdf2d88dfd09a0c4635d11d29e897d42112ad5a58eb15ff6f5b6999c962818435750fdb2052520afdf8460eedc42bfe94bca671ebac8cd1ad43e7fd9b80835206bd12a6f2f961f02b95a2016cd8ca5170e98180071cd4690e558339efcd8d3f2f4af8495692efc8ab7dc2408148e933ecc3ca8aab452ffe1ba23c8d56b3cb3d63a5a4654fa7e33afaa1d4a29298edd8235f18c5ac3d1da83f37652512b5c3176380f81eee07013afd31e56c5015c4f7dcba95f6e879fa835f25abddea742512da67ddd1324d1d871759f92c17bfe152a9eb4c00bd788c2c4acf8444b0a81e35db704edd4c4301a0df6be8ea26000b6c5f12ae720ca06f034e64ca2869c1008441f380713d637be9e973530e594d167e03196c75ecc7c4c4777f32a3e15ce4387a7394621b16dd34804308a3820973d30ce64ff7d1480cf8a48e96d073214b92f96120ac393fd7da36221312b94ed2f50e7866261be89bc693cd2fbd70d786148cb0bfa3accd5729f6e60d8c09bd1b26693323cd469a5b9696d0bfc86976f11ae3146fa4c6121964421ab5c16ee43d990a088b2e3d6d0aad07618ff2cc91009ff6196c9f1212087c93cb58424594d181f0775432fad8480cd15db2f4df2f946dbf04d996a568a8d6db2448b8a746a2b2851b2230241355513a049545742e46cf1e1c45b7a8c6e88eceb5a0711327c906e4742015ef9e3f3db0fde8a3ca2ab376f932b9334ef0ab70e144d042fb93d4694ca0fb1e3d96aac667f383f9e78ab4ab38f36bb89c42763e59dffc3335bf3c11b145395676f596540dfc340acb5d9c556d53ed4a32c91c80bb8b6d78a5a9aa878dc5eb8d8b7d58f9435e6162c5611ee9fc436a349cbc1dfe0b67a7e5fa0aba2b9fb4e056f69ab187575e14485bbfd0c6e33985d5aad4ecffec5e00f5f8e2b08f13b9df5a3c1aedadedf36ca3b5d39781796381e05fdbdb274ca76dbe15a8cf346d3cd4f0cb3a64dd779ceb5103053502c8456a4df2358434bbf4e31a2f1ba8f0481357dd2a4da15f100783cd8ea759fd2264a3ee16bc40900076ade0f168c51650a0e4f22b4c67dbfdbceb58fdc55941fb0b3fa229e3959bebd7254987004af1007a1c1e14f637c92ca9003e3652ab4dde4480d05f2eba2edd58086b165037c66ad7268cadcf445b84defa4a6c7b2bc551682ef18e3f2ea9291548e2fb4262629801baf6b83527cdd374c67cd6699283cd2ed2b68fb2c9160b4928766fc34570ede4ed55c9ed27543f1c3f50b1952d38148058afd8d72d2380ff0bbfea75ba785949f09bdcd4037475bd63ec08f80382ef9551e2a2b9346fe7e9e35b7ecc9cac454211d409675615f3ddd2fd18c1d7604544f08e15171374d5f8932bfe0a43bba4628de1e8fe698cdb263cd40ef2c8726deadb3d754df9ecfb3ef12472e6788736481427d77e62ac08760d8cac881fc1acc11b27886ec2aeec3e323ac9c7de7c2c3820b9e111e2f5af59256f80b16cc902520cfecaed77fc294f77d0ebf447a60b71cdff7d7fbb6a76de38f6823e5406fec9c46d439687637775380f1d076e8eede46f705c109b81eef0fcd918ca66cbfd48fdbadde381ab346818a4b8f82b23cc1f6097ca4087e6e0096dec7aeb3b022dafba1b7e66890e4c63726b50b80bee98f6f0267b376b7ffddb2692b20041d02599b225d112c9de8008c4623bed6da3a785217af0d00f12138f7f652a6d7a98e19a2bbc406ee1209378cc02d3618c56473bcef0df0f77726c5dd32d2891b3407cc61f044c8f1c9aa8d22a0e2e14bacdb7fce35fed662cb968da627bd0092b50de3d27a0ac084e32a0c71b4aaaed4e51f4c5da212844274f0cfe917eb61f1a8ed25a75746ed723aaaa042c04586df3bee381ccbf3820b60dba39433dcea6290e700885006cafb13b546a079c8c167d692d27a5953f085f39269a7f485264e7863be6d724fdc6264497e6bbe2089c889a93e05b6503b3759543557e548cc95bd7eec838081743392b3e9534e0caa987a728295000f4db641232817ca05c1ed6ad69a5d7a4d405373c0f88c08df0427fa24fa4696f506ce6e667737c1f09cd4617e4fb24beaabfd66d4ba20dde6cbdbbbfae1dc39a25d0b3722f9097666f9f297da3ef99d30da34811e8ff21fa59f065fd928a430ca95db6353dd0ba0857eb8b9602d1450110a18c26b3a0192e9b8c91e49204c87afd5dd94de8217a70f22a5127f68119e4745c61d2f2aa6d24c6e440a93cde90b5af41d3df9e91fc0598348eee5d70bc42949d689e5802e7e8a08979a2477352f1d62b7792750d5a8601ca96a06bc4316a36762f9edb7ba6bb7980ad3e33387be464eeaf74ed4b7c6ceb0d5e1e3428580f220b4ae3b94d5b5c175b5565624a118579c034906ebb11fa9003a6cd8d24f1338daedd48a08ae8d7c0e8799659920dfb72f898788a9ce7a22cb41d93ecadd8d12d910f22f521b1292cc20c5de3274fc1056988250660efc30dc1cd6c49958f1a56d63fbaa792d5175cee316a248c736896efb085853c088a3de87457ea920377991b5c37a2b9e878b7aa4658200b50daacd98d95028b9c8093df69fa946cdde2c9d09c2745286e2ffbb8062e4dcafcc68316320a991b1ce7b9e4e854acde22b85bc352afd822fa2786f8f443be48c90bf92ecbe0194cbc3015c6e999868dc654a09393f246be8cfc3d4c30f52057ef0fda188d6d4265ca650bdaf3add157ea46bab92712df714a58677a151dec887ff29563d7267d2c52b61a9e534b019d05dd2fabd9fe01364015b652c87ba3e44b7fb0156cc76c8904312005de90612dc1161470dca2cf800914f9c1830423efbfbf7c4e00c3231310ead34d19f806a0f1789691db242aa9a1870ffb28786a20f12812ddfd1598eecef90daf30ea39be4a493dc33bed93058a1872ed845c33cffd5e44d0947d6739a36281fc8ab6ee091a36a5a9df1022019d057a6215f9a5a77bd6f3374a9b87b0323b5a6b71053885f1eb4bbc822798a8cd04ba6d5f769954a68e67e241beb303ac7782743843c39e87717cefc2b4c2dd2f0f58c20135727d63e53b097834fd8f08f4462b3ef5847c581fb5916e7542f750d9acb1342753f1a1817440e9495f288cfa67a553ade41f7279218ac24da45a5171cd00713a60f948a218debce442fa7a78e7f4c7ea503b081fe73aa7c1be2a65b9d1935dc037a74f0965a064f0cda021266f4f01497f316621fd6ff2603fee306ba4ddef829be828c3d15155052b850c6fa25cccbc7a38a3e720f754f40a89f67bf2b46c86d7b8729059c743337fc82172e9e6b4910fefef72088ba595eaf855d549deed6eaec19f239be46abff01bf6b041407cf47469049a516bac840e00668b1c25fc6be9ef32bd341bead7baff4cf851567e9b4033696181ab473cd82dc29ee1a5ae8ed2924b7ee07624df6245a23961c4b62b0891a2e3d5b7c4c5d2b8dceb6c51ad34568750e1a77873d92c1ac8d3074102b2b65d697ab91b251d881952fb5c6f69ceb6e9efac5bb26fcea9d8d81a329e6849ae0ef315e196ca4776bacf8163e24d3dffc42ff93e064259cc16015f3aae43ec6d535a409b34036ad6281851439e5ddc78d0ef5a52d4c89eadb6bc55b2e57c655f6bd431e055986291fa5750073bb055a1faf9722dca7079bf433be6ffb6b5d141988f60373c3cceebe408502940cecfe2e38e8a8d9b0926ec5945d58a71f7021dc6ff6f7cc2bbfbf835e04563bfc7e393519c4c52c514d1f014c4882a9212956ac9c70805ddbb3a9c0f81799da071cabac27a47c11f63e323286282cc370a7728b706509b9998cd42c911cfca9fa19257fac42bcd9089742d714cba99f41cb1289bb38d729bf09461f454bbad1d5462cf3574f3d356159352d15d47e06764520fefeb6a58711ec3d79fb45585bc94c7274047684326df99c89feda2627f2d2452ea41fdb59e5710ceebee9ae3f5702affd0316e8b522d6c40e35d9eddfde793337aa90ad3df8b0ded2c6f20a6ae289cf007fe0083b02bacd3a9932881ed5d24a04d87e608cfd2d70574728b520e221473e42c81e17dc2d479fa03e28397cd797daafffb2bb392eaf0d39878490ee90abdc432f1baf97434660b1f0ac7254296f33fa5fad52593d986e7a7d36d980fe87254ae13eb8b26ab1dcf2cb202b4dc80e982df81de03b6709b76f302aa570f5f0dfa9fff3ca8d7451a2dcc89d147519ee04a9d2c2ed0612d37afb880b12c85de254b2aa6c2a5a4342b067fd358ff66624c454a333f0fd1fad46ffb903b65df87ef87ee40e0c6ef489d51078f436d90511a72e4473a6373cbad7ed985400f461fa960b12f8bc4dd7b2c204ddfd0973327d5b4933d44af72d403c693094d85b7ff762efd95d535b01b280c27d47055a85bcf6570398607bbb69335b672aff79666f3cbb77f78f57fc11bbd7b6dd38023b6fcf9ced05c04c216afd63596cf4d72d8707861c4ce5b11e683a5fbb8d92dc6dcea5da50ecd77cea9bf0841593127082dcbb343936dd5daae44c828b7933d03c66f8f7acea31bb00c38a931f638362bfc01f34a4ac7762164481ee8c5fc8818a102006834220da2bf879eff32e0acd1bd473c466df6447100ea50104415216042be277c79baa4d8c684e6589ff71a2d430929a55b1c9fb6088db097cabc2e9eb25199605877e6797dc0e239895cb3cc5d58bd5a61ed785ed98c1ef19f7df95a4e44e9946b7798c684494427c662cabdd248e383c70b377e210ccaec4901224f593ef5d9e61cbe443fdf0a45e0f898c5937d820c91f00be6f83ec3a080894cb20c825521b06779e1f0f50599e10e4f7c115ec40184789f42311e6cc91432c1df1d8362d624f3268ef3911ad0623b724e6e065e40b6cd5e6ac88df1c13b64b1e15a9cd1088f5f7c67cbd20b0442e900f22fffd5f0565362d33ddd1af3e0bc47a7145021303308aee312892686eea502efcabc4cff70107412726828dc3a4467caa0075a7967725e2836868e5b969cc3625e8d4149f0a70cf5a946d0e81a8a45782ab552d0d45721c2eb36d3e9adc5ad4c9199383bcc6aa84dc02c0d4d333d44d23a19d4ece6903099ca74ff04cce927019f2a10b1b696a36cb7495436ce1f1e6614d553e9bd09c7a51dc07ca4cdd5865758125d92fa86167e51c06a527f2775e1b54307efd6f631132be3e5160174cc47ee15ba2fd52ad85997be06f03e7236681e9e54bbb5a2c92c076088ee38b166babe535c36035b617a7353f318a87e0fd847bfc39c72c43025df3576530e88c7dabba77576b618eaa4ba35e57a4609f33fe945281e1c4ba1291e58893bc67b93d145a4706d5c4053240a87f2c307544c23cc1dadce882e63e83b382a4a56dc4d3b749a5b85f1da8ab253972b0b09e3bde5e6bb32a336f0bb2322e20c40862d95244d77e7026a59989628d3f361af6e99857f2fc7625503dfca02bd8c996541951ebe9574b1191e204df7ba88a7f30ffbd85799f673b18fefef1fbc72bb2b5a2cde4fd9c6af0aa6ba6f38dc89515aeaa7582e71bc1292a887a334a0118ef65c172355adddd983af63312190611901c6806efd8be3af42efdafa0d9a684fe60887289dbc1a72459a7d058db8078f417ff41505e067cc4abf18a98421fddd41ad37573c329b76c89af521b5916816e534136cd0fd338e72a4210e002cd105ed60871a238c7e018c7caa5b20ab022ff30dc6628c392d8aaebbd6c1005de9e22d882c8a61f5fff12c082dcfd192e4994a0889d8c50613e8a5b7b1ab5ebbc0c06e0d38e39dae049ec2d406ee99f68c597d9694fe01f13d82421d8f8ccccdecfb841394010a91def418fe038c3409cb0925a94a9434bc11963056e966287e861ffa03a6d98b1b71d0fad4d4f65bad8c7cf49a626a0e4163795b0a909d525b016a0a7be88524439309f81e6b1503cbd55aad8e6d97855eb5324ce64bc443dc57a20caade57a8668905eed9d8cad2808d2d03752cb60c7abf487c724c87fd9291efc988352b30803919025d2d6c7d05f39769170a19ebfd958fdd03d98a65f0d49a1e191f1cb284d8978a4cc637810acae7d014e1c999bbec3c7402195a6347c445bf08d7c00fb28893da21894d8e7c2cfcfe438d743ac81f16835d90b8f0214ed92e518007b6eefa194b868b04e989ae8828453c57c6894682985d2204fd46300337cc6f4f72fd14568b6b6f93970aba3ff29fb83994f9f1d976c96d33a7ac55ee686eead5cc0c365c247bc2f6223b169f33bac622d00723e23d574c867bf0ff097109dc7167673757f7ebe2e0fbe59cf3298c54c03aa1ad43e46e78d3c31c631a1d24ec087a95703e41fd23c9586905f2338f232e66844cef819c0d8f41c93bf1a9f629067cc09a227a443db1accae526ec243ead7ef7a8761aa4e60b9dc8b54b9e9624add2e4c794056806129704e749fa741a486f2de001d6b1c5b871552ebc19122994d3564385109e2660e57bb1348e003145462072f7c8d1908f35bb621def1bd26fd8f2c63342ae8940bfeaf3962751173796790dede23e283701961458b98e0378f34a82e669177924f7bb2ace8d222ab91d1f83dad8adcd68c546415ffb5f2dd31a9def3afab40a5a491157287c160145ec9bffd62997ab96bb651e05054e909304a3d330c1456a891e7c5df8b469238205f1148aad5ec4e88646860bc94105d011006e38eb07c8729bd4d8db99f2fc22e85e2d649b7e1f5362aa5eb473aa670e7b2b9b78e9b3238aea831896b69663aa2c87063c729d0adcb9f248c21648011004e10fb18f02117f44c61c0af1f398eede0854cbe3193c5c7a1468a155e44227e3217df5851db47d867df848a2f55c8593f86a5fa76fcb3b0318e9915ecda310d151c27ec9a1fb6def1c12f79616ee6b04f72bcf433b8d99ecf4a946d32445ec21e61d53085a9ec6181dfe298ab407654d543ad30f2040b9b3981869dcadeaad10c0093604c47d87aa1e5ab4a71f56bcb2a21a6a843a92c919f7cdbda96b10262c73ac1022b244cdaea2749315adf128c6f713b9ac2bff107b98e1c61cb0d4c9e38f2516b4f846c5746a1d915515eeb9c8c7a20a0a89559cc1cb24f2245f2287a9a6b85b184b18b19ed70b1dc66e60bf06dc24066abb93486435b33b905874d6552bd06225e2e5ccd00e468b7bf6e01dd63fe5380beb3d36031f5e05ce708ee80f3cff2c0f5b89d7013b9e571e5d4c9c0df9943253de490c4f52ed28c98950ff555250d3f8ede1f11031b15423714763472bcea831299f5059c3c0a0552eaa7209946d35983c7e0ceef1db24512ffb0beba616a8ce7c87da3699ad1cfcadb4d33116eaf0acc3ac56c5375a9b40b0abcea29471a2cf8be9d82a130dfeb8017c0c6456c76a75e9500daff840ed3b42fc40a796d8600bd51b2bd71c1e216139165e9a9e36d504070d22d96fd9c2ee76bf0533779dd53235b9e71a5126c81ae6783d2145ca3ad141467ad23bdba0d630f62d55b2ab36ceeec564e0284b2bf34ca8f848fb2827df0de9bc7f880bbb499556e31d09b34a97206cf55d567aae2edc8670acd9f7271be59d1ea562c2348afb30e46e5ae653a4e1eced8ac605901357737f335dae9060333f67bc074d19d6e5fa963d1610af48d3d7a10d585b52ca67d377faddcffa6430e10e3a18053400fdd96a763e36827d751151ff2706c6c1bb0dc18fdfb0a2de8c1107d4d8eed7ca799caa936a4a42a111cca9eb92256b4481d5b269a44e49e91ef442c4ad284c68515cb0939be10f2a8d8524885a8807c131926ad944472056621c008f156d84b2f6902a646e8bdda4f3d25b8692c898d168e39aa1e63d5b5f01199fa23c86eeb2361438713a3d052b3183bfd2332792bc11943e9dce9e0aa83537a87da5146491ce088dd7b76419a10134a41920e78af2042085094f749941e5d66e8fed97278c3cf2b9e9e0c32a38f926dabed5c9e9231075317e89a17a8eb8f4161a62d8ada26cea2d3651764f1a07ceee9b73042a1e9ebf0e8e7e09dfb904235828d14845726b4972fcd4016dddb9257bbd53490609565145f666a77aa4da1915ed575585e0cf05930444c428b49ff3a97b9057ec9fa15bc863a16f0b702a2fe6f3d2a7a96ce962f99c9bba0a6b97a6fddb2b39cc18c2da6f0158b77b13b81786a144affbf5f06f94894ea8f041f89eaa5d0f488193df1112a822296f8061b7d0b2be4c8870e254428bba0e93bf1348dfc4a0c28bdb5b79dbdc30f959e7681cfb0ffd7fe7802a3d3faf993f4b935faef7f89c2a4384bd06912a92d159afb9d8947028b090440a9bc9a5038bfc149d7bfa4fe21046e0766c902fd9e293a172efdf0ce7eb75f3be82076a661ba3954b79d33e1d7c1419d5e794f2197e4260dc52b2d72bab1af4f38f60a9d793d898f02a59beec7c803914df943a8f8da1af502148d6349676d1e64fe5717ee52e4d82ab5544d71533d8923f3e7a47ce3241071365bb594e0ea49608f3d37db70681c50e6680e36d4dde712c4d8cf9d31fb06270f65d96e5d7c2e6d9da940c98ec7aedb492c12e272c6922bafe3701b636926bb96924a3b90f6a42e65596ecca070df10d986ed868d186d221b9261320be735078626365bf091caf490f74a0baab50f7388f494d995bffbb8c852e9c5d51c81be63a47255c3312c94a9f4c652f4ff09ca21c5a47a23ede71ce3f4b14f9df95b893fde75d5b8c6bffa4830fa187d4a359b6f8e82bb91cff241bf58717e7e05ed986b09b24c9fca1ed9e9749256cafa328e7fc82247b5fbd3fcc07e3d265b956f3267af4c5fab42d72ec54b89efd4733b7f316bdb3468b3680601ef810431b17486acd60f681ecee058d9c67f7c9a03283e8d27dcb906ffe60d66e3ae8866768e0b68","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
