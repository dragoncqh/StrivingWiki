<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35b28edb64ae6258d184826c2d28efb1322417258ac5e07f99bc26235306a7fa04a77249cf17ff281d578a8a4e35e12d3fb46823d45187243f57f2fff419c816ddd40d277464592da4f7b1682bd0e3f2344186a319fff145a19427d4b6bced665efa454e632b77609011ae0a36356a2ec484888d2e58e6fb9974e6f83d755b47ea5c8e0f084eb7afc4c5429ab049fdae83bb8681f6f08b5f72d2b053bf9af98ce4699b5e82f8e0a50faa2601df6b952c3e4351dea756904d44be191dde0426823fd38e6b46009c03d00831c16c9f69dffcc13115016be1ece60c5c34ea5b76385180d91ae41e6fccef93578e11dc765de750e66180cbec764540b41b04bb60c8517d2e46b51814659709728f52671c95ded35cdfdca85dac812a36a86c90776c10aa9a99e13e3a862046cae42bb43fb810930bb9d01e279c793dee76e4796bdcb48e365a4f4703dca8e49b2da456d5db892053d3a5ed21b0cc75f3368831390b1a83e53c1ec2043559ebd435bbc24d3a52cf0757f798a4aebe9af0add69743abf81e0d7975e8f78dcdb414ae0204a485757bca7564e3e8469bb2ddeb4b11bbefdf93ba3b225758c4ed2d737d6a6080368b9c0ae47e85bc126bd49d2a5740e9d09075527d580e99285bb7c566cbce57c384efc1fb7a93fe87fe4c9cdf8cbff44e50d48a36318d3f537f60df13d549c6443638741d028d8290a3e6b0707878b8d287f90f0b956dfa96fefecb1fb286b7a37d1de7f368972e4ab442729e84bcd8ac05e43668f1170c62263e673825aaa9cff77cf2a8485cde6672fa798ea919fdcd038f0901e1cdef656eddb331e27a7b95edf9f96b6a24b99f41a834c8d0e6c8f13909ae184808aab9364d12db3c711101be7ca9fcfdc4c33f46932ee015531323590aeda00dfacb86deeb6a1f781ff7e58baee6ac1c9c1e5e102ffbdc9166b73d40cb08c2d6efa59b9825e9b782242105066cf0d19310dd8e783da0c3b511be9035c7d03a84d915040efccca66cb298f4ab04b2957e237e5189128a22b5d25bdcbfef2396b4e207516452d1ad659a42b42b042c25c2441124c318a9c7d2cf8b4922fd25f91b6b725ac3333d8f19e9834404d49859e35489d8a9d8cbc7a13dc7140144b5eafbad60479dc37a642a936861cf084a340979289c94481b17ec19819053b8d7210ef5e2dd70c0022f318c5b621005f9817a0f566e5008c8e9042cccd2aa74aee267b206239b89fa720b4b0618d3e35734a1e9caf4dd73f1282147b3dec0aa0ba7cac8cd5a281ba4b7feb5675406532a23aad4370082ddfe3d343390ce997ec6986541199bb8a039b81164a1d2a26628ea8a2f526933560e4994b1e0b385dc2ca975a8b71f85af89f763ba5033c529b2fa13a5d5732bbebcedfe8fbba44bffd273333614e2c331270b2b2a67098b34bce7758ef42e26182ec3aac896282c55af2f55c22c2fbf599c18ab1a15b01218d9ce3ea3d5a7ebaa5d7e95ac0743a0f8060e08bcd84df438255cb5a9882d7b0197097c2ca1b3e8d5df75c747399056c65523a793e1e192ed2c53e935c8760fd55d354a43b5cf0fc3c2a6d46a4dac215371230fa65a0618fea263ce9fce459ab4635376b6133c68829e4afd31b5f39deb1eb2a3627f391ebc58455c72a7363ca3ab8cd3281273f1ae7f9a39df30de5ff9c8f91c45e87fff4f05191130174ec6e88620c69955c337bc3b585297172e93060d1eaca896adacb9f8abc705410f174766c2bc1325d6a4279f2023d05d54fefc865ca89d8d9082d5ad9dc77ef5c322efe7dc6b1ae5195f8eac2dfd5be044a4eee6f0ebb271277a029fcdb1c40d373d3498a777d6151abed75c905e6f9883e8ff403c64cd01f5e525ad0c802b1219774e980ea31563fa7f34680f0f9d2b8ccd8989612c9f9d751138f14c70b9dbf122531deec952bea1ae8afdc5b278dddec0cf6efcfc3728a56fb926a77b82efe1819c1f6414d60213bc10d05939ad383125fb4dd44549153f666900bce22ccb41d909c73b7f5b9b85157b6e006ccff951a2a012472870cc194eb3e11be11025940808232d5b64b277efea6273d2621be67e8309a708eb638f7604caaede50e76e8dd974785466a1f3d4cea82d02cd002c799f26b8d782b1549e2e4d2dca128beca3ba0651d5aac0900ca5e3ef139bebf74b440e6268b0d868156b4dd308f7da9abd79869f23761609e9ede10020aae6b8f6b15ffe03e4c57584aa4bf12cce7515ba33142aa06f20500a1f73db53d5733c48ed7e1a712da753dd77eb064e2e8248909e019a7976189c730cd871c6dbaca49b9422aec872d2371a7d929649ab66f98a8888454bc7a4fb5d9126bedc7392d3064c90771d41ce54de853a4cd0077093a80946a9d10da16e909bcdf5ecaf874c3c8fd609c7af6041756be2bd34ee55091eaa7b89f3c90b8dd30a3839b66f780f47cadb0be2f47cdafec2f6b2b6e26af898f0c79d49c225768da769b73508815130220aea86d2dca84603c55dfcfa3ad67c138256da8cdf8500bac8541e9ca1e49d39d4e6196a546795b357303f855b0ac3e1f1cb6c7e8c2ad195e617545ae383252e36049d8463b587818f198b2aed806bbe5efe3dd6739e3df089fc4cc6024302c7a10cb0c5548bed85c282f052c4e4aebc42562e1b4d555a3452950b82f79c7c32e5c193caa0ebf5269cb36e61144700c035165deaae85bc0eddb01860f1cbcc362ee3a1e0d3ec5507ecaec0bab87bf87cbe7b12eb1db18ce6833d5c7afe9d856b773809842a076ef70a08b109186ecb1c751551551c0703b9bf9929b2108d40225b1fd921dd8cb7dbc177344ca2738524df9e5b7b7152601bbf0c949472a8b6c9657c9323100659be464947e71ae1712dde8425d8efe11d183d27ea2942b68f5045f1491ba30c1d6a995c9c8760c4aee4c4cb9058cef3fe43bb1ec725c2ff6723dc4d4cc771a6507356092be21df57243edb827a6504af808bdc775ea56e132daa72814a0c131524f7469ca17e1ab5fe246334e0a9740e1bd44ed4294ef2df7434b50b330360503b07ab1383b059c4fccd099459ed69ec71e74a79fa99452544a3975b248e401138097987ae29909d47ce8995b30be9818ffd14b2116b2157d9915424841f9ec239e50fd3bd3db21c52301e9c25f25ee19445db2ed7cef17ebe1c3c24fadde291aacbc5377bfd9a746c2b9ba80f4e9138453d6705a68de029ed41356623d1de6ba116622e37a2219c1d5e65c5c2712a1dac5aa6c6122cb45a09b63d88a6ebf600c0af8ce6c4079d0b9f20fe0aedcbd3078ca38a14d5527e7ea8bcbe4aa9fc880a90741b0777be72ad44887d47ab136057403beb1be2bcec119ae4c39514ad294673443845fc372b9e90f67361d324c53e809a88d0fff14c5252d44068d664b06866788ca1313d53e4e714e93616a2808c396d481521c77b834c2988dd5db6a60d19b8c7e9026c48d0e32a5570e5527c8cc36b0ef2c3ccaaee78b71bddad24ea31fe5397672f48dfc1a4bd0a9e32708121cf4d4a2e7538f0ea312de8678deb65e9296afcdb91a550b64553af1ca6ce489e9086da9eb0fd245ee2416cc2bbbb70b87b0f33179f4c76959c01879b16c10778fc1cd5a6b74014d6388146547f2aa6d3194abce0dd5d67868f74ed220980ffcb5d7cda195a6a8813d9b746370593b683c46cd86fa7cd41d65e2449ec0e4452c3c049bcabf404fe1084c0990a638608239dd102ce20988d0d5c6a8a6f5cf19db227d872cfd8b8655fc80214943215697796c046bd989c8b6888f25ea71f1f81ec822f58cc4f5fb4e90150dd039b4c4c8bb2dc9623c4df300dbf547103e329b16e97459c03e3667687c7473ccbe4579d85de5ceb66aa2014b3618bedec2979919b48a645444aeeb5307fa2261038f4a7d4e8343a2eb56dc72521cde02ada94ebaff24316ac71a56684582fde1f0cad48f21e17af3b4b821b638261dcf18e3f3da1cbe8184f95ab1939ebb6028de07927071c46bd4870b771e438dffd37d21e6332ac7f93e316a3e81b53356aac8d2013ef49cc263c5b4bd435c53b4ae63254c96fbec4211c47fe9bfd532a03af3682b29728b0c6c62a1e28d5bd1330cacacd22bffe320259f99d3c3b8d92fb1d42c77d48799fdc5e2d2127594e15fd3bca5a1a9df3f0e98cffcbfc703ac1a01376d103acc02dda70e23955516144df1097dc68cb5fa2974d5fc7f9413f04b651e1d8d61882f10276650ff29e70f7b27e3e691b4e15e339914d99565864041cb422113009c7b738b267decd974e45719dc2c1ea4f7f362d3f9d2e4483ca4a1bf216ced64eba09bd0431213d100e6bf963b548dadf566fe3b4657bfe65650e5450527f540848de849b9fe619caff68652d5e4a91f841a0813b5cc5e52d85377d45e55d8ce1a63f21c899c849f902ce791b6cf4daa437f7087684d055222642c21f52b0e7e9f512df2c4fa4a1cad2cbf56be622a2e731520a5433f0d0312fda081f436c7670d48b9754f38477a7bd157b45f15f4afafe619adf36dfa1abc3545d7b3668d10239e512e8e4c5ab421d49c4d18594654ca54d6b37df60381a92d6df5fbc710dd24d9e71e6db9544c1fb0835fc1e53a552d4425dcf256fc7e29356ba56829d5acb58c3ad81498c82bc8d32e5ab12cedb9d52e8b9c38447ae66562e6b23f86b4cd493d4360c3b8f3c13e3a75ef93d7400fc04e646d7adf2aa27147559259aa96dedb1e7e5fa21ebccf29b34e3bea62d0b5bda8b003e6e78eedc8d1cafdb18996b2356be06ff5d02637294c11ecea8094284f1e3971813bc1a3b117318c40b62c79a3591f3c978d1fbbae275a0cfdbe84af9c8a70a71ad05ead9f3b15bed00fa2bcce17d06d5c97e9ce2e70fe937b8f1e6f9898550d7e19a8e6b9805422f7883bf82fe794aee4c339902dff6b3909d47f344f5652128cb31d65bea801ccd086563bad43f6b29e09fef7e44c63d6bb883b6eefce4702bca00f2aac420358804fd622c51fd96063eec31b459ca37880189efa9edecf3af41cb6c87b30618fca0868ad6c62aba51eafcac851cc6b6371f3048ab761548a87b4cc7362f3cbfa3f8c09439e9d56d72455b64808592a09335d145e5b721715db9d5bdbe42e6b78c08a4c42f736575e761b7eed0e2f4a8ff3035ecb377f930ec56dc048b16e7a70a33152b1cfe8c9eabe755713d593247ba17bf9760a4b8f36e48e1c8683708b79d2ebc8dd51c08ec27b6aa26a4d9fe0d2f213a4e6c4df5c4516f74e798e2f41101c275ba379f4bcf5d74695676aa465153606ed1e87d161c6be3ce0971d2ac0f75f92010829c7faef702ef3325c4bbec46197dafa289b5428e9d05e107df317d090cf6d84376c1c3d657e4ddeda36941e8aacd859d97ed1262c470a29a20bee6c9570bc40126fc0faa6771284a2fa65383f92eaa0f1812dd3f79bc27f831f3a9186763ad7ba3b65d27b61a9e0f8a2ddd2cd1e326211adfcc053933b15987826f115ce5f5e0df0b77046834cf493cc5faa19c27f7d1344c3974c02fb4de4599dbf97ef0293be7b492385bb1832013b061ef30a140a01c62fd752c5e32b2a56a55a03ab757a313df07e616aeb136796493798a70c4e87e3dcc90dc902c16b7739e3ae67cf4fe869481e40bdbcb90ec17ea7e544b3736c213aa6c0c32060d512d9f6b4bf09d189e3492443ce65d52024fedaee3fdadfefb1b1cd831689467088640a7e0c171ec30565622c26e275eb64d54001537d4c396fb7899b6a4eff7d52172248b84d494f4b89102471b888b8bc91b86522dccbcec3dd6750161233a194f0af25f9ff71f33f648530b88c594fdc6f3326573ee4c71abf3f33e13232209b1c6d5871fd4146ad327ad9ed79c7794dff06c33a52e002ca0d474a0e33071c92ab15d5f2325cfd580baa2366ef7feb317300039bc48d3bce57f9870ef2063b918b3e88a48060a179285331d4960544c31213c774ab3428a0da601043c9d60c21280be14a9d72114d5333ad325dee61383093fc1d6976436cfefe8d7e09ee7d87a2ce048b652e06302e627788ea89edcd4eb102057ddc9b780f12dd0eb8ddf03c1094c6f4e27bc8be19a3b1a41d7af72a015136c93c972d1a3c8f86431841f40a80e92cccd54f22492653d05966682b9afe6a4f6227288ad899004aea017d9a23001993a2d457cb4fc3a5eb797750aa87a7b63dc586790f5148177f3b95272b8d9ef5c8b8480ff1a468b7f8860c8904e067f5b399fdc49de2074b2b01b03571eaabd5c976ddebba66f4941e5bc3194e7a961248463ba6253f8f1805a25e602ac83202526fb7110807d49869a686cb323b57d08ab3df3314a72370173d2e0c33f71c71245ec68d100ff52960ba0c63b05d3ac29abdb5b3887a799f8f778a8ee556bd27c2cccf56a23a01a193edb986c61361347996f1d4a056c021487e9f3855ee7ec75e07273eee99caf3385af232a241382ba37cef2d8539132e105c2cdbebf459affd96368b5bbac2f92cb478b68632dccffd3ecbeeafe29afde6eb75e7e76bf463477e18c46039c70883c71f3a7eda9f79ede7639934a8b2e887e3ef245abda12a629e2c23269955eee060319752099e5253663f6f9a704695b879c4c180ec5df97ce122c03fec5356353be30845defc60020ca83e85610ac8bfb14b0f4654278110e3daf557a0d4662c56211b02809f08b138b9a60fc0b436a3a7cb2bb18f2004ca4cfaf7a548ff033a83cc4ee76ad085f6287a5eb329db4afff95a8a81fe1c89ceb1f3bb9c564a1c0529aab0070bd508ccea6dcfe4f89f7f8ecdbb656a27362d84b5f39c926b8444349384b2239347aeee7196cd85794a1fd957b2920c35c0d8d4e1f98186ed15d92074c741470345c39996c0af78e164d8d3948c6ba4dd6c689b5b4587a6172e905b7cf618bbe0e7c97aa52ffaee31d20ebdc49928a0ce95fc863084b3a8671632a60d3b3eda1ac05d874b31ea630358b4389959d10f1200c55be729bed0d16c9fddcb86b9dd610386ae0f5851e14698f333e764aaa0394b94f1f4c0c3338599baa283a1c34d757ef61bbf2fc825b25c9c4985cf5c659dfd113fe3ec0a02454cb974df37e8f9769b2c0b6d96fd29bc8d1ae10cef6a8860af58fea78bfd646bc8b39392eb0661c6aa38337f0545ac4367d0f382d4f242d5fd5f585e1f9d6f4b01020b38900d3b3c1401f690d7b1cf5e1500c985842898395df40a7e327890f6c161a3df84f4d8a6c0137ccd789863adc811c6055124cfcf4f5f10d591c58119ecada65721a57edd4de4d217642c8357a6e6a78aa3b7168847d057b84965f1d8a878b874ba49ee324566e400a05a15d4f14aff133eefea46d9e5ece84bd9da496eb43a5bece92b67e81107d39647e5d4296550fdb2bc5042e0103763101c0a96c66c83b425aa2f7f37740d61f774460e8228b82156120e5e94472f7a1157cec0956ce2a6f6b64843cbea586650f5ea8ff2ef815cc5e7c1ad7521c0cf93fa0557b785347280118556b69957dc9c1cd0504448845cb9307f4f2ae5579f2eb79f6d9f8e7db3b26fc31735abe85bcd856f1ab49e31563a5e2759f62a5ac28525da491622946e97b1702b155ebc24e651c24063b4b66daba17b0b9375ab20856ab7dfccfbf551915ac5c2b6eb801308a5f1991c246cd3e105ad90c69d9f04c6788d59c7611457bca5e2e6909fb7c1d00c2da773d9a0c9e2a9f636f09078871a0ee5db6ce285989306f93f556b9610a08bb04a6a0406b7f553086d1560f14563720b8c6e89a3b89eaace2eaba71e9fd151b2e28cab5effc2864aea4da3c1a23004d6c6beb31fac51956855098bd0fdc98069e6a38681992174748b8cce8cfe60106644972927af1e657dc3c80d6fac6770a1fdaddb65a33532a9bd155aaea227e40a71f9d3d3cc535928a2cfcaf2505b339048005cdf16eb4626dffce7a6af67520f3a16b75c9a68508b3d583e00dd99776c6ff150365bed62dcdb43d09d14560602429d67c8dbb626e459d9a027dff6f4570f7b24c353d7b31bedf160d0951c6b016a7ecf24d0954ab24bb2034a0b1dce386b94c0d6ff080220623a639abd66d491e49a5f219c28b2e5b9c13ec391751d30aa70e2b96737239368e8fcb0d4787f7c52f7f7c058d53401566551f8d2159a3bfba5b887486f81d9d419e69035c97f5b6313d8a83849d08f9fb8667cfbd860c4a841e5103f640317230ef24dec127d392f1aa76a7dd1c9038924320acf08d37264e8380ac94888136658761efaca9d498baa79eaee73ae799b047890433ee7362388241c42ecb947dce01115b3f5b1d5a38539330a32b7f92a1eb29de10774f6e095988f9badc274c3ae583228471794a15ce57e86802b45df0616083a99e79928a81b24acbc6898ea37d4554c368826ad837382ef2a03be0ee5ace45c9eab81b4496a0c073ec140db06354839db4cc83232b81d35c370a2d89411409a099a3a6def8ab2b23a43e5b949927e76428082c7f13c2373922a483d0299c876d28151a23596b91ea64c5228b44d08cc5fe584917d6a88289225e82a18bbdb90b5c2f78490098f685f9f6c5806c636c1d54f77f06009afc413b92c9a81b1ebdc793359e74fc26a4b6e5167915315e9f7ebca08918bca30ca52d5812ce7bb6a2b352173fd9217e56fd261035bddd3e1fbe0a93fa29fa78756c1daadfb20e5d9daecdee67ac02e4ccfe6f0d2235022cb550e482c28bdf8e4cfe940e6bfd112e038559c305a162357f61327965b6d6ab7426a4fecb7bf17fbd8dfb706df71166874196facd289efafcd20131307d76ec2dd1296ad62f5500b9b57c2a8203d962ef65f4d6c5c53136c0cacd4b3eee72f4dd8277ee146dac222a11bdef2c07698f702b06226b30fb81a69210b41ed782eae4d2eece36e65dababc6b8a7b9c11be40d03e60371da9f6b699e8bcd699febd2fede4ae5ff8edbe5190c343245637e0b5cdde2d1c8a28e3f93f7a961bee088f10c0fda1b33a900d3a5a398f138e8850295287809480ad3090d40c940d3bb14cb08a794e7619b9f9eded438c2d0da1cc7135f95ca36a8b2098ba677bd983cc5e91f772b49c7e45d2fdeb4e8e951dfd5ee1372c5f4593cfb01c65bf74616edc20290bb9995196aea9b468420b2813e71f89cf96ded6761049c3c925618fc909e939b80f6d761c58a70cd858831a8fdc4f1b6a2b708c697e78b6376fb78e1001e431ae15330927035e51d9dc6bd94d8e8db4f8c9d5234cfde27c959cfa64bba1b4c0a3306305b4c00f1ac46b3387009c62cabf007116342a5b0548dfaa44b6135cb585e950d69e265ae821c6ad7c12b1d3dd73c4c461490e1ef000318d6c4c4789fc764279684275f4e0091aae003fd7e7985175d2c8f5286ab15cfdc34a894310fb505a732f2bf420d909011099e87732d95bf6ca933bd54022d4eeacaaf9354833d63848da0e60238e65d053dcdb424d30bf953e5bf1e77a542e8c71a3f93031d1c23014461b36340e619b4e825fcd1b36bd83c3828f785247cba3ffff48164a6989ab4004ad3a5f3f6a341057384ffe67950680daf665db8eae3def2e18b19993dcd68ceb5848857d3835fde89cc2caecf8a9e05a3e0a03573e4cb62d60fb72fbcf1320d92890e884d47c19a8ed62ed435623a4359634ff411eae480b57859560205c9a6a1cbe875774a7de9917f78f32aa7f11157a0d7166b9b14586597cca5d4c511d5f5606b620a19030377f2912d446aa0fb864c398e810dd3877fa2c1bd53c7022f78c93841635a22523fb9897d92ca81f88383baf03e2f9be3a9a1a1c08467eb841bddf96a0f81cefaf952171ddf6fe414f21723dd207a1d3b915389ce411f3649edf5fe5ad0fb073e59d8a2d3cbc28780544edbaa843a98b41e1b5ccc903fdae6a89e98842e00f3924591563275eb541e3dda95399507c1787f466ad43987c5ed93f2e694578906d7d814f9349df38c5f859a4a19ac3d56182d6665820173964f38f9fbdedad348596df5fd23777422474d385414f8c4a6896351842efcaa52412973cd37bcdf0e5a38139b40c96aad2969d2b2449af7d509a91b534156c64d916acb7a9b8a316c87b1ed66f6fa554931a1295b910dc7bab8094e28395144bf72b513564d7178d9170f275399d2b8489eba4b033d350e67735146942881cbe195536336d7607264da5a39183d4fea545362ce610348720449bc497fc01cdba4a92ef05a1599f737f38d170101a805ecb76bebdcec6e3a810d0753467480ca22321a197fa684f3cc633460a6a819da6252bae92f6fb0682417c6c9e29f37fed847f1c36a26703bab1ef35860d4fe24d1b540793fbd0d2bdcb3b43bd4b5bff3ed89b3cdfa185f33b6390898ca6c00180906d13921b057e859e383bc2b12ae4bb6b97689116749aa27fdb5f8ca163fea85ae8a078f736af6c840f42cecfb7660aa05d1c022d1d98c85554122ab9f829537b546f905dbbcbbac941949ba4e20ece9c42ee3f4459147300e04cfe78c30ac866e6c06929fa6a5050c15104e8fc655b6d62f8c4281b5ef8360cb0284541c52d1d8200880eda57eb5011c5715fa908bd62eebf3dfdb91c9d00de5c3dbdcd041f0838140610d5bd093d35a98ec32dd60896b23808d9eee57a1e8e5fa2ea96212df763d38e24cc1ddbef20f8571702ea42605802b35f8ffe74473361f8ac9b9fe20890e904b13c523f1171b4620f5a99d5afd58d05d23734bfd0aad2fdc795d7a5283d149e19109158d4529b4b30b0ae44d56ec6c446e9547e9739eed74af8afc9530867636cdf8785055f915bd55041329b40bd6373e4f838d8f5db378d1e9bf06dc79e94c4e09a0cd4457135b5778f543aaf96eddeb471e51bef8c5848a54e395ad921387b174ceb68c45e2e2125577b824c7c6b32953fed87ce1806c6502a5f6f63bd8b184555de78ceef6dd7ab8d686a2c35e5f4d26f24b29f796f071a53ab273337c9f183c4b48d1a9cef693fb3c633f3650398feb4f63d5e67733392a760dd6efc6bbb30133a777a17fca95e6b9e144bb5d8c964f40a02eda773bed76547070725a44dc8646899d10b25920335925fa456688782de9b9a27c69edd20468dd49ae0682cbf11e1edae6c47461f0a0eabc2a5d5fbb31d9ebea3474d48bee6c29fbb7879610dba48f5c2628f34d59c73b23d1073e10f5623b06ed136d1b4e59bf9d406750d538153284a9736e5b1298ae043c3f1906dca0f4bc169412585397f30d2281a8feee0af4f1e1ab6ff1c50c8dfbe74aaf76299bc63380d21b4b577fbfcbf3478231227083f15d030b578d4d753e2dc7dbd9b00799325510d9582960e458f322492fba91b6233e9c1ba8f60cee3bec997c07e51a4628d9fa1c8d0d212dc07d8e21769a0a645717610294e29e45d59be3a9aa5a6bd29c72f12feb9766d4502a07db32b8c7bfa6f5e48da2e634426783487ab2d1a8e62e0e2ed86b82475e4630d296ee3613b1719408196f38da5c9102b92b82074d6b9526da4a513eaadd93289deddc0f763a0a2ae19dc2180769369949c66b85f767792e1745c6589b15ba47872b43751b8bbe77e15ba0152d4875a13a470df2e188101847591372a59e5eb0a8953bcbbdbb2c39ac030e2a899bc658b0ede95a47c426f716b1aa8ef6798c122b8d0c03064766b8898f106fa2dede63bee1b4861ab3ec916bd3a5f0b30ee8dc86c850e97f8174094fe4ed8e98f24f7bd30f758179de3d9998f3c8377d404599a50d9c2c3322e43c99252ead033a41a6d0527d242fb48bd54322f9a590a8df2957730e109f55d22b41cc99d23d59f3398cbd20a2fe64c10f072ab6060d63abaea468309b51804627ab5ffb147990f48ac4d57a811637c823be33bc98f1397565bae9e4d0f2ce04bc1143afaa13024713d5c324849488ae65952215ea8c573cc0f82183a0f4dd8b9cdaf9e557e3d052c234f3711ee2388bfd4aedc33eddf6f960eee10c8cfa8a6b2cf0b2114f03c435890f53e4ef4f41aa40d9045d82374f91b86dd06d76e87b9d48dad8b24167fe7358988682b0c5661f0b0c4b368d005071ea030be7241100b8eb2e96efbc99a13fa7d367aeba87a8631123e46cf29fa5eead65d182f176afd60593320b7a07dab05869ffa26d526e8170073d3f11ada16b1710392f315bc19fa62873853a9ffab5cb5c180ec01e2fcca2549a581598e2629bc923fd2763b6b68c6f33bcb87168ce37159c9eb34d5cdbbe6b4b426dd70d93da596f8cacd04928383a42503d596aba36dbeec0c5f27341c0774fa0903104d7b40f5f0ed698fb9fa730d91f55b5c554d1f70085bf0baf57c08891d4623c41a223d3e5906420b8f9eb106230fc8dfbcd7ef61209dbe033643af8bb376c66d734521fdf6196634e7ad9f22991b7ae7e26dcb08246a24689e7516487fe0680be823993fdbd6a35898e6dd4ca462a924afca959c134df7380db754663c027bbd074bbe1ee6ce00b814cfa7e915e09bf90859ba5baec8574717bd7e5601f5c54b1583723a6c04b4edae5e12982b8480475bfbc1aeb2f9723724864ac52c2a2a74d83ac591868b876e6ec4913d41d3bacc38de24538ae751fff403cc5680d6f6def26e6bbbb385f2416a522cf4c538d010c5a321351096d484d8e963d47b2e1894f4add027737e085a3263762752f6cf899c80cf60808b9bf297bfcf05661ec84c474033b8fe9af4edc8d45341ec5b717ec40679d0e2c5ff7b75024e48767585529dc009426eb835e572f444af5b967f08654973e2d9ef30cdc91c2127b2a040ccb39d1ccb928fcc7cb9e05c278e35ef9f55aa5074f839e14fc11a2687d88280f0a926efdb9bf6cff213ae88c17170a8bcf59d3892daeb85736cf18fa4b1b045b84f051b25f725c126bd1fcc3309fe5c84accab8dac10391eeddc2e7a75bb71590e7acc7024cd2f9c0d5e884cc404096ddef8d56cfb4cec18feca1e6f4703ed9fb2a7803d5615547beba7dd622dc316193f32b0c4e4eeec67c9c1e9f9659404eef6c98261e9fc73a1a84574d77fbbf849a8b8382d1c8456681b9071016119b24a6fed8a0983a132772582e4abb5c4ddb0b8ba071318c4608473ae0dcb2553413b45a2b5f74442841cbc7cfeeb9487587361e5645b6c20720a055e285efcca9659cfd07f3aa92ef9d2f96c3e12d64d531330e44312654a1c998a31fea68666df9c5d28d7abf14686f9b26b2162a68e30a0ae52b3d4b8a6480a8d4f1e4f4bda1507e3b61b4a5ddc35f0873b658ce1c7285c3ff8287365fd12b940a021498bdec5f69273dca2ccc45afb515b4a3e161a4eca59970e55453cb8087997d89e076dd759605d98bf453f59358103beeb79e3543fc426d77b2ca0f6f48d652cdc2e7f88b978688ca1e646afa2bd5e50682fe70f44c25a0b998a5443e6604fc16f19a8f8c24ebd4c2a0207e911f4ecb61613c06fbdb295a83474756cb77e1e790e7722cc337f3522813a1096e1bbbd43e8b1750ab0ddecde2edf58ae17bb7fe177c30992366820debcb59731c99adf94694c1a97f7bef97683563a7145481ad48041d26e3c56847a966a2bf79790dd332581b3f21acdc38ab85920e5dbc3273a8eff3984cdc3e9e06ee60091ed877204ae087927e8f2201f65ff3185e6ff4d393deb17ae9deae1d815153a7d7d1f31d882453f38cdf940f6f547b1c6278d9b2f41227b67004d7d85819a7591535a006aec52469c6325ec16383e6a21016b45df8dceea14f9959d44a15760c30281c703388fcd92a6b0b05cb9479ef00b2dad5fba870826b23f4ec063291309a53fcd7234f5f1dd835c476d9c5e94a07ce283cc0f473a5f165af0af939981bf72e19156b5aeb2066473236d71d4c3181eb319a6223ba97010519f0c000804bd4c003d6f001ded78bf66ff2d65a8719c19db86cc9358a1a14b571defb546fdce05816eef3b0c565af4a0a3905a173e89afb66a932288a2a0479a24b188ac0b17be4b80bfda01b7b49e6172a36ad13a8f37c7a5b5798980ea897ae467f7cd7cc79d273a36264a098362ba6286a824aac5371080de01e1ae13a68f9c7de317b74e0a9f3e5b87c4a44d36f9bac5ffdd8d1dd9317896b4809dd5b45937687e0eb3ed468c180e8486b4101d3831646bff9a1e103b6a1f5ae225c929fa2cf7ae90ea45aa82679db8f6e3a08d9f2643f18d806ebb787d486cec54bf4a0b68f6d8d6427335588597fa05fea80f0ac58af048f785cfd17022bb4f06ad00ad61b2e09b79997001ddea63296b2c874d78145ae59ee411ebe04fb554b3e621c759f5ca6567b5d40a3b121117a36fe1d2369066f47780591ec8fe18f7620739b55128fba4b00043a3cc617f20a8b844e42ca5072e65c567c45df41b681b93d4e69475a399f6ba9b3b98c6923281cd69188d072b5c88e53d586de4ca79eaddfaa1dde08914b699638718e87491b3716bb488a6092f1a1cd1921bcd81d81c93cf79a0254283e352075e5d4a9df1de8724159d0a545edf135a88ba5df28145322db2d5462f89321e2c4a47bccbafa7eefbb6b21cc236b20e6365783b6d49687318070df946572bf620541c84a36371a06a1838ee70bd6095661ebfabe611e6e2c8ff5ae809a409715efc0042e68ab13c185615f8613628104fdcd651b868b00ba1ca6244b925f4e984530858218d349255198c6217e3faa9b5302924c1a052b48172ab4c3b1d871dc398d50db15ff7f94d20e875a23dfe20c28715009c312321af70d6d61ecd59ce4af343b9583e64aac8b84ad73b28ff79cc953bea719731702b7d4d6f42f4a3e64755517cd13a3d02a21777d111492432540d1671db293b46387b2b203779e45077e7194f96adb7e509fcbda6eb9f8af96622cab393d6a976625242b5b6896f0f9da031dff40be3d2806ae517e3ba93c402b0c910dfa0ea4a20b8cc75fb4664c1870b68f0b1f2c679517decf019aa06ae8c1d35b057cf714ddcf41f82346130f97a0c319fe5a18c5122d329b550d1041c86f1b1307d370c2ffe03bca569e6bc2227c1bc4f5567df85114defe13921ecb5423d98e3a0ccc0981e5186bf04411fae47a5978ac94018ad091e90c9a1d4f0ac5e80e6000960bc4830647c75bd86e4fea738e4c074d967856fdc232ce4fba197c0290fcaf923a05ac07fb60d77ffc6b9cd5f23b2ea24f71ae4a9dce14a1f442f9047f054dcfd3508907d7a0f77b298c93dcd9b7b16df4eeb361913bc8e6d73765617825a168627a737dfe8d5af4045e03325c54e1f9b73da7bf342579d9167c52abf0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
