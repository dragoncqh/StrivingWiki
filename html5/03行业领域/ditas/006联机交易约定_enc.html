<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57723e4fc4f90c90a82b1e3d9f8a8617f3bbe270ce3d3024bb6414eea5efeb14e6450a9a17c9c241a2d90bee8b5cbfc2f8b2cdf377680b16951aabaf25fadd61501d758a6536c86efcb3f63ac8ec3312c16279590d6939068f7ae4ae2c7105105b0b771accf95feb84f2df50242a7326af7379737506a7d3558deae4d2fae9b3136d24884fb68d8d1edfd859ed0afbc034207e6ada651e17d1593b48a087cfdef57cfbbe424619e2575184ce2116ea7dcf4af760e5f18213f34a9b0f99f69fc56196573e22131d6915b521fb8c0231fc0efd1ad3b5f31c2223d21da672c0e3312ca8e84bd0d873c029f7c8e532a7df3453ce2cd4807fc7fa391b547b40fbe04913dd8996008960aa079df0c83adf0bbb4c2ac6f7e203197d08e2c09eca018fae7f15c7f33d0b9f4bc2f4c496dc227afca03ac9cf3669d337f7ec474a63229b6bd2dd0c32adfd7557f17a36e453359cf81e9ea70ceae7651ff77efe7a4b3add65adeb155ef0371342e985b023cca560e16fa8b456f0307ba895cf6817b8f16e8baa3b96d7d0144c2da71fba8792e3496d24176cc432212b89215a8ee80dc83d47af137aba11fae258277386b03234bea666837d25005f51bfa6e7755d9657badcc2aeb45e8dd756906309a412a8e961b21fa003c42f43cfa207e52b26f88922f5dee31c489f04bc9e6800035d2fdaeb5a44a647928ed9add33207e66c4cf9e58e0d2f110f1df310300380d29d2e555f181a97fc707dba9ef67fa3c90bec9975d6a2aec64f50061a8c81a2afb8ecc80da0914bcb4b462ff0514a05122877c9130410b694f498714879d6f514d3e2e020c0fec9a1bf273af13b05a504ff9495060a73ebe4a8104014c59b32e5e521386cbfe0e71df006bf241f47ff36694710c2257bb2c7c809cbc1b3e59d5745dbfe10151f4517ee0730a76a4d9af74de4ff701c43770d05e30dc7dcc156e60a85f1380d6724223b20f2c47f4681e91e9bbcebc42d2cc852002623a4bbcdc94d0ed24835063df9c36337230fc106ee333fbcb3b8622d40367b4af4e1b1255106da7de585e96b9257d778e4253b61ff4b9b08f379fcd56f94fef152ea3729feffe3b96829c47291f113a4a09dd976bfdff3505dbac25fc14d4729ace7b4fc8951eaad8a9b7d77a8c876cba8ef2f04893480a4d9b8345b95ffbd785956e3b24cc63d10e05c684302ec722e62c10c74fbac1b6818e78c487614519f3f7b9a36af192c44e4e7edf6c075f38510dcb7dcd12d7b1f843037ccbe9f0e8295b64beb700bb6a5120a307470085a77c9c93a690b3e308e67705476aadc55fcbd6a3acfdbc49f04bbcbf265b441180842b5300e7d31efdfddea6c5e89accf0278f0cca420104fe6b3f753b6c77f37fbcb403bbd3d597539cc98cc6b0e70b11e14be9356f83d0e115f9309d2176368f2c96346db3d3bbf579e9f334b9d34b23f213cdbb4a5d69a7477cb00c0b9d1c19f2167d1074ab380de073c913a81f23d188770ff538cadbd9ae85546b25e869a3a9999c1ff56222197406ec5cf30a7586d3756a14f80965827e4298e243b6eb149188cac8318b1536dc88bb79b141d98f12357edc33483e2dc953f929cff046236ed3b48455875dd08a68e8b54e5ef4c9f8649a20326b8b4cdf281454a5c1512582336c9773db43cbeddc5875995e1fb7214771d151586e0e853670ac14939e4080f68afb73c8afac966bb49ccb0d947c5a109f27dfa0f0426903b4e67cf5642fb25fd89eeabb4d090c83928758e82a28d20e9525c472a324e934d29be37ac5665688df2c5dbe8a686369ad0c60aed6ca9602d1982d2b9d718d3f035e3866532543827f20f361773ea8fd44ce2561e55004698f66698abc2821261d0eb38c3c6556080c3524ab6748301ab48bb7c2f7aaa266a8c42c21bd8d2793bb5f31961108e3f38afd0e3b5db55c9c6df9bd0248f868307bf6987a576a74633dc0820729219dac8cc58b4af4c290f30c42c280e7c10dfc4f27c2319e4d643e6fde5ab416d005789b4e087c3811703e253d648e732a16392ffa78b6d59e19a1780fa756d4d70f1aaf8fc232df1985d627e3fd34ab708a7616f17ab0fe598a3e46e7d73d64854817078f01b4c22721038a3e03c1a907f3a04ca7876a57b74af56ab71d255e517f07738f15ca4c262680c6344006ba724ec5ea4f65c83ddec8902f715a3c05cb8a268239f571b7e54fc29eee682fdc6b9da8acb53176c503cbd9728b718606877ee3bce4f94b465afdfe5d56ccabb362d4593c330893f973b452142aa3ed07cf6d2944e80a052a4576a0ebdc29454dedfb0fd33103d1c287d70f31b4917fdd91c43b9e4c7afe696ee1fc9d62b62e3913611d8af484df5ed879e44d25a04f0ebbfec44b2ae0be084a54fbe54c004d5db666003ed16ed52b141aeea51dacf591a43fe1ea775480e5aa7cfde0d08d12e0e4a0668abfa0d50e3cb6d994dce67752bbbec65eeec6a8069645d71f133088b3e0c32538fa6aba868962fd613a9d02ac50232b4529981c310762447c91ac9d9083213fa9dd4fdc7afac585c8262c87fb90551fed7e1199abcb31448cf21a16c6f1dadf1c0f0503ef02252d3193f261853dc2bbcebf6cdeafbee67c94f41325d115d28ac82da7eb9e05f90558eb1078b74e8523078ed2a218c75871ea2a8b9de3dd821ec953f7e91359fc0cd51c17ce02a2b65e1b6d0dc94a29b7678ce9491228a7302b0991ffc3e1d05ea4714a078870961e166f1db5648e2df8d1dce33a2facfceca8108b1fb69f012eafb29b7396ae6b25c9caa04109d6ebd8fa12c8a16f7975b706add8f471bd4dd3367360d0114627e48f53fe14e1f6cdbf2710dc55eccbf39b88002749cd99561028124c155163257b89cfc2f280dec33335fe791287a0c2719a17fbdab4a6ac67e5fbd729dee4bb84a9426f39a670268f7c7cd364ff1f4e4668fdb7275308ef0a5b4e2b06aeede67aacc543805869f7223fe1ecbf1fc605909664ee9b6c8bfa84f82913714cc6c4b7d9ffcdc70adbce11fbb678ee6fb81b77bee9202b8b93ad963634f932094425431540550040a4a266605ae424c00988acf6924ef85eb72cce8ea1d8c287f452b634271a1f7d1836b56fffa74f28e011b2eda958fa563728d1cace0d3befb436260ce1b5261f0a016d381ca33dfe7864fca68d83edc62de2ed6bd2c66bd6209629a7d4e6364bc8a51510019bff865ebb991da1c614df44ae9b24067e806e19ca8ba4b18db5065e7dafb33debc05acf1379590c8c837917834015d25abc0fe3b4d04118d501ca07180745cad9b34d9bf7d47ac58a1b1e6b154d6c1bf1fcb440199de5fe0a9767a23e9d77c6e211e09c77b0df6500db9ab952a11f7f047b658c34cbfd643e9b56370cc366e0b4557784d969a233b47e2b20dae56fc142096645ec0b96613d1394aba583913d6bf48f16e74f93cb5e2ac481aee6dc30e8407983d4dc74aac09ff5e336e89259837c2d858527b85dcb1ed15672a23805fce5f9dc31e7b42dd538dc0fa1ff5aef2cb35a6d24be4e1e6c9af9391096450a683692d3e62669a2b4a4ca391543fa1aefb850a5a6f3d1254f7682931cb32529dac311d77cb07d0bef5b2cd7c3a3d510c303fde1bae1babe75f0287f6932313b9ca17f1660514ab358a4b5eefa0be2269dbcdca135d355c700f0724de8aea449ae763526ca565e0c56aa1d18a3b793e1654a7f608d92e9a248d35963c8abb24c0cd90554fdb9d514eae27d399c1e1141ba42f117af2b48416781f434f9d7e386a08c0bf5fbe4a6fd7d28b6d29905edf5f06880d7167bf3ac13598ef8967bfb809a62694bcd0af2e0e0c97ddc9321ab14b6bbb3bcc57dd81a99e7fef7d486ba103598434a9e37cb4ce3789977d8cab81cee66588de44163c62781198a2fce1eee20c8b8029b5b62c378b57af248267e5da545b9f019257f5d98fe52cc1c02b0394c5d3e28be7b3d4f1a006eeb61a082fda6cb1ceaabf65e851320c8c6d10dcb4771341bf33e01e0386eef18196e6fdf7e9764811c133ae597997ed478b33464e8bfbd73f85034367c4a9cdd45740685a3ccf05f5058f023c3d11e7038e8c0c7656f5913e7410170cf2b56ad7d29b9f5eaa6e95df249a651ac9eacd1526355549ab7dd24b0f811beb3ee559018814655a1db19354939fc76715d6be2821cf5d8c040c0ad1c70c44da094d9ba70950da6810dc87b65955391b7e89b9f6550c42b6ca25c23dcd242428b026c14eb73d47bfb6d42abc8ba98ff88f94839901e56fbfa27164d56ca240125e0cf6fe43e439625e39bf7b9e6202b2d8df78f024dfc2a578ac3567662f43c612aab62632cc255019a88de5213eddfcc6d374242ea8674dec358d1962b46f904c5afb3de2420e5c2dd71c41134c95c02a4fde79f0528473dbdf3aa5909aef4f8b32824cecff1069a617a1c42db0ccc94469682e4d5840af021d541061b95f7dfb96cd7d32142b7cb233a49e5e740b6f50eb553edbceaa1e104cf77b59777d3cef665cdda0e03f799a50081cacc145cfd5fd5b0c2ad453748c8f87c31149966fbce0a5b3623b969385d84031c5009d3d4b093e19d4a9fb727b090239ab15acf2b85630e46f490c0b961a569a7f27cc26c90c19ec261fc138838e13edbc48551c1d8873f2008080006977aea7144f2398983d2dce78abdeaeaaeb9bad258ae9914fabd06bc0642d9ad39caf2005f14dafe31a9114c20239fb28e04bbe9f9e3fe4995d5a8a7fcae72a8313e931484bdcf18cf00b443365676171b23a448b4bf9c0893aa286771db21be2c74165389fa557ea701ba6270d1444812a723ee6e0a8e51e7c11abc85febec61d9bb6ecd00d7561f48db169a04e083a0a21cbc21665628decd89a731b34d4f7140631d3ad95ed94e92c55ea7aafe132c82a61728796d1ce24e06cbf07f7325d28212b83607ca25f409e278b237e9938a08b2d6a90eceb465e7bb2cfbbfad3c7c0c36854e8e0d68db9f31331089e44bb0fe8d5206fd21bc6144e4d77986851e1df6bf584d9a6b968b5953b99ddd0fa519edf132c1889e939ac8e0f5ed8c86019178eef95b5f6e36bdf2c2ffff29f743aca7111bcff56600dc098413357e036bd590434667464a4aff318aa2bd24c08483b2c04dfde9e4e791f89a358a8ee70a983b847bf341f8c5493330f12d2c9cfbcbf1f372e843e8acf3847370fafb27725667abaf0a3956b866293d4f5ac92f4d30703ff5493f0b71cab44e4caa644bb8a63373ba5d40ad9fb87d283ff38594a0f319ac578cc28a6a2fd27a905d260502d89659d7f0b34809d91e119f62f7e5fc9d190e2447ac7ea850462dc8f470eaac6266eed9c8415368daffbeaaf7461f4cee3791cbb8c738e3af3b5782bf2a80556160d731e766c69913309e6fe90bddd2bbadb4bb5ca98ae725abc6e3c80cbb0732decc9dfd42cffa8856291861b76a30dc7c81eb3214a5e99951908625da4f0400ccf2f76688300836b694ad8c25a448088f71253457de592db3d20b9252dd8992ec01cbdc2613410031323e0f373d375cb0146eaf3fc580eb487af64fcc5fc69c094ffb0a922efec7e1270c376ab0725433f408afbde562c84fac96dabc26e078463deac501148423ba1349b32f0bd5ef52891a55e19d4fe112ed8968aaf6f7ccd4ec0964b58afb83970b4942efc80cc14000dfb780ed391b7572fe6ffda8ed21b0d058714b821d8ff304e29bb3c7133383bd89f89eecb39a336df60c0df616f2027a1761da2ea920a15a3be85c0b0ac4f12733bc86ad0b318d017ca5e17cb7ee615c61a356abe486a5602dfc15daab5677ee54ee0184880e6332e9b42de7f77dfe59ddb1fc4fc6022ed53be34396155e5e57b0aeaf085072cbe08fcafdd68fb340aa5fcab57a6c1aabc1c1c49a613d9969866d610a768894bee74f27d970cd9168a4b85626a1067e1295dc87aebc59549b37df8e07323369dfeadfbb41b58130a97c686ac7bd2902b1eda83625ec035a547a3345d4eae952acdcf30e113bc80fe242714ea7bbd6e7e5a0c3b1bbcd18acbb703c4e12e9fd1c09b124b88aedb96a74f94f9e9cbf92b61603adc8cddbb4c222591cfaaa305ba2f6e2a3d2cec373b591015daa72d019c52377369e86bcdecc24f6b35ae381a19b137cee5ab9004dafda5c7568201bfa2e0b63871f821bcaee5a8f2ab6228df736532aade3361b493c2e366e3c651f99da8bd4997199b5715dc286bfcc72984c7a9447cca1f32c3c33e30f27a22a778bd455f3cb87a954a1215f22feb4bb1d87384f4f063d7a44b7b37695b077056cce111699ec7baa1646bd768ac6ac4c54ed6376241faea088225233b163c8b3cdfabba78aec4d86a30d5b954e534dbaba0174d26ce51a652edd573fd978d745f1d4b3f1b819cce74939d51ae4968cd06cefd557ee082e90da1be077ddaef17a623e09185a54285ab70ff4efa1edaa88f5c3b516f677a76b4e598bf194d208bddb57d52a870ccbc337e1e2bd912033036c275909ab43d1cef9b622b52053fac282951fffc360b1205e53104cbabf5cd36b01438ede8ca6d40e1211d0eb6ac13358a71994456424857b983f90dbb6e8f5cf31bca039f6ebbf2bd87db599a8b5adec9f8d57ddf755d59bcb02f2ee7fca9323891d4f78e8971b0fe842ae143a03035f81381241c858bc0cba610d8e2f0d4bf260c5301d60c08b49a01e25028aea69a5834aa677a04362beeeea35a3fe4d774c1058e8afe5d222fddaeaa7be074c33924ff9101e0538d2b67fb0e6515e51b754174d3a6189c99c7c42cdcc0015814338bcb2fa5c0464e706912a79ebfc2b5b168168a27d51f2338a9b0939950195ab339403c4f27cb4a7c8baa433ed669a8fd3c77909a43dff874a9faf96bfede1f91c2ab2b7c5a81dfc61eb6f58819728aca757b206ad7d585fc99b2883af93811d7429ec6aa5c7099a9af436f0b501a186a9d60008e423d6c7292cd2ede2e6df75a54b079675beb2d37b1f96721ecd767298aec1fa11ca1cecfa787d5bea4cbb17e96f7abeb4bd87fcfcefa805481bc8720ae5e762eb637e00293ea849f8192b0d1ee8ee554e8653b7d76a571710f503a39138977700098fb371ceed0f552c4f1b84b97c25ad71576a3740af91467f5ca9e0e7424731da8f475dd1e1c2bafa4047f1ebf5d4e7cae107ded18442fffde203fd762cfa536213832fefddb6f0487f527b6376ea8c31f6da28affe7e7a01939cec313a80aad37d0ed11b1efb57a54f5e048ca88725c7374fce207debd0a559d39647965ce9860b9cbde50734093246f681b4853cfe63a81ac4d8f3629e04711bcd7199750ea48640558df4bfdc3913af857ff5abddbba69ca8b1908a72c3b51a221a1d575e3b39ea92539a65ff712bc158f6c9588ddf57170b35cab794eec0ed76193423741131959b8eaf27b8f2ff42f2af8d2fd5c3663d067c0a8d125dabeb1a818e738c0cb3cc7423b326f9fe24e83b1ef6287f02bcf06fc5266107ce6a64f1161ffabc4de32b4b5b42a1d96ca1374045943bfa9c25397d50303a682766ed10ad2c82aafbd1b60dbf65f70ebee3097f84bcdbf39bcd97930319eb4479d56c151f09facd454538cf6e9df56a07fcce15178cbb961ff4bf297b0486cbb75d8028b148034ae9ce7b95898a70104f044303c8194b55cd4e253fa365d465c8b2276bffb7e7076c6d930e2f5f24fe541941cbdcab02c208d7422df469d00dee3f9bc652d8a4c0d8f44ba332f2a766cbdc7fb19d5567ea7934720cd17a45c19000bf048ac1c95e756c8acbd62a9f7162fce0c46a942fea2130b672281c13756c44e6a2a105baca4df487a5caa8a8290c9f1bd645d3dd1a808dee16dee7c22fd5edb3b64a37b728a1bad5ccffb5ecc1d6b78b0e39c3db32b2cf577cac73b62ebe74464bdc6a5f0524307709583444c4c20e7bbec9b58f562864356af4d20488b34d8c487311070f03f166e6efd76f008eda8df2eb213e6ac277728a8c9270955cba9be094beadeb33b9ba0062a83e1ffe81b92158a4d7d988dc00a03e7e805b3a90b9ca074f14dea8c0132a8bda3cd79d4e0e1cef85f59047bee0535678ddb0235563f9b2b722121b6f0068e719256b0ec042ec6806254f5704778a548ae33a9e1f8c5e1c0285ef80dee6402d9eba7f2749f42514978355348968eedb7737c54b83745c84954d7d20028241a15e261b581933bc879a250ad905c9a0084aba9ef8b497b85195de7ee31ee178a6e1cf6c58f3ac9e8c5fd0e222c0941685fbb4411fa43146c825f8a53725cdb4934320fac1fab8142a3fa6742e2152093b3aeb937eaabfdbbcf8a4f85548427fc559b12bc64c66de69503bc2ee8daf9761e08e7341546a933e3844c133408b1688a851488a914109ee4ae3fe5ee03c955dd512b98076ca7c0e329f1575d5a7bbbf073bb7dbdc7b865087d5c10888d1b335c6a716fbfc8e04b90ad2500b0ed7fbea10be8f2c9da75187f6698c61df72095c01806b0b97cf55fde8f522b1f27998b9228891be15f2b3444b09c16de9f6d1edd93a531b210e1deb80c394305ccf80ad952d06986d9083f37171b81d5a20297628bfbddcd8acf1eed2e848750705507d1459a509a75bda3bf7815953815c61d0dde91cd1a3ca178bc2587d75adce7595413ce915c8b5bb3bb99d6daa6de740cee82d1677d33e61554288b523a7a4f0fff6d83d8bcf54af3ed1c4ddb2b47cecc6537f0e9ea5073802a4efa5e58dac53af4bf88aad0b727bf856a19b532bb5413adeecb8ea4d9cb2d979688202791a33614418a6f92412a6d13f056d7e219e2da6bb1c2a24feb879f04035c963e46b7c703d26a515150e9ce047fac9d6110368135aa31adaefaa98eb3e2c53fee8bc55161273d04c32ac9dba31c48708c777a38b0c5bef5804e4c159228f0272e338646f7342c1e48839eb6551d8ef40fc8a00cee021b104898730adec8aad1d3711528a380584361660e4e974417301182e412d26f925143f0e77a751c7f63de38eb1aa7aefafa6988af7638c64db27473d1df731d13bbaea1d0c527ba8590f5dce43635ec62fe28d6fc2d2b3726623712a9a7a737a1d3cfde41bd0f0512f9b7502b56d1a19d3b2f1de4c204bae913d672227ad5f266cdb9cb33217e312959710ac36ecaaf059b1535a967a85db556004f8a2337caf7488920aec983277477fc32e918064a78250c29670cfea09ec19182ab08f806405230cf977771aec8c8d1769bc2b1e036f2ba15425680073ad51111f9b4adacf3786cc66926d04b73a54e70b678706dbe423ef0d11d3224b859682be785d6bf739f3e34be130f5155a291e7b77eb5f7676e61f8c1d1c3fdc42e07f05ff42e4ba49244e0f6edad13656a701e4bfa4d1a3814c79fb67ca1b1dec6f90219c289a937f5d8c335af90275b18007a279e5828df5e98909b74c076970622d79e115f9343356f54ce9d7f27ce5cbe70ed075ca0567f1c706e90096397035ac210c80ff732a8640aa23ca66b0f7270ac2f16b8276b8c7378cda5788936035d75cab5dc30cf733348a6e649adac75d1f07bad1d7f3b5947ff5fd74275d44a37807105eff419b129a0be88768899af0f38cc84cefc52e31692660a4f570ca9fe4b1d143b15aacb7c8415648c1e7ca502cac43be91a608003b1cec876f3b0958e2858cb1e4b4e239a289f479973f1d8b658f60305a7b7d654042f524db5fff4fad03a5da2318d4b8ccafbcd697e271ebad8807db785d53f04b57915e71a76930aa2408e2a80e37c69bed7aa914336b4efd5097d0f58091d72f1f2105cb1f3fd54a4f431cc0476e68713399d9e8f5a7b7c00639ccb00c5d3a4cd45b8423406a20ea60f285a7b0298e842785de893c6cc318748ba75548eddc0e296c0f4e276b4a78a658e270dd7bbd830d8d1137281663ab3daf25485ced29e0745d1c8d059b6e77bccc6f67a418bfe843197c4e799c2206fb062d5979fd571940696c12759d3ffa6778d1ca84c9665676f0438cbc830b8e7359c8a10c1c756c9c950cca259c705e9c642690918a08354ce67f41a16bcc8404689101a94e1fe897883c4deadbed2cef168db2187013de3fa6af4a0b9f86170bbe061c6bc1f14bf3c7c8a8f95673c9e382a8d056046cde4057b6263d852fecf5a5186afc9757411b0a80bcb9cf9cad0f131453a9cfc8eab770e70f81ca9cda5e2825cf375ecd3eba94954165e89feefd538339320c710564795d03b88cb9c266761bd46e5c0db97d6e8c666e806baf573f62c7a93f56316faede8096cf38a121ad07dc9acc83fff6a32e917a87dcd82bf0033b7e89cbf850ea3bd50d5c2f35d355133f4141ab5bab9ecb3c145f33c0a36b0207195c3dd1d5254b587451832c4ef8ef33ef21fc02d9899c04cd190dc28210c4ecf0a5ee565965a16dd6fd176a09e5022f311816dd3e5bf241c523462ca5b85479903177ac447036ba045f3a243e7d23df9e8bdb539dcb224f2292b0ae1aa9de457875aaa7836bd6d3c398f45276052fe8e57f0acd40266669720bdefaa3f4fb0f33ba9b5a022d4ee26d1732410a54079d7e5b701eab9daaa74be620a8d513fea5b89008e01ff22a11099a93caae383fc307e3ae628cf1ca0b12ebd3622d2e95f5674a59105d12a7a4d5d94ac510cbda1292d8d00f18e27cfb73dffdaf083d59531c93143ad3396645370b9b73a32f09b217d91e0de7e8e70466fe5739edb763c339aeb52773eb0b259c1ea359d007c15998f06f4cabe25bf7be8cf21bfb1a2d07e64ff6ee86698ed56cd8550fab39e5d94efea506cf7f8f071407cbee08be533bf4a2a5ed4b78a561a9cc80c2e2ace11ba4b775925a513f58dc2ecdada9d17d231e7821bce92643377ffa92d8ef6af07211830388522f298dd214877a5e38414ff785175d67e2ebc76f7a269acce3c475c52d3846ba1bf536db0e56b7bb60b783a9544067c497ebd9bfd4755326db7d10c51babeaa337b564a8ccc9b3aa2cec379023bdf34fdf91a996e423962f2b322b89f790903e4369e8a4abcda24de6e7afc38c0c8d561d14fdd2f717bb029acc74818e71225fa879ee3eb67068e8a2641c14642c22e97ce23e1f8d817cbbd6f5db70bd342e78a18491abd1b2e972f52f8b7b7caf07ba13c7a61c1de371df365e34e1928c5791f8df1b319abfc901b0046514e6e9d89d8385ef83c6da87f9c0957b44d166704bca3c26ae4716cc99880fe22abf9676250bf7d2195bd0586d05f350c986184aa349e9d06b0aca1fbd6c30a5b41a083f7a53f88ffddd583b3a397bc64a5735ad76c6ff4b921897b14b9d595e66b94293e456c3ce67a59f51289d69264c3b8bb1af904e5a332cd5fa11cb02022b4cf5b3f9b31b72b2dfa5649801290d3bad55ecf5e9344efffa775f6d038e02a278e66c7ba508d72e7b8b21b4d1cde1a275aa80c37e87c78c6d26c66ea69383bfc5f0dbda7b77b639d17c044403a249034159b88660b6ea5ea3c2d2a477da976113781307559e6af3b610e61bfc5de470408943c28133f7b3008ed3ecfe99ca0341ee94e8b5582f2de292887747949ca827c6f71f97b3232eba168a2199190ca534ef52278da63fd886d471da3470a11565c1e78c6f8acae6cd59e7519a27b909c1cb98fe947145eaf986a6af3ffb83dfd12c6b64688cf4b45d5c97453a6105b53c2a4abfd18b015374ac34364be020b68323c52a140d4e82cac61aa9d79c006160e987fe22f6e1e946aa73ed82a9b500d7ed4b031f1aaad2f3f951972b734295c3423c90538d4a249f3cd1f78c0701b1546670b1406c1fb392ff08300f7ff9b687b81509aed82550696629ed4e33ea9083ef6c31adcc2f83bd1975035402d76ed0fc74ef052eed4df36e4fc993a16c6744e9b48f654f5492f922d1ed224d832b46077bef3c4351d26575e82178f605c66254a1417165af0a821e2edce50864e083711af40a2d122fd7e30a5e672a35b405a2d068c1e91d6464aed21b81edebcf7b3de5b37987d982577d8362141a243a5dd6087eda64d1af8f69b97d3a22a60046778b87710e380c5376775a4a5f32e52d6e0623a3f745d013f541fc0523029736cb7f396f662def21434e7843bf98e2f082435a5d14a22da0d341879b1c030abeedf2bec3f1b235e397c7caa9fdd36c6220df259c60a0a14140c0c6266cda9f5e1c42dc69178210b2bc847be4573a67bbee1fa68f31f94c572f96ad9d43c47be4570a87d18367235f5f58fe1747db4d4d934bec917e181b9813ab1bfc0ebaf433091d1c61e0287aa918b96a80f248eb85f5b1e352a4c3bb986cf113c6fdbde944af81a96d78094da2822dd02fe0d15759feeede50bde1bde644812953dfa76e9d7ffcb7a46fcda233e2edd9544eed282e061edb5130bf00f3d8bcd09d8dd02d4a2d2bb1c42723cc7850e7823406a5fc848f6d62c40d3bf60004778bc6bd0f21e730803fca7531c11983c7fbf1485793372c17e29c082d324031a84477a7133fca25904925f330268fd711ef5db29176037ce2a136b99495dd638dde1c820cbefa96ae2ee81eba8a70f7809af7bd4ff0ce0627553cb4b276005c5798f8615697f2a7baed51ff278946b823e16c1f8a8a6686262030631b5f95a18933a04dddf845aaa11431dd8926d3c3c7a60761ab22273264d7ea3abae105b89fa36f1d373f96487d3ad6cc99df4e237132b5fcda6c77e68defaf06d7e195b96c2865f234b45c18d3f4e19556d4a8f1a9e6c6fa35caf7f35e9c66bd4b2b5af807fbe1f2aab431de6818f34b640926a639c416d8a6001e320c6f0529ed794681428a79841c3739e37afd2aad4f321112b497eb1855767af7f0c8d4371a870457d982f803ff583a998939b44329984e19556ac4ad359b91afec2e605f29c00c796b5004661d0386b1caee57ec7fb7c28c92a471727f0d1ae616ac9b3524686f30322d58b6333a7320f4f27a139e487d34fa8b174e23cd420d28f4f5c8c64bc39348ca16c2313e47d296137b4321625462b1fe2faa5798873e594681b1ed094cbddf2a1e3560a2254b826b2d166f345b1de816bd67e89c862d87758320d5b3c99a03ae70df3b953bdb4e5b0bd1102c73850c00038096413de4ba7475d6b8de6619fd5c35976959cd50c8852c7c2cc3af95e0cd5e6167f6c771472e53e5acd1004f7022137f3a252e2f54e6884a0e5cf9e818f59ae2f5ee8ad66bc4e3a98403ea8373d2f8631b6b26a2c1023402e48e3dcb473cfaa44e796a92037793b27d89080dfa5a83364c9e54713d24ca78ef2381c81586485361ba73d0c9044da9d5a8242c30871018bda7f2cea64900c0162797e19db5cca96e848a83628c84e70f99165b1ca7a1a0297baa0dba8cad471b2f93bfec61f755c50cc8093ca1c8faeea7ec92dba38e6b6c80f1ea98c75ca6f29ffc9f17ee6b9e8245fff9343565473d53a4452f43a8222484e5ab7b4d705b9fdf884c56c20e1499e758b60584db24ea78d17a3c69b05e81a840722e0ccbdc27330cb953aab70af357c9fac9e801b9a95e724a06d906db52b96fe9e0161c3c40ecdb09256283b9ca0490322aaf3db695cef82699848985754e327305b371dd514f95dafc35015d6b03618385e8d86047331741b7c3b4a6e7444d910cd4cd6d359e5b08c546f892298d1abd8f610ff1b025047c2d0f4f765e46c242eab1cdf1aaf5cd3828fa78a8d923e978dc05953301ab4b60ae94a2955970a44a9745d6bd3eb4561eba429261d7f2598f4255ab04fcce834d9c9e9129fa058c22a11634f834b55c3e1a55509394b2347a2389c1a827a670eb1e6433d1fc3c225537793f204896d121c9155a1eb305d7ffff1ec4f58a708d1b80d0e692a39cdba9002a13c883daa7cfb3073ad36364c195971be399976b016a581650396f062525d4498a7a979e17203a1ee77d14697c4556410b1449512e47edad58e9bea08479e0893a1037a9e60230355ecc3a551b008f3708768cfdb1692c22fd9d73eb80c7064adebbe11c820a64e572396309048cc0501c852283e2dd4172de144466ea66bc5c8383b329d9d6d240f0c4ef072c3da6df0324f1b953b2f25846fea23c7178f504769dad83713f50928744d265d4aa3f68894f6fe0c18c531cb5a4bda0daa0dd7dd90ee859652163141e0383d5f284741bf7f08a59f85861a42cd97cb13ea2283d45dc9a7455a6e0a3d1edb272548bb8f78a96a74f48398fc78291259bdefc73877d5e326ea1b0c2ce56f3b400e33d31c926fed83d1a46b4c646f96341ecab4b70a74d0e50112a666a9e75d4fe0254ca318d56b0c9874e3278244ac165c821e21a7360a50539cbce2857b25cf84d4db50b99401b1e88bb4ebfdf847f8ac2751a37eaee9d77711e45b56c5cb5792a5246aead3551be38a1d8bff9e854280aa8910b7bd4f43eaf1bef0adc19a3fd0b0b7617936e736a8c1553ca638221763ee604d509c787c98c681b87278e0f92cbe1e5b3fa789a20c6bd9b337bc29dc76ca40bc6f86f109d3552eb3dc0cf336f517f01a07e49c13971073c02df90137eff161cc0a67cec5a9010697fb567dba1df72cb97414675cfb6bf0f43a6428ef51d9e61f3f3ec7e47a67d56a56475b711393cfc88b4ae1e87fc8b7c2707f70e9625591218c55fc07c3f116ccab655f05bc32735bb29fddcf6dd5e886f36c19f4906e761d0ce01911aefd0d354dd945cc778a41da2ef11c7f9a8d5810954b4a171cbb779070300d5549e57fa716e19c7e32054e4698c2ca5b3fc41110ad7f127c6ae15b2d1f5ca758c83c62e703c638b7068e3c0e12baf4074d5bf172daa4e57a5377f4319083c64409bfcaf0418e56b3e86cba66706c2e90cedd2fc81e6a5586d15b02f872b02699f5228e90517cecddd9b9e67c58c75daabee817082e70a85ce6ce2ff70f99a2c2fd86677fc42cd50fcac7472fc930a8e44d0fe3e432ce8ba407a8794f499b513167b97974ecd3fdab65f0b8ab14e2b60afeda16b37d42e72991a3477d27b6f9318a520c6ef91333c2db0c32b446e178697071de9858730bfb990e1ff495b49c2f39806190892346edd693f9eef9ac7471c97ea4c2e512e50064d243af3abd0b79b7b88c3268ae32efa83f7bb6a558320f3be8cc96338b1818c92662a8b8f251110dad687f992bd32562e8634bec76a16db08fc87dfa80cb532d9359f7d92167dab26f782ebc869bf94262d8e530bbc942c36dec15edabe3143f209ed744ca680b538299a31b1df5f6cc2092b714e7c2248ef04ee8330bbd2fdc3af76b2c92ec1b0baefc5a9119a63b4f265805a57215de1c858254a8f3b25585cf98a5638c05659dd9fde1d8f85901b8025f91d6125dbeb64eb9523af33631dd8ad68839d190b344960373a8a61e65ef79e3a9af3a754e4eae31e7963499b2ab38833f72409b363508b8ea65b03cf388bf6bad45e40579a43e42493bf7a1b59b1ee1434140d6fa8f8b26de209133bcb8d96ee5b47b8aa5de71db0f1d44e7573113adbaa95ab37bccfd6d8a365efd1b87a774ed9b9d431dcaad0afe7832b15dbcfb4677643409c6f1f2040d2e1bf9bbe5cc4446bc7e4b49533e31f55df13cf726e9dac57a7b87c1a0db10c9855880952aa66b9f42d69d52a6fd3b86cc09661203710ebccb8cb76691199c58f303a961397af97854fde96d622b8780c81c9127674de0b1821ebcc29428f3a092971d9e9a5238a8d46d40391a3c23a80bc8eaa5a0f31d021ce0aba623977a91398533e25340a93aeabd65371bc40e381dd3f8098c62ad0c34e666f8053ab00b48018bf9d1a1e35621b1288d0c7c3c11ec4739d41b1e8bc49792ebfc7800e6f384a1f8f22bb0bd092808e40bdd3a79bf0715ba3bce08e780f74ed2bddc8a8e86cefe72e329efccc97603d7595075d411a377ddc488a0f776b8c1607dcc540a7308a1cbbf30b68e68ff4ebfa677fc013ce0384a35b89efd074835a61f09bdacb51d337d32280bc7570d873cdb432a47dd78a89417c9f81cd31e5ecc7b4a2b19150f22da0dff61a486992b28ed8e265147557055087deb93d6b6a5ad23f894188013b3c155b54b654ced7aa74e7596a443c3e53069ba0b9f88f01e3aa0fec2eaed94775e453379b82cdd58aefe6937c5111b91d20c57cdd92cec0aa7b968eac26663ff757ae1ac43c260c32a0fa1908344b76c9c326de9312c3c1cf5df6ab6954176e3fce9663c10d10a32c38fd09d4c7f92b0b9b9c1bc514071f97275da2c1750d4d6159d890d83d1889ad4c8ec9a52a642ddd340597bda0632e6ebf5224fef03732352ed3f663dd1e4e99915ee1f6e966f8a8cdcb92d9adf0c8835624984d2defe22ef240863a2e8287167a757228e0c619fa9f89da1da40bd9f197ab28d86da4d1b2ca36634b1ad516a5fa3afaa2a68e9e72260dc48afc3cc83a01e44d4b05c62de4cab35318b4d64521c17fe37cbf62d6035a5fea0e917a210b44f4b978341231d09fbf7121c0686a5e7c7c1a69d1482318679d3e64a332d58a2d546ac74e74d0734eacf330890163aeaf6e45b3fbbfeb8ee3d8a02fc6a5b87935059930d737d63a2f1683e2c419783d7fa8ed873071397e804d3ebce4585f5dc928e63c2bbaf001d54393f15e6f709f9ef7481334d368ec01abcd45baefb78fbe5020a9d354232dee2d1be31fbf55108ea205693dac35b8011b1bdeba1383828ce22b325ca1e7e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
