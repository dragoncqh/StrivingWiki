<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8600b6450374ceb59519d78a8bd71a3201a063e21e01306d6c4b23648f565cd222747b5e42bfe194dc366f465478fb942e09c5ec902ba80af7ed5c6aec047ddf67a9a234597216b07bdb741e8aa8163a6da3a4632e08ea34cd34c73cd6315d685dc0e2bfac96a4757770ced59b02ab5d730c5e087a84ac71df7521a38e7df53152a75cf298bc0aa83547b22b4e54119669d368725ecb5e616fafe5ef9a3cb7cc312d99e37487df6b481f8bf4ee86b64f3657a3624e63479466f061e593a3b31777bdb16633884f7145b6467de1c112013df75c88b34f7f9d4246a623d06a031ed61b6113e5ea080aa3304ce4e0b119c9e420c65fc51a73cfb119dfd32e3cf55473171ee82d3c05952169d4f51e7ec3409df52835b248f10b78627bb6914298f73b69c99d34e22e2341d958c100ee5689d4d0a2bf17ba35be75ab1a9864742850adb31cdb02ac41d264bf251a3139d8cefe41ee7237ed4691d7a5da1bad54345c47e6a00a44173cdc07a3fa8f74ed1284c05d2f35d1eb5b72590ed7cb5e6977ae520f61c42f8b4af459370086fada89cc749f704190fe9e42885b6292af0592875a398f3d54bfa63e592d20f0f59936a794b15cb5ab295c481f8598fefd0efc7c4d6c5e3bec98895986e35850ec065e18f1e27fae4c95deb3735935406cc084c6551deff465413f047ee5d0265ddcf88095dc0c8b9749c0325d0f069b04046f7c4a3396d67ba98f10177220292c984cd4c0ca4fb1e66097c2fed125bd5a710bab401e833b8bf08d99ae35dfb5bca57933529f5f7f76af33ad7808fbf05d13b5024743663f13900bf28707bab4dae2b1b497a641ad2687a23c7a040aaeef949f1d81dcfbcd900f4f1633a0ba61ed83f9ce8f97a9f5f2840bc0f002f5f1125d188ad358a7269a5cdcd02ca1f394a7acd3960bd707a06e1df482b0e21dc030ac3f1923fa86544c61d196f7766d23fe626d52017251d7b1be476c0804213e587cf5187c0075e235efa7a0ae45a25b70f6297f2d9b7c15343e6fa842fd931b5411375e1cdf990ebabfadfe9f5035f2820f77a8c6e180befa966ee8bef64bd75c4026e6bc774d94307338e911f94100f200c27957f851b1057847bb5125026f725575d03cb29e6c24cd3b3abcad4b76ab69e2d92a8f09c37c46343e9e57ca7c78ed072c50a93f7fc92b30c69ce2c49b169cb2b79a70754dfd7bb9a03c4e10d74d1f9da62d6964eae6b43b5e8647e1309043df9b219ef26f3995eac106fb7da7b61656cec7fa733d2b550163060ada1e58d99207c5a79b1829099f82018b089785ab0972cccd1889f7eba3ea9c50804c2cda5790f61dcfa7fb0faa909f2d675b1f69a9793e416490ba51d2d14fd215326912fe9a9f3150824a086f2283bae2ea5edcb401c5dbae3d6aba867a527c4400683b5c26331156b9bf34ee54ef3fae10916aa2f0902a20c285944757b4dd1346e6f9aa874523c2d5f7179eb6753ed7ce0e32b9c8d88ffc160b1ae27adbc1746e77807e866453a3807dacdae62eed7ea4c2e8be97a2ded268cb5d962871683eab3c34497b9ade46f8435c3c1530a8734d009a275730b2e5b99775b1287fdedd3531e77508841bb731505f1aa5d02f6fd555b3b9fbf1970f33706df7b18d9eee7fde86a2103a29fed699e7e97482b332f6e29f46b53de622e1c416673a98ff533d3b708dc6126d43b4d1b148885b4871d94357b18d1d3914a7b6ba6db56ac7063b715106852ac59049efa5ac9b81583730d6ed167d1f4c428787626ce55c73f1a4eb915e9bc4f554e916b573c32f68ed83e6a2cb54f140ad02e67e7d19f5835a5a0100c88edef14b206d6a129f06fbfd5047736e968da84f92cca38fa4187a9e9fbdb4c70562f4c4892ad480d4b2b70dad23ebf9be8537ea4fbf0f8ccb3d378d780e5c969de3a6cc43269962f59e45a4359cfe85382552d0eb248e35b8d02384e4f9847638dafb74941c8c72158728b1ffdf6d7723b0635d3348e6ac8e9499eaeee39284bd8afb5827b4012e35e9e3f232f2f967d6704b84b876c693fdbea5dac74a2a9473cd73a974a06f4db27c0979eeb99cb554c1f1473063a16a1a645224768ac296ef39f30e85f2e94d4dd0eb70d399137cc5f774b4cd81961eb72f2ca27085498437f42a984587fddec28dd66f1f3a753896d5804c58f25178d801c7f2aa8078df69071337ad31cd0c1c66fd5b908bf720a6d28e5514533b773b8281ad81226417dba428687255242d17c4719648b04a13f4cd8d72b2734a3db09ece123fd10396b8388e2332ddb66c5e5cdd9b7b9e35786a6286cc31fe19647f617fe473467bc750423691de3e681eea7064cbdf4c6794db48e5a3f7af3934aebfaab4b3ac6b90a5c74e31f625cec39d296c9c7c369b3167a7d5784670cfa22c8a725ad4a36b0a3d2050d5456faedeccdc1e2c6565437075aee622f8947217c03e239a6b8d6044443a28497cac5bd355e9106700ec6d02af52d4de6c41c1cf4a22fda86b357ac9c3eacfc6a75c162f1b69ad335360c322112f851390abf05ca1f0d3bd2bda41f304737c1bf40e389d77c380d1aef1419c6046c1a883d33602a513373fff925b43e20c68a27c7e0a47faf01af4f81aa7f2858c7a0f206d99e14874fb95b6d2e4ef8e9a845a922fee5adff434e5d06a44873f668646486357b72a5ff8ca573ac09e5f1f09bddca643d71b09f77b30d7a273541fc20e8c21aa38e46478d18af86758005a7f6744bf44d2913ba658c6cdae8243d668be6ceb1cc88143b866fcb473791a9e20f8d00daf574e54a7047fdb8da2586fcbae571b66bb24e3c91f4a88e9c6078f6ebaa0cb5b58a4729c0b2b00b8968a0960d011f6af9abce4e317ac1d87540613003fac937e16bb475dda268b62d4aa70f5afb162250ce9ca43c0778a17cc667ac845251f21c9ae799c60cfc9c9704b2e23b1bacf8a47b1d3a5c6cb1fd9ccf96cd593bf210155a21049aec67a4ffa01c2431a66d562b2435dee4eeebe7e2d7bbfca8bd28bafd2668c55c29857ece6304aae8c2f21f6cd02149a2962b2fb469b69b82298ed1030f56f5733b567da757296f4f94a5e3085c716cd9d8114cf324a2647c7f18d45e7ef661b4a4ebd747fe23a81cbb6c7ab0e9f70470b591e8cddd88671226d52cd5cd5e2efbaec358d72390ed8d2287a888c580f73ae872af84eee13c8683bcae638445624f6cb1209502095cc2644a8aff7acac5f548e91f44bb57d92f0c9436298fa4697721ab37e0a0e8ddcc34267fed6c9c5268e64cd7db062546a822704bd5497dc2c9ec2d4447c1821a0abcb2478283c4d82f2117367c52830bccd0ba7ba1d664c1cb3763084f140bf27432bc1ded706dd100391045b02a813cac016b776cbbe7e6b97bdeb37a5d73fa4df4a22ad62fc6b48709e7c285d77b5aadd5c97c5ea0675d25cbe967c31170ee5ae748662f46daae7e308ada71b847c0ee826dbc27f06ef35c2313a035d401ce8289971e51cf548564954fcbe8c013b0cdc89d8fd625d73d1d42da732b759e070183126f1d1b39d8e8101cfff4637ce460f8d64b4cbe7f99531fe54272c3d43c64bb8c0284032ec05a06b87178b9831a62738b1758b5b20eadd146414532bf11c1ea3ee5b1cf6cb16c989421c102f29e64632abae8d205ae2432c8e37b2f850f694428ce7dd3fc10792210c130e0fbd39d6a82d704952540b7ca31eb86128c1eca616074cf395082d1b1362aa14eb493341aeb560d9e89e5ac7d997252abcb0a4b1c8530b365610260fd50886d42c93c9109478877ea03fed4870c836b01349df3500ceb73e59d859ebf6d1c5bc4a794cba2df535faca20f9476a313daef955a14920c02a063a57cbd2712f9e4882e23bae593f3dac6bc158a958fdf698a25e38f0a02a7be1187d98ec9bc0e91eae379976c65e4fb392738519d6618d10c1ba22e8715a4c0a8340db50a526880741b8561685d06ae06f376363a25a44d0d7c4b4dedffc67152a4f55f4fb2e91620ba00bf4f5e325b172b8cd3f2c2ff38f5415bc1ec73585af8117ce5389258b5c425fa4acbf4c954b2bca277be2b1b2d31712d30ed27314f1b0d3cbccff1134f2fd13508f3958012dc0d73c65f225b50f295b75e3b0c5d882e49023b41700fd73131e1f472e38cf422dfbbeceb693e69601dc0e67c24b8938ad166c6eabfc24a0f77bce3264cdce3da90a2eb479f3464fe6c3506286967eb8666d2881cfc7d4aa1786ba6aff71e3faffa3006d59b2b13c84b93ece97177bc9ddf25a5ebf504cea6faee647d2e49effb40fbe7f56ae3dcdb3405f4495d4578cf22d2bc9d7e6171d4adee418a3d7cc9cec5aa2541784f54374973dbb048c4a17ab0815ff04d32b92618576ac722a75d3ed76a6eb86f5df889e4dbef90d5485e5f709a98d054b4029437541b8d5874fd0afc6f42c5a13f6be8a420a541e28754c2010293c74df1967595e38d46a52efd10ca0db7739c5e1d813e0e9d60da1c8070c94c2dbb1ecc25b549439902a57e83b376d6c2433d8ac24d6963dea0b0739b41dabf0ca76f297ea4c36075c062d5fc10ffc854f7b0f2c71f25fa21eee88616719dc2f5a076b203c15648cbadd733c4d67efedcc0e318d4b016114e401e0cdc92b9fbbd251951242eaa77b7987ecfbde4c913aaeba85a2d616f24b1543e098ba01e39f1cde7f90dc1b240425203a3d1cdd95a1762c5c44f6b1da735b17ff1fb12219f7c3d81ab80210c6b864816be53ec4db89d1abf27708e25a4a5c412b485cfd14983d8c03dea6d26285549ea29fdfe3cedaa8703765ccf22fe99b94e1d576fd845a39e69e00d8c8eb0f57974a31593336ad7ef74e547115ccdf71ecafb72a5f49e76cb4c5785f27a7b3123cc5a062a34147d9a52cf6cb93fe704d47450458ef4abc5160664f5caa0edc17e9c191f7757bba34977e00887562fda92d3c24f58db3a4cf6b06dd70d38480be6019c8a3cace211f5e5d3912948a165774d159c2fc3101500565b92455ee1cde15ee629cd2210885ce664a537cdf8b6b4fbad26b28d8530abd56f35dbd039921ef87ad28fd2b4b21aee9f6f50e434a637d8f8a562c72630841b5c0ea96b341a4644d99e5c3c3ba94034a1054272913baa97c9417419e9948118fd7b2ed2adf7c7a34af633d4c0724408612664d3ee572eead45d0dc52dc9e476acaaaf572a68a16de5eb37ee63d08923c52a662deadb56acad999ca1410b400ac6db15d9ef9e3325bbd3ac10b65a2f1a6e0d146ea9bbb49a1d555d237f2f16e667649a478730de4139a9031bade0a7486cd1a69917767d4460fe332fc7ee054769ec9fd8fff2959eb3f6f66662000f218d5d85688c7267acf91983bd1bab0c934a56ce37080c0b1786ddf85b93a1e177153aa9e2afc71f3a635ec5a0af42c79d454b9b01216719f87367867fade15065342440e5ef73ac116f623ea3987006167a7927eaa6af796cd0861ab3205ca24a06f378320e7d4655746829d4a3e2e2edb90f4dc33a306f4ec563d2247cf2fe4f0d2dc4cd2c3a4591c3e3227efec8eda750142e6e7aab9d1effc471625ccfc8f954e2d928304424c17eefad38bd855d08ee87c21ad4bc4676dd31ab8e0f70a45ea36ebdbe8236d8deb979aa94a7a774571c1d23adf4bbe5887ff2288932cc5e2ba6686dc18241db5a73c52d93a8dc925891028a821552bfb33b0b7e1f1fa64c1f1021e191c04ddce42c054fb6428b10801936da9d763df4fb9359be1c5d980d7d206803b07a57a4a10faccc77dd9de1e76973b7be3e4772b2d10c556a821054da267f8b3c2cdb9df3432ec83e545c6de93f6c10bc4af3c92203def2b7b1c4087420b1f2483b5bb2ae44a88d5cf5277a50ac988cec6e980b5a9558caac496912245d80ad904e7d7c3ea713bae5a3828036e6b52e12c283023ed7dbdb9eae4cb8fe499fa196a01a6c5dfca152a9023a0a95a086b0608d04fd878b2106e2a981eba69f5fefdefddf61f50b282a2a777833fda769bab6f8040550c852e0d921605497c29f7ccf396d7059b1f0383f65c478f6482f9f2cb220c7b0899d7fcea76137f9512e143781a8941e29e42b71d657ef67ba926eb303ef442fee23d97428718b132f08cc5da674abc7c745eda352e00763d9a78c18e4f8c69e8c3334e44c23844ea78f70eea36d4d6bb27eda76cc94e6a86bd46a0e2d9ec30a68bef101fa5481a40192792eea2c66c6bb8e42eb984acc23e63e6cb602a4c48f265a31fe4f262541e4daeeaa284c062e67b0982b08417f587a80e4ed3a55f9c70f11f9710aa3ccc6d52e0dae730b83fb38e09e6509fa93084fdd6a9447a042d100adbbb4e4d38a60dcb0ef09c9975a963a35b0cc749448d71c62323408e4af3564ca75d0cbb7c7cc26b9f4ce56b504bc6d90c1176b68b0a45fa4e73d3e00d400b18b4bcd6f3c6407af88a0a2fa96af47e4541d85298084067cafd45c180d9e2a24a0a402c69c0ca9e9aba1d11eace90c174ca4f52fd2535e33a02948dbd07ff0baff35c561c3b82cb0da44d6ff61ad754d0dce21cecf3abdfdce4d2d6af89da9de773dea027b7ef5a479ccc97db9a955a929675da4ef4b33a2463e9646af69cb5339fb76aa10301b4a6b8e8c1aa37781fed2872deca6de4b8487e643219a56b7b0ca5e2c1bfb175aafb366789a961e96f1140051fa090816deb1cf94c8418ae0b677c8d4149198f3b9a04a1e384bb783df266867df3a2f45cc8f92803b65414e7ebab8af63aa2ef3c573f16895a8a3b09628f5b22c03156eae15b2bfa91189a69aa90660bde2813f713f5e705f944dfc921136e05f0415614382c6e018028e3b69d261c18886784bfbf8c5d3c7d6f566a3254ab99a77d32fac22e3b1ebe7b1a3cd7ec31bcd2bb450067cd0d8fea5877b4bcc460862a8115bf0264dd26f1b3d039272d9ab0930c6044148eb4e6bb2a97d9ca2cd1a1bc77b98e9b3a25c5498a662a24bae098f771c7b648b07308561482a16ed0da9fe8f03d6487951431ce77317c82f97ec6006e68cf0ecfc1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
