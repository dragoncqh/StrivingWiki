<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe025a066536db713db47c809e77f4027ef7fe25cc521037d2b1d8bbf04801078a86a72fe8cbcfcd379d6a2b1dbc991bca5d694477a235e8c2698134edecdb0b342e898d87d6f6af897eaf72fd4b14e4449607c3d723c71c63c9406da7d9bb48c326931c1c6128080e57bbb274e071721e6a89157d78a9d123f8f83d1f19a3a26da31b8baba24ccb690a9a5534076766f82fc27a6f04fd80978bee58e8bf45af881d850c03151abb97396de78d2868901926d1dabc6fa951c1a01bd8213323bce77003c2adac4abf0fb8f8e44767efec9c8f1cc9b6858d17a0d4bab2f9573ad783214f9bf2ffcb2870bfdf91f3f4193a63321c10c6473f415e27a9dd460e434c4fa70af0b9139b2c43b1b25fa4ff19b6abd58cb7694c217fdffa32d22499d04eee4dd44fd15091410a00213cfcdf6a14039f4722623eee110caa4bd5379a0111494c367a5bbcda7c3d91a2df951341ee0edea04f2578d2d97319a93f100790fc663cffe160215d6dc5651f98a84f67c12e0039c889cd662a6e0f9a8e5a640c5e719a5b5dc2a94b8c2b028de4565b7cadee14068bb7a32bc3020913d12fd7d091572d09040691b62a4a8ea001e18ea720f6de166e85cb1df24f69139d6ed7af874e4cc70374a003790e8ea250b350ce4c2796a59af15abd3cd1770dbbc7015502232e777da516de5e0de7f2427c497f02e513bb6153ff595d2fd463d3cf7660460dcf61e5269deb4b7d70401d3578edc069297111d458b60c44a136456a609e3c75a6a90b2433f4a9a0656c102d0a2c1a82a1efd4231b062891b9d70fcb26e4395fc7f1d451780395ae10a93a5bb837417de6e01270884311aa6abf6d1050fd5953995d1ca9421a0da3de435202d334f54c76849cdc3fe9429017cc5c108d6a67474856ba0ba1a98e5cda49e51fa202ece6022d06f5cf72bd2431bf002e4b9287cb7e58670ef1d38815af0ad5d9f4958871cabd13e2d07969fc670f32ae6f9f6245f66d87bc917bb6224d33583205a1f796969ccc0f57ca044823cdc685507f5d183603fc6c1c4855ad1fe019bb7a4ed3c32dbfc9de2b55e3db0c566d67ddb55caec532c25b0d57e61e022e46a8670a75afcf5777d12489545865c99da5614163149648d1a18e64f3f38ea4591634ca3f03922447ee400aa6df868092db048b36104582849dccdff6b2c23bd8e798adef8a411d7eea6995eb00a1c205dda90eb83361fce60b4c12bf7d7b13b99620ed06835d7d79fb98d5be5bf43da775a0878c5c71c0aff785d8f099cc2805cf0bcf4d4aec0c768005a62f7b72cf5c3266570b416260de96fce2d7138a8d30baa17a42bc6a9a95baf58f6f5a231d655f144933a08f9e6209a966fe8423830a100101b7b9d251b8c55167ef9358648d5463f833e54986821c088631babfc70b37e28ba4a2ec432cb747dd1e046306752b06432139a0218d661e27272bac430860ceeabfdae0e7d473179cce0f95be8ac005a2e204b50ed95574d7fe880466a9411b8d3af9758e19c636a3ea8ae84244ede512d30a643855a1bdc581eabc9df9c24858300b9982337d08aaea6b5e11dd2180d591f4602451a854e5eb9d643addf7f65f7f5bcd910e7b701937bc6a9343eb0a4044084942840c9532776a53b5808335b16f6bdcde1f383f0da8df6b12622064bc10231f9600942c1968efb05a17c8409ccc344393ca674ba131d90e7697bce511c16d01c9c76f88692be5f416e5fed1545524f87a0b180be7b523827cc2ffc407340509b6d5bc7cd4ddf3f49b7e5b1d32a89a2bac8a6b64dc9ac9da1d85d9494e20cfd808a9f4c766674dd03e18baf2eec48c8d34a7519e6e494efb3d84ee3d7a93f090f5354f5ab60a392a3458922c30ded7e2b1e3dacfabf039894b3efbedd6f256d0ab35fea018a854ec4d3e84639bdc904fbb9f204b15e7d2e1022d1fa34bb85bbefd008e88af44b7cbffbf8b184bb00642b61cd21dde7ceaee9813032b596ab9ae33b8851bcc75d241444514339f3c8bf7910978f26e72c7bd3ad2e5c30bb4edb032ea93e411896fa4e4198baa5f46fd15604eb833b8af5e7b3f801cf08d0c06918e7239c343bcce0d3c66b3f77d65c4b16fac7670cb2b379efa26f04dc6e806e1786deb39ed86c9b496bff488aeb59766f765c301b3a6693184265e6a4566501e4e8ca07b3fa628721c656b420cc75988964322db01d18fa5bcf60106956150cb8e773bd7fb6d9fc27c09908e180836774cc8b06eb4d7f6b6abb4c167b7dd9750a04bb8272c0c54e58ad7c858cb4470f07d94d2e82d7ec57a3c6867a146a7ccd15dd6d54ac3775e79e2892a4ae139f407e23c37df3d40c64dfe7ae97cd10331d076051de11e4fde5bd3cd96c08948519730606412358642b0d3d1246667dbaffda44032b2b4ec4e978e604109052e520a249a0ca36094caac78d8134eb2a818adc6156270864b73d2c27a12ae64cedaad7f865623910f4f53e673dc1f6b1b61ba2fa2b7a58c20c902c98ba817f13d5c8da4c9675f3af0a042dd6c0bf57921c91d0eb91da64ec63bfdd7911be516e01391d0ed8b1e21769e96247e9395d10cba248320089b71e7cce4ace56f2a881d759ebfd289cfc1dd7c2b34931c562ede7f62e14374f4d568890305d9470abaa6a60a528bebbc2bdee2719b703234c30a2139306d9d29e6be02a3e06cc222d50bb83477e6b77c1d74d2a57d1a18d76e1b3a2d95ff29e086974f0a10c9d8eaf13c916038e345d4e5b57b293a70b9ec2da77101a89307b0d5974331c5a12387577f0585f9a32a175094ed6f297ac63d303ec0468b2f8ba0ad21b8e8e25f63cf907dd8d86c4a191687c1dc495d0f1a6857e2045cfa55ffe80b11a597a197e26fd753b2a4ea1204d41fbaf4e3f961df7d62210293e22f0375357bd1bc9e5393500ec21271f63bc7d39710549391c0726c1e1d855372f09e127b564487c8f43437ddd81a11b1e4ec5db09f7995d90210bdd243ed6d5fb4b9e202c0e548277af1f09fa21c4eec8506420ad0a4a5b989f5de2f09a4c1ad147c66a61f8390eb76fcbaeb4bb2e5e04a3c2b90d75242002f36460133924aa5d524720221421040732e31e149a08f1ea11260103e90284eda115a6f6d72d1660e3f1fa79a8737f1429787feb0c6a73591a3b19adb083aba1990f195b3e8af7c78eb42eed7cea7dd4e3858b2b1229e0e0fadddc284c48a1a395c9472574b3c01dd5e5b3621a542e36bb7a45c1a29fb3472574c587ae83aef60dd18f014a5d5fcd7af910590ec12c514d2abb90a5516036a1eef9ff1add03c27ba0cbc672b0ad8f6e971b183ca5047cb73b88e9b565fb0d8bbaeefed803e0f635b9b74e72daa28594a764e5ff81551844c278a494b0bf25e0416118449c44786b149f28bbfcb975864537cb505168dbdc894c9adbc184abd8229510f412205c260ba395020be3a6e9557f8bbb45e40c23837e857628676b8a2de056ba463663dcd23bb3f730b1b7491ed9e0bfd49a98de6298fd340a56e1743eb9cbcbf29c4987e4f76184eaa9dbf3745e48fcba365903ab8ca3507e818706f4d97998f43fe1eafbe261fe07c17d1c79e650249d52b8ab3e57fd98f42135d7c92da8d287e0c66cfde6195a8ce8a2de452f6cc04113637a525056e0895d032cbc8296048eefdb4a3651ea120eebe96c7e680a2a34c037888d2994b5d425edcdab4bc5d39f32327906caa736af89ca987edc0f10f2d88ef000f3943f663337fdc73217a1d2210f17bc0b091ba6e97cf76563c010a7888c7176f8580cc1c7185c217eda2bbadc4f8ce82662bdac32111f7890785574938d51947cfd763d1dcc8c5d9259e0f1b140a57343c15c5234cb4f3361137559f07bf898a35c4e5391bdc05556431477c84db9b1501f28a79ccb0fa946296364fa85b4b7a2ed845bf0e03fd90435fbdbdb3f08fc03d9207f4a9164168c8258152f40808d11c265448b21644c0a63e3186858979a1fa04a504634b3906cb6c3f09353fc2a02578c91780977dc105cff448fbff8ff646d7bc65ac7e4f6edbf728f78593ba23d7ba8a43fca7fce91470de9fd6204a28bd6f4341e3adef9b91aa4e3193b84135bccef7e45090a418b9a6761ae59b66e2e825e1b037cd4423f49dee209557c81cc37c7e69cb31becc9ff60744b5df55e156a64a4c30664aea0382304db6b23d2e03a1795050e3d45c78cae1ad2e0ed4c854d29a82f68220cff7a4e50c45bcfc106522904ef0b84b8c0d17d85469758a6e1b7f9577da8a91cd912404d69bdd25242db75ad3c155493fb1378a62b8a82e11540cf2dbcbf92326104557dccd241284c7ce1bf8defcf6264ebf0ceb8ca40a8899b1968ed1b010b0fce0f203697b1e0b139cacc64146575a21d191cd8dfb78d11e744a6ae577460d04f07085dab88b0b14828ddf79627bf625cac153977a362b1f624718ed27d1cd490fd04d07ce88fce0463734c77240fd48d8cdaa1227a297c21fbce8569fd8d1ca0aa6b60d5059b32a89f64d097dcec9375a05f72c5ad3ba8c0c417ceed16696698b6cd9cad29f476a3b89c66aee5cb2d38018a0bd9a7d5d1e7dd82f5035e75b2bfe5f35dad7200ce4678dce48fc6ecc8bcacc6e7d8362a9daa9e63a8da4430d2c2760e3c2bb75c7903427d7f771371f8a0133740f2ff44d3ab6c2de0077a801b1fe0f8e91dc8a10d9e24c3d43df6c0be7fbcbc19083f4738bf86fd05dddc6b1fd39e490c7669151688179d3aabe7f01a924489d2fbe6842ef860476a95216b023fae12af3a92c96d9508e8d080be75ea3f5061291b1579ab028fbf7273c78f1b020c075ea0164ee6d9a9d82b8152769313278c10194cc0976932720f862b1940717397ec35f838305405ec4f2af9eaf45f998d586f2be43d917feff146f8c143050ca17051d6d9cc2d9589700747de69c3581bcb9918614d8c7858dae4117abd7aa46d9ec3d08bd5db423e0b7744e0e0c52a11577709bc91a1194017fe657fc387f7e00f18aa3b44cfe484be8c65e7749ae9cfa02a55a2ad55d54eea2f939e7732ca964a6f541d0ed0226c8df258b9ce1adc4dec2785bbcad8466578c4f1c6534257884b90a76e6f7ee38b0dac1726b4308f641f440544e5495a0b9573b92e5005512fad9b27db94e498da0b4d975eb098af8f861702d25b09802104e6f495a0a81ef66c1b50802f8f7b4f795b20e4ab8764c5b313c811cac93fc252d534e98336d004efcd7afbd810243a433c376fb596c6b24067435102b3e327f01c0efae431ee95b3d50c987a00edf21510aada27f9e045ebb768541926fd77ade7047d1afbf5bbe531197773aefe4fe792b2f88e340c2b7d68b135fbc00348456d88d2952e0f0f7fdea0f4c7b4ff7ce0e60d0d4d4771db3952aee1f9cc7a9bc421b79777aed1f0d8197bf527e99c46338360efe28bfae1a4478a065210dc90429a993eb652f3cdea7f93b80f91834bbe6bd812ef894baa9440ab7978e7428519b01c750a6ac191faed0fba7561c6d281d7f8063818b93926174adec0251d5be09761977b6049187236e345dbb48a21be574ac6a063c5c4965e0c863aa1bc48cf42953904a61e6927783d675e0ce1907bd726dbecbefad4a1a6f87524352cd9dd262e563263fa7270152caafda64e6d120574d804b0e2afca7fb6f7150cfcee749827a3b93a2ea004c1eeb7e7ffe0c614d5c6abb3ef0153afa5aa4bef02359f8502b4e46c2096ad469fe851f26c9b85f0538639e841ebba9be6b3fb9d59b86d164180572e040b976615588a4405647122ff9cfb905b561c861ade7851343c44ad742eab8491b11c88c870a8136c04a3cd1e03c655cf4623378ce7697318f7e7961ce347a15b806c0e75662a13bafec3edd9d9acc86a236b6aba47d8ea7eb9dcf1be6c207b1dfd10bde473d9608d0b9c486972aa818ef565d8b99a99393b4d28a0406988b3231747391d7b57ecd239955ae8e74ea0ccf41999abcde1fe526210b4d554b050ac51a93bc9d8a6cdad14d175d06b2322b5aa2e2d10b718883171ea971b9ad767abaed0c27e72b0c81182317ab3b22b6d5b0c01dbe7ccde175bc7938b10058946de16ad12acae41d62dbdca866871e705bcca473eded1c678f8df75382ca240d1f83f609078a0ac5ac375deba72a914399d37a345c42efc8508c0393411d40d7b49217c9c3840cd3191523e2a7ef358370beb7e8f98579f18f8094cfe739dedb8b6a63d4a2007d815f16cd028909ba65f55028db76480e705b3dc8a0170f72da672af4f5ccf0f4f64e07a4d1723a8d05b018d15d97e83ccd462e09e2723c19cefe46a8344728c1774a9424cb383c427e02bab993c4eb4f6b4dbadb3144b121d7e021a176fd7c62a6faab1406f766a4389c37fc8e8dea37781faf75e6ce2aaaf44afb5454b43d0806fbac70893b424bc6c213d1ed1310eb13caf207c0f313fe1a19bfbec64e7003cdbecbbec44ecb64dbafd2fb0e52e685e283d78772749d44690a44b9a27caabb924aed16133f35433088c143d33807c10607d6934151626055d1dfddaf8652ef2dc51b2d3229c967725658163d0a3baf781d66aca97a403c3e9293ff8616c2b16bba75ed0d189995465a5a871860b615155c7afb91f2d4646f7e137e9a428e7dfbd8297cd7a1c0a064c6866575ddbfa8a201c2b6c199caebe9382f2d63622f2f8fd10675061b6e96a6c691b0030e8b67468c7e52cded848ed139eedb9b355a15134f57fb1265217eb05d824ef50dd5153706472579e8a427be54ad8b2d0d83e422e5b845ceb96be2b1b56c9b6b65e2a96036e11771e041afb88cecdeb8a672ffcb2902b3ecf78db47bf49a9985882b20360732231d636dc19320e951a2176b9fd4718464cd7a8f5fbad3b51814f6550b92f0afbd9e67b7549fb17463ef2ca1b4b851e195688c4484e5c6e288bfb99e545a10f8fae5d4144054466e168af694fcc92fa161b8c07633bbc83637e0632909916c8885ba2c7e2a30bf2259887346f3cdf4c473d0e393d2523b8271d01260769cbdd836a2f74347dd5e5212e638548d9e40a054da835bd6b04adbc1bdf35e5fec5e065d6eaac6b8c073ca288b48f44a0464bcb02c0f761a85a9f781f0f5dff97c80c357d1df5f1f49e38a5336b24c9179a7f3aa28f4ab18cf1214eabc0a69de8c2918dd067aba57aea5cb61bb1af13391edcc0f22a7544d60c173e654801fdbdefa398702be341bd93594f7e22aada457d4bc4da3a0cb3990df1fcc95f189f3eaa26fb76736a756b01f34262e6d728b3ab014caaf85ffae1921026255a47c6f2e09f2af0761950789056050feb2621e9c7cfb87e08f0b5ebd5b525f28aecdda0f9af1066a9932395493c9093e80849790750cf0726b376e8a28acdeba269672a745ea88a1594a68052d3ccbbd61c48477c3732a91d29e8719524573e07d46eea2683a4c5af8b5a9a3d8fe0b7de589dae517c9ae5116629afeb45c4879f50fa09e45a0e7cb919fc5c2fe15a8864ff833f7413b517fe31cf1b91902dbf7582d8dc3726b071126a1f9db01530741e9028d95d398ca99e36eb61b7c62c8fe75df3f1ca47c3e6afdc5e5be2e80f64ad1c6fa9815cecb28d3c4a1ba72cf7a6ff75e8d64011a96d0b579101d733ed894c53f612fe20195a7ff9114296c501c23d0991b413bd694eb3c033871f2e99393b1a98635762f16d63c6312a8cd1335fc4f095239afb8923e6a7f2d28330124f883734c274818a8cc631a867c4d847983c13c2b572a4f4f4e2c0aad17ea944775ae76d0814de81147bd0e3c4d9991f640477ac33dfa8ae3787800bcfbeeb73d1dcddd074ab2f372303b22966f07586bf8bfffeb35c52b64b022a9c8b4f8dc1b9641b0da503aff854a815649f77c7ebeba336b27d6bc992836ec24e72262ffe71bd0cb5cd9687a0f0e8796b46fe8b4baeea4cbd4798d4e5386f340c737648d644c55b203d454fb780139bc95806046a5f49ec6fc4883f17c6fa78da0867822ff31dc516f6ba6b2b269de819263f7d561320bb7e4e6673f6cabcf32a8dcc7bbec4e3a3149b8d9964305d4241b4f48b6a9f6e2a486674ba344f531f630bacb1f15933edc159be971ca3cb29ee8631524dcc75100c4f9ae474438ba88f3804630ed16946ae32152edb8ed21bbc00933c6fe13776622f842da97748208a8b3287a4df31d6fa1c0d4a1a27929cf153952c332ca0a3e562922bdfd9286c15fb548f25793ad84010eeef6d2de68035b26b0eb7ad405e2cf3856d95a8be9c825e009a47c8da1888f04da0a4e8b3c24e64b6acb3e5532799c719b4e5a548e25918c9d7bee9327ab7f5633d52f423c6cf91e154ab2cd6684d93fe79ab83e7d9a0295175005de63b3642b889cdb7b82fa47b169d89748bddd1e3008199432dff19b65edd69943ee634fb41a14849078925d7932d44f8a484168a5d233d4de812eb417eec43771cba1806a8cabacc00dd8806eb348e61b3b64c92798bf404d8bedc6cf2c7d20a9b7f4f3a4e8cc3ec4240901ad9f16d7dbf9246effeb45c4c563277aafec5e4caf6f6b75e3bc90472b010365d38dd84d9e1ff61f47820580228e3c87d7c369b74eba949248f9cc5ccab180ff664f68fd32f4725c473d009a53b150101859e5b128605cac1a5f6593faeb2129574a806663cd42067e1331871dd7feee168c35e2452cb2ffd6fb228d89fddde4749ec430dd2cd030396e86401e6240f439a36730d9abf04060c1a1728d53f51db08b6a09dd514bf5f3c43b2232aae7c1995916ce66d284a6751862b07d35b17fe15fc11c1e353770b26039022cea1a3af64993f68a70615085e3f85d549af1c349210bb64edc8950ded153410a8eddc4797a55ffcf52ea958729d177e205fce40e5a1c7c2da904a6fc4cfc4dc2f56260a775140ac84794f1391ae5ec9de8442a52cf0b439b1bf889f0eabf997fde4ab5e5405b7384e0a401310247976907eaf96ce2be75a3bfc7f4c0261ae2f82a66d51deafcbe6c59c4ed0a869c8d7ebfacb628872efbcb5a02f4dbbb153a585a04839970893b6ba420dd87bb7a78e5cb593bb988566ecf32ecf27a2cac85ed66be268773a71de3160a4fa43eb1b1c3199964509e50d897b4d200aed5501c43fa02f7d4082434e6b62362f84f478586a6676a4a08dd158e4b7e588f346fdbae0a4da411550add8978f49cfec281087c7e3a4bb10df1c089a9d2f36d07e24c39d78b8ecaad294490849253cd82cc07074e9920fd4050f4a77123127dab9dd104aaeb2a50b56cd778b6fbd69156806c28f5613f47f00ffdbcb894e28384a65d090bf062ee20acd2945c52d2b4c36c63be2e1e35e8845d0a523527c935e42542dea926f9e6b6b6bb039db3775fa9d92f72cb69c272ad5792d6af46d37c0a3c030690ed092f888062ccbe91b8671fd26d332c9025bc5e7a138a2b62cb89a446a4a802708da2700184430ece97a493279a0d46deca321fc6b9af8e1f91188dd1c2b57594bbe155daec32adce58970800ab16b266c24820c2790d28ba74a33bf3919020b250c73274560284405f6a4f72ec196d63dc45e53d8962855f32ba577eca8093f6bd1fc12750c065c251a2bce1e2cb84897ff230088d46e9b41dc07195bdbcff174b67dcdc6b26272370c9bc5a5c7d5395a09262dffceaf4d31243159d8e6fdb87545cb9bfdecf9681467c75255d7136924a5663286fc5d65fb17529b79ebda3a02324270f8274298c9c4a71202ac76fc0c16b2c5be7a390207c4238c12e66dd6b424ed85f1ee08072174a7f5be36752077fb7929a97f26399aea06fa65c062e857bbb3db7eabdaadf868890e27142a4dd371b36a8c53f9c75d733cb28f1defa59311d84a4d46f807299f3c9009a6b7f7ac5d63a813c7c7b477a71e0faaf28e92a467dee752b37bf76fdcc44079455ef0aa43c9532d72967ec21c5f5c24991c654786ed6bcba146a38713d5d87b0c90a95f549c4f1142b7f4770150483b613c9c6d764a9d182febd68732ee3a7335fb621d11d8f22360fba7454324278ea58efd33dd9f167963764795441b8c63e8e48e73b7bcc281a2c9a102560ce9b88c9d62453e8a263dc6677c6347546366ec991695a2ef4d32cea26bd3eb314f58f9f6efd2c150bccd1b2d80bd0d94ae8697b300ee86aec0b6912cfb054aeca8ad8d6536a19430eb8f8a8e0e0075504a8084ab200554704af0a595be39fb88a07302fc2f290efb8f02a7577872eac9473386bbc9797ad5fb2eef0d305f63441435307dd307468d24eebc4e1c286dbea95380fe650137c8bc5cc846cbecfd758dd88aec09af28e36aa1065fb98af4f905a6f1c390222be662fba51a4c78a597d59fb2e4a7c9179d9519c2b4fed18b5c7d3b96328ba5c649c477ad0ac1c1f61d044487c4574744c51b858ebf6fd3ca25b37c7f4f8aa7f5cd67a5668aeb92875541f2204828582670479bc93fa357203accc7bc3d486327ec8ccd12b021c70a5002121711efa35510cf9a45f22aeaae9d35000220120798c02fe6104bdf28e0efbd39fe8cb9b2a0da07e539d2c3732c1e731a588043b95603996e36219e08acde53ad1670a51098053a836eb376de37737b5595dab8f867af2cbca1c7a4208880e2be26447cfbde2cabbb1a0876a822e67b40f539170e63f56cc6c7fb76f743ec0f024f54fc413ffcb1a892555effa9283e09302e8d084becc96d5a04598dff1aaf493261e69ca68c9968d079471f42107402da027c901c48e852134d2f970360a3576440e791240759064fe107bc498f453ef581a23a07dbbb5f49aa96aa1c2c38475cc4eda5c7d74de056963b344c4e21645775167695d74e91460f3ca4e4cbd97e8d8fbb843e868e985de4f82beb64173d4309c84f6d4c004a48e2b6c8deb3fbba8d054565fa697ec7d56e9a00843afb22efecf57dcccbd055ae51e3a9cddc8ba42f50e4b804a719bfdd09ca243dfaf82d883b510d04abfb6a59a507d2afa13a19b31a51da028d1030b5ffdaf08bf0b994ec2673d2cb4339ee63cef658c0f11d9bbf5db40d1a4a8bf89f3dbe4b02f5a25cd48b34341e597a131c6311e4c73142255dba42b8da588f7b40f2b02fa5defde052c110edb58bda7c9b413d84067c6ca767de8a1d6a633cb7d61f7004c431e4f3b87e38f0f3bea634d7fb91cddda4adba2d6a1784bca799ca939c805e9f6b782b9e0042521ba0d5733eeaa54d07e6b1499111e72b4adf3dab708baca52ad677de53575055a90f509ba099dcd559b040393abe6571456069d21f83cec07bafd6c8f372a0c34324ea349ed9e8d8caf4544312732ea3c44c0eb2680fc268a9ff6cb2e0cf9caa07e2f4afb2c39abadfe358fba4d562fc683606501dc87fbf61df9ef5f759ad319bc633c98883ce1a00588e328bcaa66c2a39551dac554fbd8c1d871cfab57c95277c82b1470bf6d26dbda991885358a85669de71150c8f08cb6ac274d648f3d1535e0061593803f080e279bfb52c214b24c1570fc57925c2cfe4a7861fc54f4a962ed59e9833f1c2db7aedca3d93870d046be6a734fb6c3e323577a56ac7529818b146760607fafbf759176a37f4dc7e6f1b8febfe7c03eb9078d38","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
