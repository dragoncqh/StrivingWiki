<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"418b37a7a46998771dac11ad174e8c93516ceaa96702b37c5dbf1746e9b896c61d5d0c9d1fc9b6f617483cb104355d4284f4b8d029ba4d0a26bf127c5547ff3f85ad4d1717c745486e1b3e5bbf07ca626e6b9251aba99f175bc646fb6981b26811892b94dd7f43c1853ccb5664fca6d1cfeb7ff913f97f73c17af7101ebcc1c3f94f7d8fd210dbc812277b61bdd857a3aa634c21bc6bafc3f9a438180c0072ce1392ac32cde55ab9af2276e215d7ce1aa3b8a7c39e0d668bda1ab45232725662d2e75f4e43c8920af754f3a505339f4ee7a8a52f0428f2f9393fb6c308e86f0a2364fc2f972a74d027914068f18f3813a4a89802a4c5138318641185f4120e47d48949926bbf7501c61f11c1fe36579de24d79aa2f56fc7db65540bdb271b336577768e66f319767096f4e2a495cdda0183b19504195b722dcb2ca2df551a0bb06f588268caca3073319da2aef28e6b196ea1cdd6aa7e0f6b4ebdaa1a848cbc84f4aaa15f7fdbe72533b60cf140c9bb2573e5fdaacfcc71c7079a4c544c475ea916f19110a40b4cf2909ffdf8eddac427dff0c62f928d904cc5d742be0a3fa53e67d717df9575405de45bc66b5cd7d18b1114af327929744ccaacee0d75011c4dc4f156406ec12a1820af97e0efd155e6e610bfcc7c73312082dd76bef7eedcbeb89cacc6db05aa8a5fbaf01cfba14c48b69597aa0bb5d95c0dd691ffc74964fab9746ce4e9af9a665d73dbd2ed71037e7ac300585296d88d2fd7961d1fbfa11388d96e2d17dbbc7c9ac77c45b4a4fbe372c633e6a1e923de0c33a3ee1a4e26ead5609d63c22682811b1ecdc6348498cca05e4db78b5ad6a01516d3f5a21e3c4c80e2df42aa462a136afd0f2b73345271908f3ad5f83f117c7bb9846031e5a246de6b2299398e9d7f2f59c04bd03718d4696e47ac8d70865d6962893f66ea5f93075b5360461a43ad00d4774c5056d687d0eadbe6b75c91dcd02c151ce8bbcc96929c79e03367eb04ef86f38eb51a39e1adb7b95db202cdac5df9d4868d449ff6fbb5fa02bf080f89b40118169d7ff7c63a6ef0c59437da7573105334cb0d84e36c922f842085bef0a130dc7d224bfec69068720346cda93aef804e27e3c7b8ddf994a2d7439f504e99a411e069b776a0abc5a31c5ce63700583fab5fb3abe1f6809e33cc22ecd225a646cd43a8212152d5d067a6f57dafd50becdc937e1b82a3c21219b9f4e589597cd9d7bdb652cde62b6f137ff2466d27a4a8dd42cb743de92eba71930fe1a5cf663710de670d076c9e7fc31cec831d6767758faacbc6bd86feaea137c124becf0508e7d78eb674a4ff7e2f3bd9a31ff0e5c018567a77387fde96d2f7888225286150da35268a12644f5084187526b24d86f028c45ac9df1bf1d79d8b0be07307a77aaec211aef7db92e72c1905fc7eeaf5c0a5975520dcccfc1ad3b625300714273534d721d952a09983fe94d0eb3c84d530456730de9be86ec8ff9acd9a7104940bf12e4971c0799a1a56ccc509e8f57a597331063c85b271a1d7c056b5fbe6e0d3bffcf7056169ea64b02bff355d46e4460c6d45180d070bd561d9834a6137827e46c415f7ad68a5732b302f9dd1308a342759256d603b5cbc28c474aad6ded407188d217160bcd510dbde459610d0df3a79cdb23dc7d6096dcd9869163cad3e0794c8970254391d82bada4264bace7230159163f8eea447634916a32e93a0c7df806c6991f60bcf898f61ede2ce05494e6bf667dd382a4a7a8a6d3c18187f4251bb096c61af3aa482ded4f06dc30c90e5ff1b04608febbabf8f26b5c7d86f9b9723fa91486bda32b27c17e1ecdaaf1578ac6a1c34dbd06c3004b69118ae7fd64c7baeb6610db895339d6fcdb430136694780b734b38cea0494e9d531473063fffd207c0e3894fb72457eafd7a1f80178232e2f47bb86142a6cc1ae091c5259017aa2fee5957adb7446141191c4196b64baaa7dd9e636081b5b9954d70e1b2320427fd4b242d3ac9ee7dd283bc66b70093897d0113f1d1d7634a09fbea706ec77a31295812d0b6342d5c78817ace1a0d545e7871c3c716a5f10db78b87cefe4a9f90280803bd968090d4ddd3292c6ab5d50f67508da21393fb065a58367e135c3ab4134ab1d79aac04fe1d45b5c132ee090cd4188d6b2aa0197efe7be575ce67444754a417b655fc78b2e811ad221d34ab9be8c7daa1951e7c7e546c150521ec41df8c71dbceea078feb4662cd2e0d783830581656f002c18a71bdd9d5c813ed3e6c501883eeeba063450d42a9fba7167e7a4ef04278f2de1a433d357a40f7602640e321580d4f1d386fd8ab99191cfa4089a247a0b6740e8c31f9ab77f6ab5c2599ff145332a86b0bb3bb7dd301358a0526be6cd4e42c7ee758ca81442f2b96d84305a1abf92e904352b1f0eddc9ff3631724f6521e793a66a03f3358cff6b94877b6cc419cdbf33c5e9db108b394943f97924e9266ff2785cada9f6ff0890533ea08d1d2e2da4446e8da41be2f1a3980017e56dcb083e5b8af1fd50ddf06289dfbc1716c28d56cbd310b3e5855e050dcc7e3950aa84aef8506eae94b1f1e212e3f79a90cae3bae51fdc2c0c8a425d55cd3c0b4efcc052f958d291c5c0951b821fe5ada59509e1c1ae9021ec96ed2c66f0c328dbfbd83c3c2d22e4e1263d262f5dc315859f8ca7cfb2629315fae670f97bc68ab61ac019dbfd95564054b90e159f8c290f8891dab016b298811daaff2487eddf7b857293e81bad7580b09abddb8d6ed6afa792b38b810db028f21555db9e4a9fdf519eb78d7ef7a901266f16ec46c2311ba0928e688417363322c017b1f0cca4e8c4d285eddf96a1d223979975f7deeae819ff0f600f73ad8c99a0bf4192710dea22d73d238076aee4ac73f605eee4bfee037b5adf6708eb0d0fa2b0a4fc44aa0ffef1e5503faa23b3ad2a3641b5421ec1b8a87a757a97f39ba0f66956d9d9dd2b45da8c456c4dbb78ae5ad2271ebb576341bcd47fef71a1c5cc87e79e6e248c35ca3afdf969165b3c3177e53924fdb497bb6227cab25b088ae3467408fccfd72b3c7177b40a4fbebcfaf7f4768324d2363772db1092b82fd56e84ffe97a3a240f9003db71be829f6d3d1dce0ba1f85968979e957f36192095ed5e88616a76355e5292e872a31957490364ce6250d8d52921667c7be39dc7ceb901ec89e27375d43e30b9502c00d00fe6e321138950c9ba60db7789ab020d3a0c1be17cf7f7a4f21621085550154de5b69ee8629b47f8c3d29087ca965ca613c4d14f6705a967781f31634a02fb4879b838ad3454a81c9df22c38d3e0b0a83c3c168d85a6d310f9bb748807701d4f85bd5b5e8af3f07f1fec6dffc79fb40985f6ef37a63031f95066dba042c49dc71b958ab1d91098e329ab75aad13e24d9139a905db07858c089c51b0727ce23ab9e2c47b9cf4128d25a5b90837f3fb28d906f4cdd34ca5b7fa625f12bcf332302e62464e8a62037a88b0f7b7443ac196cfadd39760f2a83c442e9298773303dd0acfab45dfb137313c25f7cbf68c984e4e7c785313e23391ec153165f60d713851ce18f8ed07e6dd9bb19faeefe9825ea853fd32d29c54d22b915798dd625e29866326d48f9fc0c69324abfbab226f0fb359ea7ea79913c4a7c41cf5ce68b7d6425ae1a7aedeba0e1aea570feed3c649b1ac12b70eee31d6016db07b21a125e1c8d000b57978a2c6487ae70fe5d6e64aae71d676135fbd87369a75b6b3abc418505bc31772494f536cc0bc1d23d2f52b9bc59d0aa219945acb232ce676e9079eebd09202d8daae9cfe154d686b448f89d6c741c22e4504f9fdb34dd805589908c240f0e0e8fd0d543778dfbe0bdd0e8639fd89668123c628034f85d536828611b017129ac324722833b2778d99ec3e0d2f7dcdf8f905701cd6f9fc75049f540bdcc8cea0ac7e794212d8aa4af52ffa7cb17111e7073d5e7fb79952198ab14fb84361f92507e719556ad8f7137bce3b924e1bd2e74318f0b239badf590dee8522f0365f20388f13669bf7232d582ababbb41b2f1625f8fc571fdb60ea23990f911237f450fbc076ef3db270cd609014557aaea28a64d888e47ee90b0a6a4644fe873a87edfe32f1a9594a21ea6b666a61a234eb0aa1b7559f7c33a4518441206c7e956e72dc3e9e652a37f43326f587639fcd3d2278205c017b670ffc9cba81b2632e6b5656a1fef0060ad3508cc0c2c2feba547ca3c92afecfeedffbe4e61dd09a1e897bc88f280bc219352f98aa5080e23a8f52253962798047bcc6d4385c198e2f3cb9cf91b8b8ea1415c6221a6902ce11af28bccb23b0105e00c22d5815f7c79eb7e56eb3ded4c421b7b41ee566665bfdc6e6cb27d824c47cca5c7f99d65a3b08e3c8f1c26efbbf20cc5351ace7ec0acf3ae90e996febc6b4986e0ee409a046b84935f19b75401dae470326e40f8a341883bcdf56c8e9922050769162babda0e2e696a7c93f2c510706e7f8f7d1b66667a0bce157bb88d95a4abd766c83a43b6d752ba458802c07a5f931c8f9cd297f6168ea34d72939c21b0f681c907f5e13b63b134186e4f0edbd62aa8725e5f20400a3318d7aed39c2021f1c2ce5eee681dec223738eb548ae5afc21b9cc70625ccace537c1b4f3f5bb1d84c29dbad4d6e81bd1c899113a8f15b481330625c909b3acd36602634358782403d911863f0575d53ede4fc287386f1083ba93fc43e61b1d3913df9c7fe3eac72d97109249cdc1e0acb21e7e406bf4e9ad6ecbbff0486f513573d3c07fb23eca34bab78ae43bb06b93656db2dbeae13f5131d99ec37784defe7d09afed240146a1f3600d9a53a5aff89716e92c0bd7f7ecd79cb6b81b9c9b229ccdd381120276087205e2a1d44da339fb53797a12110f010b82d5627ccec0b55daff865e16e0e2723bd33c5ba937736950bf7169133a1ee0cd7600bb9d6b982cdc7a5ec7abe6b3eaae5d923c3fd29c28179ca4eabd15ba5178697acce8dbc8885c6d31db51267500067dc39d84cf49ab8548a8a9ce72d75a6ca07327dcd7aeffd3b06b12ace34fee500dce5e576f08ba8ffc01312e9da2c4c947c13b3176d09bc43cbf54ac18cf17f36950df05268818b0743397a78b7c7eea4817ab95e65b2507953e23ae625bac806c55174f856740b3132440de4af24202703b47422bb84acde064268f3f081ed22406ac0db6207e1355d027d799912f7f221835a1f12a35d5b103964b73848be663e7af79feca6ee977fbf8d1533d45d1813deb5d56b9cea09e4e16a9f0a8ef12a3159df6e4c09e25219b56d89574e31ed4ab01da6c30d5a8bf78ca79dc248e032b6ac99edf4adc2dee7684d37698b3f436c59572635a905e50de7734eb8dabdfb6999782f385dc22628fbdec74f59f000ef351fc30fa7248abd3db1aef26af60c96ec2183bfd4e7be749a9d684e09834d16cc2301be5b64f06715c9a6bfe33d67e7569dc99c82b921ae8abde43f46c700ec8e300e43dff6dbd888fd4687e221249d0bbb598b227b4f24dd1b833036e354e25db0aaa30408c856f63f3232f8fa3701c8249f6f0e2b4fda365bbce3cac68841ca409f4d8a2f08de7c2bb77d501048677941e996a623b3045df31be3eb4a207ac3e1ef11f7b3f100d3007236e67e645857a2c183ec08f1626b65d810e4bdf08ec43e71270af15e2475bade5ec17b03268631fb548bf90ce130d0b2596368972e26be65fbb8594360d771cd86b4e179c1b5d19e29527ad0c8bfc8e5fd3d8e72bf85d1abd85c854ca1e2d2b80847a1c2f960a86d0f502fef4329788424f2d87f05ef0990ab011fe0bb52210bcf8e97e0b31fe7b168dfc59d6266c9998c657ee703ba577a2a98637d219586c6119f4869e6eae42f07f74bc90a6e23c6c3481dac545f0375b3db9e1552b380a59ad6bc34e66c456cf9cfc1db9bd160ac515ce0a17237c64412cca254fba96eb9ca5474db2438aff10f367eb915bbaaa01ad4512b5298642af1fe07c5e2eed4342ed35ccd3d98b21db70c35791b5959f69f91597f0137c40247592fcb309f50fc7a3d709644ff0bf98dfdd6e15597d092be243b489a83ceb90034b3a52ca72bbdf314b2df9e6cb93ab923c4a6c98b103394b4c5d07965d9626f6ba83e4417bc396035d35a1e8161df6c8532155fa49b1f186c3a8378ba1cd6f16008252325be63b22795c97a0c8cdfef38d55793233f267ba62ba5d88f5850b25f6b140975e9c774a0a50ca3a52403782ffe4086205e1e61c01c6c5d3fade20b86259a0e391e0a85b80dcf03c0bb4513c85c85da70624e9c63616e466d79762e79e0de7ded018907adfa8c63440977866fc67a1b5c6b27a2c42685003785dd2a5ae787c5ae6e9d31049fe520e9b16ba98f352c6990f93cb5ff1f712d7686b863e3dc56f57f4a7fdc5f6194bc530b5dd24a5048977b026e63aa8fe9ef41b67c7810afcb829949b9f9bb0ce7d30146649cc83d173bd03f8f91f94e6dcc85c3f271e4e3026e21492b1aefaae3db2e2ecd72afc1dcca0d19b73c66d82b69f15cf4b7c3446fcb23f52eb489ac5f9d29a31353c36d5d6fc3783da786672c5d2391da1668aa9c06e4500cbc0d12b901b7adc77c51c9f5c6171a0e6b9df773549c2764b4d184e6e6d0f62a118ace2fdc300d39c8a0ad92c70fc716b738ed85e7c68c7457c065a9bb40986410e3e44a530349199bf5bb0b3d5211db1ea9e28b886c89d68a8eb11d0cc90c96861df59141750998c6df7da65094c7d0944a641f93c9b177a6c9794dc14c5f49d8496da2e5af23cdee693c7fd06f19b38802f1f5bebd6331f59776346c2b0ce1d4631db38d2c4058ff7d099f1e2fe1a7f9da8720617f975b61c4eb3f36ab8ead62067e002f6b155f35356e753a484f973aed9c6ebb5cb2cdb37c80880aeba71ebfbcfe904a56296e836fb591cc69196216ed4f79e69f93ddebca928bd848fa5632b9165cfa9ae277dc62d9eca1055b5a6ef6699fb5c1b28d03bf2b30cc9651a9e11ed9271390dd7f27a0745c9a3aabeb9496bd22b810ec9481b22d92abee6738008f8c6453addc918720fa63b588054d94f62b499b30e1631fa190bc48ce6a9530aed98df429c3b6170d7c831160c3bc81527b239bdce434cf240bca1432d275d4e9dab22ec0165c2474139a9af1c83283727f86e46c26daab2110b1dfe8321ca970d9e0d2ccd2ef152ac73a8d87f24d37e47b7cf5b6bbde853e53e3acfb69cc00c1dd311473688b1c618f19c91a376ec9a839a6add4f1514df86441e4150c349d6fe9a43547771e86ea58a55538d003f4dbeef12dc9d4eae5d9aa9ef357ee591e572d3ac2afba02d7cb7eb784baff676821f7a9049d1e1d58d3d6f9330a78519cdff9cc62dc1256173ac249efcca0ee3e2e990e3bc629cb9adb73bcf75539e89dbdd2ebb82624beb32d5e263551d19b05453450476fe7e7f44c83dbde8c533851123ee84a5606edbd0895d7faabdba292a0aff3b7d1c4215a3cca07980b4a131537411fbe5b6a33fc3201a81caa38739f0dd877486d90836fe8345aa30e6398515bd7809cd30170bf48c8be75bd5136aefbb3ab56cc0d487518a0782828541ee1cb2a7ab88fcc3d0ef05b15a9f8013598f7150bbb2208fb758c02f8fa49ca40ef3e29186236b15f156abb3cd44e34417d4f8214d90ac8ce4125b745a01d7f020579ddee639e089efb4d28985e5380a7818e4b82ca005c497bf4b11d6d670016f7bdd87ef668683f79973b8321fb1090ef5596a3c29868b37e7ff4bc01c0f8074c691f2f25021908e36525b4e1cf5dd253406f315b93022ce3c7adc50b3fcd4e7765c6aa29b62256df59b656363fefdefbbe4d72c69c88592af61202b12cf12861138053ffc52f2bada398682472f1371493f7eb53028b388e1a74ff7b5d6781b05dd3b018a2a20de9a17437ec123c13532601fc6dc2b7f0fdfedcca1c96a512964dd8ff755d973a3840b41668912ff66213659b76bfa7c3bdef8824da1b6fe2e36d30e14504554dc65331d1b8f151b230ffa70962989850a656a0f2933a8dcfa5bb15fe6b97a24c25170c376691668dcd610b51354d099d8ad6449d9be129151a23823d483e2e584a7824dd2fd9de825acdea0547e84468399d9421c582f25c9b8cb65006123f57ef2b320ee6c27647420eef0438083e6539a93a4932851748ee7023f833faf54ffca503a72bdb8369e576f033056e48a2054a283c90f91bbd61ef5d4bd97339eb71f9e2722d6fdce848beab2324586832d77379171cda16d1dc4a98a2ac2302cb98a2ceeb2737847a1fa61683ff6666a4c0d8a89678dea6f253a1e387e6461d3d424fae49f88bd3c75736b496ecafe8ef700d1826f4a6f78f31c6ad4ec20f149af93ebd17352320f176c33a18c3820eb34aa6f3204414ff640d8cfed9a9a380a77dcd11b0637626429ba936fd4acfd53d843f654d2265d3ec02dd11a05907cae920aa8a9d5895e734c1bc33222cbcc67ae2d0de16ddc4633624aad1b7ee158ad2f4c72010a591d00e3166aef23fb7df4f86a782595cd974aab2c9827f609df884ad14a98d755396a797c5be7725893b36386eb46ad04d228bedb8442334141ab29f0344991f09124fc2c0e33e859a5a66f3d78881b2994083de39b2113bfbc159479ebdebad737e55e6583639ec0658f560405733a5d24abce91dd4553ae73b24f309aeb7f77e5a51fbd2ffcb8f3fcbace5ab9a3c3d8b9a950aea96aea2d71c19e1ec8f6054c4b1654c8c8aa003d06113ecbf5761e84df42302a321eb2a1f615cd0e30ec5b0b49692758d2e4fde88fdb8d6a4047d5b274101a0b74f80f4333ba726b0dbb0bdb3d910cc7ef6283635175986f712dc0c642c2d8416a202573de703e0df0b6b905183bf2c440817288e5c0c67e9f287b7101be6f2eb7e36e95e7d392b16548d79eff55283e483941f96a0490168d24250ef47bdd6fc43f2d52ae02588cd0892a4d48aa14c5536121e1f381e53e1f432ebd14e57c740e9921a2a3969fc8d275895cc2837454d427dd3612869e2522ae2385a29f5d2dc500f4ee2bb65277ff7ca2beda790ad3f0e4d4411f3122e5751b4d9401fb3759455c21db35f0248e56e779c52d69d72b8455b995731994cf88788f1891dc2651590bd1a56d4790c54cc811a4a462f502ffb67e6f410795e4a0cb7a998a45aa11748d07117cf9f111424e1daf1c65480088dcd777e7bd6ccdd57d7682479e7144fa4dfd120dc51451c448ce8321a1aac786f77f5e77c0bdb6b73152e8f85837ade64afbff1f2c4edec1bd976134185e9e45462a9c2a406bd9ef7f36a951a583bffa9f59aa1f26a2cfa2840ee0e7503e8e45ecd6f15e1bff93359c42c1b8220ad65e93fbcc8801dfd9bed3d9fb9a8c84a5fa1018eaeb1ae336c12aefe46d8dde3071809439927c71d74f4a5eab423291dba489d5f1dc36653dad3d1eaa101f73d9131221d1a65699701c07ff61b467bd6ce3ac207527a448792d8589ea37032008dc139c08f11ba2264775b767f88403a84bd0e9bfd588b122eb03d142d70c603f2dd0b90c333d3e80a93bb7fef3ec8f19ad8fbdcdf43cc24b0dd2b63efc96a800e210d3368125ee6e079dfd0543171b603233211c629b5f0a07ae3ea7af0f39f054026cc161955ddef62fce4038723b376483de27a7362283f577150baf8a3e240214a61fe9424929b399599fa95fda4019e192ca016fb05334effcef01092312fd45fccbfb4f18dbfefdb19233ef3a50c512694cf18a510c0c97e78bd1f9f78361664a5a9745a314c235f34113a823c8a93fe9e6fa6e6a2e8b82a661bae58153e029a11aac45aed73de531c6ad3dc4cb745a4770fc3cad52be71bfa1511340df60f226f69c9604b474d068eb7081301b37d0778f07fb1093cfff6f68f711e238ed67c0398e997b78cf777acf8d0ed2bccfbb3c6d332772a5df19a2194eaf625cc0892026de7787e1b2706228c9a0a2e460ea6ee605001064a7768d216e0716796858e5467bae3a674908b5c3b1b39338887709d8f4d8ef67bb66f562eab44d343d1fdd32d870ff3553873af90e38aa0a338203324c90c5168cf9a1ee21a8365cbeb4bd345a8f5e8cb53840ad9ba03aa6472e61342d1f047329be1195715e7c1e6b90e17dcaa6e0a62dd1bd6916192acff5344ddb478adeb2265ae27676c5f0e9600e3ab03c2d6f4b860c31c5b896fb07f5ebb98b32bd6c0a772e8788abc4d4b5779fad4baebf3997e6e2b056c0104a383d7edfb7f9aac2ad3517f38c426c3ef93f3b6f190dc73b192e83009eb36069f2f49bac617dd83bd3903df8dc52febcab0e0252a8a38106018cba8d06e23e044a189f5f33bbb9b7e71786c51a7f40fdfe5144bb8d4496c24dc494fcd7cd75e6dc59b7bf25808876391857036d3933f4a200178779a33b5055d39e384a78b09509801c9f6b41d963fc0c1033ee4c9e1c92367b69dbb62569b5235a8cc3a0f59c7375cf2d4782e73ac3cfbc92b3e0d7e384f55c873d965eb6f857633d518c6bbff4eef0ea5687e3fe67a6a4ca727bba556696b45c9c75d564289878c660d3d993ab6416359def80fef22ba6abace49624967c90e2a6cf1ae13c82aa460a4b00d4ca7a84edc9ab9d434e7e8883c2797a5bdba2adeb13b473874079531d3f52fc1a7351c094abcfcc5d017cd7a1832010879bfabb7d10c05fa9ad342bf6c3f972c36ef717866ac5ed2f5268aea7fa456839a394ffa61d601440ad2386a12ca17af8f80b7858df902be6c3df594d86da7398780a0cdbdbde1024f73902906eda6ef35f745c968c0c23436a6e02cc62abe08b34081b2e28be077b23cb4df43c636671ca5bfcd992058b2506c5b826f4c83fb5ba1bd07b365b2d31fa24a7c50da9b9fa5ee93528fc8d2c5ee3c31df61ba25bc9e1720a64939ce43a120ae96357e3ed1b7158f1285a4094361a64697447e4d47d5f32ec6532ec7e84d5d32f5612e503ffae31c8d58c300e464a3b9b2300eea40af8ae75404520ebb31323b169abb19cfba8bfad9b20af5e1f8250538c94a1a01835c4291d8540155a4c1eb18b01de4008fc4bb46d2aaa5b3d329239e2ce1fe4c347f64aee4fc9ce2b02e6d2fe6e485d99141c817a2672658bdb03595c4a5605e6263b68e5727bf8ae942bac3d258c1a0b8f890286bdd0743e5dd1ba5989c7e650cd0a7743da29c355c05c2c340ffe26ab095e0a008d7ddff335eb98708490e23b975fd63b24863a3f9545aed74881db22f84073bfbd953fe7bd10659adfcf91cb7f57809073a5bd713ebb95193fe98922cfece259b8d8e547c8179e7afe4540751308f8fbf49743550879dedfd57d135d867a1cc219acaee3f2e17db59a05722366b4a644c719476256c81a7f11eb4ea94df57d9e27bb9457a6b5204077b1a44f96d8dd1551ff810bd8e14ea5f47604e65f56a909f9682d5b5f7d04ce0a6bc99fbbdb3c638fb2a81e00096d5e48278cc4d5e45f664aaa7c56c9f1cb23d0db7fbe7c48f89834462f1a2c35e10c413b72cc3c8de55bd3689473205af3dd1bea8105ca7d3c57e5f77f679bb56318232d8b1594bdd72d2f6c7be20b32ff485c6f92d213e9f97c796d96649351200d6939d4de2485b7535c3df7edd33025a2fa5120bf4a5d513deac1b3fc76b482efd93c8e0877d1b88d9df12593f0e3075bc7c604f2b8c1ca77970b0e4200177a471df29d055ae67e1049a9126f0f54e0bdc818f74f278ba2f2aaa30f9fc5626a0c34544d77ad2589df1d1d1f8ae8b1fd18486c01117ae969838467d4f3360fcfe585b9b91733073f739127fbfb15bb1c3c2fe4f74b6cbea0d362f020f3e62bb5eb1766f2e55a36f8186a21bf544090946b5ce8b24b39fbe98d17133af79d70b2c686ee04391f4acef3d394762a5606d31cf79a16365e166c5d5472ce668c092b3d7ad1fd84deebb31e423b683a5c4319d0611fc26c84c7dec1c7a20586a0c851433c7acc2fafff17e5d59b3ce8d962565f0a7065ba94994a3edc6b1b9831ae81edad335a730438b345f4e084d1085f414795f5287bcc958d4e45568227e93fdead53243e3f7e6f348c95746cb82c358f7df1140fc949e521f02c417c29240a7d8da91ce903da05aee6141d04ff694d6b91728217072ea17ba293a25bd493b6df3d753d1195ea5c935b78afb2295888468be770a062d5b2cdcde4dbbbb2b7ec06115a8bb601574477f771ede232aa5ff2fe79867baa46e8c5fd416a83e439f83e5d02c620178eb8fd8668c1bd2507eaef832b320512e27a002318e6ed26113ce71b0853b64027853d4b31580ac14c463cc1d4d5f43dd1a1dca90875fbbf2cea690617a3a81fd83d1d857c9865e21913041b8926c91a1c11c08a6d84151fd62772a3bf965768dcea026c6552c77d505ec9a716a86839209579600213afe2e47dae98d4efb68a1bdbfb8b93b3d40aa53b5504abe0d745cf1a0fa6097ed400ebefeb5dd8ca4b0da86f8ea518f89d913fa79473d54db807d111228d63141696363e5d6db82a9ea89902ac16965e002878acca609799d448355e94bd350e3e7c72cad9496de1f88bb0a446f21f368d52993b92380f75c6836000cab2b462c6144e62586a01026333f62a5ebfd94fc7ed5f1f9df41fa3b030660b5504fe7aab7586c544eded637e889eda6e1196e406ee8bb2d50836c60c511b80043e805aa2a7cbc8aa4c176a5dcd9298206240a2ffa24fb6d0effb90c4ae188b2032ecc1a44cedea900aa68a115e03bb61b4477dc0bbebad37990dd4d359937a6d50c8c6db9a76b74ad06cffb18c013a66c7b8822826569447afe3c54623d483b54bbd17f7b79c59f97f930f8c01e479cbeeaca40fb61e36739eaed0459cf3fc0bf56bade5d2410fac3731820efa34c332aae83afb4ea71e54ad73624befd9f006dfdae7176d414653b06cd6d9fefdca4c6e52330ab6d2c3d520ceb50f8419cdf2893f76a9c1c8001063c032a0193679abbaf7ecd9ed295e7b4d409e0c1372373475b4d32ed1e45f7ecec248e25434ceec2c190be05829905b652f855c6d648ba5e04cdb4c2efc0e94c267da0ae13bf4af68d20843c5b6e3200d404439882c77e316ea12c91f8ee8f9eacdf4dfaf71444798868988dbc9fefd691856a8a0d071c7e2d961bef9eddf31b5e65cf980cbc5e061c8547e686dc9f02d04b8e398f3cf770496c7b68af6c52d99518f5c70cb886c9dcf8239bc39e49aac2d252e9e15332305dedf3ebdb891efde2fe3e0b556aa2a193fdd3b2d87169963675b2586a8aa6d5823051c80c5c96933df947e8f5b9c40abad7bc5c9800c12f0c3baceefc6e5a593b30e5a88ceb881beb05371988fc29ae0f91617ca1236a153249aa2d0c6bbc21c9603a3a609f95751d8cb2ffa4e4d831a94d525cda54a8bbb5349e357c862fb269369b976941af040bff4aca31d70cae925e7c2c3c1d986f68079311eb856ae6848ed55b7b80036a76e791fbdbb23eeae0b5b71729b0f367db11fbe4486ba983fdb4caaae4ae71f6c03debaeea1f41197fbbbce3a8b83aecb58095d05c456962fb11d5fe140a62dcd71cc1916fc18720d9e847ba45b9aab1f365c56c82107d951d586e98c24e1168864463dba27a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
