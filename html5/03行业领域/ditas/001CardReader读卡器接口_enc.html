<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a80323d22d31c76fd6d1faa668f6ea8ad43327ac33056265065c8a940686ed95bc661b6edd4a86b0e977515e914895d9364a5eb36c5c53cdf339f4936b2287c590be47125f6d508339227d1b9d20b081f18d17050e07b73dc4e2664c4e00c0cf191c21ab47fa4618f77e3b1bf2049b5bcc039fb573ac4f24c842ff37e9f666d219f952580eaf764397fa37aa03754a1959e09338442928b468c5095dff70902c8c240d24d44e37097d58b975d42985428318b42922f0e82699a80403b8f7c051bdf1975e0beb1f2398f6723693839ea8a0ef9f20b374381bc6a57221ffdfce05da10b4d6dc4cd9a6332e83fac60245fe3ead71b67af380535f7fb2c90c6ed53a65d397a846926b73b0fdd9cb6401b3a4988035937544c1b21753c9ad59c05371ef2690874643f00d823178dbdfb515dc12b7fff1aee1487873cb7cb8b5b0245099035e3848834c2f6b0c7f83066da6fb246a98b51873f9f432cbad4808c2ce4e2ff81855d1c7526693cab91b6a72a1ade99876eb39df77511b9a4afac002ee8792f245ed27ce2bd887df638ddd2caa6c274364f16084c2362e81a2ea2ab4006b7ea78a453f1922ebaddf9646123d4c94ec3dc083b3bb83e91a73f4314d30b64119752258800c285ca9139afdb6c01e30ccfce8150791bc30686752cd74df6664502aa0c78dc770d45c0832bf27c0ccc43433a645168ffa542cd6e2b6feced718348e7c08a7ee1d428781691c176d14fa5744d5fc34e464def6dc29a58b13171008e8db9aae738819c5afb8cbd77730d827d9999c0ad1f53d4129173997fc4542438cae2baccff93bb5254f77c3f96e25b5d79fcf2b0d4d5c01bffeeac742d1d3692a75bfb0d15b3e52442eeeef20e30898a6c8984ac717b6ef9f8622bf8df9bb6c42cf17fde97672c3914f783c05792569129fa226464c8bbe79b23818f02ecd97ec000fcb8f3a2cc7138ce1d5154133e2ef6e3bfbcc8e59d8a6801313c29bb759e0b73e9b5300571e9a5aa2fa68e2537fb270b08d4e0d49792253dcf78f473f1e70575f47e36729e6a6b43395c59cb276588b45c5c1cfbd2d8e3f565e09f4eb0099dd22fc8f5fab6807934fa2810701a3a386c63d03b6e076a57a17faf4e114171525afd0ed156cbf2de4ff3fabcae932de71761ed513f27ed37c9602d619f53e9ef2e70f520a3c4548f92bb96f2bd5c2bb747e6395f17daf75dade62a36ce3d44b0486134979fa55dab092fefc006c26130f5653086acf4a7cb2de604639680b00d5a882fa712b2f8e68d30118ca683c6df531bcf1caae74d4e7b18bd8afbd020636217e08917647287ef1e24ae5efc01dfabd4dc1abadb82873e33283eca2713d3b9c606370ff8bb2c57376d0d54fe56eaf1d4f7e48678ce25d2dd62eaf02b648d86d00c2ca3f73a18e0478fa78ddd6167aeb37b83d6530f7def24f7def12c50cfc19f65e68b9fa33a9134b26506330b0c6dec5708547265dfba9ec562d8c0d9f1ecfdd064d29ddbcf099d136b352e6d7b29ba59e48a2047336abb2fc96919e5ba9aef1920bae7870fe133850577b75bd9dbb40745b7175ce4086b01387fc6536a8dfcac0446c8e163df4cb9e82afb4917c7d2f31ce69f3a2aa906b1adf305c0fbb4246bf91e62fd681965a25b3958819648a8f11f5484cf19a0da22a7206d597a60b89294b5fa4a9998bc75d9ddaa1d7faab3e5fcfae49f6a4a025a62791100ba1b42e4e42679bc8623969ff49c86f647dcb91b9f5808d8eed235d62b4ec2f9e0b692362cf936a99397b79bdbd6ddfff77029a2cb9bfbac55e383b992ec7d3640b599552bc1b68ef3fd2ef600a0285a97610e38764027272cae320e553047e9aa83c7f3dbc675dd64f07993bbbdf13c6957e3b074464332b87c38f77b398865882884dc8b99ca1abcb370583e8052ec0fa4f5a17990c54b138a5aada0db54649863801547bbbea45d07a78153395ef6e1341b26ba7dac4913b86f3dd5f98a575c48244443959f9baf910c95f485828451ba00a7bf41b49a1969c1cf8993c0916d2bdd04e6b047a8574c396d7cc775757fae80fcb4c386180c8987a04d07320aa18892caa50b5ecdbd68585541bd52e29a9fd24b0d1e8cc90b38c4a70abfbc0ce471ecde0880525a0c674a6743218f8f83df5896529559c6ba6367985ede8c328d28b025e8b871c4a09ef63e60431bb2392a6b72afbd327d5fac718f76f83306474f8d5401b83c1dae70ca81f30e42d74f0f0ff0cec1bc2ecd31d2b4fefc854c56f2148890e2585531d408f3d82ec199c8e4bd76af036269b049913047b5c4c50889eb04d219fc6c4571237fc38f5178c15d3cdb9c49d02dd5d1ed5721ddf74e17e844d5b505de16813654001195f54773f4fecc8de896b34c5367aca61a95fa64902ddacbc22cd39ea023891f65dc27761042302f7578616f99de7d8d36008e522bb45bf4bbc0efc02ff5ea57980f1a679be2e00330ef26c74b4903729cdae6dcc960c8ffc0f4e56451a1a17c9f6824bd7f1f3d1f62ff4af97809c23320b3635f6878880543ce0512aa958b9347c98619b64e1e0a98b3689f680b92b8e7c50a8d9d3dbb170eb4eac406ba6d5f8edf391c9d651a2ac83683c2ae1375383713585dceed8e86c33f2339e0f33d6172d62082c539072b6482a90d1ae04cd069d78f8ea726743f71a532c76a18d114e2d12e851cf6bb1dca09ee107c8e4e7586aa0a7cd9af743017e139ba413f3ea4a5028e9695b1a32349a27b5dafbdf9811d0010d15d9260e7bddcc5be8551d4a89385c951676dd2d120d25582dd93cabe1361ba1c646631e5a6ae883e6017fffff4514f37e1350d3e6b65e96140a5800a510b6b245be948f2ca7fbc02881f5beaec6275abf449c8e48be3411406db4431b6ff000b4577f7248230d8efe5e506083ea8f14a73615bc4b008303d6f7f2e29e9608bbc40a1699bdf3fb9dd9bb4fc4dfc55ebfad60651912b6de227d0d2987f085bdbcd12d07019a89a8115e10812276555928ce46a3604841a286c561f8046481f28666d7f7634e9fbb2398041a55b0a0263b18fe08d400b8b27f0a6547adf2b2b4429e0dcd74eea885bedc478a08919194a6e1cb4f8b7d9c0da34380723436f65fa754ee965a191b232dde30814d781a583f77e6129f831e601eb3c5e19bff4edac869698ffe0b7e9ceb66ede3cada679c416c69414d69f0415e28acd0e506eb207333f3780dac0df73aaefc04cfdc79e7790746ad8ec2c1955e417b64c58f5a0a257fab0d25b1d536825efd9db7177889ae3f90bb45e24abab278cbe981b7f6a6ee0b547b6e0cf022e6ecefe9e05c12a4157c2961b39ba7624cc29019ac3d4c8f66da60f668f16fabfe074d08cd4207f40fbe0748045c402195dc2302c04793b617c5ae0ba26386e40e4e35b75ffb1ebb66e6d4c10e8b6fe3cbdbfe75c23c054fad14776686df6e142bea0e4818471d9602821fcbc4818d7804bf90351c6231b4b4cd089fa0ccfeb740741de7872f7c828cb18711f2c57e856547e9553e732b20bc0afb33938714ad6757c47e3bd994a7508e431a1bc7f5a835b144f7fe76d30d2ca832b15c2da50184f124acbde4ce8ca95d70a2511319bc1d142f83171ebafc9f0a40636286a69746e49fe9c73cb82e72f39c847456c2aae9a1084fe844cc53a030755db4421f09cae749e88872eb7f43d62089a5eeb66c7b03821d084bd4df8bb917a16d058891275a85245c825b87624928876e1aeeca60be15e782c69de860ddf7a41503872ddde2b1cb214fe1d3f0a9ad2cf6212b07bf1acebbad820e63a274ad6ab1d0c9f31804347d09c47e28f2786a8696e5ff4afd4d35773e8a1e6618a2643b2eea564b136fe4db61ecb174381cef9def0bf4339580e6ecf98753fb022e7a06aef501b07e36a93b671efb5913c3502c5c55baae5a674463a93b0e7b214bd0371d4998f6193e65a822b89494a942a2d248dd0167388349566dc5fbbe941886c2561376128d2af51ac3e1e1614acb69971ad2e6bd641be8d5eaecb372c99a16d7c7db891205518b7163b1c781e3acbd79acd6ba0c49b206d87637533dc8c10ade6f90e872936e9684d7e6b7edab90cd5fee8a2f09214ce8427b3f9162d9f641bacc17470a82f7088f39375579dfa40737802f1fb8f0774fe9990942d3e4dd2b630760f86e94a942590e67a1182061bee475e04b285650f4fd76aa06ce09d7860357828b49e815d3276d389b919cdb9edac2a8766ad213af6f7089a1e1226e3589815c9782338c84f62ea5d9b5714e7b1fcd144b560b658d5956bcc8724c3baf3afd61761d62ccf1e66a0a3c7a11328855d0e8ba5630a1c121139d6a7186914af4e0d254a06f967091308f7ad9af0365adacb5d36a5e5dda63466fc7757e6fd65cb8e27d0859c074593c3973f733e545b57c9accd848f22e9529c8897a8f4784e35faa1551938dd23f3d1b438dd11ab5900a8502b7f6ff87f8b96c9cbbbd1e40318ccbe0cfdbb1c56d1d8fe942177cc8c786244d9cfe81335daf459f7279dbf3065b5998577b2bad10de3ca2d8b2055a9c9739f3ec5221bc8535e2dd4d77f66a8e55e09e00dc4a369b2ff9380c4de555c0ade71271b4317e2cda0f900ea4775417462381faaae7f45dc3eec3a360a8efcd379505458dc4a73fcaf357b1a32388775dd4a13040c9f503b791a364fac66cd1169b8194fdddc8aeb70f9eb24fdd788093b5056c77a8e443b5ee396f6ec86c884d8d41da5207ef6bde59bac8b95676d21c4e7cc96a21045cfa0f4cdbdcd51e351f7617f8a350c21774f0367c21040817e534e5dbe1321f093d78736823c234cc1bb505a4da429fa265dafede48dc3ccebab6caf298f7295a0649741a42911116bd1db5a297674ce8c07fed020e0b9b953fba90cdc6a808b0f8821ee93bc403a733b3aff74aba9ef837e8715e0e92d3fae5c36a4dc10a29f76e491040c022bda2e0c8591c05246a70c8452c9dde98cb1618335e6d216077d3d75be1dd58fb0f7006552c09ea2ae5a9ae23eb5eb2ced1693c1190969e27b80498f5ef80efe97dd8c8df9a290711e42b013daa120a1e15d09f2f59cf38e0e7426731c06be6415bddbd45b1f16b0c25ff937fbd3000672e7de3cfc577e546ba3760776ccda3889520680aa2c2b2515f82cce15d9ab848e76d944a911c66f9e026281b277e5b76d62fde08f7f69d74ef9a7596d3bdf50bbb4301b36f46b5d4d99925da9fdce004354aa3828fe9b5c139610ef702d75687c1579172c8b79684e861b1fcdfdc0ea0c2ec56339a9c92777b66d8d4d340c494d7549827337101a7a384599a01aca35f312e7ded7199cc7a5d09487a9dbde5761a942134aca2766177e733726183e79ea12ec6e546686d477b2158434793a3c4c9318623c180601eabd9a5be0062cf5505204f8449dd4b4d622cc85fbd4a323de70f05ab3428cf8a06368df36cae4561e664b194d6d7abcd8fccc556a950d996ab44311dcaee797da379af80787946acf77d784e40efd5c07bdea55c86530bff110e9695ad8e4153c05cf86d64c9c0e80ccfc93ec4ce824b1f6646f5c9f1eed040e42ac235eaabbeaa7e82f9dde93495feaa4472c6899d70a971128c848cc2965d32ac76d611bfd55ee85df9f4ef3fb20278675edfeb166078ae24defc5799db1af018552656319cb01966dd7231a2eb7fd23fa83181f3664fabdac9f34772339151802a977ce3299e608f57a413bc2c832ca63b06d23b094b84a271997bdc8ca2b07eda26dcdc39e4b34c393357a7b31b416c202b00271ccb250cb249be216042081d959568709d7f37bc5e78f713fe360b119db6c9dcd5a5cc1028558741fec451c63fd46d99a816c323de59ef01381b2677e1f85002fe3712dd2d2ae19e57ee28c463c42507283332cb80dba76d8e70c3dbd2a29cc4daab842ca09a6e81a9b4fa9944f7259a86974624747e62fc32c0708e53f3c6ed596e15b33bfe59d7978b42710ab458b13f0b1cf36079f77b60834516b0a67d55d3845b5f0c5124f49103f61f6e62e1acf34b42c885788a0225c9dd51d29fd199e3d4af54e39dcba07eca4adad6af5e3cfa4162711c6e39c85accd8aa5b3314106cf8775352b5af07c87f61fa69e12189803258fd3e7392e87a5e286c330b080c8b75fe74efb6fe690c2be95060ebf2420a9b72deb08f4f5ec042e91c1c69ee5fb65c1bdbc6d101bbacc415da97c1c992a78f4c3bd918e3edc3222084ff76fdfa85e13de774211177399d6fd3f24e86f9a05da4f0ee086a191af11fa9bea146d6cb176c08c6cdb13ec5c7c6cf7068f5a85cc0ba900143a87e78e1aa6b7a870edbfe30f89a80095bd230fc1f71f7f8d90e3edcb7532aef323534e004f1d9275142ca6420a958d6b8b76e48c1ecbf19367e75358fea657b763c58d24a22a11ae680cd1a501075f2eb1c5767ab92ae02f8dd7c7e9319103ea6b1472e8c39a44efad378e93325a7974cb2cd4b33db3bf428e04a5024b92af3b715f805aa2e91e7dd0e2c6305ff8eb8d3129803f54342c0a791251c6e719c4882b9fd5969212b1f0cd46348cc89d5b543c4ec6474e4a30c23ba1833eea3ac6616b7d7c73d3596c55a8ae4cc71e0357b77028b24dd19feeb1f68792b7757377d271c93a0853a23b1f33487dca5fe54949ab8d5c4c13fa7076776799e2d6c2371b36a57c2ac600485a541d2787701c241213e844f441fde817fd2e24c6b57a68e4bdea3db790d3b79acccc2db491ba0de5edeb7c2a65b997d4551c809a78d5d82fafeb7dc06a44e96c8e84a178cb008004e8c7896b4c045aec5f04ba764dec3dc39b4802a3dbbb081a02acf0cd73cf5a47b2690034f3129616e59b10770a08e621f3ba700f65c13d739049865ba27eeb0740b367fd3d33c3690a8817435d4c2b6b1638e9f6ec33d753e75eb0247ca1ff45bc9d3d9965101db3c4e3adebbe420615b299405847dd8839346e560685e052452b46b257a3316b9dacf2b9c91e812c19cfac26b703be378f0159cde6b830eed0adf11b66008eb1bff7131da670e6c82dffd9a6707943f7ae687505da709e27cf0b87fa95c44af96686615258986cb9308f2a606a76ed8c01da2d5e0b484014ab141cf26c5db783664af8044c7529b71a5ec3f9c9480c3142cd1dde55d0950c70bd46f581f855aea51985058ef760a83d0c58dca32bf0ac85089145bbc02db6f9c6e38bd835cfd5ac36d07dac2382ab1766587e998795c83eac3e55dbe536fa9bed3dfd0166947aba5ef955508e482d93b64b3433ca70b00f475447de5c535f99eb4f7a5e0a94809e2f39c649b852860c9c5ed486056c08babad853fe6cd9819235225961863126b902302432c539a7692638a4ca4c94ad74233b31e9ac180b94d137e94d22ec8acc49ff944ae4f7882a69f88fc4e8666e0aa170e8282598e121c8e5f593f8914c80d00a7e3a7bc217cb9ad3762a8caf8af36f71c5ea0a3db967db0e00094bc4a83e3c444e5109ddafa9ae74666496c8e246b2792daef00c06f3b29fe547aa229d0a4dc66d840de986e32694bb75a6830761598e36f3c51e01f7e777a2961bba38a08939562f5c623d8ff3dc2e78b555ba2e476e64e884f6680a701c8f9c521239053cf52cfac62ca05a4d1ac88de8363663eed2aff5a36fa3e6484cc45928948f2404fb53a6233266afd628d43e46f5c92e7f06d11d611dcea3d356a78bbf658f5944aca1e2e5998505121e3d1ef9ef5d905829af75a91d88c8bdc507a92a17410dd92db695f686cb1e70975aa8031857a10a979bb84812bcfa11348b231910da2c5dd09bf72513d3856aa367c94574a49692c7b4e49f37ce6d84082c0281862d5283a9dfa3b3d0eca0032f306d8861d279180791d5bd62cf63b95f973220d708f1c87fa1fc8973631e0e97e99736eef1edcd8be7d966ab850ed612e7c93e9537285b00e25005107dd47a2ff279928f33f04942902a84f732a0cb60de64ca35db0c371eaa810f8ed899cfe6630a534d27710050aedea87fe23c00b043e5c7174662af336a8c311c1c5c75bbfeb71a0986de91cd50ebed8ed82a414486c54919ec316bd9f799e2919bb92ea586e3f7eb8fb3080648cefd271633b2450ca5eaa12c41a9842e2566978215b910e280497d1f9d60c03451b74de2f09c723e0029f146098a9a9b82bab7f43e743af6165ef36117af3263a72820e2310c1c06934b7dcc68a932761380a6c0b342c6579afd7769eea0f80d83d524081327ea7df33def927ccb762f596bbfa40f9fba0e80a47a7044fa83e61b3b8abe086b21ffa38bb2356502b68da8b91ea44cd9edfbcc22e1cb36c2fdecb16fbfcbb8b870c0783da63b497cc63abf5855f4bb6a1cda62d1fded0b98a6014b249816eb64ea6047d7d764b5dc964e45b5b4b3aaae4a41e23ab9fbaed46c385747c8fd08dc6da3c7b97f77b9eb4f1d2b933a34605e18ee83db3350f0e3363f3ead02d428d15d3c6f7b629fa4e51f88d45e4f8b525755e075564364a08a17c56b7cda827d2953a1a83c6bd4ea5c9aa928109e087b67e5b24e53cb09f04db7aa6d56302b8eeae33629a2f97c5bb64260db718f3c55318b9276fb3f7183c6c0c0c8546c961da6733b7973f4f1c0c770ffd20d48e6cead849ac715ca52ea69dc10aa22bf27d0bf2f74498bd1746a6b2f815f6af84d7537abbb8cec167d0859fa7ac4b5d1b2a3b57b5ec13569fcf2bef387197e140d33632656ff8a90b438fb1828eda4fdf28572e54c07d76c567cb0c801703c4c2183784fbd7fb057227d7f417d2e1a2bb0547c91f97fa27d568b9261cbb13998b1f58b19fefbe00a7db61ba1e73dde90cbb1a3d68f643bb5f24394e0cbc0c9afcd923cdee5e2b07356bafe4ef1ba84a91391805b1947fdf15ffc949db2a6fcb1817d82ae13e7a5366d62775cd948087a1be4d191eb936895ddbac587021b1c2facb44a8a5a79ff4d9433dd8ada569dd56e19a5686765719b3faca565183457b7a038145561c111d2fc871c585a558b06fc3d1891ccd2ca20d0a57b247d91b9bb67ab15cc17d4003bb1654bc404dbcd9cd63a4a203cb89e83a21c0d3a4161a2f5b33bb5f21044258d3de6674c6a58edef134df32f02f0e0b3d164817f9a2b714d0b8a9c1cc8dbaf0d3110b1b759905cfd00963c163c4f552efd5bcc03040131017fbf4bc570d87b8b38686c92aaae2fed5306915cc18358cad772a9736f120a0c11c06a0720631ea14a0fe03807e1470397a5d32abc3745931f62ff8783808a1785608b4d647cd677284412316771c4b2830228659cc9a01cced0d61ac93d1b001ffb50e12bb625cbac1dad85398b4906afc61577ad11d55fb8a6341d72a7161546cbe4861c31d642aeabdd8d5db6f7a58d85c8b7cfb6c5f93fb5a59677606068b6117ecb608825f7257b21e8367b47ff445411d9c073cd45bf6d76364212d66a17239d2c0a66d19ec58ff77ab59d8c63319c1f84dcfff8c478b8dcdc020b386d065a831e58d5e601161a3d57b2575afe5ac613d5db95591acdd8d66b84eccf4caf4c6ce2d425e8dd92a9a6770eac88e3388f5c7f75064a75fbf704b93b5470a207430607326099799aa8912f27de2ce42e06d2aae0352c6998e8ee2aafa207b2667462ff1858f67bab974e1cc1727da54f0969db4548443b33e8f3bc1c925f4eff799ae7e56348bcb4e999df22d366f8ddfd2d55d9d041c536894d10406446f7fc4eadfb3f92a9f0f6654b4287a8d1250a9a33d90d7905b82e7d687d7fbff8a8c6f6166d00151418906242f480d9b6ba4333e6bd5a9ee88b706d0a6877bb90090720d0b5bed9cb43d56e536287b4dea3b7b3933af1afac6f755e3222ae9a5597f0f86b70590e240bf4e97571ce97ccdff23d0ee15c497250cd350f9e6705aea65ae16db622707f6dba08be76c34de05714c8b9ec7a72dd0d978f570b92409fa794e35b85c08448a68745e790fbd835d2ffe193e4006f6cebee5cc151ec123357a7d347a0f01828a2cb03835c58c3c9ce8f0f9c70cdc93e45ff675fc47513c76c5e8703881dea1d425542111fef008aa2b87327102d5f3a9833a2911c98950a6953415ef23653b79ff9d824406f517976f863a7b58d5e267c810bf9486481b82b906b939383ebc4b85517ddc4f04da6b452f934e09992658531ba763c86fca8568e236b7afec3c579695bcf770084650e0689d95f5152cb19e243e6aed01bd60fce7bb20aff8de30faae0f579f7beeef099368a48e213169a9f3d4e9efb2206ecea4c8fe67feedf909fac977922f3f38b20a323a73e5113584bd672c66c8070720400639353fd74f50a8e5ed1e1ed3a1624cea12ba05ec170dbe57488464e0a6dd12443e9bacb1bba94ae33da99a3c55b85be0d4ee7474e7573d59a69ec83537316b8ff55e2ca7f14a21d0ecca53cc6c0f7533e989185b4a155cc4609309700a17a08ad2348acef335f431738d3fbf4fdc3a950aa1f8733c1b567a170aa67ebcc1f1689e8b1173f5cb0467423bffd655720b14945966f84d8aed2840c321fbb2341be70a7bade1202b53036aac63e916f26789bc636bb27d543c36b85b5394a2ef95b912fbd0bae75f6c3ae42f1744cbcc0822d9867b0d51ea75f52820b10b2350368019238e03400a94addc0cc7e6b519ff985f0d250991625ee3d870446f841504407fdf916766cb8547ebe16e50237d435e4f570781eca58bb4a3f1cfa9a914eac397231eda18ffd09007cacd31db9260d00152ec50db4c2e7ed3b6ecf44e584d7972398197e004f22423bae413cb394954a7ac1392652725d39d7ea65376731d9509a52ab3e7894c4b218a2cb0e2e12d063d31f31855c4a5f41cf455ff9b2a5abadfd20582a7fe98c1e499d96171178de24cd261d733e26039032dea1a37721db600285593203dce9c1b6c2d8636064c0750c1ff94e705bca19ba34c838d1fdbdf43cc6914c0c613e393058244c2c67b08beec6aab989b062c7f28deeed692bbf5628b155699382f507dfe29d2759978d3e91cb616323d4adbf5e49b5318c529a7b601ee79620c5ad00705048f613c9addec59fa993fe98239e7be30b671f9dcb65df8d88879deb60bed50a4953bf68330eb8aab0df6e75763861e03963c4e780a19bbecc9d84954867758ad2f1293948d9144023ede650b9da5927c56b87ece97e36a6a734fc875831d2551d66e46b9f8e4e28a780829867a6996a965e1a7439e478b2b914e238fecc4e8ac34c331e2f45987176b2c73b6256e20d6b4831f76b91a84055a1187780badad35e7b4764ffb201615c321697597bf2bebfdc19a51427aaf92bf0f96dc662a00bdfbdff4fd8022916e2c4f68e1036c5e91cdcafb46d376001f4064f161744fa03a13edb5e57154bbd1e9482ba7cc75c15e3773ee7be234f2501b4b37a820ff07d538c3c6b78655b29200326897aef72fb129a61b18a98e9499e151815031a2445d435e241c773eed63267a57ee03b1ab705f743ac31aa7eb5c1e6a27f402742de8a1eccd6fb82d2effa417aaa3032a0274c039a6ffb94277143ea9ef54a393960837f88ad528ac2d1744871aae012cbcdb203044cbfbdcbe2849839e6b1670474ceb059d0edb25f6896abfb4c545dadca2341b872724256448cb24f1ef5d74991c836716c155595db43e2c7ff60110fd01ea0b6a4ac2c37eef2fc292e6af852de791faa0a88c8b5f11561d8af8d669e798fce6088f71137a4c5eec0d7ec26b36f64b126d6dbc8655dfb8acd1a970f36d08aadeb545f1dfac6ef0923c577e30fc1d480aa23cd869099f1ad8e1092aea60fe14692cd36b8d95035be64cfe52cd2deb6cbbececafa1141bfe5f57c46719fc76abfd3457adf9c98ab4dbc5ea368d0de0d20975edc35a419823ff37735d8227e2bb3d43be3d2fdfee85f1aecc7dc7e43e396ad8da54a65d34e4ec7070dcbd195ea229642d032f79f02bf573aee5cd51ad47f83edc8528326493a19902f6da1d5ad55f050d1b7b4ecc818f655915ad3db4d002bf5f73eaeae26c61081f0349e815289f85188d25d519221225d9e04390675fc94124d805763c5a200a09abf8db697dcff7a9419e365f619a7deee2ca8ec08688f2bb05f59a8700ce24c0364839eed9e2171293fdd505471d961d2a36a0704535acfad2403afdad7a39c1c483e5b9375bc802bec5291d6cbaa3b06e9773eb28bd062e7e94b03a40b58d49d43fb09993652e0c86175a55870868fb839146dc0b247584d8fc9315206c7e3d8d8578b829d8f5f7a2a628b90214beb733353a0b6b2318b895aac6efa6616dde36e15b07e679b2b74d89d5619239c92f596f83fb9145ef5d222227202afc033fce6b87f80f4b73bfa719e2f7db6723d9ff61d59f236ff12a170a337aeb4a9fad8b99538f16a1515485b92f305b68789c9dca23830db5fa64e19649704d2416594ea001dd3453952209abb375e4e6a715ebe8e292716bb932c1e792038d6b50979d26762c65d892c72edfb027a313a949cca804ec28035ea041f6fe81b8b6a6d7da6c81e6d6559d30d5f322dc37d72905e15af571cfd3f4d0db58564403f2c1561e512679350af489019e766acf38bc335c831ca4405c4295c21908c8f92773c587855a1775e708c8c696b98306cb0838476ddf54a24888e6479d4f25af649a26f0fbb4cf6f7b11a4ce99cf726da9c6c01fd0e2b59df9ba17ee859841530fe139d1e474303e37d9b0bffa62ecca046551ea7fdbceaae177454dc65d09733c5b4515898948ec5404e3fad1292e45b2251875f601f947ad2fae323b37e5fc49f3d691a35c677eb185e4f26dda77be3fda8ee46b60786e739720b498c1cdd8044abf3e156a42fe6f0aecae2160b29ad0aaffeee171da6b39bdc490aa8be52057b4e14ad76de98215362c4e487902b6997e85fa436e9c70a51d7fd87f39acd5e2f078c1e80420e3b15cab995f9d02274400711d6fb94f713c72b3f00d15ff5e56ffa89da2d79f64321da5eda0f6acb5ac3a917cb5e3c8f97cbf11b99193a8e945479751e5fd098e491ed427ada5d7410a4f30cc987d7e99cd49df9b4922e111e5a7185e60484561fa46886af93bfb7c4aa9834da783c54a6fabd526678536f380766eae727e74f8d4f0d751952dfbfa4f236731ce1f34795b4c8e2426a5aef6666c99a2efb00a218cebb1036183efc523b432fc405adbc5493254761c230233fcad97f42e13594eead4e5e8bd88e0050912e49e9c136662ca85f3c9862c193e94a0eae341dc254a0dc577a5a118b51e2ade8d4500ef2aaef54961e843c84069ce698d34b26b864bd52013c0bd38f7c31cf5e13daa9e42396590db76150240ae6d458f41cf80ce8459a12f9bcd6b5ecbe6a6d7f39643d80f6b106aa298a161f5574c5b30e9ef42d42c1ebc51c64c5fb7761688f61df1472f4cf8da49bbc6bcd92c1ceaf8dbb2d7443da5a7c6989a71db905fbce1cd165b0c409ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
