<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8ffce15e8b2885bda233e9fca35f62dbe9154ce5dc3fac8fef06ee1c1a28ff6c3761f71ff7c648299b71c1db04ed1fdcea38c5dc1d064c4d74bbf90e7945fcc18b7ad806d1d96eec9e23865f9656ac9e466115c5cd01a6a31cbbe043526b9f82c9ff9a6d14961a84993d7bcd210a9552198dd19f2df2739abc2d4532167874d95e98ae14f5a1b5969c1530188701c30d28ce17a15b270c9990e86bef1f3d3ee02ff469baffbfd25e900956177309b821d4428648781c19a2b10cb4683729d5dce4e5da63251305f2ce4c84304deafd605192a0ac5cab9f0bce502e124372629128df9e5ad5a543c6811d17797126765cc35ea812f20eeeed76efd381a4a6e1e5286dd84e21588e1ceeda58fc811de864ad8e8ea0ededb88aacd093102d9c8a78444b97ec43fc47dfe5e2fce90d1b65ee09c0c3b1b354d6feb62fd8d0959b799a0b1794887798a642d07e51eb023dba86faa4967bb5ac7e1613a405b34c17c77b58373dc3625bcad62969b5912c1eacda68da6ca1fe6e5395727dd7a6e1f939f50dfb0824c5b80d96fe861753e711ed6717d24bb13c947b3a7fb93e9d55faee3a6817deba059487138a7e5be16ac13173fefd0b07d383ea6e7c456e5dc9f8ba76aeff2d198255b6af295dd03672066b503d2f0d92197f99cef6d5b1771c50d8732f08297232456e81803910adbca393cb1ad0e8ccbe6ada6842df21c2cdbb3a0f096e3ef7513a1c43e07cc28b1f8c86113f8e6dd3d1db6c61d63316769e542b2a94d1b8c9583b7dfbaf044e049839a134b5f19720e992a1331e27c874b22c638a893c3e77ba4c9121b6645ec1dee86e9e7d2f51cee2c57a28f43fc885fd3e30c7d711c43631ce24b55201243df72fab11800c57cf2910ac7fde588daa2048232feceff99d219307bf617876a588e911efd3322968091488e0b383d18fd5c040f898b818200d82fb6ef13f1dcb5efc045c1903279dc21173bdc0c9809b0ac3f4bafe2f7132aac98a81e2f263b9e7a170a20cd36f729f885fa13f049770fe45a77bef2e0fb911534bcc5139266fe84829a83ef49e6fa911ee2b59ac40372b9f09e530cb0fb87b423d6387ede4bec7b24bae1853e47bbdf53ee7f352e5859b99096fb811329ba6688be590e3eb29097cb0e4b7a49ee53addda9745459b849bf1a8392e48cacc6dbdf9a7f55c93f2f510052d7c25f16e46cce05cf9e355038c1ff916447317ffa2586ffe3738258a29327bddb6d55a1565f2a9b36cf841936266c2cb01119f7a27488cc130b0c442e1fbc62174011ca07af67dfa04f90567c3b0e1fb51a4dc77725b3b2a41c511c50e522183211c933ae20d7e061c1df42489629aa90404ec2d3627af4e8e1ec994bef772e2d18a1c31e2356e927dfbc40d7a15d8077915357b9b1330ae03611184ef272dbe67a985b175884009aff10670818c9d1a89557dbc622e1e804ad5749a5fcfe2b259837799f804cb69a2686986905be7b4a4cf240fd8d53729ffa1ee58bd19b828e2c6843935a8c702aa616990c90bcfadcb9987b68ad038f73bf9aa1716611a769d729aba667672701ee03ad92bb51b2fd380422b46cf569f24a323e2824f92e711b7ee4a41e666e5d3a37aee5ac4601aea0d155a44d4bf7ba43484b234fea5044f61e132ebc5eb0997cab7b3ee68ec1f3c71bf4f7da84c7b150cb9c425b9749ef0851a1497cdf5aafa833bc248e6828dcad2cf389460086a1dde966cc375eee5f7733747199578930a05ced3330afb61ec461d99c75901286cac1a501b59c0465d901f0ec296e222fc55408beb248bf60cb314fa2edac4571cbce4adff59633514e1e094a9270a54fb17ad8f7ca0457de1b8d522f2f9b7180ab3461f9c5f7d6ace0668d360363c68573129377bb43eb819ffba30ccac5f6f098133a9f24debf08ba0a69b6d4ea4724f3035ea2d52d890f8e2c25886780ff573b6d27700bc2a85fc2694507dd0d3bc49db06df48ea80dae8c31def8f192892811d82ce2dd3c6cfa1e5a7c76feef31dc5240629ad8547e0b93e3f087b8c7f5f8fbdbf59537b547f92daf989f2ed619a4f46b63dca68f3a3604eae84fdd377a8ca8b4a684329fd4527b44ecb7a834c2a05af9eb6a74e2ce58695bf728788ee2e76f24710ce6b7da759fbef4689c3eeb73c85cdffe29ba55b0ced667cb4a34b720baf528f17f7187aadd63f53a817fd7f81dc2505b8330979d148e939a9bda408eae9b2daa5bab4618ad79234af3e84b7315c2c46bf539b2331ecaf0c760e6d9c48811677f3b9adc61dd8c2c892ad223befa0544b6f2afc4f9c1041957994ef66072d2527fe903b0db1dc74da42fdec0c41cda2d833a50e65c49a9f88d78a0d4772f05d12b77c6ab8e36139ee3896d6664d05f9239cc638c36318b35efa4185e3e57bfa2d841713b3620776ac8d7bd6ba35f06114ac75f66f70bfcf168c3bf03cc6bbd29b565045e4bef0d411031319ff43215afa7e5e417b7a430332823668211386a44fcc0221d165dd3592f4ce63f4976e255d3bf9863442be417628a00e5ce84d31b01ddaf54c689d0af3a5fda727a69fa409a6598d386c17fe53923938827fa5016ccf43a2c34d7868d22d353be463ada12680d308694b55745ee87b063b704d0895107405406081279039747fa4c834ca86f3b931eaf06228c39b4b205aa7c941de806693f877f723e47ac717a210c4c18f2c1d8b482f176326b88d249974a6ba111dacefd740ad2417029c4d268122c0671aa47d6f34c26a0293dd15042806dcf9bfac8a92554702f6b124439f3fb26b9823c2b627b6157c47473fd2c7f1e95c5937fec3987f4735d66cd3bf0dc868b0aa70f9d964e3a948e892a847f8931bc456cb8ec591bbacf3867942c6a1f3154f16a217bd0089a6edf430b61893ba000a6f5787ce86309cf92e3db4e245033e492c092e662d04d061d6e392d9089ba936a874773b1653e37699e0c57a5af43ab8f733767ca1fab45f2ac985fb7fad104b32d8b97e14fefe52eb953f6e6176bb05383371bd108eb10f59ce7afb71c02332999c2c31aec4b8e4fa3434426b93f355844ecd8a725ae266b0680b0539e47903c0ac3ac78c502845151524b5bfc1a07635c72745eafa3c21c124fe43e1b3a97733d97a13627e0fdeb8ee572726973349cf8a6c1185b2da826d283180ea49816f02c175902825a53e5732ddbf3c7438d44b602078e15b42c41788519b8e91dde7b4673ec1e4a35888ca0fce9ae991eb665d17d0a4502a51b42515c3365a8b3271488a37459f5c184b2a3c7614af01cf65dc566f2a1d1f9894ffc9f0ae768a113ef51ba67b9bf8561329a354a8960184ed6c0117f931a9a6f2b7b2d246dd2b1353ccc8ab742ebf6dbb491fe049443ea8e7f23b5779cc751333b64fae24a1c29e63539f44552ca047971fb0382af7810c3690b0a8d32ec04cd7aea25a1910cf8e1a2cd427f459c6c742a6f916a397f707918addfbbfba18352b1b01514da41ff9444ca2295087c5c1df1a150eb859cfaea47f013f6a7bdc77555a4a22ec85183da02fc68dd2e0701eae141119de72cb694d789b91e76b571886d978dab1960bb35e35fd9d3b8eee060643438aa978d12c595794bf39def760d086b6aafbea158059802ab8484ed29a859b6a1d9c7fb2870c86ebfab4730f62a0c2b679dd53fa318d9b5e9bce38cedc28cad8574f8ce718c6a59d2613e3e02480ce49b5a6b17d9d09b164a36d318d3a4f21f7c8fc3eb76bab40bfb422a071f039e945d4dcb62199cce9c18711e7e8f3de23d5099a066bc89ae28807432fc924b76d13f5f7db92f6997582ec993f3939442b582ce38365a3d95304d44a6532fd047f481de6ec663151407ebb813434cb4daa9e57e20718f969477a0eb92697db0ad3d79c3c7fa0977084d2a3d8ea6ae9ee00673edf28c3f6db888be63dc203a1655930c3431f1ee69fe0526fa9877166e01eab4e99795b99bcda75655f50d6f93e75fca6997c2b550ac56b9535450d027c51ba46c07b35a831590db0e7466323e17d0cda2582b2bdcbb642709221d1d23016eebd24a2bcb043f3b042472a0cf50a61bb4659c4bf319ff238222e217086f5fbd11350b15fd3310c6dd2fdd73b1a2c4e860251c4b82cd9078b8db9ddfef405d2f86f25331303746f65c29857fdf8e013ab030a0d3398398998ae67ee656d0ba1d2b7e1b00ee3f22841884b1f9f69c009f71a443a503223a923c0b68e2b13670138b1367f6b76a312489d837ad0c525a543dd95a3d06fe028f3eda8c7ff16666ef8ed5a7fdf3c559a5874cbd671ec205b29d710fd9e2ed2cd9f87f84558bcb645b539d26fbfba5e729792074633793f195e5a7f681188c0b34fbacb0ecd346b02fce4b28816a4f93d5eb42df47c5ca3a9a898c28f095e08303c5375b5615bc132c646d38977139aac48803381e87441fb6295ce7558131ce7666763aaf3693e98ddbfb3b1bacc91f691070752462a9b6f6b573ffcd0594ead12ddf14dbf05a7a06c26df47f40531b1b68042b2b902ecf1dc7a15951ec4bd145267dfb854fdcafb092ffd3bfd3c5f8d7fa9970e25501255939259eb4464869b1ec1c1022574de270d954282fc07c43dda0aaa3acf864eb4b3c7e0552db71e57f02ba02fd87d27f64188a0c4982d14fe6564ed8cc2074380fdb65021ee5b64d50e39072e9cafc534211586aff4e6dd994caf2b1fe17207c90bfd7c774270d43b1253626957f753a56576f43445bb0161cb86bc7bd71a0bccdf930148d4a5660f52d5c431ad1277e437eeacbf8fb9e16fb3f5c02b9bccd02cf12736f61ecd44814f7a8282a9bff2dfa1e1eb1aac11aab5182e345fb6f553b9739f3098883914493768a3756ac90aa20e47d58c6e4ff585019cf38ac0960ac5cd846f0cbd4b333048e5f650dbf7c7aa644972a66f6b51ac982f8843a61165fdfb5fdeec41041ef29bd4c09eddec42693d8c79b6cd3a20a7cae9af2c8118178274bb8f6bc2ceaee9cb0e089f971add4f8e1a84c404e0d9b5fc5f26ac26c8dfc70e9c72469201d324868bd93e53f3736a5211d464450fa11850d85106c54e608a28588230e04ee1415b35fc245c47ba66864bf50867d870f7eb83ad84bd36806270d4d4049d8fdc4668a0e2f42e4244b0749daf469dc0760cd3fd17c182c925f461221a284e75b3dce3334c84e397b86fa97452832365ba25e5649a01b7367f2d17373be61b460398398db27f9cc4ebe5922092dfdd4820da9cb6fc62baf91e0b85f76f5bbee1cae40d32407524a008e3462045c543d957db8209316c02ad94fecf59755e86c6a7fb53a4ab2f11fdd6aa10410908fcdf1002489efce8dcdc3536256efe753b2e3387838ec187ce112517996479e59f543fe16e5813116d6e11b47f554dd559345c281a8988a02108806ab8310b465ca80a1e42d29cd1dc1387b5039d814f14df9b203746a2f79c0a0875e4f2d074ec73c048ab6bce2384ef028d37322cab42b5359ae536c86a9cd3fe8bf29a07c9a3533f9773fa15f20001d78f566918375222125cab6ad01f888325c611e079a49508e835d87a31c52897c8a634785f95bbb4d11b8a3ab1a8b072526e93ae4c75475665f30fbc25e8b5c6643d06378779e425866d6b046c25edf31a9937488d7156effc4dec363a487fc7f0653fc8e224bba5f524bf129ae3fca53f9ddeb455ea9dc1589c9274dca0bde54c5caf45b4e262979d2e154f38b225e42fc74ec1b0f6f5cca55b69054d3b111cccd23a1f752095e7c106545c4c3e8a4e6ad6e891d2e493fca38205a144251de144cdfa3cbedfe2a740ecc8c0d561379fa0f43c70714822a930b93b9be9f231b70b039f4c621ea51db3de19dad6776abd4a96d9015b0305f61d4f6eb61cae8fffb96c9b3ae690ab868a03667f28b9622a25f48e05df2e3de5ce3a80a509802c7adc6b82a77b1f8baa25653cacd0413d0d0cf4f711340b3412bebe6ad2e86a38677f230c0696fb314cf8fd11ad53c1954f4dde83d17ee76112d428d2fecb0f0a3dc6a87aeb5f69c70c96d2235e43d68f877988da4ae150bbe7f09253d13ab9a8b86d69a83b7a485d7faba7e0406431dc19e66bc8a9f73044d114eece5e5b2cabcf8680b882f545816ebbfb08a0868dee9acf5998d289aa6f4a7ae5b79628c9d0d32fc1b97078a439d67e78be1a228d286f3e530ef9e4f02e0e8c368e43d10b688690ca558a497dfeb917550725afc3b608a51a4705de28c3378dcd37365e9f57b9ee53a0d8561501e204a104f77beebd60adfc277d9f4fa3f1ec2c1f50aa0a1de8057204376666f13225fa25f0e5722642e8ce570667a694be18fe24c8fd2b3d1fc83802d29a362324b479f30173bd20b4abfeb2860f26a30ca701e874a9c269f7e587297c91566ebbeacf7db172320b9f6ef965ccdc89683a4f52d56a1eed7e05be88de2dcac0835ae45dc63be4b9e16a90b50a2f9d3f4ef06d7c75d846e778315330db53854c4d80c3f4709f489b1e2e5cf31bcf758ed389e9c095a5cfcfbb7961416311554851781e40e112876f8b75bd1e363710363631ca85d6cfd13480ab4d94da82da64c22cfb47aefc1e95623a81eab01deace20c1d7379686d8b703e3cd5906a3e4649c16cfd89fa4c7645472a24abeb3e218c5bfe9f50b88f766d900a3fc681c5708e51e81bdfbf254925a82ce3d0493fe0fe1e5df2961cc990d1e2189e732295119c9a8251b73cab5170536036701c44e1f3b52d0da5dea4fb3e1acbe8e5b58bf284526c50192399d788c9c1e96eef5ade28e4af0d4d0793eaad20624086718356aaddebc64c426bc8514cd03bac18a2d939966842ffa6b7f9c7ee224a7cfbdbff0f5c134a909119b86740d5bc4d61ea160befdabecda701348eaa54f609d0f0cbf573cea4ef8406f6399532bbdb9b117554b74f5aea9dea69b504990fdca5e5481217de909b8281ee4aba58ae64276ffae7d3b69baa619e09be9a62a8e9e3fd59873d575fe4f3bb4a8490181ca0268ae2f5f0bf58792b4167cc33974870208323932a610bcab97a1c0a74169bc8d5df4aaf9f2faf229b8312dbd6a4198f8e256a0d073ede9a7073dabfb2fc0d24033e7f907dddb8c60a774f6ecbe5872944bc454fc49b8b0c6834e5c485a5a72d9c99a45b696eb7074b4830419af00dd8e00f0291705bd68e494fbc4d706b7dd8b08ae22cbb487e865dcdab20d73376a42cd7d67ad041d8286f5f33ca69d366cf75f983ca76bc10f7f780f8be52a377f62e09b26cf9b62b39232e38ce6bd6515800e799a9c0d07e51d4b36863af4d8b11f7d317a484c9c0a5905c4faef2365e78f4ad36fddfe734c99bf8de3c42f451e551fae967d189d657742b97fdb930ac6a8bd8f0b418f2e5f6f8c050ca60ca43511649c53a8ad4137cb4494ffaf1db2f3f73e97cf1ef4f76719aba57d1f373149bdaff3b32464cf7d77c2112c4f690649dffd60c1278bb0234c6fea32ba2092856f59d368afb1bbdb18a091f26381ef249516179b7ce28f27dd1af4eb0e47fdfb315a7db0f11012415e64f58da129aa156174410bdd6db6d995d198805e4cc5f48afed9639ad2e0c7bcc4878c0f00061cdd70a87946acaac92ffcc0347af38230c27147667f6330c6e4d80b4b373ceb738ed8ed073b99220a7b24df387e9400fd6b0c4c0dce9cfe2df412218206becbab60104a2f301652d92fd6320e61c5738f0d3a9d929c89f993dd6246d12db3ecf8fca798b9991739245547229","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
