<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08a340940293eaffc71613fc3b8d96e4b4f5ab2defcb0a3f0c0bd52d3a69e32f0f8894f4f522f908e3e6f601002d669cbe61e81f3e604dfeb7ddc1d211ac72306d39c4540e335fae3ff1602ded8b05c2ad93a68ad7b01d99e5fbf4c6346e6e4c383a95646797e4dfe28841ff15d145c8e420c64e3d31f4875e05de6a3592fee477e49309222a0b2a64eb5b2877adbd0cbe7721d49f4cc52a689f4b4b9a91f14163a6f0f67b988fff886de74e12d1d9075543b24d89dab845e383bb4c41976ea8c074c7e05b8019beb8b74d624096b491c7428d107ff093bbdc81e48cc4fc0c1e0f833c39ed90d15619f4fbe8478c777256bafbf136e6dd6050a374a6775f53f4be6da9dce7debe3eb74f0cbe76ec1587b12c531a9d03deb7f947c4a0192b2bffab9d3985dbce3b4bbafaac1280b4b1ae8a8e53a8d6120018549299e815963d31d9dafe634841b8df676dbccbda04fbe025d577abf5067bbb736d7bb905f5fa2b4644f345e0381014f1303699c8a5382f59263e3f5010686e4bb60e7786d48af064b4b9cf65750af0fa191e0f66a344b267282b3f74a5607e32fbe0d3a3325bc0a99e452ce2a1d2d1810c3572798755e62fa8506499e7164db2874f05c8ebc293123beada28104448ed17b7a0b82b1b8f34b024f6fa2b8b1952c9467382df60a8b04081dae42f3313faf0b558b09945ae3145919f06fd21b91fa3f70933d3d5a7b11f2385be27b821f9c10e3fec73a0300ccd0ddcf255d8e782719a2db0c0715f683698ae32e09427d2ab55beb5cf7862507081688a1c64b36f4ac6b681aab9a1b980e2ce4a8934752fa1765b31fc2b4fa2baa35097370de8006589529fe4da1371fdbb956fb1ea0304bf9f1684ac994a6e6a8fcc455b562a30dab9bd00b9af08a10b83663e150e19169ae9c4c8761f57909db479c748eca45519c87389aeea6789c7132a79e81eebb6ff300bd2d2e564643bf50b60d371e786eaae9d3ce39d7b36673b27cdae451772e756efa413164a1045fd499ffae0d4146b8dfbdba0cd610e99eda7134ead11f7df1f2d92094692bb4ad56374209de2a2e96bc3062465a8805119dfd2e38db167f87f5d573cf2e070f4d1a498654d1255fafbab88f1d446c922de254dd63df480b4bd2bf9299245001529da543ba3f08fa6401a14190c948e861873f80096fb304fa0f270ad7a62a963f677aee7f8bf197ea6d0fe58bb1788ae2b6f126d513b4ebf8f5ba3da4e7e1a35d06773ed8af3c016cabf495db475607c24f94c88863c8586d79ca2e69e8e0be1e153bd3069ec0cc557f1a900049241680e523627f51b902a395f86d7300d5854e5fda0351b148ac59196a12d0f458ca3517971202c850bc2defa20141cc83845feb6c438a75ed31c40a7d5217c4fcf6f8a1e1415290ebff9565a89ac863ca6b003d49c11964b56ab748a5351ede02f0e3e4304bc81434481e28e7c408e7792312ced2d2c8a0372340849955873a6725a6147314eac70e120f9d7792665ef2c1cade04e253f5ccb1d4c42016b88ffcdaf91acff4de3e674f02654c81e6e673648f266a46b671f11523f6bb8722142f8756701868bb4875ad9990e7bfd0e91327ba3318867c274374155fe826f466b49c86ffcc27b86c4de163c413ffd88caa9dbda3436e3766515cdd4a9eaeb5bff574619a148cd5face7387ca40923cafd426e5ee5e25c1b471b646cf018f851ad38b941f2176632a13fd8668977316dd3e549102766ed1771a57fb8be4bc7a8220500614870583e5c40c62d8925ae34f39bd7105d45cd95c57d4139507abec1b3ab16fdf449b0f7837da37ef760e0f60f8c1936ab758cdc0987fd27c6d25610e688331108da961955bc218428a930a1d6d19df5e37560317de724164793fdee7ea7f0cd47e706e057c284f60e9a147fd0558a22534ce0e134543a89aa4b89bbc7588ebb2d0dbc52845862b5a7617749e3bcc58d268e42916b9c9e4d88e7a2a09187375152ac47f2d2ba1b2b60274b5a8e7932c6e8f792af3cf517d2674486c956da04b7afeb66e49e5975fad06f4228f8e8b062b2dafac6e00331a1ddf0492b60fd3ece7beaa8095e529eabd1a0df87c0b8b6cb8aa6af4044723808352f4883d309b8ec55a39c59ec44d46262b2f6ea400097a0f1f234a4348ba4b557690565c19cc3f4483cb4ae4ac8161a766dfe996e3c8844a5b548723bb52d572d5b5defbfdd3c771a0a1cdf5650e93764612b08eb158c3a0b15f16213326ce9a31e14a745409712668d9df5d7378cb2c75214244bea6043a06616edcb08481f543df715e07337d30975729333a1072a837679855adb44dad4c441805135d38c04f13c3602cbd35e8788bb34d87235d0a2ab42b35ba6551f28f789ec890725dbda4779d18aaa6a6a395cb5625a61e7f8e5b74cbf1aa760f43667dc73b1ec573113dfd8bea3aafbb53e23d5037372e5c63547942e2304920d506f01364614045f548e938d3fe8532b55f4f4fa785ecfcf7e14602810ba8bfef59454270a022d1cba2c31d1ab4cbed1f5d65790a227cfb99b8f257595b48679829edb953acf6630817d1621b6019db656eb60659f39906f1b84a7a37bc71d025567d3f031757de7da1ae1eb192915900e793c7c05d8afbacbd080a4e1dfcc6ef1c032989f60ae7207834502f1e408fa61374a33de7f00e0a9f490552ee3df64ac4f318179a90672aa19928b0314d3692d8dc45fa4987eb3999010e2ffa8bf5e1dbf015197d287b249e8e7298a57006017bfbf93efeb5fa406bcdf745d65336ac4784ea1b21634a979757b45ad0c0e45efff556b5432b7ca2f728ce9f4d535840f3b5ff9f0b7d829a9c6d979b73e96029d9b022466bfcb58cc750de363fca251ebfdf7a6cdb59f2df004657231fe3635d09e1a0803eda116975a5767a551a994dbac08c0405d53a46b4b30ee887d056a66e7e0384d5b7d11fb6855483a1c98c26c722e07d63a5170f724daaec1fef62139e81929e7859431af6b8b6c2be3442b354b2862d24fccef497fab574fd18161b452ed55aeed305125585e75984fac0bb342be05d90aa49fc551828bdc341370a5aee2b5a5b413bd22e5a6d9bfcbad55835b2e8e28ee8549741fd903405f1b5690cc2fcab8d43fff067206dd3bd05a09cf1010f9a2f1fa3182430dab34a7ed66d064f354a8906dba5c83fdb967319779edfd3f07334582321cf8ec34dc3ee19ab380de77203b3997317dd973cea24dc151ffe1f6695b161d037b3d366d934f5022f4b96f70a2f66827d56d6ff62edadffa7c362c644e0ced53a89ea9e7d1086787dddaff50fdebf7f550162faca42bf6b1d96d8c872ad4ab70b14f2517efe91450aad251a456c3daaee06dbcb8c438102f4fe73dfbb78fb8e12345c0ebeb5fc3985c9e871c675b58b6d244141abff7116a5aa27b67a60b6d2c3876b22feda5b0b413017aae78e0842d393590783a4199b85b830eaeae53323a9b612c31900c189adca624c87962aab2ff1d9631328cdd3af77f02e8f3f665dd08d98bf5368a2d4ae78da7b6e9a720c31a6e5f4481cc92d9240b9b077d4da02a52cf64d69c96978b0f29d4e56d4a6b1c5adb6a1b509cccebc3412c8ff89dfa5274f31ec119322e0f85f7f3ca38fa200fa33f0f666c26db5fc20f0bfe576c74ed2cc8f05376e5a9ced9af78e59c3f7b36551e4eb379ccfc42b4b39c4ebe487991b16fb44fbb7a6ec0947c40d5d98c955268061d124d14066e4dd649f1e57e2bb4e590ccf82fa10876e440e9074ce3f287bd18bb9fbcd25d78c58612c6d7bd4dde89485fa8ac310066c2b1a284b9c0f6e7dd4aded3c6464ad58d10d8d9b5acb5c5e0600618c83a8cae5d79e485ca070b63aed61b2e2133c20fbca851928f54d1e257a0714c7540fd57dd0c27918b30327265e6335a8316a3330b55777f9dd20d8b28743eb1f4d8312e098df9c0bf9785f0a4cc6dade03e45d2d0caa68809e41e14ed3b9c7f9f8975bba5c6826e46bba262a7ccb08ca66cd4b168684a51ec183ea1aebe072588a4350ea1294b0a0ce7535b203ca1e7a9a2f1d689e516a1060f46c4ec873bc201c9822f73f2b6813e7789094c488e667b70f43eebc7e7684748a0c779a11b99a3c6e0b640b889da4a89b3d92240a766b2973928ea836bca58d725812b5728d2b876a0ed9a3f2ad2bf799a60ac118e6bd99127546140807824803793c1dec028ab03fc13fc2c241d7573f475361543105f6b80d4747274b29d84c90bdf3e0fe9ef149006e54adc9d36e5244981b20a3685a115b557cd9faf53e0af7b1e5dfe8438e78e1ac53cc5e18ff9f9e5d114c59d367ae669e315d23f005882bb924fc88bf6a745010b5f44a17ddbaea4138730a140ad269de1744f3ca02f88b53f2e7dfcf6f09be9450c042654ce830654963685bfcf33047b4c74c4ed9a6370b4b080d9fdb1e9328b2f2c3e6d9751e78b13850db2be786daa025a25c0536e049e4efaa6fc83763a3e987cb8387a5c105b9796d11b933e5e57fa340bce8e08e2ffcea51aad29a895602ed2693ecbf2a3949acef0b03ec1e0afd4e27c2a948fefb70babe09ac6d809c4b57b563b446b561fbd2a823909aa1dfd5d93a854b05443b4cb188376d1679cb07a6eff41f4fd54ff556885a89bdb2cca841668657ac881fdf0b7774f85a2733690695878052be2ba36d193c6ca6d17d65356858874da9f1f8ea270af04d68995e1603b60d1744c724c944a4f75138b85c4996dc7db75ceb017939faa4bcab763d926ff18bbc276a501706a85bbb41bd551419dafe8dd1ec0fc6f4d915c12317a4e36823d75a3ac3478ef8e3543c20e205b68a58d769abf2172511e04b6e3ae9e43a8b1b275aa1bf372693858aaaca36311ebb12089c6090d3e27ec57977b46cc55f5c96d42a07fff7b72d4f2b244620142ad5620968a74e6f6e67f97b8cb0b1498c8e942fa9204da506a42933181cc37f7b7fbaa67e7a1b96472e288da4e83a01878012cf7446b8daa6cdeee468bcd5bccd21fb2c9dc1213f1d0153b0197c520f58ff3cc51de5ba1c082449010c55b1f9875a58329bd18d771f36e6224211f84367b6d995f77edab97cb8a253f30d839ac0c39faea09a2f41178eb88e761ba2d1c47eba1ab1f086968f818fbfbf6bd1deee475e2613398685d1455e620d000095c348fb1642f99df9e111f0af49881bf9a870193b9ab0016f4448fff61561178d3a1c21f9ad7749f34ee06a0f9b6144193006e060163a8269995858263e95008a50395b674d6295a1abec9a058779248a364535ebabb3564742f995f048167ec1a868cc3a6dbb631a9f103b752508e71b200d9875126c802f8853f72733c5a6e08fe288caaf90e89024eff7b598d8a9e6df43172bc8411b49b84cef7ef4b8079996c8718a8534c7543718a3aa8532cf6ea9a9db3eab40b317b311aec6ce29048edc4d184b8e688d9cc4491d3f01a318d5bdc3d33d3e8e97a91d696143f49399a8ab93011d4d36d62243de8fa3dd58bf95c81e344de0fadd2174a940ec595f648e844d0b645df3d4984155478770ce19a62091649f27350718fa22ec4d64d793e71a4df14e03f3bbed6ad0cdebaf665830c3c62d62b5c62c48a9ee84cc2f8fbb8d80adbe59425391d3bbec8197ea70bb7a4c96203c2743418a05def7eed71de47de93fc749b39fe2205f833a587c3db02d0c3baecb1aec82fbec267f26f6cf62f4d3d069b8a1c52cf79c8fae46b42ab6a36f28e4664e549a74cbb385b0c41fda6ed3737a0220a9080782cd0e8b9b8b9f841b7f0aadab24cc8babf4b094f0c70c88cb8b887f09c55e494fd03a5b322766614fcc0beece122fa352fb392afd0151662529b7812b74f9403df93188bd1e08bb655a226267e85eeaa7c34a937ec3e2d75d96df4e983e2d83fe70b1ae7a1a52ca437d2301550dd9fb4f97c5ad4295fe036ecc79f45fe0ef8d06cc4a4aea34cdd1a7960c15a435e2bb525b98512b3f90fae839b740fae513a8d89bf2523265f15da14e9360e3614d4a8360bc00a31685dfdb1d9652ed47f9ec6c9150c23f24c7d666e7f0b2f6a697d2d866d92d8a57b58c2266a4b0eccdd476de82e5ad9a1f84c089509c2d3df693f286a47dfdf13989c4710a2b846752053cc1caf1e57c78b730150abfd27323c05b03f39f77f63ce73d5b4caf37f26fb426fde8f3c0fcf2e39fe81711ad790f24a1ca09af7f8b830018f4e6cdd613c3a9076d5cb9c0b78059f78b9e94570df2845a18e728a110539c73aa9fb35f51a0990b71e0bd99d833c258afd998e65fe0dbe71538eb8344da9fec5ca4a6a493b67999bc4392eb4c4573d62bc01208eed366aca2d88dd9e173bf7f8998d1bdb597557c8b394ab8e2e8e40dcad4d710e0b9c0eb9772c6593cedd0b5a183247456355475154d8241fd7367ec514949e41dfc36d524f2fec65f2f52c88542a93526a1f5e180dbbc2db2fe299055aaa4642a7cb839283dac5f305e9130018a945b5cdb1a84babcda1d72b181a5f5f3e232cfc7ef01ca10bead3722067e57c9e81c1fc64e82af20c293f4fd8faffb1100e57126b08b8f8fae1279dbfe58060e34a196bde4061cb0bcd76566d85f2147460320ac9df36d297e75002684af76168f177ea107119e4b0c4218624c1accf213d8de0fe9183402caa5866e9f393e8dece6d950ecc1bbc5abf5a6960c4b170f9ff1dee78bb8f1f62308865e95ba465c67d0fe926c9b77fa95b0e25c05d292160c42cdbe4c0e63a88fb3667515e36d128923844b12b439e92c8776614947096691d9e2b17422f8c929ad04cd208008a883cde82c48677b7352f7d77b3e0646b71032b286dd4d9dc421f4452e04e494b8e9fca1f54f95e0b26faba79afc6aa207180eb98e7eb81984852c61756edbc92d0031205764f79fb1d85392db151c91954bc9d27e954b2aa541a546307651dcd57f9aed8cd84f42218be5cc9748eeb6aedae0f23764efde0e36d85edb1cc1ebaf22cb8d32b22c45639955edffae251924bac082541b917f24e78e531bb11318128819c674fd2ad0feda01fdfafc7db1c2f7ddef30e313253af9a35d34f30d0da5e40e061d4386dbef8ac326ba2b08ee797bdb3d3f68a60d170d6199c9a321d0dc856afeb787a2eb200846294e5a6b35bd6e7e29c660470bb904287d392f918b8ca8e5824d3cc252dee6c5ed978f343b00ab96a564a7c9d1e5d42f9b0b96e8e25c41b0b2f20add11e48799e2b8830b5bede14afa2f7c6279393e4f5c425c8081fcc1485c723fae175d813c3d8de89f5ca5214a70f62940cd92cf9589f29468214d4953b6f6d1b1fa007f058a0ea93c87df75fa1ce3184a7f8b2989942959b6e6e3cea0506126dd5781e3048edfbe94a0472289fa8c727d742090f74dc0e64b6bc7a658623213dc7a206c5be697b39b4f819188a84f180462dbeb48c1fe672a54706102cfad16d6eab3712f2338b602979f22fd8ca47838c8f5952f8a83e38da592915ea325ed499312b21c539aac82688b6eb9d040c2c2390261cd9278072637c6e5759f10221170accd161dcb3ea15a0d2a807c309a5d977b8876aaaffe4d12176e9a443b09c1a4c76481f8e65edc2e3586a3879c0da82055698202bde5d7a3269ee728cb4ce833a0f5d9bcbfd319aaa8ee2d3500fcf2cb428e38fc36e1ebc8c50ee5da61a2b48f739463aa7ad6aef2bc5f3a0ff3e108c395cbdb531e8ab85d8a854d55329cedf208218cf09f5012133cf3f99b26e115e62e9090cee9e961353c0051e8885e334e15178aca9e0d258fcca5b918e0e83a37f48d6735d117030fc73c414661f2ca1e2617c9157fa3a2a7e1f64910d792c2fe43d7c5ebfa3d12b3f9b44cc98b08cb103ab642248204963d65abe8ba1fa363debdf367232ec4599ed70cc957e7d557bab90d26fd45a1da2120301367ded086d0e8152057ee99280fd0e296ac0d0ef62d9e9092fc2889ebe9574c9acf8d7ad2934fdc56f9bd89bd8bc2106981bf99ff5ab3b08773dcc370f78942822cde37755b88de0670b7556318877fe8fe28443aa940637c149d3100e0cb411a99b3641569dd83cc13341c17d62e56b4245c8a64a9f8d2416dd76ab4245c090d399b3092451113aacc50fce8663513ebfbc9d1d2206ea6e23c63b46f4edcd3108853f64128d23cb685c6759e8e236cc17658c27de54475128ffa0645887fe8d0f2d2062c4ac765793a985d753e78e0e4c47e89edea3d5d334f945c5ae5de24676b76f493897ec37348d1ff410efa1061c4ed100dc12e8c93f4efca3cc19d340ac2a69264ca3323c90e0eb3964ddcb16ecb86f8555b4dcc1c70fc4294b370dbdb6870ca882a07fa7435fab132d795cb98838c827f7833a7dc0891c2e8d103e37bd944ba68c6bff0f9ea51a2cd92263ac6936ef12539ea802ee2c32058c8144ac0e6445f55bddb415a58edfe28f179ab541af288618d3f960200ae23018e3dac1333ada49ca778b603107e3d034d9c15b6472e160a5bb9fdadc05fde5cac818a3761113df446ffd0d9d15c851405d185178a3822b80ad4eaa6f235a6ff96fd30385a8fbe84668e99c2e8489dfbd434ad59b15a4ce6ae13a390492327d0bd8c70fa1fb192d7ca3c6ca7ef493b1b16cdf028ee409cc217774d8da977287ee21d21468a8d83aa8ee4bc823f0ed2675e6a6285b20227792c15567f77617e237e4d4785837b69f2c2d2df624799882ffe35c7db9247770a7e231bb7ae1108dc73afb995771e5aa509aa24e6d31b72699051d51ce87bcd0065d2de6d28863799491c46e0c5b18421dcc7be0fd33a1b562a15f2dabd08a5fbff1ab7a3b1c52efb221847cd50f65b0395c50717ce2460407db50084bd0bdf3b6e6f6b4306368ca8d4b42813e11ff3d82e416c96fb0c6b4c77b0e996ee60d65fc7111b07ed08b4239a8ab145885b56b75e39b0e46c70dbcea478f2f40e6f5b8a30a5a85fa0ffa2de4aea99c8a179da2e7209be98548cd250413a63eb017b08f193d2039df322d653318922c3252c9aacaf2867f3505b702deb7de0e0174015100d191748e7ed3dc722bea134582b7bd0b5e6f42a794292af15f6102fc4b2fe8fb7af6f5bb354780f647011b53e193931d0b61d71468c13f3067744f47fdb0e385edeb7d332e5ec695f4f3e17ecbbf080aa9f6770be7d9cc39d8ec8c95eeaaad38724a6ba8d6020a34a893f3d59b3b19092926a58c47a8e1a9586e53f35722d0792e075b987989bcf56a784390604b11ada9128bf7cca989182895ebfe7a8a6c49f81c851e3a1b9a554fa916224e2e1857b6cef2020835903d7ea311b9411b31d84cf7c59d30c0f46e3d4f71380c4df601de8ae3a39e0b0055e1b0464137085b1a760b4f414d16aff6d0eb585b69c1f2ff68e1c65f48c014e93445733e5494db5cf317733fc3f6426b56070cc1e9649d8b3b02c60a1e7115f76ec13a4fc3ffdd6b5878e59afef6f1bb9e54f271c7736f8ca06ba75bfe22f34016ed57ebba6c8fbf04638e643545ff87ded972b26f4ae03cfe9844d849069cc1866256639d075998a878e6eedf680da07f775af8ba6b0e43b13ac8973ba6f6cd1db56baa4e49d59e26bdf361784d4a88ecebd254e703cfbb51d50ff3de6dcff2f377d1be9c6a8c727ffebeef846458bb4b13c0546915d7ac2997734134b9e08b4b352c835dbaf468d6a551bdbb0f67ae6d9064f421c102ad4f72011d4530eb79e90e3ca2ef69afece92e0fc05bdfa4e9d6cd2842da49abd1be6c62bb1929e1b24bbee2e79037076ed2c881e4c29f0f5248e25115fecb72b3d7ea51c04957b313da8c1e87f798b19c97c7294947c0f1a84fa5435b82a464c11ca5a0dcbec1e4900d992a5cd6322ca5eecf96cd8e75ce876814cac2fd9b0770fdffddaea70ca450dd3a18c31b66c4fcd869d41c26df9417692481b3437803d1062aedf87edc05928fb11ae40b8993eed066790a9a1ab907e3d01beb39eea3caeec55671c5cc7adf4c5484d0f14941b64038c8a721b43157cabedbb7e362d5fb5beb99a9a9563e807b28cb638286fc90436f85dfdfcbc2cb690f6a5c68187ae6ef388f5296b3940fc3ad0d908db76451af0dceabc0c814c8c51cbc717a30c211f0fb6edc0801ee2e6b9bd507548d330e77eb7f74c875adaa7f1f5f5bc5c959afae4b91c4ce1e159b02745e9cb4b953196c10b0444b155600fce80b7735e3f112c909a3cd6426df3bb68874347aae634c0b87d92d0f014b830f87ddddc806c69a1b01a8fb7fae297d93a76447a96fa30496dac6d03bec03e6a92338aa46bdc04be25a64fc3501c7ef52ac1fcf5756ea8073465cb2f478bf747515141f8aae80bb0e631db5f92b731fd9474ee527f3b9a8b12f3d5c89bd7e47d79e9b5b56be56e8f2140323c1a18e3f0ec1c6fd561eb7c9a3d25e34f6a0046c95469ba9068208ff9de4e8c6905d60c0caec88abe045a91538e639b7e6e8c3588100604dbbffea5c3f2686e277edc0f340ee93b3447a675e3786a5bc574a2c2b9d7e97fd30a860d01b0f0bbb117ebab9238707ae825defb7fc4a421fa179457509e62074007f39c42905ad86a17b5cf03ca3e51699944e3e3d6b533bfa9df1eb6fc06cc5448b1cde43a418a8c1cb1240e3098611decd26a9205716f91c28939b49fc77ea5e46254d818ceafd1c9d281b2809f2e32358b4c842a62daf9c2b5f97a2b085f2bbd43dad2f37108961963e9b23faec3d09fb3948c1e23d6c2b9abf1c76d738422b9b4ce196259a30a1e9262c35b7ec6c4569fb5f5b56f6d8e59febd69395de460b01e79f4bfd8647e192cbd4fc62e680548d1ac28273d09dd403032ee7903f4f148331c219638ef5c518fa8e06d4012b592446fab5b9c10dc8e0bc2b9013a1709a0f7c850463fd3c464f6d103b63e438a1291ce8af6e637e350b6ee36435f3f91fa48ec14b93ef1e8aefb4ee8ed41008ba5ae0e48b6f90f2d72bb0b255463cd78307d791800e84534aad77ec0926b8733af1564c20d8c63a42bb9bc21bd0777512d6a87b9a41bd7973938432b4d9646d6ab1a13e5cc62e72b1270421443b1fb3e269cb8203010afe260282a4b94093b02df85e3826e785bc6b069464e09fe8f2824a15add4fd74c50c15d2b9abb1d83e13381dc3d4e8c6eb37e98e195a6b1fd65429c84a3e65a32a9a6e7346cff50fdab6a73c545a0f7077e2403af88f348636f1593507d5d0e04da8906a96c27f9e10ae49886c928e2c47dd912225b2abf9578329a7148fb4eb7127cb2e407d3e1061aef2e3f05a3f718222a3be009efb92795c35901a1bdce3ca9130e81af3d829dfa6ba16224b311aa448c9309e5ec056cf8c52b66c9ce9ff824ee316f7c3c83e68d9065a4e0ed2010f77e86c6547ba0874df47e735bb3e06f03649c5426193c52d68020452c2f44dde52a91f18a028b467feea11cb87a55d998fb445e492a8220cd54de760fed1935d1f2fcbc2c254a8508080e1d29f14c75eb6af397f181cb2509312ca1c922b775d0e8f42b3db9badb7e480b50f37296bcb6e6ea70001c6a026c8bbf031e043d7395d4cd59c9b740800f9f69511aaa41dfaca1434615356a61dc5c1184ccdc3fb93cf1500fd4203f724d58fc7f40438897abde51740651cb5709d2dbdb56b6d2957a89f05f1c08ed2dc060ca294de83e09364f4660dc88e9fa9650704bc84e23045eb0b2665de50a2aa91e916914947e3d8318f25eab46a07c99017d6c7acd8292d349558a466a63633e6352255eb9c0bfa488cce905742f86d0cbc64cdbaf23c2954ebcfdca99c9fa37ff6780d12c338a1a43b1fb58fa586e261a3e768f8210a0c7fae89c94c08ba00f04eec25797dc4c51966e2c27a42999604089000e2285af530b664e4432510055a578eb167b20d2824ff1231c4c7e04f35a202c26eee2d8005b8702bafe200682fe934fb75a4a17093507dabb15fdf33ddaaf978c89e69347590e8eb82e5699a915bf1b0fba5126fbc64f48d7905dbfc4810247ea23bcaf76c14f168d47e014c1ec06985dea8ffcb50cd6bde4b45c97e1a71fe544492222c4ad4b63668b8cfec871f2da8ad0f92fb6c76c53cd69ce6d494573c1795cf0af51d178261aa1c300522358b45b93980c10316f9e0c6e2bc957a5053d91542a4f466ee4168b1b6751a0fce6ec94312151a15452146b30cd58a6339d21fe1367f843df0422191a30b5a09804912c74a20808558b6b96ef115fb18e6a677117ff7416df0f2e85659d96f51318ce79ad34058d229353b7723a36f31f0e59f73598ff73bf7cf137d05915ecafbccecff0e365a1465a230cd9699bec361b586c05ff2306d43a5e3d3c6e39e59b54a7ed30148412fd0684a894ce7a7a0167f0316938d36e068e8682e7cf5cd3af8d015318b29ee5f81172156f9c7ed21e0e367234856a96a71ac9243ebd36ed8d03363f7a7a7f563d88069148d0239d1f1511b9d50b65cfa5533ff6c7686f65e44dc4fa1ebbbc02cd7a36bf062a3c65a51a27af91bdb913c749c2b579520f0843b27e107e86501082743d44dff8f5c4e12aaef60d2466037c90fe8d34a6b7e9a22acd36dd2f035001a31dd4ccfd73904010ce2e817f60a6d3614aeefbff10a8d2dcc81383b48b3fe7cc9b7836281e50b7a70966c6bf7ab876009c61198f5e0b4713061ec24c3ee3cd0c99516c95f5491e4f06a26328319d43651a49bd5346bc4758c1f1d9a743f3e36247bb93b6f483076f0fb56959a4d8aeab4288ed82fa47b4538359c56d7491996f45e6e3e5edabfed808d1103e3da44babc7617809397a918f2165149a856fe7cdb43a135945312c34e75ecfeff7ae32fcda7ce34501a8931ae6df7e7a7ab8152107cc552b30ef9fd0158a3379f723c9c4085e8d985208ea0fa051f2ff13b4339f01e6a4cca31b579a3e7126f7f4e117f0e8758f73636d575f04c25f943e706454b9b9b1ff156da770f690e9c7c17159c69072604118c2139aca93423f5620e4863e516eff043939ebfae9dd784142dccdd9e0085c90d86c5a148e15db9ee8e7f54e0427aeadbab7dfa358de424cb5dcda075a7c45af53c754ffd6e15fbbb53157f9ec5bb9af3c6582059b122ee9a2f84d54ebf3ec92ed04486a01329d8fe66f27085ff7440197d5b238f04f3e55b65fddacbd88afee59c0f5794da1c7973e1462be07ab72452c7c5140a0425b4aaf007322bdf445dae429b2b2d95e59ca6e9d69a913ad2516e4daf2ccbb939b0ec226f3d01fe917b0b25923fc3663150c35c0312de2b6b993f2d97fe0b32657ab2498e79837da44397087bdd2c1dc11addf9d9a65ae643ceb976a079e89377a992e629b55c8b1955fe4b75fe73970ef0af511b5e38de361fe54361f451961639e348fdb1f07228ba3ddc1456f3ee38a6c08dc18cf5e9d72fdce38e3d2a2b8f9ec859a5f03d88c3f30a9ebb73a59567bdb29d8e368c24a58854d61c252adff1efcf14d132a48475f2484ea045d9c57133fe1e6f3079ee4b80149077eccd3ce6757a5ff17e93d60d756d9ff81c3d6059c14c25b1367b691362b718666152a2fab785ce8f5dd43b87a1efb51db887f504c725573231a076173e45c550a142aaae983cd5760d8d8a5e30bc264cdf437f55cd9f8b16d43bbe75b2bc666055fd6d54c25cc0e1612289707d6a6ef6fe6a3d5168a265c2e66068f588c4fd1a92c38dd53c1d18f44ab09f35397c4bc6bd460ce10b4a39624670d5acb001e5b9902ec6884f84e9e051639a5aa465a21c6e5a9de677e6c665e18f829c59c5cb57e5c0098a0925b8dcd435df474558689c753a8996873279bdabd963dbea36017a83b93c4ed38fa5d3a9097cb08478ba0da8b7190b0015e0fc7b9439a5cd25dbe6a639edb1c3fe8d41831dfd92ea8416daf513149b4eca20a32541bdad7b68883837c83351bd0d985ceb0751d8cdfae671bfed3bafe53bdb1b8f54e067d985a5f0597fc06c1614b45b8da7eb462f0813547be6f23600b777d108295e79ff297c6f7ac77aa07b143248e9d89d51f5da895a73d9124d9f76dd73fdc5d1b121b9b61c151355d63e4d72d230382f9a590efaf3abb22b71ddfcbf4a97c298701c47b1c527b0313138ae14c7bbf3111bd775fcb42e1dce55e00164ae7d075c17f5659804371a940850c647d3967d11025654b503f92f9025f441447448eff69a447c713d2ce57d88b6dc2534f89b4699f80d93e692ee56a296a3f409d55901cb9736dd1e5faecfd01e663b90afddc807449fd25186a6983b1ff382843c076bb38f0163c71233e7f5b4b925710af0db107c5c36e302161f1d61647bc9030056630e6dcca47c1c3673e9bea5ac87092534400d8d03e9cc6830","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
