<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f613fde2a4a75ae839037f466b17f0fef5b9b32451d67b3c8d82a80a11fa42de036ba94feffd17b41b56b7b2d1b5be32891be81e0ae764a03ead014b3339ee6217ae7d43b797d96a9945064cce7b9c12913f39dc0c97d26600ef7b6ffd9a9815fc4d2ca327b837bd31fb62911e479f0057298a180c1921d7e59bd6b43adaea287684f413b145038a4b73b161f121711cb866030cc7f636c70402afac1aab48abd6ef6d78e679d13bb7ad1cbd298128c6db56ed60480aa043d92c3337867b4f96f4ed241dd745bc82ea72c7bde7d6368c7429f5f2be0523c4f8e9b2923df93eca35813468fc8965612a66863580fdd87f8c8fadcb78b77b2c0c6caa9b04e3946f78f5cd8857a32485f2eea8f975708605e6e2813f757061f61387363c633e58672495d0421f34a7595599acc3a21613d6b289459fcdfc1d43c2f303e8edc5706d29617780240fc58d9e7cdad23df4a99e13adc9b8ea5ed933c072088b144d3afbc44cc660c766a326c67815dde4c5deec69b05125985cc51ff3248bdfe36f62f2c829ef7a0d6bbd1bf6faae0a1664e9e7e1853bc60c8b0447f9ca27746f176f93a46406056b8d3ad54d46696542fed72797063c85fa4844f946e05253e34108eb103a33128edb6f6cb62cc4509c83b278f1827854f612f238bc20467a86429c71b764321cf3767d7502dc5f0ae7bd49880876a81ba2ef4c5e3b682f84acaa1bf56767f68aaf0443362f903750d995241676ece101319d84c0b5b39b1cf496c7fa7e939271e8981e31da7e97b499cf122694028293ae0f78d0f4a20938a65114e65e8699067cee63a66774067f9cc05c4faed2979f7504242506f33f6a2dffc1e0b41e4fc20909525baf52da90b3befcf7d8f61a62fb1dff38ae12b874bb3e38c2c92381c860261c1e5053782621dfa99d9483cef3b20607e1b212be5f2cd6ccbe9a93bf93d9b7ae3b03da3350721c458943bf889adb7a4e39522f0eeaa471cb56017ec436be849e97e588141d50535edc06b1245d3bbb616f3781e8914e52df631ec43088e901c4d2d0a456a201e4b13e0df5b225d622b78cc1f0dfd2321324bc183b0c8e2f09641a32398194ca6b55f764f452ffd5539ebde24b91934412c980c3888aa624670f9b065fbd9ff9194c8612da745cd8af3eb03118a190678489cb75bb70147f1fc68e2522aecae9b12f0f23c571fa5cf1105997b2e1d35456bc86b61164d52bd1e549f3bf4ed63bbd7f824b3dd73ba1bdf56e32ccbbb6c00324dfa80048cf2838613dea804fb462bbe92bb8eae50072e53e2285e47c96dac50d51c59118a28ecf95556d673984df514b6cc73efd77e7c6c1efb06493bf62c9d8ed27f43f18c9246f589ce9a6e3c8235adc06f350979569bfb3e40b3c5c3d86f23d8919047ec545cba6fe7ddeb4bc4b8235dc4bb5081df27a81e9349f113f22c8b7cd7fbf107d0352242bcbc7fa90db4c957f42e344eba04db5447654c87f42534d2bd1b7cab6d6339a3d6a92d8f0b40a2fcaadffda759219eb9217b24a210bfdce5dda67b35ce6e9983e9b21cf567f8c09cc18ed3b6eaffc5e8fd47ff5479075216faaf7d5bc618d3b47502d9878c2f813cabf3e11f1e99cca70f1ebceec8b6ff4a6288aafa6ee91eb84d57fe86520c396e076beb688c8351261effcb626d5ffc630758d3c2bd9931e123f5e17b5bbe90ffb111943081f6735fcca4a465815486b39dac367846214dfa069cb64f949ac55df4500142f2e45f72b942ffe6435b0ab388cc141cdc7d6f8f01a537d062a25d410e0844cbe19912fa210dd11a137b607db9506b7b661436a2da423a46b7dd5f2fc0edbe5d2ad61e507e84a4708b3cf9ce7a4b87ace1f9648e1cb67ce22a70699dfbbeaea65e15e42d8aea6a8a785aa13e57bfc609dc005b798fdef40f8a3dac77c2761f4a2494213bf50726f04a10336620215edb8fa42c048834c13da83aa0ba7101293fdae6beb7715b210a8df8db6c4f2eececbf4ac9b7ba95c7223cdf9d393aa5a3223476b55e57144b4fafd4b7a254a21d478e3a9352143158ed9424bb885e070b4371d43363bce05ce0463c31969a76f86b37c343ba448daed7c2d66fab966f0f6ea094a274fe66e817cc66e21c2f5ad693fd2dd4704b8a27f55936c907bd120f386cdb63dbb68b50be4183ee432ec18f77ab33111a65284ff153a0b910363d431dde47716e943c54d359e9309bb29a97648ca4f58e40e450c62788ba047e3f117855e471e4a430fd3bffcc16b57946e8e659a44502da49f4b497a6fbe21125b0fa5d1e9aeb2f579e1fcda5a4d941cd6cf5001a2dbaed8ac99590db44e2ca2f7944acd1f56ca2fc85d7b83b05c04550bce552beaf9ce065fdee5792d4b0cb706cfef4cd495aedb754d66fa3770bcfa24f83c2210ff4261f26c935cd5dd97237c28e6100742f64e64d07e00f7e51355b951f82a13d829d524510a77792017bc9726526e45fd3d7d41fe65dece4dc600806d6b6c139d34c201078348631d1999d9b067b25418d2d58e69b550f0b39ed600be92f9483cdce5ba75fe91d09e044787fdae75759f8cf3505143cd7b8dee7a3e40ae81275c4c24ba1f5f3844c39564f856464d9b25bedd79aeec2f94ef1f64e0e2947c33f81f6892471c2222877ffab7767c123436b031fe7b6a586d5ae0382335427a0417aabc7db0ebc2bc5708ce60edc81b9e9cc2065b91f63d301e5ed398ea8c4f23596962a8e346a11d670cdcccd2d6cf1a8b4290ab2d2362f10fd69299e5b4e4ae9735aa17125ea3b65e4bac58c6b5ddc1e4c70dcc1da25305eeec157c500048b92c4582be38dd43e1884f062781d7c771ac8086fafe9f26875c095fe8c9f5770407156568457f9f9a76b5654ff90c6c2f20c6fda802bc7e1e7c90850b068386cdb177a2e38d74b52da930e00a66a563c084e7d91b5d76f6c3f195f324e16aab0dfb71af7754c7aa809bd432135535a50310f64390cba97a44f0a9a2d0b05d772d176e436a9381244c21b5a1aa4462c93ef904ca79919eff380eb9951f699f4c5fc4da5ddc6150dd62a06d0a65f25b4c33289e8c083e9f16f6f9d9dac74c94d3d07a1f6eb1044f8ecab1c28cb8aafc650bd16384af7501bed81197b28fb0c0518ff05108032fc67194dc44912f7d94502ba4a5bf585d28e7af7f3a7d4c7fa47ac6659452e3b67dddefaaf010a14549b58579669f1504d5390b0e79c0a862929483e9ad9482c8d676b3dc145891d3ebb869c4b0349625e7063dfec2e807b2801ff99642cee68a75d1e398dea9ee6845ebefda010b9a6554e1b807c335129e3ec0266689ac0cee10996ed09cf90423cefd5cdb0b81f517fb8bfebbb38c86effb48fb8a20bef2a1cda1f01a6ebc0ea9834bd5331c48039ff9b9a7b9829aaed8f8f1a38e771c0cd91a7a3d7a06a142757f38ee7c19e0f8dcaa572ce965a54347096a5956cb36b8d623ac5500fb6597bb89299837b49fb6921f5f5095f3bcd18f87b1d52300a8181f122dd866b950e56bff907eaddca60efb1508a9b782c7cdff6dd6338ed7218168baedcdbeb6524a63006b86326a5377207fa7dbeac12ff540b9acd820b470c3bf09e63b51cd9e2f87a82c764b9f37357afe07bbc8b8488e39f2c31b15e6816bb88717269b9e730bfe0ad8fadb35fe6bd13107dee11d1c7db8b6cc1cfaf6ba328d13684e973d4113d526cc11eab508de5b227c2c9f481058f2baeebb88b75da250e3cc708d575618a62358851b53a1b1fa7d542b446bb1a5a84ce15a8402639b04367286e2fdbfa00790eaf3a71d3cb978c116561d5e0c38fcc244996eed8afd37b46ccc3150a7a3a118d5c26dab06fa30b66bbf7d5aa26a36ec8f670a81dc88c6cfeddfe6c6ad93a361ff04102d0bd1bbdaaa9018ec2ecc87a60e2a275915f9588b3d62e548036c951acb50eeef9e5f6c5a5fecedcbfdffffe549820e9b0f601615f02a20f5caf36e1950a5e5fc9f395e8a0dae23979b87e801d9448da8b2503986f9fef5a792594c089fcf880d4a9108600d05e39d0412929913cc62c5ae33562ca689270d5c4585d139b82fe3c497f29f6b54a7cb445dd826a3e88897b86543f361d72da765579997fd58434fc893be3749128fe609fdb835f9f5b7977b045406e156541a922daca13dca2034ac4ea480340661949361d2605cc8fe20c29930303a6d64e87e199fab92a3e1411244f2972e1148c707814b4d2631e9f2f89f718f4345de91e74649e401b3ded6408053430a867f5e562d65327a9211588a82e238528898b12da4cfa068c1a656ad55b0acd218b35d3c69290710b332b878d412750639090d65ac89c064c3aecf723a2b199d65f6e274ac669e6fed722275c5cf77b3cf1d8e3b26f35b42cdf8c2a5cfbf4cce893737cebdc057e08b306679b9ab9e208a0ac24579d2f12dd3e8fcb29c2d68f8436fbdf5ac5035e44818a466d68c51dd5c9801ef60ecdf4fe80bed5c3789b0c6307889413d62291bd5e235b47e660a000e95d7a968d38415124fe85f4755b3960b74ae4f3b48407a8c0261f9fa43a2dcc1091c8862c9a6e8c1c8db42700ff2ff048c35c85fdda2ac539a552baca8d22d4002942ca705cd43430a61def6c09dc3381006d31959ac59d5ddcee9dfa3ee6cee8241d4097683c5fee5fad41e81ad95680e7b3f0aded0337ae5fbc57c3568a358fa8d91f3a6769e8e3ed24d7356452e99dcace84b9d795eb3372c273ccb9c178d7739b3582d7ce3dd4edf333ac396344aedec219a7122f1c7b5821fac8af755e7df8513b5de6971b0ef47f818fbae88ab03e59566f278f0ee9d6e984d615cc51164dc0a4810744f2e6eb208370d7f2c46536b22b89dfbdf39ad1c13d26fbe23a94356bd691f03935dcf51b1a04c34c5f929473a12661b935080fd0ddaa8260d65073c1fce821333e78311473b98c3469314d75691dec7cb4c894300c20f9ee3dcede47f7e37b89bc85203e05f097dfa4e88201481f08f878d0a5ed20ed12dd883f347802dc3aeae787b0010a59b17bc5bf1c92c03bb066c3ed8bef5e1b5df09ed52eedd0234911f89521dd0692c8404855c638919901a69c963b500cdeb92ce957e83abb2a9570c60190153742b6a67713db232a12468b588902ee609e4049b6476c528b2b23ff6262116af5ddd00d5b876a2e6c71db9ace121f20b3688508709bc2ea9f43a7109cd97745b539fae34a4de9d29dadb597658953c0dfd4a9cbbd235a6a050ff2e84189d3b6bb0e72883c66fb8d07f4e2c05794df7bbf1267bd031c1d9e5021f6be2eae5cec81bc93c08572f0a30c44df05c08e16b7684b705934ceb05743677de28395cce1555cf35b9084c22f1ab9f682621f09bca0612af8e956dbe4ed8b4488a6371d50eaa529d7b89369de4722df49d43a6849c9e82bbfed8c6f8f95f07205b0c1b8ad5f80435de617efae2cfe4f0826e14c0e5c439120283b289e38674376e0ceb8823dc3444e4fa7af03f5ebd32bcccc8329e87c8472fa8895b61cfc84bf507fb41220aa05fffd37f7abbb4f5edf5b5c513ff25778d781939a1dbe023f66570bf88c1afe5f9f5ff966b68313ab089ad1cf77f2e12b382924fc35fb47a10b97080b184b73af0603c717b2639c0ef734f8406cc04a7ba9d6cad61a4ac44ac08447dd4689947caa8014d37f9cd0aaf3ba7c47b28971a481aeb546589394b4f35aa8ffbba924a23f95345124647e391c45e97a391156c243ac86c04658973ac3fb8ad00e09f6922a6716947425ce1651135e388d9d0e5dba5959a48ce4ab371eab53b7a3e57388439a807f240c4680a9355025a8f50d95b7aba6d3e1c406ea1565ddb429bddc1c648f25c318e9c1f0542f36bddf69b65235ae6e194726e7e5286a3c1c58d21c122707222f444fea1468bca6b254826665a4eaccc1633a08245033cc8f472ce3806bb76768b3cb689a2bcb8c0d2dbd8af3120e45da53b51b20e7836963e19e301cf6d6177f9bbabd23da388bbb9d0d3078b0b090e678d581530748379a14eaa5f51593d49d40b19923dda75d7142d814c5d8f181e080a20ce88440367f8af93c08fc29b4f65a36eaf255217619aa05c8d8b63895f56686738063865b9fe51d84c7b3e584f5b361cd63d918c0d8aa6b70ad6c1f916cfd40b327c291f515466a98cd531913d8cdb61f40a65021f1fbb5ed4b59cf5b09d76fabedbed68840d81e9cff13b33c6b5be2a017a7e4369de7656c4b57f7a05d79a9a5f3516e15a1dece97caf48b3d59efb39b7a54c00376e3020c5f171edac448df2687e1b9bed65a5b6467f707f432af6fb0a7c33d472f8aed73d99cc47d68de3ee07ca11606a36545e144d64139ad77be373e2a454367e796a7f5ad053b2a61e89840edf288b36cfba74808742c4fc2b27669cd70450faada2f9ce9b45f2b483589b8f191dd0dcb0ed15a4cc08b026400e4cf959c91f83162c895007546ecfc0ab52dbe39af84e2c7e5b20d91c76f260ab478dacab725ac62eb86fc38efe386fac2f5121d173ffa2655fc5f720ef0aa4d9e6cd5cc6dd974931efa67ae2594a7bcf30da7e46cadc3c8ec56ec52e3b77797e2f2085e995faf56f1d494fb85d5f35e79c77e7ec970bec9b97e8282bb6e338c9dcdd5ea8316124a77718b1deb9c0900984a03a73d3085553d15eb5c682998745767512d399281db9dfe6597a9f5754b10ec07e29353b0ba7f5508756d634f2f491bd80faa8c632610d4e5af30e4f8993e4dd6ff432dddcaa2e2fa9f317c800a23f0239269b909cd6c8ae3cc9ba2c24b46992440716d305db6a43aa3c08394eb4a308612ce0d70ca423c2e17d8fe0e3cb7355850c5fa55c14af73f0c52ae66fc91781260c455268f86605fb612135fab87ddddef18c7c6038f90947fb00deab8d75e524d56c53bb7f808dad0ebc8b31d0ad5389b887fac1c695d7941e703c059e19a0c52b14c8e4603ae359c4083ca08224129ffa84a6108b017f5c9b48fc959aba78322a170dfe5f77f28dc902deff6c52a08599de2b2901def08135d7b3e5b0467be65fe2fd53f6d815d130498aa9d7d83c4c308607ece5a684721c45a2d01c84cb88fe5083b62f23c34fccb753fc68ba6d18453c2a95fff312bc810f410d4e93f1785645aca516ac63ab604b61c7d7b651c82d8dfbf1a203e8230310f26340c953bab0aeb4bbef21e9bf3d820f5978ed4b9e6b5411ce59e66c22f179abc33e6be95aa03a828b8e8d35385347512251ecbd79cb8b3b17a02eed219fdc83c2d6c8d66d900a5c8a360e57f6de0f3a1168c69c911a4dd0b79fe07e2702a2e39a0049e0f94db6f475c3138cc1cf38fd7d4218829f56451bfb9ba8b855700f3df1d43adff1f264ad613a261a3ad6fd2425dd28231ae029265fa941aef67c82b2bbf8002d82d847b764e79d2dc276a16016bdfc9a1b59967d35819420dc9c62558f702297ae98d36f0d370eccf7599b4935f23887d55c9d4f839baf746208b4cac7c0fc4a92dac0539d5fb537e2ca5a1f7536b47bbed84568aad840ef7dace0ef3454e4924a551624eecc22ef649c630ff6d6a5287bd781bc5445d08fb3da358a7e181057f3cbba8683322e96d0df3ad26c9161f0f17ef6db78efd12d67e9fd596aea77f6be98f185bdf7505da0477cdcd7345095f7d0cf32201e966b84baa670f55076ec6382cffb9b8ef5097dbe8102e70167c81568d9645d0ab488925eedb585d692b541d895f4f0a02e5f6bd96b4b75f03e1a5ab111ff99c19f988dd7405a402b2d817bbcea7e44b8d0d78fb2230e34829cb6a52f6209de9814731f775d0d214944c874fa93b72c8cff1a456ff9077dbca96f74cb2ff086cbb08bc35148087d0b797c62399079264c94a688b38d1037bfdf1d350ae9bf6f08558c6a2fba8a90b49406fb8e7bc97f75f03e55953375278c364d50cbcefb3bb71c1a2f973caed57c6b48783b8957a899ae4ee208e64fe0d9b1c7dbe36e52fb907a7509f9fd847fa881158b52a40db093785de1ed409edc340f2a15e597c598f38fba6a3368a3453f74fc01cc4ac2e3ae02d85e904ffec0698b6f5561fd7d51a5874d49e0e69f8bce78438753effafc0923fb4b28f9bb2d12056f188959451135ea28774545b44f9db0defd758a76ea123772bcf3f140d2e0be30392ab0496096b14495538b98d989c0bc2081b255ee5ec1079d8227c0514bab9ca0c4d455837b6d61f421716849132a9b9cabcaebfe865f83b0cdcbd94e9c3368913247157e0d1f29a189360f829991def1e0682c0e9c1f53ca8864b7d29ec95b05d0c5f5f2b73bae53c8afc72cab949b12c6e130dc06649627af03db30bcb6a3a89e4036a02f8e1c2eaf9fa0207b63de64cfbe076e73502b159a1bd7121e66c052ba6a157c54fe9e4ae4b8dad287ce508ca61f7b46dad23ebe326aaa1820a69b28a9b8baef060f6771b1d5cf5febb1ad10c553ed3f74a0883b01c0d45420e75138dc55d0529c8eb7120571bc0d83f6365e48db075971759ac8b234ea44c33f9f38ca013a2d4fdfe7f83a9e5f22e269f35e34d8e0e95966a1e9aa2aa3bf60d4e1d85674efce20a465a36a2332d4fd62a71894c3dbddb9b59fe41fc810f685c96551aedc3683321fff50aba027d908e165940b66911d25c9cc91c578d0d85808f4430d1d212e921785f6adfbc25711f4040e73ababcd0a7549f089945e8d3dc65baf748a00565926a2a658aeeb6e9e0610ad6e3384afca28dd43afa1614f9b03fbeef50ac135200a1afea585cafd884a3d9687953dcbd98cbadff56943f9ab6019b1b619c9fbe25077abf72f7227094ced0552979a393c3c8878b100282f4066b0d918a741a72d379dc38bc17f23ed8d28bea474818455b219f4929ad16a89f28eed73785b9d9400b83e3964d3ae3ea4b7f509dddb97ce6de087eb3b704700f0e14785e7aa8975afe1fb68d88d7658a1a8e091af3c1e5d284aaa3f666a7e76ce8c7a8c3b15cfbf53f7f22736661a245e2c4ff8a9987effcfc86b645bd28ccb5f955c7fa6b6dbb872e0dbfda7cd2804219b41284993db4ba6772c983f71c06e0a339ccfd7770341294d25dbc506560c8d8a973b242bd222076bb0a23068010b8c8213f7f4b136379f2d163f707b6c524b1ff25f828f75530c426ceed6343fe6176a875cae3a6bd598d04685f12dc881bc6acc7862e389326c60d5f4e3e10f18e0ca5501676387efbdc102b01b08fe4153a6baadc62765450f73080c12eb8eba0dbbc50a6d5e7925af1524d5b54aeadd37a550dc972d085e01434494a2f0ac232750cef5b59d6a4fdc3d39aaf7073d322218944f2a6236678ebb0119c2ecadcc4fdafcb0c58e0b87ec375d7cb0e27340fb5a2274d3accaea63f6e615f9cbcf84748397f281af93cdbb405faf281fc7a55ef0d2a5d0959b9629ff65712397f9509ebf9382caf5aae7159c1c259c3554f0acd4c2c8c0089b84f668e7bba01eb00d6fce21d85e92c27f8e47be8a156a3feaaf987e98f88276ed6c1325486b915318e16102461f69147a5de6c563acb40c56a14fc4eaa9708b699828ac1b15900a8404934693be9870572ce42c328a473888adf5e08f909421d20c55d8383ece3b4beffe0c6cdc9baa76c96c3f69446ee69d005053c1cbd7f0e4463d060033a9e1ebc2d4d48add178cac3fc6fb5628824745592b5ccabe513f78b8b44d6330931e58af565c738c6e52386868e718942e67a4af9e6ec38092d62d0de498ee98a45954e2a4fc5d471b6bf6a612156d6d6072d1f49b1478087001e2a111ba3bd2902e2c1377b9ceac6a73c4403c542a2dfecfffce0d20620285b3208cc44fe5f8741409c3a08af54f179b0c8099e73edef30059b02e15c7d6250dde076be08532a95ba2602d4032379b3709c0eea6b63100ee3db90bfdc961298eb200d4c1c1973692922b57eaf337ba2280544e0e7cc8d284a0b03901012b93da9c6a1a2596ff2b853f1add6932caacefcb0e808e955c47dd5250d2dcc4456b6c7c20f14a0f32c97c2dc431c049af5e3271bbdff0ce438312b00820fbae6c56b320ee964eb4bb759869707c2d6debce86526f0ad4926480f5a6122859d207a789846ecc7aa009752db48c8d0a8a64917f3a6e79a425321e8d672e70203b9b90e83191e44170c10c2912972ad6cf1040f9334e50d4d73ac8ebcd1b8b5a7143c7104c25113969ca46950ee29bc95457526ecf0be9cd106dc5894172f012302b216cb6f0f51dd0bc4c300158e33fe93c7368fc46ba779abc542dab6ff95e1451cd1d93d7d51fcb84a1d12cfd30fb40ff3f07a13c8970e8b16d16d3edac5cc3994318e14781a949babe08923a49c09e01e22dad62f3158e78ae1e28c918d92839ed674a2fb7d46cc8ea5fbbc539b16c16612ebfa7a30cb64fa2976534fe3512f05ff13ae24d35f29f9c0bb15da5cacad00b2fb38ae71b2aa81bd4f94372ca2aa3b2a6d9d4018b88138e19c469859a4ace5f8ceb6a4a241ffdd3e8902b16289a2fb3e7ca693d349a69158e974e56a5b79934aaec69432b4e4a55d2acd9875f138a0370e3423eaab51af6a862ec9f84b9cf75d1b280938e2e0e80acd5009e3dd5c95b2a33d7f32a19ece9e803bcc2e987df86f7cafa148079e99083ed84b17519f676c1c5c3a27227fb03cb25f656531d640ef6377d5ac4f51ef4ad5b2b0a6d82869923be75e159f0d4fd59e29c9ef0eb3b5633da0ff1a75595e17f8c5c2cb4d4de7ea14b56331dd35fe5064377b74a9bf60133f754c6ecebe68df906206eb7f3be38519f669fe62223c6d6df0a48f02ea46fc45c83e2982c8f4026b093a69ed3383864bec5b4301c3a9b55ec02f7f427dbe3142d52338f3cd3fd002319bb6733258662e82e1022ddb64a8b6446d9c16300060f8ff1720f280565f4233bffb21a3552f8e355484f42d6431df1392bb7cc8ceb3a95e63bd08303ed1c5268603871d53eedb4adf896abe6203b79cec41d4c1ca55aba30e6fa576681515ea0f3d245732e8a8dd5f65c4a884f3d06f5f496b6a1ae8f67a91fd03030e39a3c951a88299928b8d7c85d63a3d584f957210bde5a6529f12add224c62de20d1486547ba3809186f1b22a786cea35c8ebcb4391368cc40f40c81f0bab241c25cbf5381bcf4827f07c7f72253236919cee3d9348ae9ddbbbd4a732e872b34ca921e3aa9754338902c6b2ed6ade4eb933eb25b6d9ae199fe44ffe70b4caa9323c44bcc4f6e545e97b2f97a136a74c7753f237f93d1c2595a8e2040b3ef13721d920f40fec85ee792470e47660347bbb041a69ef1fb7289a66caa1693c7a161a80b4b5ace0a76c08cc2fdf57eb4c61d8f016ff8ef17c908347a0a68bded0aff92374ad95c6edcd330d88db757f8f2913f3321442cd5e4c50283e5ee3c662f4e0de8dcaf2ba9dae115f0930dc0182fbd07f9fbdd23cdc5d589e312b65678ff43b74d02a9024d4f3b8f2869de7125a447460f7aa4ead148abab43c6180cb3c072d2d34ec418e0d165b9dcb421fc5b92226d8dd5785fa2ddc46cf58a8069d0dbba9fe214da4dcf5d364ef5ed33a437d534f50a52aad70ce76ef54ed8a7e0f60d4bdcedf063b930bde08457d0ec04b02c22beeefc8ad8b7423daf248bfc3112345a6504fdb2e0d237d3611c0a10104854aef8a5720166e9ecfa04c102b3403e422912ed9ab21ad18857fac28828969b91aa6add7cdecf0ec037b7dd43638bcb0d3a34751568839e329f935f9d93a5c690947acb03aaafbe9a1c4cfd3a5fb9e84440cc35d375361a7daa4b75a8d9849225bf2a43aa9266836b75ad6d34fa7657757f9579edff816fdb04f2a9a0d9b3f675f202d16e4e7474cd87014016acd9550397a617a8f97e91c2262792272bc53070713b0103f3d26b02ef13702c71395508a0fb159f23dc2507f77f5dde32de0f6d1070ed42446d95f1b784a63fd1eaf254cde043cfd623530bc4b9d5ecf578d5981502527256b68bb20ab90be4a01ea191f569716ff2fa6797d152ad38be1104637ece031912ce4f9da487c98d706af19495068dd25bc2293b1d5bff75f5cb56f78de38ac7a0a2cb5c41a1a0861320892ae8749473b7afa320442c272f9fb38c32b2a7232cb4cd6aca1168fb572db4c95ee633bee87e9c2e26463ba0b2357d961a8749b481db0873c4163e639a5cc2a9e0ef0220f390772258fe4286c18d21e1344ef1f3dc7f1c036272f7ac7772ef8eb4f8865212a11ab9cccfb49616e521e0a6c63c6d8ff51fe70dafcdb030d83ba080dc8646c048047073d6448845617c86d30e9b07c1028d70c3d0683e170b3ba0b231e944bb77e6b014d31ac0b999ccb98072088cff46f6663ff1aca3ba178375abad200505d17f6a0fe3ec2cdea1100c005fe28baaa55de4218acca4392c77da6eab75db8e7edd21674eb2f7ec3961ab08f790d3e9f22f5b6c47e5d8e1185422551fb7a846688b7cf5893a02597a692beba7e4b82a98611de5270c65a7085104569131cebd60330d695a70df5177a60b5d5abba36cf28b19d14b003d726bdc7868275041375aecee596c7736ef860539c257f66c763cf564a5c40c6f5737cbc098d6a6920115d80ce622b333c84718a2ac4f6b31bdf0028459200d826085ad5b2981ca4b1f800d9e72255707cae68a2434967c3439bdeb0e0c6d4595b001a7f94d0e92e33ba0c2625901e0b1e9d4f3c5388ea4d2ec32356af239afec4aab182f99748a15db6cdbe5fc493ab895169acbf7986dbad8eb799ef4df6b395ba9dd0cbb8bb42b3655faef83fe8a11ea124f72aeaa71b5328587be51bb632f2572310da5ae8e46864406e4e80cbbcbda2b6394a94cbc1fc8f1e1968f0f82cc84fad3ca59c8a5d084ffe2878374b8735ca3c7d0dfa2b3e482ce822f7d3a23f5b67efbb097a3da06baf5162357111c806afaa74713201e83bef8d7da4475ee62c0e289f17270945f78b2535078b325f0e3f3f58e0c9d29d45fbbf8d5566737c8b045f114a25b5025ba3196f1f9ed4ae6d75b18fce4fb7515d385b0d6e41842a2375f550003463e07ea3af8d720c39e33489f68bcbeea6239e9089656993b6285bffd5a99123534c5dae3c4772815af50bb3fd90afd0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
