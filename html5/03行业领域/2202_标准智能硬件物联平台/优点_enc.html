<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7643cac4d0c1d4cca81edf9f6282a2622214ed0a2cfb4ec464526edd55c6124f22005a64c6be047dd43992b01f9d850593fbecbd7fbc0bcdba94265d66e5ccfb9401a9dcd2b0f8b78822e0b7f193c81cb31381b6b60bd56a473eff2fc8e127b95e66ce8c49800f7ed37d527b9b52f04c6b51dd04f298d28a605f97ef7e1ced5f683cb244b1def5cf466d11165e019bcf04e024937d8bc8a0356f52560e4caa9e0746c3d14248df07f8cb9a4f26d4add7a20a9d4b6acbcb655c68c3a2077a0dc503f31976c34b680ebe53daeb001ec0d24fbcb955995f65b9c7e44466fa86e580633df65325c7625b73e245c33c34a403cef08cebfbf47eba176062dcccc517d7132a7093bb72196b0d4617bf4d51a8362fe07b17374325a84c95191c5dbf06142d3f7d3c350e1a37875ea5c13e400ca8365f630926f1db640be4ae13d4a209df22c8832a703ea859aed535879ba20ce22959a20a9e12e5579241e6df1a4a09b89839bfd4c49effa465158bde10dc492633b47f925f0910b01c376d3880297d2f21c0f206f3f13b97337369f38cf14b0d2afca2d0b9201bd56b27093fea1a68db17fd29cbfb096d413c716df925123a7f334525c2c12e3968be85b1141687fed01f193702845cd0a37cb8357eb7f836f9a7d1aabe5b8660e8014bc20497930906444f1e9792d5b9bf55b01169781d6da83b2a8a8e071a46f7739ff0146fb84dce11eaee30c81063d9914f37e47bb6afa4b27d75b2d12dca0bf42924dd7329a66e1fc4a283fb83a629cc929f205d8210c28afd3cdaed28030542b666c2f320c1f44577a780c84991f649d3e120799e0ec7d3041463450ad166d5a9237d0489398d8ec0e54f05725de30dd66d39f2e7de8d7f7728eddbaf3f06344c8e28758b731e757b5f54fd04e86e420cf4cc32ce7eb43f8b083c0a2d3ec282f2c19d25aec0a4e2b96bf5d0307069564f326d016b81bbdfaaf592a8ea558170b48c75f0e2dabc5a795c4b788ce0a5862222b8888e97afc7f2de0db9ede1dfb7f4f7648f8beff6f55c5bcbf8f341d60b45bd141257591c9c2bc7696e1c6b90b97f1da3485cdbe567b31ce190b1d141d40d64a5cc892cdf7e1c9fac3978007ab5755dd2dc1e1366d92a5edd9ccf21032aa359e93a32560fdf98cda4cde15ec9f74a1adc04dd186fcb2540778fd11e5456ade841872f867ffb996b20960c458f84c91c4f5e843e1e6906801e5a7d5449fc6b67a2d064afbb3dbe0cfaac908ea379af2f29b6e23846391f8b092e5ffeea40fcb093f4c40a20a2e574f1a5fa3897b2572e6163d436f1c7da25931a8a4ae65dc7faa92d8149919ad5145d63775428291662f6c91cbc755fb3da903d96f0370aab79fbd132a933a94139940cbf1900c7b1bfbde1097e1b20843ba12553da53d56493fa0c1030c731702e6be3eb323d4622392f911a0b8c3d66c332ca0fadd343b662aac9a92b9cb63566bf4e3c5b43e7c3b7e63f9db7d78235ba1628ea6a4007c7aa6d7e93220ec84fdf0678dfc8f79f6f0c6728eaf70a2d63f022b3c5dd6f0078878bcacb7a914162953c3963300ac83f86147b6ddf1efe8402e5dd46284ffc8c6064ba46cef7cfadf12181523252b41577f5fe8921724f7cf1f47e387e4206f00226673b08e3bf3f676611a279c84401bd99cadb4146f4fca5977a143bbc53b21685de9c741b6a8447e4cf850219c00429e59edd43a5483b442ed598fff0aa34890dbf81105a671474ef0f2595e8e97cacd83a9fb94157c6b845e10d8ecc2627ae56fe15437bfd8429b2f5874aa050afc3dacb78ffc3db4148f2f6a8a57c049298802580920bf74ba59f086ad26b38053361e5bf616143673875f16b6c8a8261d826d427c7038f04bb34fa4a0b2decbc0d1a8a8289607cc43691c005ce10e951a1b3f60b1cc5af8e11dc527c00c3304913c75613b974e8b7731963dcc96ff12cff0913fbcf6ed22ee8d84c2a7791e535561c8616768369690849bf6452f4def22e0551dd86d18e791409863095cdca9506b4cb2c5d7abe43ff89c6a8c776da7377cc6224dd9337fb83787ca5ccc5918a47baf881989cdd6a99fb876c83365058395978169f91bbc27f36abea470020bd7e4691c04c109b2fac79d43512b79c3e3cac683be622e7fa83d94007da18c3c628c24b7f99216ad5c18d7c5b2a616da7d21e025f385998e39419097148f4f1070ff6cbeb1505c48b9289d3492db5407678239c683ff4b092b40562b5cb58cb6ed71f01c8091cbef75dc1f8bcd67f3dcd121087b6b69696ee41f70e30d89f71f940d8f8291405360e1db859cafaac44b0e186890190bc5beda06846acae06808d8a8c8e820aa9b3495828c785518090be3bbfe38b248edaf9dd77a55d74aa3f581a57375295e08eb5aa4fa91cd90acee601e9dfd8c6eb33a9764adfb4736e4c9930251f8aa5bfa46a00cc4b94252868120a2cb22cff81a5037926969704eddcf8c804469217d011dbc4abfd54cbadfed458f50aa571b2b630df533f378a2581f23f742011cdce461c148cadb19fb37730f7ff0aab0bfcda5be4872e3736ad3d8a9ca26f1003991380deea7d4593caa9fa034e3d1a6acb8b6bfcd4312225dba534d50824ab2b2781e3e6d6a50e51b7fa87266f342ea51429169c8247c4e3e36e632ab0809f1380fd98e51b65284dc68bcc017a91024fba7aaa80b29915958cab41e74919475408bf8e3fb43fdfe5ed1588d1d4bbbae134378cc404079403b4efeabaac32de612307f90e3a83235b4ee28e0fb8c2afd4d57bacda773168dad3731f8fb55f7abff86568460981d7f162b3227ae43cbeead25c6c982ef968eb46ff3b7afd7bee9f8985e4539571a9ccddbc1836385052b7128bce5098debcbf30feaf0625ad133d676d10b03052f081c4a5f7c1e3e8ade366cca593f304f80569b7fb6a1448834b65c9628aa1198de92f6cbe6030f233545aec60c6b523665efb0cf7153509f2981e4d0f76ed08c56e2d69653eed3eefadf62897c22bbddf1db2659a59a5c0a5fd34bf633ed08c5e97ac2a577749594e55bb39d3c140044add0044169e6d5adcb6d782c2d72b0cc47c49f77f711b9081a0d502e1d6df36e7c536c7fbfbbcaa635119fdb6779ad42a43a7ccfb1c64082540cfc1171589015dcefb90762ed304eb7478b5f1cea27ab4d98c57c41c5495fb2e7fddace4439177823c3a18a81f15e6cc2715fd197713946d87eceb6fa23634e9e6f2cd866df8e7637ca9c73454fcd18946f6a4e149660edf70e21b5fbf933b6e0b1aefe98d5e38542f4a75fd2d3c08652173c9daf0bb96a6dcbd4e6bde57841230680a3ad4d33b5fc02a993ce2f9b31fa1c93872ae13f73d2bdee63bef080e1ab870d1eb1e50e92d6772f23cb6803c0c0e091df9583475de4abecd7621f97bf87bc9849d2b1769fa2ca7569ec216b5274c48d5d53b432594cd679a64ff02e8907870c1a23cf59101c94ce19d7a07d6da9ca4d6d8d87952523940d436eaf51484c69364038c0fe9620d7397b06215177e89307fdc231cc2d50a78a12753402103688bab64005260fc27ce68d374819b90477fda9ed75ea04ccd1a2fa2019a33b0eb7b31bfa9cbfbbff21937e824560a25883c5abbe38cffd426ff080d3a956deedb95a75e28cfe212f09051a7c0c75646dd705d508ec39173eb2ff4b853c9901c92e2e8c9d8ff3e03d23a6ab5f56035b148cc1e20262d947d8802ea755fcc5cc5d03bc936447a41b7ca0b1e78a364171b9a71d00bab1e3aa470e51775ac19749a7c1f5cc0b5b844ec9e8ba911fd9c99279dd9b98143f3dd4b56b379fb6545bc57fa7b0afa4eedc9da3497434637389611c5be7e0463773254686e18ad782b82ff88e7ea52e8fd95e466f7b85a0ecee4c9612576eee20ad5ff350038f404727780c2084c0c527ab7f9b9083e2a2df70889a05afb8409f1ad15d0c1cd5eb5616f820b20948497f10dc80d4f1ca08f3bbce38b1fd2bae5aa2a9c33b0a8a22ad0629f57c209402e190b2386b915aa6134085d66b7d88f43e26b0ecfb4e84daa5c2c2f04049e81415920ba0466d0be91135fa62485a7cc891c7ea24b8ab1317da6a01fced182031295590612ab183cc4af887c7f57b9d0422f74079c0e33ba0842e5fe55b24a7f2fb74d9a29ed451cf995ac3faad819ba4d848b9ae6ad358257bbcb11f49f89f08c42c488f4c1d4fe2c3b4424b3563c52b46fe1d17ad4070ddfb304f820810d40564a0a340cbbb8eaaf8f116ca4a487daca2a6fadd4b24419ad675170ed1bdb25033789fe0edd3c88727ad6594df5e0a8df1b2b8dcc48ad384f8cb382855e206cc51ff4a216afd6fc8e3b73a5e2991daf3b6cf8e419a7a1fe4084d4d699e1f310de2a9e4c620cae7f12265a7970b839dba91be1789f3b1604fbda34cc3de69632573eddbc5793c5865731812fb295d50cd7d706ab3cbcf9abd2b66ef1ee0d4a7875f4b27c642e87fd9dec9bcf8444e814e6c904e083966e2df03de31f3eddfc8ad801a568d4b365e175c6666b3cd74312786376cf106c74edddb3290f748c767e422414d66ef28453b2f9993fa154a1783e33ca72c1bc0e3d166b95bad6245f571cc52cc3173685cfac47ee66233f8be94516e8fee282c9c28f61f83b73f1bf11a143cc3635c44c6ad85bf22640f92422c2f0748e36414effdcb2b0c0476da0f34f8a74a87e017c1ac1088bed9ca4399bdca401f3823b724868941d96a462b7956124160606c6bdd7a669c54e87dd53160478427d0285fe452ddfeb5b31f12d33495f0a5a450e7de13e2356690e2dc48eabd1ea2b96cb7097a598ea0bd2512dc319b0c8d94896728c239737216f868fa9797cae76ae06942af12490d135162849694594235753898a18745fdfb82748403d0ee6ee3153eaa0e446006cb0370ccf6fd74f414d19b6993f9797d9a9fa284338c6d48a6d3840ea14f3b1882beeb895cd37fbadef5bf666455abc1b80a170025183c7300fc2d661c8c48d9df888e7e6b4b5aa0e4d40afae1cf5996ed33e97127f2a19514df1b378f03216df40b1f0901beac9b53678e76e6a0e077e699e53f6180c069c02be4e4395767e9c4d20624887635c49e4d32ad40e502fde19fd997b8dcb9c7ddbb09c090a37faad156e98300e050e3cd6b28283f65c42160f37bc4d4289e9e1b37658db8141876f91311c4e1e20961cec11e7b21494e65f849edb7470b93c869718a93993643396246e8400a6a6e663a0e94e502ae72820f9c1c2c6b956e5a2a0dd0265d5a326de465b195b5383d15bb1f3a6a38ab056d4ab23b61ca59e3aba36c26a59f3591ee80ff90c6e7025648e5ae9bfe2a543a0ef23350f4566dc727a620b7e899fcdc9f39b5328c8a4470481e09bac3e7dc4ef1b403b264414598052308fd82b89c1a8febac40427b30565a4ec98187d07adbcfcead5056d41bfbfc5818dd2ac08772b9aec9d4d5de9848da952810ff1161c39c717e047feb6dba1427c6caf39c3ba7b5150dcda1a01a7edf4fc433386f256500844a0892bd22db1881696867ab065cf01d8a1991f9487fa7aaaa1cfbd68d85658b1e0af77395f2b6d8da7dd701dda346ec34c09af23f3e09e9b189b31b375fae44924ac04830eaa282a07307df7c696d9b9cff2bfac55c391b831b75299bb274bac0244fb17bca127269bd195e54a48ec02ea36c34f9cb2ca114824ede7981e170d963a49cec92fb0a714d805bbef6b53042cc17865d14baa2ab44f21c5163f6356d132ec8ca16875b662b7f1db7608426f7c906242c4efbc41c517e5b876530d8264dc13b0a3603df99d79810e97d26a7b86dcf40ac1933de1d4604cc118216686a1dd332aa676dfd690c0060faef374ad84a116dc7269b2f7700a8169298aed33190bf3833539577f49f7385ce2a434e65b307c1a374e6a381e537ca1715397e4252fce948a91295b161b43ccf222c6d748800b3b5aa179db565f735ddf123e86578d149b009ddfa4fa4eda8bd302cb2ad80b9ecaac5f5e4d5be57d72c46279ceb5978982f0a799bf3ddec60f0d15bb2a59096644f4deec8de459de24bb82d0fdefb0556460b15900cc2477e353b56ea122ebf1a68e1d5e0bbf22f3d99050e68d4eebab3277467623352d6aebeb2f09be51b21d2c5a007b6e377a29ec186a8bacdc7b8f65aa2d9a416c19e4c3d938a4a6bdce5196f0d416e1e96df70d27dfdd9131ce88b41ce76726701063ac5063749674c086d0fb9885f68d0b3a5edea5df9a037145c61576ffce7751c4229fea3001e0153e99bc49f2ae9cd0515b92da842cfc615a322ac425cd6938709244a82ff5b6e1952ccfe6aa3f1e9743cbcae098f8fedcfe1ccb45020323d13281310357abe0e640ce3d87208ed9c3c4a1bcc9bb72823ab3d11d5dd9fbcb5ada71ac48334c09883e03c921fc9b1fb8179c9b586e353ada27a88369c0744b0141504544ea6d4a34141c9eb063111dce98b9697c2b0e44ff401a163389b7cd15ebe03db4f3e03c74a9f15199722bd2f0e127910ae31e66c58801d893e690c9c7c3de0520928622c0b9629fc2aed822159f1bfd671cd9ee3eb5634c2ec409e6ff7ded40004abf217c7574774d262332158c96abbcde96b7abaae8d3e30e194a9c1000ae884b62a34e9781ec521ffa396526ad1cb2ba6c50ebd7fd57d3817db1b16d3245d7b903e2f7f85757d91630c6a9b5753b83116753eb2b372ae14a4f03ef46f94ad942db83e3a40bc28c6f4d8139d36e46f0d84a8e048703ff9b9f2bed9f8df0378518dc64693ccb9989e9b6cc60fa4833de6793e6f5dace6f6138e5743d5a62f089bb01d9d88c708ca037d7f5b6acee9b8f642c8cdf228466cafb1a8c3fbf69dd7cbc77a245edab62f50443b09c5d17496cb96fe7735a99945096fc5e4d66de96d86a1730183c3d45279053fcbac0c168cfd556078e1249f29b275d008f6dcde9dc71e6f24688667e6ad827e1214133e538e439e5654cfdc6b08959eeec58712acfc77f4c4048e2fa43c3f029ced1bdd8e49fe29a92f75973a66a7c1be1a7ac90d21b9145182109e466e8daf2bc16116585d372264617b087f0c3c2beec04324da30833b0728254effc4339f53f206282974a8c185a22f62b1c8828cc286b364d5df9b014281114553e427c464de87fb055a741a4bee3041f5884d896a811648a7031a7cfd7347751573f45c7bb82c6f077c14fb29295f10c18ef9e2a406ca5f6b9ec179bdb7b61377e51695ebbb428fde24db62152305b406f31c26388c70ea5e2a6ef61b20997176ea481c7ebe5dd321788b8d9a81bc5c2e48250d38d7e4133c5ac37cdcc89d6b8ba2b7dbc5dee3f8051881391f9966b02687a7dc6e302bfeaa6720660703fd60cefbdef0f0698de3b43060d5743b966ad922e1dc5a29a85dd5976c5e16b6e2bba387466e929d7a2257e27ac3773534734df0b1181911a23f40c583ed4a2c78c2ac2722bdb209cf526cc59f126dde1b29e363f4089d286bdd3982eb878d61ebc95672280fe7069b6fa2c2e237b21d069e45c9abe47f69d5e155e206896d5098194cbe999ec183e8bf7656c77aee1681d9d9b0a82120dbd42039421800a0ab00e0312212afa830fa7959a2e582e03ecb1dc3614d8416ea324bb7778b47fd64e1148ff51ac5ddae34dc83c757d95ca31a133a1623120253b7edc65abea5a89111ba8824edb3d57bf8c3dc2f9219b740b75fe01047060aa16a5d5cac3555bc44f7d444d430f9ed76f0059a37b9eae8eb133ea0714cd684dae539204cf45fbf9b3680a39912556044ec6520b4909c3fac4219e6b50f2cba03f05d4357475a01eb45df78edf4254aa04caf02207b967ebadeb00f7fc3306e8358e91edb1445e71cb1d028e8a51154b264541f4255d46b0c6978e930fdcc0d0fd8e517b7c90477050f696de311f9e8d1d0c07fc8f339d0b959249e671a085b5ad7285e4ab2a05bd04161cd3e9118906f10f7e246d663f3134d1dd063be278d11cd257a714cb5370fe4fe8829fc9ebb25da64a85910317e16fcee145f8e365510cd15d48dddb057dda00724aa3ac2f304e9facea206f13f1b6a3bef58cc761fb50efc1bc8fadff0c8145073844fffcfeb7896ef0bde05faf3724021dba387200b53c2819ecb437531f2c2f6fb895291b5ff32a98be6d007fd4bb6bc84eaf6fa156b4f01c3f2955bf9a7d2271ac315a7e946e7a1299a37bc5011f3a020391bdc21cdc8122b9960a11eaaf270eb4bb8397d646efd5e77861aaddf42192bbc52a49d30a52989876c0a0bd4b18f02f856f000bc6c94d97d7209740fddc5ac3521f060f44de65b837d1685dbd62c930da197e87788810743c1abf1899246fba2565e94c9a82845ddd4bbd240104349f6eb7cfecb52b0263b62178b61ef5547d6943c7d55d44557aaac34a403185a8c2754331ffce3bbacf5afd7aa9a5f0b9631a2f4731b557228e3a47e16fa41b3dd076ac23ff14e143a0e3ffe972a3446fd87f9be85ae02cd505e6795935800cf94422b12e8299b8f941b85fde72d442c5db0ec4787dad181415bab76becf83b5b6dc69936e33fba0955efa1714183f52b01ec05b4eeaa611d79b70a2721e2fdfb0274283fbe7970690f6ee65cbd6f55bb3ce8fcea9859fbc3f5f65b621b723242f361ceb8676b872f21adb58973880d6685503c9211a5b19ddbd15e5c7a1b76012db0103b601143017718c53eeea29e3e2129c18f7278d0196ed01f3ca12bb7f937aea22cece562a2537522176a0fab0ff46698f68343bb66185f19ae0f4ea471c6d83cc5a8239d51dd8d6a2aec143523defc86c9d4eb198d63a9705ef59f36c047e95498b4edc0d7369ada59c2d25162fadbb30267ed1f57df9c14eeab0c98684fb3e57b8f6cdd2ef2017a7fc77eb2a91fc88dde9ffd750e72b29da71aa79cf84e50f0c3e335067dd792501a07675fbef59eaaadb05b02433987c24f93dc53c32c1b68a3c70711adc9149197dd5bd35f5326417c4b6aba037f3f01df1e114febe0e5eedf5a00adc14c4e9b52ef56fc788adbc11b22dde88dd0fac40bbb5099f56bf19c1ccbbaa22aa5dcabe161869f69c932827411dc532200355dbfafa4434af08ac5fc5b68c8e87573532f39555481435a71db3e49f34004d8bc4fd0f605644f055c48bec3b60c5fb409181d950ab97943f46025722da3156a3adff2c331711b244cb065a243d06dc04cd043f1b87ac6d528f97f48b4d3147cb44a86e449f2fb16a16901faa40f0870cca0493f0d9b6272b6beda11e1b8f4fdff18b50a1e05d2c8db33ea934cbfcd7325685cee1a8446d7d4a72c0052f36a3eff111b828811eb0dfc1e4b14498006c647a027e702eaab05d54ff6e7208f650232db49400c73fa225624413a9c31ec53c4c55fb4cdb680bf1fa34ebd812c535d01261c8548fd91682c733ccc77cb413c14d1f11b013d7c36505b45a1fdc5fa8d508cc8a50c8f3b1e901f982b9e01ae4ffe229aedda289bc46be1d579eaadc6b723d6b17f868ca9a1e414f25341eac34e440823901af684e5cfc36e57853c4443f8cfd3c5b8e3848fa7a5f37171d0ef1a8912218b41c0b11ca97d2bb844538a277297d384773e6a43f74b49bda69bfd3dd8cb0aead604d49613c02b3055e0a551ced6d4fa403bd1c665a670e8d1370246ef7f4f88d4235513bb1a67ca850a423068a1e8addd7097bd9725e2111f5f02404407c008a07c71cd59e295a0ad131a49240207fc001da6c689458344a3b5be2415d0a1599362fade11460d221cb8a59414e9e718983fab90de43f27c6ac1f79749427cb0535238b5ed69b68880887e812cea46d1b403e57c94e7eaac30c4f22d97f65de8af17f227de43d24cc93b7834569b5516fcf3f99446e879405e802ee7f62220c94f080dfe38d703e858d03ad4ceb704244163a23fc33d49a14eb560a80818bfdac50d7db4c0dee578f0ddc2dc964407fe60469b2938a8f6740456a92aff01b0ab6eb01e8a153350268888ef868d6b50b45d638da13353ed28e0949ef3a5a7187bcbd2c0dccba0212846125944eea79c8b8f5dcdb8849ea67cd254cfe91ebeb89036876957c9f9d8f4fac89947e44bb84cf43dd20decd0f53b0b2fedbcc6c335dee0e319752f592a7966a7f997663023ee2267c68600f8bafbb8d52517d80414a5aa5a7effc8b041ce1880a9e69bc30da79a2bbfac73a63835e5dc7b880dca7eb3c0076e4105ceec7e80f25c2f5ebfedd3a09aab46a4afe7736105d547c029216aa383df275a48520da2ce9363c0a4448f6de3c6545473ed03e020432028bc691fd7f5ba2f808d4bf68838914673f702fb8f3e432b2a92e6977de733e2f4e4bbafd1f38f1e4beaab49783d19a5c790bb9952ed4699bade633431019e243f34265bf4f06fa4873e1b2486451f980d4feb57e640aec26b3ea421fba7b24542368e8993fb5e2f0aec984aadee4bef1320b6eea787e7b80f437f1819234845f051eca32395de9a648de8b48c80b99b7096f7c247b72e9f0e8bcedd4a9fd2452f83efcd5065a496ae0f390acf89fc93907430c9638ca90c03eba54824402df5bd49426b53c7fa15e5569a6b028a012b03b8cc0b98310afbffc8b8a81742a85101ac6dc8140361ccd1170ab5eb9422ab3c838052e7c39803f42af3e6ac2ea6fc4e31707c76b962f7c05e3888710922b0e630a91d005842f0ce50c04fdcc92eecb414bd78c02c5ce675e838f7421d51e08a773b669f0465bea5920a5987460ab779d8bf0256e514f99e4d9524d09cda2d699c5229bc3f490be823d7a7ee3ed5d3d1c4ea3a020d8618490dc8e7980b16cdceb657406aeaa01a56e376bb9aaf4a4903056da214ebebe18c949b01ab871312a1ba017ffd74cd369d81a5f241d898c86377c01752f5325fbb3ee4baadab31c0e9d26fd7f3573be95a4684aa21a2eb33c473aee74821a8202a5f59e63b5e418d03b80482b4735a7408bea97a554a9962334b639b2711d6ccdea1e922771c13cbb28a7bb8f4a6273bb142ac6c22d37169c89335f9d5761c4e149eb10c544441a8111af0f86380dcc9dfc4bd788ef5c22975fc05a540a5ef601852e07de6ec2f66c5937e73dfd4c98c7586758ae5b067dbd58e7982dbe26ff9af3d8cb2c248c6a9715e5e70dc05ce2f035f7a9e5c3b576659f76a91b2a19695b644ce5f8cc523f953192b91e92612ff4ce5f10b5d0e84506be4210307095a44477c4ec79834685346a1d5b52a34c9b535f594c2552d7e6a898e4bab63130c97bbe89948d9db2e0667a0bd88216b78af22913997868a3b441c2241222828aff4f9c594c6af33e23eb1293a2165c1c39f3aac13ab4e379a1b2e5c873abd1c0f40923c2592f0581eaf69a302725e5b0ce4590c588a88e595325f79413d40d2848f2efee3258a9249ce3093e59033a7fc74915b48e3268d946143f522da3460ef18a1d906bf5bfcc4c3f83d0826297dbd31b217613c6bcbdf7d2f6e233fec954f909a01378174e0684f7ef2e151a4ec894189dff27c6a729821c811e34a4b61f05e0917eb232b81da56806c4dfb4319bc60ed48975298c55e8a6bee2dd715a1bcf2dbefb0f129455084441afcf841aab18078ceae419bdf5dd3ca17d4a3944d5283ad75ca8a1991ea8d886f6edfbbc880994baa8db83afcabf197a8e97cd6773bb1b27d5598c254234b7725ffc435c2ed2254b172a1bb8a85cf5aaacad8717b4e6c382cb924de0f55f7a8d1b2e8a9c9bb8fc29369fb5f82be1613c5e3dedf432e97dbc75e63c25d95236d41f2863b95e5a32ab199da3b7e0bfae896543fe1654e6c3fe841877e22bb5474ca8119f96b6d0b537919b753ccac208fd1d010e719cfa128ff83b82ed13b852342dbae1769a1962eba6f84f6fe963e29e3fbd6fa41e3e4110af88e7ef9d3353668c9da76030b73f847f6264c4584c44c9cd868d0472f458a99093c11421513069673ef13465e95a81dbd4694f5bfa1a05c42f05e7cad1f5e1159cc375ba594280c664d40fbd75281108c25695e525a59dd008067a904ba90c859c88668e57c4a8c30ddb771510d1d48870045a19c739030b6841cd4f4b02e057f8d70ac9d42e2c4da323ebb51806d219508510fa3853d8fe4471eca96cc3526dd8106e473b9b5886d69eb635673102c55f1b56ef170f44834c9d160fdc68f62f799c0ea73621377dc308b06cf4a42b24ddf6719f5a55337077d4ba104899052fdb6f19322a712f18ff4e2a8bf13b507117852d249e2ab473a7503bb7fc33f9ee28c88d0b69247dc7c3805c330158339ee4cfc7f11aada7385b75871f4280a7b6e80b26ee709ff349ee8bdba457f0abf28e5dc01c40623972d4a43f5c1604f625ffc8d4cd981b0af726a366a74853a81aa96a791cea43dd82b9bb71d814589c9f787077803485dca582aa59a58f0548a10e68cf7594bd01928c87960f176fb98aa93b4da30ab4182b783aedc0d60f4b2b10abb4638c0018438730674660a9163149464600b373bb537b6dcc9f7099b581e526586656729fc4de3547ba07d04a4acf58c4c03d2d5d82ef59ab574a6d82f14dc5c5555aa4100f23532c6a028b426a076fe877dbc90df57df37fe70884b9c7e07841d912c339ab4a31be98175d37910ae7cacbd562c0a8a60aff0eff7d01942f41a9d6c2d4586f2644fb0599fd40e1b26c9822ccdd0a74955145ae7557a079ba1b63fff8b4424a1fe8df55a0daf3c59de2731c4653ce118818ff4fe5787ded2e4bf9bdb9b15900a8f2ecfdd9014a5452ea6bc4d64fd4bc97a62f49cb769c5aa7d02ffb7f85fb2f51142fca5f970bf6c94acec7bd9ca2421b190c0dee9a62d364558b79682876209db7c268abcfa9c710a2530598f3fbc3f8397f5386dc39f82d6d44419331f828abcaa5dbd1100badc258122456960c013b232de780b0e7c409dd2d1527a487cef56db2acb5ac02c723a315eede08a45ee669c400cebb94deb920e56e8cd14aacf87c8691cf221d382e9d6dd486d606d6aad4575714f0eec308ae961eb45222e00aa94a3e19f703449090159c42c32ea5521a483c2aad51534b0946ef631e18773c2449b95918f41c7fbbaa9ef4439e7947bee8ef81644cf9c9c37a97cb51bed992b4c987b39a8c49c763373f700b68d3b95919feebc82fcec4029055a6e35a3b53f9ec4d7e1c681c46c7e52a67317451f45c799368933cd2ae3256f6e0091a48150da2a331a4cbc100c817e648b985ffb8ae0f64c3256979ebb5e8ef68e620e2d2bc8cd3ec977c3550b08dbf228d9d71d91d4bbbf2b939e8063cd498edb867fbd6dda5862bb91f3effc1c5462460ced5795e9fa9f6916b955b67489291ec73465da957aaf59e99d1584114cdd726dceb719a16de0685fb4ff5293c8378f7b1d62e4642a6da64054c8a870c368059c631ebc263e1471c36f1ad560b6079a7d2d0817aa20f0208cea3032b473159357f196fb35f0b93f83588464b2f9ba1c6a2e25e8a4b95d5bc480738950bc933c847c4f202afcca757332568eab91debb890f8c0dd3bda69554a76917cd6fd5c4c18d0be3f17c394c86b51c03797ef9ad36e2391a044aec9c8b6b99d17710e09eb2c6182f07bbfa15694a1292152c0bb24944cab249ced200e0ff0a33a23c9365930ad099106dd7823398c7ed7272f7d7c177b68369856dc81b0d672573c85e06326d079e396396ee8d5526fa1c6be42dab743e86929dce900747f22f07950edb6be27a6ce4783bb2501d88ab8a5cb0b4c7656ed1c798e005e2fc54e136801ebde4652422cf08907ccbd31a1edd33a0b64137732b020e992502ec9f11f409cf989cca84226ca2735b0f20d9f57737f020c1140427c69d42c391486da6265e5d79e2c19691cae0c373f7011cabb8ad34c765274d23bd299b07fe65d18abcaa0a0f2529bae20657a9490fce8af1c0522e7cc4868d9abf45ef6c6b58d59ef92f3f35123a4fab81652e91aff183fd83ec78db4b1b2d0e7748d363d2d9b1a0804b14a83e7e1b5c1c64a03e0c104052fa07e61c3859eaac63f7669d199c390ebd056a4d0998749ccd89579727e8e3a933e8530e50d4d7fe2759cfae7709a9f5bea76647bfeda5105953ff3bf8d8f5e86d61ac5ea4bb70a04aa890a41c17bbb444ce2940dd68a17ba617f4b75d4be92a496fc0c7a793ac871144e2515a252e4e2bf1221f130701a9162294f7d97134f37396773c5e8686d87626693cc8c3efba8b43d649e8a5640ca03d99028753c2fd114c302904aca067fe525717bed058b24ad263e72d8080a70aa39cb9121e8180f8f6b855b753e736b9906fdb7a6c6f9d6622bc73f9da412d3bf3f63e12f3b9fbc0955fc1495fd63375170f45dc4571b80993158daf2e7fbf775eadf4ad428c6fecf67efe2a7617ef7bd276f6850c1acde20960e6519d7a6e53cc1df87beebc126b73cd0ec23d616c3d542b9fba84eddc2b08458008b0ca48dff06bb219166f5bbc6e906cf45e89a35198dc0bcbb5ace2d0afee4f87e9c37652b8ba7005fbbab1e0a3d3437bca5561f7ac8f17cec5f9917463df94b5bf4bdfff325086c9ec0be84f72a1de0ac8ed9011e41f13a5814db1e50f0365f7ec288e34e0482de2ec9822725d9cd23c7f4ac225917537feb2abb30f430eded2b0a150fcf36ffde8e18f8cc2e507741a4b26a3b28cd725a02d462d775aadf6d72dcfc30b3fb1ced92631c7b25e770559024ebf802b64c06151a32eb61d85a47461fd2d755a634cf70a1532a57c790b64e27c1c45a8a7b06d4ae00f32896310393bf5801aa2af42ecdaf040ab25f07aa0011568d85312afb5a850424fe9931348d641133c455288666bdbfd6ed9ca7f31ca331e36e3dd176df4568d9c0d38cbc3f72e0b1c71929c0d518fa33d2617eff0f38bff8095f7b0d30953b9dbdc1637e5822b824b8b36e118cc77fc4ce64a9c1d12b382e6c7506ca6477663828dcdcb988b99f7af23d2211406e21b1232175ee989819e7e65756464b11379f298943d64a384fb2a51a4950dcc049624227528160c8b7951cf01a6a836bff4929f45442e983423f8d195d7d1b61f4c235ed63","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
