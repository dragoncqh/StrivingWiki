<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f39641bcf636d00bd8c8baf72dfa92ffe94f2892752c50a2fe7c443741a885de434f73bb48170a130721200631c56d5f8d5dbef7d34bbf8a44c2167a52f111a81f39133391a74e392dbf27ad98615d83aa26ba07009896490a654279a96a42dd160bdbddf394184f506ea94cd2f653e4cc7b2b7f9678b92d3b2b56f5a233853e28aec677fb5d645abc2be033d90a9c0f4401e5b035824eba5703ca26e1a4629bd1e75e5b8ae30ad543013a54b0b1847f4ae635597e8f1edee4aeef7affe91fa890a0d206037481041d1b7f5a8c3c9bf6897ae3d34af406a70866e7d43296f815f968a8ec1f035060c94976d17825b843d48652942f161a53a1501c1edd5e6ec4ef23848f2fc6f331d5c95b4ccda48fbf2532732788b7bc377dc5606287cb18bbaa8c70ccffdd5ec9de0674aa2854cda489a4ef62c6860cbb85ee066e007f6c2641808a1dc3b30b5c3ccfd83285f2fde7a63a66ffcea89775be81fca58d5b090255b322f0f763cd374b8a7c6e0869f62900036f51c001541259438343e07033cfd4ac09495d7ed512abf907fee95b6025038a9749d813543ffa6832ec7529acbc1d95f7e4d2df27de8abd2bd91b6d27c11b09473ac39f87f9e85e9e0ca8f88e0d99b47519ed17154a872e297e1d2b043aa853c86776cb6bdf808c6fe7f583a8b81ffd7745040ef4af139a2640d9961e40a7f6c823895c6b90e16425b2f0f3279cb8550055f557a7766c8f4bf2708323ec52e2cfafc7fb2d249a159c6568ff50895547e0ca6c74faf13b4289f040c1f55688b5f2c1aade139aa01705613da7a60316d76f6d00e2dbd4166501e51df367b38cb654dc02705bf1ceadf5620284ea204dee27c087171c58e30e8c4ebb7b99eb7bd03bc7782d9940fb46743d1c501695a990f451f852f101ca276420577892d81178ee1a90575770f53c5e6ab7c8e113bcd35070ee113129927e96683418576ce4dd271247c6ae93362b33f0555857a947913b703e71ed21abd47f21e325e0ebc8a580eb6f6d01c1ce152a931a58064363340c1e33065dfc7c257fedc6e65cad4f8c1b5f488fa960a135d1b50ddad1038969437dfe23e6c1e6b0c481488f01bda6f23b80fa1f987338332d2a7b09c04e3b8b6c49f612cc99daab5af769e1d381e985f48206fb6967faa7a4d5c51fe94404a814f4f9b668a112ee975881305d07a2fbe958ae4188f0eb6257fc96245d5122278f0eaf3b5a27923635b160666535a00830d48a3305668730ff0e54958d23b7841f94591eb3d05f9bd86f64e55c819874973c8191389519fe43bbbe5956d5d56e1cb5d3002db39f92381bada8cf8ba164788f252b4c81c8693f343d50d9eed728d40d2d8b917d0db41348670c9125079654ab43112f782959d255d782891f78e7b80a3e25dc36158c496ef674819b7b56ded4386b6320da2ba111b509e9f31bbe825a269411ff0e8b15adbe5dccf08feab0d830c8b18458e2afe7af621fe18a2dfd27256f5fedb72877562ffc6611131ab8f55ae27a1f1c4905cff3dae5cfe65c7a7cf9f9e89d3992230079a1b86c9e148e4a075394532b5c902d234e6dce009e42ba920b3769d5b1c418bd9f5d2fad5d3088408c849cf6abe4daf2f68c52705c549807677642ada951eddfb615addaa6c586c19e46bc98467b2bb93cbbbb1bf19386505f2e9fb9395765934ff00d79e1f16c0544b7de36c527b3d0f5785a04a78bec30851f51c21b41323236aea6f1d0b6dc8fd2c6301a6a77aec76a67231017f359a4eafd61ae22e02b9b847307b8e19fabb701705b1a8f17bce3c242b6bd057a3c5bd69b7742642dccd6c916a2b705a7a1abc4a1e8f1068af98057143f53cc8aa2b7be7adb9ce0657b3a9694abd18bf219f6f798f51536a3062c0a9d9fc7a7fcdf68de1c19de521ee77a9b43db1b57cf7f9fb217ec3fdf8dc4845b68fbf6529c84cd2307dc377028063565a5d90934607b05cf564b965b6687d48cfcaaa582c8bcfdbd525af57c56cf04d9507827c3054c89f178307ccc600466da5ff7ada5379f97d7e40909e8257c4ec48884e6b77617dbd4a0bbc6a14d301ad53535e6317e912b1e43eb7cff715b5a9c965db1341acc9103523a628d0a42306602610d5a413cfaf7c319b0c8476148a71081767c687e4160a76423d1f589465ad238808265be6861024adf8c52efaae50152185bef8285c184c12b0d0ea81965765d2c9cfbae2815b73dac7a0dfcb76def607ff0f1d421d36a1dd3aa45075d79691ab84dfaae598ffbb4f5f5f2dffa86639e935cdbf1cff9ae147d635aaf84f52b6c01eb1f8815a352c43f8d27b8ee14285ecaac71759029349c19b97e10febd57d6420372c034e6903b5c6deec4e151c39854da72c161ee67919d464766863dc41fb49972c7a1c6f8818f00c9a328fee36035767504205f97857f69a8ccd79ea5428ffa7e841b7f323106cfdd5de62778d7c0d188fd62d60cfe07ea5fc92d26c10325899d93a9750d3e20175b0c393d49fa49ab05b8619da78c627185e9fcc5dff3da45e3712a67ec8babcc5686427f98706aca021853fa34dc3e521d650df1062b26aeedc7341ee75393ae716aab11415dc2fbba611fb225cbe5ce0d63a25b9f9c6c9b860561ed69e380de83082691e57ddb17b35099a7515e84e5201a19cbcea06a76702f5e0eec8477fc75e388927ae3d7e3b643bf21b651879461ff7c9326eeaaf2e6d9b77e7588c1180f145cb48f86e06169c5c0db80b014f3744b15e705701662e5a3f22d87c4c489b132ddbb999964c61ff871f2be2f688c9f3283f3ac49ecd1bfd62725e03c288d4e660dfb68008889bc224b5ce525ad2aabbc0ba7e4cb5b96a30af95f76e9632ee8389addc6e34caf998405a537d7f89d7095de6cf1ef7d307785d3525afbc846530b265438a8750a2b2cd0b5493502c02fa4cd1c1f261f023d3f4906d14e87099e3f5ffee6ed9de8f6496386bcc34abc43bead32d9622eea34238b075eb667d443b7bfeae236f1b8dcb631cb8ede7c0bc4c74f5bfc94fb01af87dd834ae90a5399b65044bb75a7960a6bc7df7bfeda0b863278cbd741d39b7fba7a598521e76936469177d7b5a7671787f4b21c10f56af4ca85c8f4983f76a5ef4f0508e871429e0cf114ff1c16452f41551d802f221b60973f6ac469ae20cb78d766212523b74558612181dae9b3e0e759904487165bb6d890e74796cc0aad806e54b0064f931c6e8a390c42ada484fed3ed0e562d39b634adacbb2a87ff5193afbf1454bbe265003b308b00a2dac180417386a6e13d3dd03670b38205078119ef8ce3c4948acd33ece288d6f65d426bf4858129b7f8cd8796efa52bc2fb7c3c0df3d40d5d2d54c8d22dea6d84daa083030fd6eaace012e3e82d3578c97a305f436f0225f1eb0837bebf17201f7a4818df39c9810f7f1940b1030c9eb365e9447e1e80cf604bf9c16635606ac4f62f4c4a75e1d4fc8db2328d447185a02711882967fb96a6b5b960f0422ae85a8a33d83c0f7d24fc4e0a63bceb3f7ea84ff18ff9e2bf6bb6b1dd0044309526c4adb11033c31b4936c8a2226e87c8cf503b52cbb6092c61e5573d5e7aa97732993d3a60b363bfa9d6dea0779e385e9235122457d3c26e5e065fc6f49d0acb45779cdcde6f02986dcad9a1b70d66c72949692ffbb32cb844f8d513a1348124b78f2d1228453b85f2daa908cd9ae875ba2106b8b77cd787be5b4b389086c354bc48e29f006ce293d46ee1312d6ff0ff27370a38edca4140b7230dd503c03ec3ef2b75b6731be4b0ff2027f9208308b5121b95ed591c3bd9a84ee930619dccdd70dcd1dbdab74de2dd55dc5435a6413d3bf85cd08ee3e8382f0604be1d217148704223a45cc3f32c4382cd02f867846cec2539360bc469a8486084dad99c66b24858f7e7ab5ddd1fb8ff405c00a2c80ba2b5f05becd3f4a57359d3a83be824035f4fe4908f7c376843607836c371fe2d36534c1a401efde2ec66b846c2730f93e13d6d418d44570d3b81d4a7d300f7ddee336ce3e54ebde74b4e2c5bc09b64a0ed989ccdaac88d488f6d4ea7fab78f2f76ce2355e70ced015fc97451e0e54420255513cbc68f8980680fda529d8991b7614189f5862bf12ed5df18dfcdf4834674cb7814afd124f58e5f0703ac0f58e48470bee35b3cec222efec462688d373105146090c0aaf0d6416fdcbd5150206040c05dc63ec2a399c21a6059d76386f9bea9f9de6875a8aee81cab9d2bc589a4df3ba9253e57ba6bb6155cb68ed57d7a501c8d8f64818cd1b612e69e5c02c51ea35df7768977f19878e7045a112be423060800194a1967f773fed5a2dd860eb4e05aea2d2589bdf832284f921cf88e150b4d3a7c3b734fd5efde1ba6bb35c0579df5d1aeb8d715f0a7fa068a6b80a644814ac9eece77554d347d203b1f8c13263b8fcbb4ed94faf5f32427c86d93e3d35cf1076725a13b3d702c32a74e11b92a4f484d205d457f16ab7f7084f391a6e802e17376c4fea462d21c49b6e258afc406f0ddabc286d9aad27cebbf2c47f4c33e6b506c059253d3c853550f3c7e3c49e1f108a675bf60642a39076ada2e8d23b962a8d81317ccb71285163524c5d24cc7d7f31146fec5265ff458eb8c0d2f808ebf35da1a8194099bbb117f30bce5e62cb93867b3804af778b72be8e8f313a1f945b7c00d71f4c812c0e0455095943a4dcdd4c9b0c688721526cc5a8948b0116579d879f90c89ca86998e7260541650e8b33fb1ee28a2d8bef7f06f34cc8971212bbe24cfdbd7d921b61e7887dd244fae4d2aa41de1db374a6e65840e4ad43cc7911928c7e5e7430564db471c04346dc400e99de68d95cfa93bb32970e047297bb6b28aaed4c5ec7b21de0ccc49f93cc06b24a5769922a553bacfbacabcdc614bc2145f3561977b3bdad6524a3c35c6d2aa462c1a01167f88a89e286e7c3db8ac4a1358997e8955ad2d584b85de38ddb23ed1af09af7e0c7de35d47e6a2175e5d1992c53afe964ae73edf0ac76080bb4caf9dbc02d4a7d7c32a1f5b236bb01b9c292bbd8071eeb1d3ed10cb82f754ff4909db519d717bf0625919b561c7750181219040652f1dc1b5c3d94bb025555d81cdb7bf2ae9a554b94abe30b0ce155ec73fb6e0915f7b2874450a16c6c691d212338401eb3558ebf0bf590cd63f310de24c92bc8cb77d57d98df70b596d9a02969e9de1eb5806bd071b6ace6570eaeec7a4781c4af09aba9a6898cd23de735a2e81c6c143ecb8ff431eb26362340d272d8caaadfa049152e5f06aa7dc771b24ff11d325510d00fe70b9835bc649c0251a1acf4930ffd27d930b4cc58b7e51993beb48c836ee956e7859ffb2416387bf4c611389a1006ec1466a06da319c4a92c4be5b891bdbc107a8bb795dceb5ff4e6a6c2f67c3230a231344291bbc1e285154b3cb7bcd8878b0deed97041d90bba3480db260ec24ecff4d99672d899bbd242dfe93ec99577be07f3f275943ac4cb13e83f1d11e2b1bd1c3abd628da622192686a57689c47d6880f604862c8352f83ff4514ee36facde4c4a3bdb2687ff0a46c4126fc65478f9829915b0e470361dffd2dd30c247ea3689bbb527310cd1a1e9bb874d455f1e1a7d340447ff9d714396a1c6862daf87bb569726159e9a18d43041db3b087eac33a1ec8e1f4c9b0cde8067f4d12ee097bd5e5ca830ecb5897126a23b2fdf695461ef686eb60e0b313877a70a59ed6591fbcbdedb1db08ea3d3e6e3ed210e37184f9e5eb09404128bcfcccce50ab6800430092b2128bcbcdc07a137ffa747daeeb20866e8a19157d8e70e041524518f86e250ac79132df7b7bb24d80316e1c4c0d3b4a2608ec840e15b146ad371222842534fb42d35c6239454477da6e4026b59e2c458cbc481bca23d9239a352e02ee61e4a3266251b9bdac9d8360624da7b609ef06c4bb3e344aa89c3de0c0d723dfe1cc58f43d8b0f79b2841f20c03ff46cf5848afe3fe94515f8887a980bb2b68d18ef3bf5127934ff15127068005d95ee4991abad2585ddf66303dea907040a0c27d66910945ba021c4a044abec451ce3d79c34a012687e615746b8b7402eabfba2d114748d18ff7caa95527996f77b6c9a2dbb19b4e176be3b095939e80447cfa8e4d1d2f18d695b9ece274accf982d30be6fd081d0fa6c426280fca44097128e0388b67e906cd5f9abd93bcd1c6506ff24cd7431c6d7c094bd074c651f0cc767d9085d43862b0ad5931fecda405bb8b4558521bf26235dec75e7b975d1121bfbc52622cee9f03a2828a5391e46c6656c28ec673d0176f27654f83bcd494a145d821efa3dc164a9751dd7d5811957abdc60c93287d6ba3a07698e0ae6463e036781d12ca73d40fd51f5193effb004e6a4b0c424c06997ba0d749ef832cdd505f8ce055c542c0fef6924973eeff586a02c3dbe594503346f61bc48732cab61605c671d1ebf2d31b2b8237db46fd61b87b457a555b18eff233700eb9979c12bb85d588423095cb1951c008194661c94357a874d4075da78fa186d6040e6e4f92a34aff76a282df2e62bf59c29741ec89df97a19da1e77921fcb52c7f46d77e941d43418a636478e0cbdcb1c7a6f56f82f39c8bae272ee099e0a33c6bc8e5f66fd3c919e89e90b2f18c8f20a394ce029261b7296dfd67a10c943673c07ce0c0143b1a09b0dad143a2b95327c427623f5b7f033cd9ef7da6b8107ce9e56f1d687c5bc18e51e66ae2af9a26af9d05559fc18ca9daaf266784e51ffc44ab9e38b83422cf8ccc6c6cb46916ffff7472d76c3e0579d980e1eab63080d9e28addf2d7eaa1d3beee2be9bb7e9456d14434e7b88a656cecdea05e3d26cbbaa91ebd9d133c47c60a80ef05e8f7a3c3f3361268e10c75615bcc4501fb6eadd5ec60e5618f9523425784d41d49efbe4eae4fe90c0ea4c3d33e2a8534fae29223c96618fb0057708a2a46e5219b382812274b74e4855b0fd955ae6748ac82d6b1a38dbb8aa88ef570f421ff7e79c358399beca9e6ef962c8a8dc71af3d08f70e2a1ea180c6d110366f9e8b69bbb87320291901687868f6b585d196a0e1553de9c6ef32c071b956e2f1852f9a1008240e35d36c58afd42d58c1b842da8ebe64656e9898756564506830903c199f47cd00ea06c0306f4d868e7e8fd39c55200d5f4611aef6300b5d7db6930a27579e34e0d7fba8241e057a19d4e83939fd144962b27a738bb8e27ddaeab90ace5a3c6913d6c504827edc02b2352541888e0eb4c3ee11080ab8507d882b74b2ff0ee7fab394c3d117de0e1f33eb8b237ed3f15a9204f857cfe9a433d2cd1781b7fe1ef727ddde8861411b0f0100623ffe34e8adc2d03a9dcabd87c521e48436747ea58a962b8f0dabe620168a84e18b677c5864e17e8ec0d58079432591f7b6b1a33c2d868f5b081db066e38ed5da807cfdb8b1abd7f02b11337175a6704a6806b96156faa57b3674f593280515c5d0913aae40645eccfdf56932dc516ca3e96f6c4ae97dea70d51911bc0c8e8e4ed0f52fb759db28ed6ca3ff6649c1f728306a62caeb184891ac1266cde69fe232ba95f7482e960d2b260f0ae28e89c06348ab00fbe5de84882980268d2683b9957653e55a67612f1a89398fc87e9f79ce9134c0d67c4cf9667fe15b5467abaf8fb6294f214f36d9eca2caf5179cc3e180de90099ad9151335c9c994c75970f0eb802b9fa2a1fc77cbd4e89a497e318789646aa575b234bb688e91eb99f0d27a52fb9f1a3f74602057d8cd1571cc316ac30a1d2f871ee446d5a6fb4fd575465b4577d7f2f9d0d88512539f638adff1dc0089de6d6cc1076917f4e17b8453d7a5931b7cc091b967dc64b05c0cafd33852aa2b5effc9c75050c9d2b0850c55b67fba08cf5a1cf1b188ff6cf3873ae5fb42a312d92d9f699ea2e8b5a8616bf004fa3d2fda4f062c5b7d45a66628a6954583ee01473d2682cec1adc9ae193ac3beb5ce155df318647c977fb31d931ba6845a28a83604ca7b7f77fe5e6b1060e32c82e40790d250a97efc1f336d62572bcb965b90e21ef466f6881031f4f7d8e9de5fb4d4cb0a6659efb3ec8ccc0590463f779707165a15d06f7ca38e4917248642a1de5a25e029539c78793466e1b7af151b002cd26b1ace5ae1a06a87ea078649a902a0fc9ab92a9e4f9d9c7bc74309710e326c5220773b698ee9093751dc78245978c4be10e68164a42834bd2ffb9a8e8dd366250b7a80b0d2df444bf9af5a40f428821e9e4082f139f8ce16ed211554326a0268219a8953737be3e64c2ab93e4c94259eeebf03d2c1881df8107139ebcbc8da4104a4b3846c77979f42b380090128603bdb52507aa31be0f6bfba5e03cb22e03658342a5167261ec6fbaa62d1195e15440523bd89064990c8dc7146c63ca0456dc86e293ccd46e7c188d8f6574b65b343197dc5c227c60bb09c71a93376e59243256f617a2aab32cc87db0414bf49d52ca15dc4781eaad615944c6ca13c7f6fcb90d7755b17a3d4fba0e94968849a437229bdf47dd90584656ff8b8b9fa857b69a966fc488858e86a55c218446277ead680cb27811e66cce1fe265d6a7f1382e35c3b03cd887fccaa5645422aaba0292ac129fa542669c2c929f93a2058bf6072936f42fc39d3eba96e7da751d405de376884aaf26825ffa99cf3130064105037eb79e571929c474bbdc8defd959905019445713149cc7d3901252670fa861e3165fb693dfd10e7d850780d1eaed4f49153afef1824ffceb7c56d20fade17ac8edad2d0bd603fc5eabfeb056c96303e40b2b3d9484e7e1d93fff42493bc45a1b83d5b1c7b692ca8a5eb586605dc54e31ccedd1b47c28d4d685d01ff73620aa8757f637b50b6e40561e98bd1fc93117d129cf34566a22cb65f5d3dead3344e65d1524852b602e2d9a8da6b91dbfede4ee424bfa67715f6bf9b502f16290cb88d37258db807afd701b136afc0d8db0f976fb0da3baadcac7043df1c256fa0b82640222d6861caf2659bbe1f7ab9b2c714e17e1be643ffeca56fd80645893864e0b8676590d4ca3f865f75333d2ad683f4430dece7bb1df3adc115bfc89a910021bfcc4ab4f1ffac3d05de90bb8cc12940374cfbdb255a39fd28a5b3b318af5567196c37a6fba9852d3a0304ff8c499c3f590baa65addcb641e5e3499ef6ee7a05dfde74bb0940d5ea85278f1a5a206321e000c5724c7d16520432e09c5b8d11e68cacea2f5b43ae33f78e70a0de87b5beab0f9ee32e11bcf36c16febc1d63fa6ab32559e6d65ef0caf726f59b798bc2d67c0d53cc173185932fda7073d587020c132c834470f26d681e5a0b48cbd0d9bd12fa04a4fc6a3ae558ee6dd53a1cff0d032a0264ca1d06c9f384086a6dd0ad7c266b1c4c76f427b93ac14adea6df976ded58a2008b050abc79daeca121e21a275ec0035cfae55e5420e750c2971bf772fc236631285197b4a489ab855fc8142a5caf6b100eef8870ad4881369cea02e4886d6ac67e7069cfa854445df5a7f2b94a87b089851981622e6cef3bed1e5aad2eb205b504665bdaac7c96a338c6c8d2945e9ce6ea054c4c3b161072ae7e2849c09e511457f0aaeb8c06261f62a0a372b5e41c79f59b45bf1e9c5c07e5e2f391e3ef4090e804a7a8b2677e4833429fde3bd21cf0474ede2bd4374e8481e7579c42048fd2c0a29cd89ea8f4f4301e485ae72983f22a320f6a280a2f2867a8714dd3c8275d33c64859c0e4e9a0a08806d531a4fd75f5ecbdf29d69c55fdb33c28b8860c1005e8c884383f924c095c655db73718e32447a30bdd4dec19501d6a13d2b617553fdf9bda8528c3e8dd183946d6080c7ff3d48c74b7087e5e0c93b9d50d6b59b77d431081d53b06bc38a9e1d25452fad4b9786f986bdab025b3ea0cf0397613da54ff4a54924369414cf7d96a8045c916065c12f555a2fb03261bb7ab952d99f1aa74870ae4f3e08c78b8f9c1d21d746b65f907b5649e3f4acd324a0838bb8ee7525630c9389f442a1cc56b6f84c0216f674f7bf9e20254113749c3c980559f9a2418f172a2b405257315daef446807927092202c00ab3bc8c41a7ef5abf7f586f04bbc81543ed9106fdd47f7733ed57ea536c03543b489f1dd113f6806e76bd0bfa4c107b63ceb74c23c8bc9b9c49ada8e917b2ac378ae4cdf00291ea1db35239e83edb97078c3a2e472b071a70f0e76c34ffff39d2318dc0b458edad50ef996e7225f163d68adafcb6fd9ee1ba1f76af6ebe0bfebec574eab51c1d22771f8d7f867a0e3390def4acec0a9fdc53f9d369cd4e6c6e462a85b0c50714bf2e4de0afcac7c35a5687fe1e0e8f0f886b6a9741335514a78e0854ddacea38599665b27eb66fe0817738206b1a5c3595319718654220ec9c208f04b8f6c18cb2a2fc48d7216a9f4a33f98ba8233816a69368393590c894991bc17726190a36a9d7bbaaf9ede54eefa1366813549076f0d34c6ef9d892c6db77fcb385033dbb3a590488068c929bfd43aee0d761a2cdd25059817adb96d5a931233f8d658e1f4782445929b82b97da7b847a62c3c644fd177307083948e1025014177f206208ae68a9d94f02e609afd99787a43c8e432d99f2d480d5cbcae5d19ad2b6f6b107eba7ba1cd71cb25fd9b0ab9b4e36c7c9d95271065591393c33678341bfe04865d932b43ecedb492f467e24380b3c9fd8d4fe43549b8869fdec839d16129ccd1d18c5fab0cb58f711f7d28a90f97f9558a12fda1f1502cfa793232e4511679c09617c572dbe6be779c5cf448ea59553e5c170d783b63655df274ed37f81ce7e03169392841520983226587440e936eea3c591511ff2f8aaf02f448bdc4307b47b8cd3c1b9d6f853d077681af1bf2ac84e7e43cb08548b43077c9e5c99a2cf86b4c1a9e8bf54fac45f1af469d978a8bc4293075fd35275d1482c1359e5f3c301be52946d7aeadf6ad2157be19aa99375dd9c5571517734d8a4fc0fdf9decc697b969f097aa9696151759b6cfcc8acd828ab89dbff7cbe47ecd43011bdb7212edd033233cd3dc1d8e68c61b35a9106e778663fb844eabf7172d4fd88cbf6fd24785f9e2367f83b489a9eafd58228f4aa6690bed502f7138a94f7261f09b4bd18ccb0352f378d860f73ac352e8b4d6716d7b542133caed44db91c54c9e308caf0be0b73f7f2bedf652c8ab7ac88633629fc5956e1ba10ead920cd4b7f24d23088d8d468b2d4a42c34e57c94fd751fe429596b10684fbd11442459d43f6de486247f5e87f329e846673dbf96cfa5853dbb33c86826def0c6011fa284956ea077830ec59b1ecbb7ec764dd0bf386e5075205705b5ff48079883b9de16e5f3ac2895b9282da85e4b2444b6608c442dba2792d59b881f6785103ab7f4aad0d4a5419733eea9569fab0d6e515b5892756568fefea487d128c8fe76f884e4a5226cdd9401e307a8a66152e5b054fc71429c5bfc780895e87f4e9aab01d8612dab78e00440ca94ed3db6d73a3a088aa1fc49c39d48f459bc2a6599d02c27a32c81f502c9d7f7eb40f708804d8cc63ab173d55c0ec9e0175c5323b50f81dfb6689fb2c5221cd38e368f22c4ac5d10ae71d737f8f07fb1162e2ff82ae5ce27999650b0cdb9e4000cbbbf697216f21ed8b4c6813fbeff9c85704c583053186fb961bdc28b275265e4d66152f8e9673c33a9f8be6aefa307ed1cf416d1c2a8d5f329d689c42a6f54a1ed4f42fb05b7b0ea51a3f4ffa15b921a9a4c16c9f5d361a099b4386f818ef79224a1e37c94b716d20635042832fa65292c0a395caff2f93e46f5d505608225996ef3b65650901fa0500b75cebad5df727d605002422bae8ec9c9835fbbd3dd65ac95c1bd4a19e1fc9326eb2e7921114f30a7ca4830942f403042b08427df7e6e0c5d503bb4c7fe35ac074ab93259dfb77b5f53bc0d47fee657cedce0298574ce69d8a912dfc0f9b20f2938a1db99ad31b5e8f6223ba6ba7158f8d919f94a4781925d231df275306f2ff60548b9f2dabcc171480f5ae5c3ca03c5d699a7fff719e108972dfbdb8f1161ad1b83452116758679236d8c112491a5f55f5b03e498b9fd0f91594a8ba4fcbc21f6499e75a6db04b7c7a5c675163ee2965e8da974057f29467607a9aa060f04405dbccf171a19d62be18a18f20d8ddbaf094c65f9cdfa0ebadf9558c79699d82121f31c724336237488701e437e06125089b886a1fb73ecf69a29a114c6ae3d21c558695715a94cd850064cc2845b93cb22651ef5b826cef5524c46aef30118cb7996af905937bdc092e5788f5b27f4197c5d8c6c80a703397259fc5791729d20d39c0ec553da5242c5ce0fe7dee5a87990691e85d33ec485f2602e6f749c2349d17d6ffaacc58e79ccf8ff51372382f88fe0c05bb040eded3fcef3b3836d0c081af3e26affbdcc6d4353c525b9a81810c7cd3f1ca7d62ecfa8433692841dbca5ff168f5ab1dfdbcc2fcd1bebd3e1f459eb1b554080a0731a93784550c0e6696dc0cacd4773d2292ca17fa2b24b5a5d7379d1911c7ddfd9b4fc81cc2d6e6f17a96252995e19dd77fd1add3697371228d9151f877aa04ee3e9ecaed365fb6c272b199070f0785ba26098a8011561d430c203d195c9a0596ca35a8785e89b1bd695253e0af4c5d95b84521c97ad0cdef4bc8c1178ff2c7e1eac359aab22bc4d2a5218b9b3ee9a00c2fd1e89ce2a14dffc36c07d29f48f531668cf8dfa0acc896a3f76635df81333211eaf2b99cafcc915452f29d540aa81dbea5d611c75a7c4c72b2727fd20cba17e1207e6cf888e6a9c0727118f0dee76886e22805374864376e65278882f68c2e87e7e685755014cd577963c68bb6d87457f3aec2e88acc7ff2dbbf4c86487fd20ec617f9895162f2e4e7645eb4d9b249f3830c42da1418d48020c7dbef4b4caca4f999596f034d9712125472bd3212b25cf8d7c82b395f8c1ff8cf5c827f90809297b84a74ab38712051f10e9270631d0d05ce050b9375ece8309093c93abfa32fa75115cc8b5ce5e50a03cfb2d027967ef61cbb4103fd8219c55ebb5b25fb770570788bb9a498ebbb1cc26fd472e592d746ecfe2cfe5f25f7068a1653dca4394b7df776fbfd97cf8fd4d65b0167c6b8140903289d146771838f11747bef2815e273a420fb28bc934409d5861e548b72393feb5862ccad4cb1dacd67725b75d8488c49637dc5a210f19d505db8f5b3ef95bd927b1cc9f9e84b80ece497adadccf75172f7898c156174688fda649c0842c12bc27c58c6f9d2860fe48a5a8ed9919fec95a81599cfb6632db0ce6226f8cc3c1352954dca1742278747b01f6ecd27af75d4b8d9dfc043a2fc6bccaf357b1e3427bab72f6c4a2c3ac6acde537d5299ad11b6b8e087c98defb6177b0a3a98827d874b846774b1711873e6116fa62d9bafd408ac8efb1fd91ca448a6aa9e5b6cbbddd8b8ae791c8e3b8bb0daaab18bcdad74d6ec0e7d8b531da225b9313df0c66a9a73b61bf6678a571d860fcf5425944ed3d5cc6b740540402beb7abf4822285a6d17c837ef4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
