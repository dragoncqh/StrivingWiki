<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50a48bdb949435ab9b9b4dd57325cd385649d89083cf67cf3235420f4117482089e17f1df661bf11ae78f25a22cf71a1d4c684ca9be319f8c34a145ffd73479f4d96a35ffc000f6ad0fc321f31b29a32fe94a5c8e75bff6fff5eb94a639b246d4883f607cac25982e1e634d96a18d20c89af9ba6c564135d2ab30e640cc848bf5051704baebf56351910eea389338eafea71acb519ef26f33477b0e4062894c24f481a6674b503fbff477021eb029f58c31039d3947017dd4c750c8940e53101a91c1f6850bd6c82acfa863150ff30f47a2022951df4275b9a080642dd71f83ac039438ef9c82b9d3544c2578834776ef9dd5bd96c538e0dbc563da6b556bc367b45c0e5720b0105e7bf335e34e8db16b09e5f36603ac8f1739ab96055b27108c5f6533978bea8c7513fde0b57c064e599a860f5dbdd75dba9efbde9d49ed409342cae0a06421d36270e1789ded88bea9c29099660f2aab2bf2d0fb1ab6d71fd6bd4cf3f1450923ad0697590af4f998e7f5bd894dde560d461c6fec6e6f2a213255b6e677f5edab6fae1c088d84df31971724e005d0b1cc6da8875e4d80c32e79767e9bcb47f8817ed5286e884627534c0f9be8f463c482e36fbdf7c25c41d349ad19d32ae6aeb8aee5032a36167da20921c7a2930e0315e65a2ad639d8f949064a5f04a3d6efcc0f1ae854f07854f9413f68f97edd2ffaf177ad248ba5243049620288be0212603393d2c57f54bc759ef817bf9cda29ccdc081356f1e04bb855bb70351f42fd3812c890acf26f00e51a015f09d5826cf2a89b222224b06bdece1f19c6a01d5743080d8aed7c2d0658cf360578d5ae0ea14e917a205448552830162fd447dc6471e0b4fc995f880d2a9e1e0ca0d193852a98445177344c5bb2c7a1ed819d1be1ada0b5b8363e735b7878b51594464536b16ed8c83f4090abd07884f7d655bdf6dc4013aa49b7dff115e7806bd1588596fd5d5aa94abd4767c1946daddb91bd08d801608c2f455179bca3760c3a828e7b8f75b0a4a913019b77473f4c5d03ef483e3f859a1cc87b56c525417abfdb91e491c16377db54600070449c9215890f31ce8eb179f719e58d662e59cc3e3e298a91ece0b5c0da9770415ca18608044eff44817a3f8be1d552fd1b601362a9c06cfd97173fe0279be4202bd2aa084d89af5195a30a47d94a398378b40bec58a2fc180fcd198fec0055613c92c4f396ccbbf68a4ac2a95cc9e8ce042b77d118deff5c589ffd6976a6351091265ce2715b047d38ff9c25ea1b57322c380a1189b550d9e54c5c1ec15b524d21d821c348d7eb2a0b9b4352499879a8bb68e343960216f7daab0dfd2b16a62592169812823ce45ff05e74d68bf1dc4f5474b92b18e0bb2cf3ca6ca50c5e37e0b924ed70a2d21fce7af2ef932245d0d9df28de0ca92b4df80d341a12ec58911ef8424c267b9b51d2de2db0b055ace9309ed66a45c3c5d3d455492cd6ff51bd380e2239dd608a28bd88e4ff8d67c730f53c59c1e2b386f36c4d4af375fecfd516728b2beaf39149362bc2fa9d425daaedc570fdfc66e1469704326d3b1960790327623629782872b580298b7973d2ea33fcd89392f09b39ea0fcac087b8b9a29552f7e2c0708f29019e7b3caddedb3ac797dfc62d4b2a83577731ba1d9cee1b4b8133d3c409e2315661c971cd8aef92389911ee79b1a68a0881c211bc6d6ab902f26c3086defff20cf167bf7873b8fd0ea5c9ed8b2dc9f03b16fd5295d91f22636eb4efa28119d872d2a1025b55308390603f7a080b8d8fd0727e6d023c3f6e3550fb8cb9bd745b0eadf6c1f14c439decfa7883b30828c4bc5c118155bb551209c98c493cf1284b1eea1f0489ca16055b7e77be2a0d3b1a30da783f85cc563ffd7cbbaabbdd5a0ec03d9b638a14374b9d6f6af1d51ef65ae37be4341ba37f3657a7316a00970615e8245eea5ee92c8c5494986246c272ec9cdbd6ea080c90443df25e7a433a4ccc5ee712a139c0981a1644422c55d61a73c6ceb2301476a470a92d71d92d7db9f73d135bf9d8e95ab029bccf86a2768565d87745fb1dd94db813d7b19c13ac6c67227cfcb8942b79d04e1017a93a9667b477a744d7eae0eea67b057331ca4fbb63768ea01858de92bedea4ce0bf5d80977867eb2a980674fbb94464cd03d254e0aad9d6aeafb3c4530272cc83946bbb21b37ac5f3e3ae830601b5ee0f8bbbfc5785ae59c1b700e0a241815833d9943e2ca5ac161e7d1eb41a1584847fbdc4caca8f4193491a7e9cd27e6599b856e653cbe4600fd435606c00151553718610df03f279ad261ed075749de477748acee9297f9e217360fe150d7dbb42090b72cebc3fc140ff416e5a835f2c18ff493b0629fb2bff73b39bfa01d25a3bdd9c8d55f10780ff1278c667814ddae576a3f2c8792475d4af8ef3aedae322ae9097bdc2f400648a5d85e8f64b6dc5ead47074b6a3ee749bc1537d4782a07f67f5c119ae2bd5bd7c7d770c3ff907d9e299eb3f5c2798f6dee9f393d947234dcd4cedc20a2f83727c5473f8c6d2c6f88321be734b04f834cfa7d3d72955d76275f4ae2b3feff364b016666e4163b32d8cb6f339a7b579bb68aa938f2b496459bf4d81b9b1d359fff895e365fc986dc4f9e945df35b1e390518e93e3f9cb36c98cd21a9e62204ffe08cc3810a841b17372c09edd1c4a6c3cd1a3837c390b4c7437fcb97cea2ecbaae0ac269c153342e0ea6fdd9b2806f21170febe814b89d8243b0d513e21179f30c36cee985a75892922ac257a4d8c2e29164a8bfaf73bdeea21ca131ce8f55c52279394d37fada0c9ebb1b0a83db3c0627f0af93f32cd1a93e9c456a6058db2a44e32d6a9ec75d8af2a1c025d78025a874a1e369c47c56810c517479c4b677d5edbdb18e2522f78a495408b95d70b76c2357b32567c0adc09d8127a696b14c4ccc1dcf5420dd8f3154001eaa4187f54f3098945d0fd440f516563c105f92a251746a728480af2a490ac2173e929d38a533184230cdc6c41b1235770eac551d8ef2184dbcd72fa92908a7a9f83bc8cb1cc575da3a1773041dfb15f72259c9d4a72bd85abc7820427f360e6a308ed1221731fb2c25619edf907a84ec63dfbb947e655291928b5765c4816ac65549524737bf8e714abd03c5b0d3de627295babe676abee6009bbb51db8344af28b8f366738fd2a813503213c90ad92755c39a4095e22221c153f438b686bc6e2e229ecd0585dbf12429837336351b9538671c61deb25fefc40399fe35dbc4d4e99d7ccac4e24a24a8f81d00ad7effcd6af05197d7b955ea9eaa7aef15b5b9a3e17b8956de3f4ec97ffaa253ae61071dcf7b2337ae6dbe4b221eac3d223e4f7bed6c50834812310e9211df905509e7872ecd26fcf4adf2db2b401d7acd589df41e7da021dbd3c1ac8037b09a4162147df12bc2a48b8593ca9c9f17413655abd6cd544944fd8b85093532b4c130285475fb56843ac7001aea846e6f5f18d30b19395a44c2f4c6b999098f9f8d6968d45b9d6e5e117db6185124a07eac001325aba98b55fcdf425ee49ac8ff54b79f89daa110ad7719816415d95a835c452bb7cad194716836ade1d9cd05285f951ddb7fa2d1196066fd023a72dbef1d64d77e51a41a9814b445c9c740416c3ba6e7b5b1366bed459fde5e07f2fb8aa6b6c614bd6052120dd80743045ca604246826f812091f422857e97b7933d60d35de64065ea0715e1a1df07f7ad726dcf6c867ff1f84e6df49fa7e44b3f1d8c5b490b38234067a32455facff33f443844030ee0ba9b95b765353f650b80d3a46cc40826506bf31daac94c7fefadce74e64ff34e1d74f64155ce76e545025251813457b5092839c90d0da0a24a20c69301a5db0bcb2621b465b50741c425f102c07acf3ea7db9011aef5dac8fd9964f0ec082ae198803363b36080f1df871816b4368c6c0827a38c825f958935ce5947c1739c1434afb4fac74880b5e10541f8131802a9ef37d195c62d18bdff8f568f0e3f3418638a5da7a8ac30708d21870fbc983e6fba0a3959cac6adea3d17f837f3f520f4eea037ad5a2013f4e44fbc7983fcd3eb493eeff6e0fbf5dc5dd133c529d7b18a6978713e97b3f6c4710f932ac1a9b322915b6599e87fef0722520028a67255796796dd4553beaee1510fd1e61312136b844ad0a7b7bcff290ab7ed3406161e97689f8387fbfd96237e3d73606fe576881e31dc80673b102cafc9d870bb289675e7bd9e1cdb7aa8a369618afe163d6bde79499d6fd05c42af4868ca3e04873c98410d3fd4ce3b55cd4249fc1881d635aa89f9fd26458fdc45e6899d43bda4922441774a914f50821fdd5cfa452a3de06feefad871dca1f68c88abe73103a55c21908132de141f16894012531713708aefe41b282761547aba690252a50f68d1ff52a41367631488949458228e430d403a8e2f89b4c59b770c667f12e55da2b39b600cf61b29fec2346da9b09f5536fdb27f9ae386099eaabe7a6b3d5769885cc1cbc8d67c5a6ac75f2ef7c88d268a2bd24ec8953e1119b95353b0411d7744d5cf28955ba88e329efac632b1b12f7d0efcd155b8f5b1d4bda10a471c0cde6af8c215bd777941f6fa3b73f36af42c4fb1e753715f39fd8fd3021371ebca193832872c85ee5807998e5eb0b9ba2af88200c4db47d41bf33740999f01152a73a2f085f5dc4416ae6afd041ae00fce9a96ff2352a0538dbb54cb3ac7430e5294652e33a3e8d6c323ebb0ef693a14447e2ec7aa8be79da0c97573c4e2f8b264cc8ad66eaf0f450a6d57b259e4ba5ad686e99c1ebde3902bb794897330c0b5ce9f959c0e27e22d9eb185e47972cd07accdc818047ecd9c412b4cd13e0478fec3737b9177c667c5b6e40879f34580bf0a7d39ac33ce39aba1ab3959cf4492941099bcf39148426dfd6ba1913987ba79ed499d5ea1d0a649de97a5a3665e5316c4d8b5fa9fee1227ea958b0f7349816181a07019047a35800f659e6c1388278a06da05e38ddc443c8cb2821553eee54519dec34f556ddc9c000d37591808cd95438201fb1545e99aaee91e6488d1e2bd6aee3f97275a2b1ffeef1c3f4b94515ddfd80e6a2977f40f4c6d7efe0c763e6250831268510241ffd8a6037a05fe621e199c8822bc5c9bfc39990134accd1712a334b35d501dde5ab1b84214bf6a34f159f1502112bd93f9cfbf6746e97e7dfddc6f1f91209de3e17194c8ed3745f345112380f276ba5aa7cf91a669d80d51434f0904854052ea277a915087d2eca749a0591add818fecc30eb565e62ac2387b07f58541f61fe4e1e200237d59c046a1e1e5a8cef39d34335a865162f54882af4777acffe0cfe352de76a867b3144c6c8094c2adcb66218c3ade6b5515872827ffa5c5052db33f308ce8a01c614630e755eca45923a0ebf7070ebdd36e4657c82418e618ae5cbe68e7599977048bef33173ee93d9a7a2f294e40a65c329e8b13b9ae9bdf0d7cbf389506bacc668f60a22a9695267da3b7767065d4cfd4e62fbea67e24456d0c27c3de5ff080825940435227eaf227ff50ed9d7a636fd0f4ddd11a990760a3507d1c2ca16788f28c69b663b8ed762ef0d033e8dcad204254354ce55b5d9dbfabc0f05d3a8232f485f05610a63abc8db35aada60cb31d9e43fb042931fa136826970ac73865f3beb9906a2c220d44973386dc1593c28092bd461a58a0e910213ce2187dc65cf9f29b95e4cc8cce6952b7b17c0b4edf47221377660d43ff98f186f93508d0330e3ad51894d92ae9a731a27159cc02236e868973f2583e1dbc76734e3f4acad6c9a0dabeb36cbe04edc24aed7dc952346925446019961a6b63827f786cf1a7e9d6f26ed4f98bf93daedb41b65f07688f9ced3b4731c5409e612181ee53471fc2fc49ae8fb270661d938498e4af924ef80ef8e69dba20a3701a350d592e78c003e026d68a33996e1f1b8fb0f9a8806ccb5b675d71d1d2898a9988740cf62d8d500137b29bc15f011f378fadf175e3c0d486e272377890b6ae2a0acb160be9340b885dd3de7c2b2b6b6f4aaa97c7d1784756a94d0d16bd0a7d01d8f98c62599354bbcafcb4214a386dfa4cd899399f6c78ef1ff58248cc1b7858ab1711770fa9260d3f43a22c5fea380d0afbaaad376a526bf8068099dbb46741dad74bb35e59b9bea8c8a1cdd7586e2aaebba2cc51f5ae4503cf0cc25538c80c080deefa071364d7513494f06f51557623e445b6aa46975160411798a032acade0427188007e75e86376d1bc95a63a5332031022eaa9907f036720f99bd62940ecc57dbf87edfa50714014c1bd64f1172e418408cd493454dc9bea0bbb35262419fc6c69e088ce1544b6e2bfd4c6cfd72bf8771ba8c7228c83237370e3539f97ed385bbff95939425621a7c39da3919e710e5cf24797c3f58f9468529f5635b227166b2c3ca1f13e8281201a542aca8faf1b5dfe5cc2d750a6b4889b7d07b9666c08ffd0a538232a3249bc8011e078e516e0d9a65f26bb1ed76e0ee80d9b01584b8eea86861ed5adc4207594e4e9243cd220a36ebe63a7e623138ba89fe5b1467696b0a466804c1d7ccf50ae6580ff1364eed9ebde4843f3c782d894b4d0b7999a07c4b0cd7d3635cf1d7e5440229d8e81cdad13df81ae3f5bbfccdaf93fb068d23cb299d950c048356005a979adbcf1e9abc5e05cab6e885cd363f787043a79297f292efb012688183ee914d1f5f9ab8b2216fb725be742f97d9338c8af06a5446d554aa2c03291406a91a1078bb6a57adbbc1efb5d57c981ee2dca5f48755a163c1c1c47fbcaf07dd9786f67258bbd738e604a7bb4ac4bb36773455b4ffef1574a4f3b890e101693cb5c6ad4b1b14993e910e4eac3b8f9efa6df8087f948f92147f664c3fb874ac01a41f32e62279fbdd0610121960abbf1b4a0639af8c831fcda3cb2697e296606558471b73226d6a4b186eeece1e7a930390a1cf1e40482a62d251ce02b9c6555d84cfa398de6b7223cc1114b68e94bd11b56157fdf5f66b7ee871f841c6cc403e776cb4fe93926f648d463229970e442a27094dcfa5b1b6ba00439be203ab3ba82a97ffdad728216cf22a5b49a22f73128d464b7606bb7ce87b036cb448bb69a4e4f8ca06e88280274a10c8976d148ea9cfb45ef745e0ade65592d3053682e8725144485097163b3a1ddc19d1b992e751dfd6e459a3eb81d2d59d20985680a68195470c5c112beffc40a1f771aad02001cc5761820cff98d97ee8fd552be11475696ea55c48020fc8d790b65dda7578fb572575a2e0f9c6b654913ec579fa33803377f59e364eccd1ae67875347cec3d60c06644dfd3eee7bd5e947e80f3c15af1bd174a2bb34b959c4b4b20bc763e23783ae8021f028b623054332764187d4f145986de763a01457533fa83a3ed6fc831b7e2063dffc3fb15cd984d52b3ae4e218c8ec4a81129be27ff21b034d0e6aea31041030a33cb38dae7f732628f19ec0f15fb1f934f093aba77f5187f63acbefeaf127d615a1e94a8ecfc2a9899f90385a81901cc6e072118b36ad6b40470e46b03c73e14ea779386d34524adcc388cdad28c50022dac56f6ab290fb7f080e423686ba685f2f4df737697bd71b93e0dda0daa80e0fd8de91740b95dc867821a7d03e736fd77a97f929d74f02bee776e5ca8846f00e381fab3786024d73de866d6a69d7b744d64944290cb7323c5e52a5756e5fa0c230166834f4060f8e9133e3b444963d461cc84fde868364a13b98fce67d5f575f17f49381d263d23ed93dcb0c21c0bbba0cb185c970467a1189f8beae19b46bc8933f06bf568c03fd1ae106dfe9c51907307b84c17fd88d635c1d469b8918369be78ec2823aa8701a54ffd044cfe80716cae99bfedca92a4058dde355d1d70eaf996beebf727af91c771361ececa6b1c4dea81b81cd7fc15d1e9275c6903bbaf8160cbabb97e9680ecc1be8673c858bcd4e42242b74bfb0f655fbdc1db465bef5a2bc9f36afaa60cf2ca470d5285fefe693416a095f754d4940bd4b95de348259745938ec87c84c20e66980b8b8a908d6ade33de45e14bdbae98d395b2e1aec3aabb088e6a43e596f40e0780ada9d14f829a4bd126af1953f0ee4fa4f9db7b74e89ca71101f1ce26bd1747512765737c9cd6c41e066e872489a22f2f57c4bcc40108d793cfc37384aedf2b8e3240ebfef6b1ec01c13ee3cf63b087ce5244707d1c5fbe76c2757889d81f6c8f1f5cfd8f1ea6e6b6dbd4e18dc7c929a084fcab8c10ff97c980615b0693d078f68d989d94c6e5c9181b0ba73912872b3f414b1e036d8b8df2610a9035320aa3ddd1715f78c5b29f8a77fb1593ffe0ed871eff649c58a54fbb7770e94993e23db3d3dd3cd7ccd046b1b70aa2af224ade3a0c6ab89da93c13ae020896fb6a9a244209b89b9fed0b9beafac11ebb47f539ce2c1b0f4e47b665c0c0facc8abc2a0855823684ca0e7f2ae3cf03edbb327b5dd2799226292746743e4e696ade82f28282e2f812bd22d8e521ff451a685238a67041720d6e9a9ba04c2698d59f62d3706122ad1f507c45d6a0afc827d2236d1b1dbe59360f4e1656f87340447dc0092c0dd8b99e422266337a86ada88104768490c1fd42e4ee38d12d8d0165b126daf22a19ea5a05abf8aa1f606fb049247c0ebb031c044983a12ee897025b3155179b71714c17700854c40cc5c310aea2817583b28210e9ce78f2b5d539aaa4b7ce1914faf56ff7f07f8e294b99ca22e3fb4f30be253aef8d294e67ecb57c241280fe47a6051d09afb3eab197be5b72efdfa5256043587f1549d2223ea2e266176c3e1764fc2749fa74c868b802c9acdd154a6c02ca734e73a5249b5840b320319e899f0f4e15b7959f68099acc4f14631d628326761369f263b672f97d5624232397bb5af417d1d5b09723d9d23fee7894dc1323eae07c16b17785c10ac01ba6afabb3389e0b68720cb9e5801b01f177a32ee507a7c5abefb850e16331122a54a303b4973099a5015c2e8cfcb463e20fd3a2612f3a880e9ebbf7b4e5771fc3bf55c86f0f8184125909c7645d294389e33b6c7d84420b903b275a6e0d5630c7f06f1cd776a3e15b321d5db03ad626d4b7abd13c3a62b4e8bbfa1aca95905ece4ed550b35da3e2c4266c81c06bc9e801c2ed77166440a76a2e29499475e08ed535840553e47dc02dbc3c30c20c6cfc524f5f3089220ebc35ada20da7be9ffbdbd02d78fe92a30c453fea276a5a77efd8d9a055c566ff519fcf675d8ee37684a0740be3fc82dab3cc55843f20e6816b5928d1fbd2e31510aa875dfe14482c2f9d5777dd840f9a0c11d6eaf844b7c7bdcb858bd4c9b848646efc3d71a05fc8d96b053141c04c4a8fa83e2bbd9a1fc0bebe01ce0992d0358ed79c2ec8028cbea50efd880d03069082cafed28f677e0f85af1796039db5528e4e200d791280050f6edafc775436c5da739215d57ab20b19e4372713d70d00072bac347f756e16e991af683da2e73f2aa6ed1fa82a4e25f46535436bf9d009fd8046ea8946da2d8096e5650720c42fe39c9b91197e7271fd26c8bacac8d85bab9aab147070428a81c755a0e46675e420dc5d37696181d66d671ece1ad256ca4a042b322021c528e653af0343b54fa822310b6e1d5281516ae049d15ca372012ee76360a2f392eb259475bdf67d509878e3fca7593069809acbc7244c28f1cc44ce16c3fb1e73143f3d1f24f83fd8ca04ed9150195b44f35274b0901ae7073dd429eee87f180ed1d4c3e338f32fbcf9b1080cc16a8d5e1481635f23a4513ed160985b435c1d5a1f423a12fed5bfb5fb767c09aaf563b4a6f29d98dc9c8bf826f4ffe56b079a02f5808860f3920d9e4b82902a4791edc1e8f28e1af4c71280e36c639ddb3b3547a28b179d70738f20c3f9693e5523683c4c15c7ea0a18b3e93234d825521e49b22f2eb48b267082101775583382c55a4dde4411317d1387c80127372f99a126fd3e3f487863139232dc8f3c24873bd1c2dccea654679a1e26e70a748ddffd129b5d676221cb14890ed61bced3fd2054a41a0bd4ab935c1d1fe668b3b85e2ce294463ca92c00ebf0291f1e7eb1abf971a5e65e29f4874793570983f999fc4d1118a191ece118bd6f50a1368b3a7220a53f5068a6a47b55027d96bc80e11b101cd7568ae2be653f7126591595f27aeda7fa62d0d900b1509207781a4598d8f5650a05e3ce938c5230e9ce2bc88675952a6ec891160434710f1e2ab67866b767dff8f03d9260291ded5535c7ce0e1a344ed30bb03c65eaa500443a8bcae816525e4877015b6f6a50b9d9cdcdfff5c5105a624df6eb4759ded1dc2c5e43ef64781faebebd73778640e10b2c60ab442371c767e8cee7f7ae699356d043ccfdf072f6edf0738d76237012e7b8efa84301a1dab4201e95e7ed6e940bcd97d4b115aab9a9460f9ab9d6e19387849076c8cbb33d744f3d71c6e128df1e519a27eeefdf7b55e4701ba997c86f9c63c4309cda8497087821731db154759573bd71b272b6e7db21c592cb6aa6ac2d59293876d3f1b23882e6f9fd51970347c7a8b65d22080289ff902c21453c77297ba5e8fa803a49e065ece1870f3d384ae1c796ba3954520f7cb609439ce28ae57f71682e21cf91ed9bfafa96633deed60c7e9114236f5984b2a5c1d2ab3e382d8b3252e0865b518263376fa39fa327befd22cae4f5dd7778617222e80464d0e6db930ffa1ac19d7888d03b66e587be8aab78c74bcce78ded696c0fcaf98aa1e08c69000b3197bac271dc3c7f505f4cffb5ddf61f14238930cb05c980bdae036d137a7f9eafada9c35f3c3b4b789fece9fefe11291bf0e2483c766e7044eb853f6cc002277e2e2bd41ae8a05d59ca571dc27ff45af7c91c109bd4adb2144fbd8574c8e3a84283a7c9725d5a0734a3a94383a5ee76e71a989fe26f1ac00ee7eec87001e9356b00e0f75a5101a41cd4aaa98512e5c8c235af178ca8114c51022048bb4e186f6e8107cc8a4226cc10011ef2abb5d3a4d1be61c17ecf0cb21f69c4c419bbc56bb9a2b63860855c56230083dc3211409ea72a44c95c9738342cd0fd0c188711a2f6ccd9ba8e845546303054884e36c9185a12fd1ffdf5c50cbe97839ac4f7aa786017fa70ffdbcd88d5c69688edf3fe666b59107cc172529f1ca688b47b8d26a42c6cf190b231b5d3c37dd954dd2d5613b70c9a401e4a9ba53ee9945d60bc3211db7aa2101911d11e070a007e358264be8827060324db53923d4abd35182e008ef9128abe4f77f23c7d0b1374570ca2e069fe395654d573d44a23c9b4a67a1a4cdb4db848f2c2fae4091fca26d5dc575f6b563e8bf0c6c7bd1cae3fb7a07cd4f850931d5ad1da35acc5dabf603e16387bff90c9871c9d42c8f8b4499afcc62043473a781f3a1a0775223bcf8927c497a3c709a4834d6c5ba8df4e2e461f331824df8597ec23d036959fd8e4efbe8c16655a0a5a0c9ca7987f761a65f7040f395e0001cf60252877cd53c180aa92cbcd69f7961724d8aa202a90e953bcfd54b91c5ad79b55ef5a9cfb399c597f75be5d8e02f31e31b481084c27905dff91385a4e09ab3b9e65f2a75f53b176bf12ac8be2053b6615abe93b33397c214c601eca1f7b26b21125d3a0b2dd560ea85b78bdf448f814be1581a36649a5e86e282a29c7805c157bfba5519ed8bcb98d6d145c63b5515252c0f3f4a8616f7ab8293a50e3c172bf819eb9fa333fba6ccca945b7ac78aaaed089ada500ef15f9523955850af48ec477af37e666d6a12cc5500d328189da763fc4a331f02d8e68b3bff6a8e0e58c1ba4b5ab157dd22653897cf6da9b4014ac4c481ec4c1efb8b66712adafbceb874ac0aacfc04265d488f594c53c5e8365dfc0a8d5d3fad7c972f28f9133717744b9d73b8f319d34302e3c82f6b3cd50ba3f8f10bd8c1cb7a36457bdac3a20ca52ac071782bb282062001b8e4cb251523ca83cf2d0145e8249107ca2fd25818666aa84f5450d7146740c13a6ad3b4c25e2254ce42abcb27f236168918d0481681aeb64c47e717dc3d5da752b416d1600448333575fd451bf92026ed43b4ed7271699d3819ada422e21608dd6e571f762a04161c233d92a1ea8576d65bbd023cc55a178138be4d0785caed9573bd3f138068a5d791c87e7614598ae2ce915155c97795eefbd29d5235868a8f99ead2db92cd058e9740627af160dc7933b393ccc052d21c8dd816568267cbc4e4ff2f7125e566a27e5bc512fc2e80485619bbc4b3cdc79450181918cf4b2e19771f1b62f8fcb360c74ca8e63fbb473ba765223f896ddc00c9abe0ab8d8de8549574bf88cbd1d6d1e6c5794b9950bdbba77d6ac72b4b013dad4af17713d030da43220896ff6d20249aa4520ca1ca97ac15777c1ffb3ae76499ceb01ee1b61079fc20a18416549653ad63c33493ce3932b6f6228afa83994934920ae6b3900f6a0dfd1c0640be77ebfa7418d1e3f9d524841322112568dc818ae59a85c400efae3eec9299a29b17bb0f852d1c5e66c0e727a4e1e74f5e9dce8014d1488e92b0716b160119cfecde9e7199804a71a146ccaf92afd5c7c2487daef58d4bf44a7b0ae7ba0ce9e448a3e7b79b44b3d9bd1d34e6b94280f2d86929d6a9d3000cef21741a3e54436be574e3013d1a49dc5c706f3ac5f55660d2760ff780d48fcebd6d384df60fe4108877a0072c20c31d929d7b1564a14c08389b32f3406b150548661becd43acf2064d61c0d2b342e2d1934b68d125753d0e5561378875cd43944bbf1c0144da075e5faa26f6d8f37ddba39260a96baa19b257a6267c73e4ef7d8bcb3cb29e6093d33fd8ee7a962e74f9d4c318c0b8da51bb080835bf08f66377183564a3afb2cace1604722c60be032ed83abff56a9632cdb088089aec7eca4fb7a841115c0d2a07874b2e5cf017eec9a1b216ef61d614d67fc161f08d8084bf81a7482d6f7046df66364723fcdb3781329e65280835d4ca9a05bfa86ba3da5e4a06e8b985b785c24f54c21ac715cac10f52e0df3c53b6c2db8577c10e32d315323244ac37b689719a45214b9dff3a6a9346d0636d03e49c6d440ab46d40f074c7a0ea852da6627a649b6d05eb13a530f6804f842942b3bb743f3d6b3f96713d52fc41f42e5bfeaba67bfd6ba41700a020d1f4024c59d058fa7ed8ba48513e8a5bdf625cc6e246eadecc90be364a9bd7b654183a29623986478bdf8c50333e275644a414ffa81273ed2a8ff6e23c805533a9823bb6fb8ce5371b561e24b486ca6e356c513b3b8c3e094886fe82d6196303da92823d7682189c8d646d23e04f6a57927b843afa6929b30109d532fab81ec14ec143dab46da7870625440008fec51d065247435d7e9df972445b878cf2908a7288602b12b5fe2d84ba92b93e68bed3cceaa2401c03b406d6e6f10c43cb4fa96706569be16c3ac84143bf7e5635ff49c8e9095d90c03fbf07d41c77c565afc72089b042f2cfc7ba3cf76c8a3f71d7139fe3ad0f6915aeed20c145d279de035582f24d9cc2d317b227bf201d54d6019716da1f490c35693d3429a9743185babd2050c7830d9b882aa901257607c663d9c082ad6c6da667271d827f17097099eed1aea68c30d174494f5e82592313733928481364a0e82b5fddd56939adc2318c03dee5044f999fdbeba118f7bb6b573a0d616c0a43a54cb1928f3eb6e7d0a4e82995a4f0a40298556616e6ee38b6053cd1254a9f1146d2ad8f87d1421aeae89dd2893c609433a896b8e057db9b0b24922c198fb4da7c1bc94358d1bf2173bac35753ff7b8052e0f93e3bf8b3456b9c953db0a7095526c592b50569dceb06ab78b22dffdb87525a88acc958bc3be53ac41c3af57e36e80d84a23b66aebf884cabd2209144574e08c84078b2fb3c5cafab3a3347819e5947e9ffe5293cf5459d7ac946b277e33100f15d9a743d149807172e2b11a277c909b9a86a7b224f3a61400ef8bb4ffc26aa4016476491ab0e2712d426ff318d9f9bb8570550b536e23c155be9628f35acf63aa9c818cc9f609742ddad62099c2a0cd60f86972b3805bec8a40effa76c30e3285a87780d3c75f308b5145e0b84bea5cdaac1725d6bc7071b781a827af256d61c91a73c2d54ec6560024f26b71a9dc9d613b7554b5b9a8d3d9344dfddc032015a9c4db5eb6f781ad3532e5d7c4fecf100ccc8887d4c0b58f6c6d87a849a7bb02253f901ccbbc405cc896b57560e566dbf6fc8c26ab1fecd39c8a339ad91cb83414c5b5d87fc375436277a5b8097fb6ea81b4953f1beac7253bb169b01b32ac5913ffd10d7d067be37d4ed0115cd846b6a3575a60ff5391adc391098360c99e7ac5527300ea02e995f1907e8ca38b69e0fc29b996475eb109e5bc9e2be00dde4bdc4e69fcb73653433020541e3401ed3fe16e191e0852865e11c6979853a3db4615f420339d8c5e631ac098290ad0f15f0edbab0a2128ec4db074942fecf971e207fb24999af625d7aac31f87f5759d323bbd74f48f5345d451d2cf4edd4b602c1802e97a9231c004803a9aeb397a2a3cf67d7bbc045b63c4c3d76e75845ad945d8a1e515890fb0829e7f40cf5913d9fbcf5231450cee0b773347e8bb31974bc569e3c8372238622082c8abac4c9f1397dd411397e040229abf8ace029ebdaaad00a5d93393e41fc5d64931acb482e7c66fa1eb735f914a9ca79204c1fb333c25381c4db9fcadf7286a2e95bc915b8f7c134871b41adb810c156b4552216a0792cd619061732fbe98b3bfef3c9400bb35ce28e3752f62761fbc2d64afa6779a2fa815d7c67925ca8eece28fcae59f5463cb058711d4cb0298fd119c53f726dd6cf82d1bf106a3575a38d5330dbd73fea1b924c894be5fca201bf869e2e6fed8d597c8138e8de5ea053e387c2604059850b04e4e424d1e3325f8ecb12de0b3603f9ec6c65001f303f246f56ba7181ad8191cdb4f40fb56615e1b2bd482c4302873f76edcb9eb966e4b4e070448777325a587794e414c159a2ff86372dabd8b5d05f24b2d6150ffb5cc65fbe192bfc7a63748ac9f1d4389ae2cf9b0ab1edad1180779e37a5b28c0607a5d62c1a9227b77893581b581bc7f784c25eb640591df918f00ca14a7fd651d71a7a094e8d6e9f2340fe4ca0b08005db52f4e4fc3080038224183c596fe497dbe0f8c14447267a688fbc8bc5ee6d1e5120a1af20cd6fd8ef88e18d0c0b888c808063891de714f651ec47135d8674e3f9db89764523e2ce300df7be6f2a749bf7cafdd3521970e0bb08e0e998d59a2431defa108addb2b0eec594160d75bdf3a272dd9d7b4f144d1d0a9add8d8a162bef841208bf5f4458059b95501d621fad067c10b97a0e2eced26c4517509f250c6ed0d139b1bc7f11ba1ee6f443fcf53283a7dec54394ef86a286d12b7416215f71a1f5d6ca734d5bd6cafc17c6b2187a90931fc6eaac32acaf09819dba7cf9545fb15003107fdab9f984c7a692e8780bf6fd843cb781764a7e04b0c0f3a05efac731e21e2a97ecde42883a7ed4ed7fb2e4d514053cb2ceacf8093a58e924e1a6af67fc5d0aa074815c47efc7a7ffb66f6e176d6782765ba7b8b947b86b107ef689743ddd0b36877678a8ac34537ad0249b4f162f4b324f572ea13af5fc35a995d0fa546e461b9d58b8ff3c8f43a03d35bae5b7b8e0860babc724adc7806852424415eadad5836b3cce3abe843f48b55e44115c44cbc915d644cd09f9e99b7cb69ac8faf0d426f9dd263cb5ee9e1dff7614f5b5641a537499f5ca6503d11ebdeb9b37766b1cf2dda016a4fb47c9be691ccd53137bc6dee5c326a27fca3ac2d509943b13f1372fad1de0df681aee881da78b7d4c448f1deb43fc1621b10659e416b4c05825b28950f005ce6cb15e699ca48c0f84ed04d832846eb45e836cb01a1fe974f02c4de9f6ca2ea01842f5610b68daeee39ac56e882e11c563bced0847bc9b657bdd293229dd46d24b5e10e0537208b51db013351a0a58769534aee6ff9babcf1e590087a99716f9a9d12f277011d23e59fc7e2bb6c7aa92f7c4ed1a62fe115227727662a9a717a55b69f9daa161b85cd2f0cc1a1a131368beaee89809948085ce0e1fb8426f63cb437ae657d398b06730e596e56cfe86536a764adacf8b0c06877414cd3450cce52d0f923a0e3f36cada7003881c95d3b989844c38a5bc8109d90b3f6217f66310d80704237ad71585987020356427a06baa60c349a8c2d18f1ffbafa54d8bef6edd47246e144985e2b6658e88cb0618619b09d7ad7d421c317dbcb9866b64920cf02604b630cbbac1655375e798ab7508fd700cf7947311247d50d1e1b3e5c4df9380cdd80bf49c56db0e5ba8bac4761e00ef48408894619eedf85388a2c0d14c8dc2288a34cf01245ec06289d023e67556d95af46385b35fc8baf5ca8904e36a1c0c2177f34f597f94402a55623efbf8c50eb540f368c3946500d153ea184d903e4abe5aaa530e273261aa02548bd6c4214d35885bf0fb94da9738ebd447fc611e5ae8a89f6384929a6d80f1a151d68abc97305de25eb37aa0043bade452a66e8924922a19d1766cade56ac2b7c1f84e16d62a82d29a6c8ed24171bbe9dc9613558640c4517571789d026ed4bc47cd7e8f70547a38fcb10e4f4ff27acf76aa7cbfb03643b1ad4fbabba95b0ea66f568ecbd3b771ab0f9d39dd3c0840ea8645168fc3461873457236ed141bc013d5b789ea344bcc4a2d64afc913be8dbd5ec19e481dcfaac34f53d1da1656dd9681287f3eb0f7c04dd6f98e002fde69a5d8329ae67a2394eeaffb8fecdc30dd72ed4540c62f4866d7877a3538d054ed06243c3bfc66e77eca69f7c0316536cd6f2ab37859d583bb8caa2b789344fe4e5329b442e69e99c3165ddbb119bd28807348","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
