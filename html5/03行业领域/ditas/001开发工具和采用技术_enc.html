<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3cae090b4f0355d637dd85e169f69b99b6e2ad77a922afc7e70b76484c220f973b0f1137a0219f47e8f2e428e91cfc28bfac5b6e00318cb8902293574b19401796541cd4f15b515a1fc4fe639579e3107b7d14147ced1adb19ab9c5f2e05213960955934c330f08c416d05da08eee7db20190cab77ce71827b872e784aec6972f66581c135913386d0014db85a4eac0dad77f56365225378f248296639d9661954121040fcdf1f8498802baf8a1b6082aac9be70ac805ce46cd30a4d2e4d73c6fd59604ce6c310aeafc2acd10f532e2a8477166ac883011f28b5674e35143d1da7689fa578ed402bbc8a0c8e55ca411032a18c0d916db8b64671ed1f61824a896d1b306e7b701c39a36eef85d90d8ebce6beeb7941765081b50818884e40a27a2a6917ca040c1e5174b9ab07c1f71557e9169bb379063129a4c01941df723e985f2bc05ca49267be2da6c67fb31bcccfaa08f8b07f68763deb08d52e9f5c53a6d3c91250f4f6d34230a2855e53b0f615b1537fd36551ccb08a3668dfe86e2feb11f96b679971791d9923ba09a639b9c1e6eab010d1b311a8c788f773fac03f359a33a69d7154df88b55a99c1030f13b064c1bae52366ff1bd9f17c21a31c3faaf25c096a57261f686da986e4e87daec8f60e4b1549ca36f5afc33626b6a92f5805e1df40dee51440ca75f5456e9803a93b9cb39ca13edd99fc0205f0ba1e5e54ef17ba6296d6b53805e355d4fedf3e3d79af2318a4d356517a3a952bd18e45f688f4a930800cdcc62f219b209a8b419e62e0cd21a0e830bc6148598f62660bbe22ce0b76a74458a13d823acd47ab1be4b35730b15e628676bb367bbc5dee5e5584403c448c11bc4e99ae94fc26b581ac887acae4bec8b658be8a9740101fa6f5f5c0e029bf0f6889bfae289c07aafeccb285acef6f834a64f7449c2689d709a334654d3b6475eed28ef6f6f5a5aba890f764749727b833bcee5dea8d4e34708fabfc9e134daa7e035a095627801cc1331a96e9c200f54ca2848ba4fb399876ec41035f4c2e06e743949deef81810da1ba16f63c638784613bd92c5bafb6caf426095b6e29fe2bca6ea6cd6b4e816311b6c1d67b3a985c96a2ea03c46bd3315f375abc8bd63e4aaa7e4bee42da6fb38b7dcdee184408f9427f15f322e146d65030b696197f13b7a9c170d563fe203796971c1fe1978dda3d9c99bbe796dcc1ead9f4cd9091d274bda2f9d71240e55a22052e864133e8a034aaa779b0e4ac0e3ac00a7d5c34ab15acfe4179024926960c521139ea115d38b6e277ebf39dde7cee7f814235ba7f158e2fdd3640d8aa80a7d2a4c471a43b9ecb503144dcf5c8f56a33a2c1a95b7a0e5507e9d43db846e9c1d13f1f6d0bb0a4cee2f8a0a436afb56cba58304648532c63df840e691e00c697979b8aa1c36d55c5a838dfd223e955dd253c690efa68ff0fb0dc3c225c04a607423df304ad65f5e8b51ffd4c011fa649941137525de465d0539a59c29faca553856d3df0a593078e64fb817388557f345ad5b337ac0eab334b5b5f21833807e6ce9c31a29c23c7767c8f7ba517e9aa2d78aeb80dd2b64f0fc5623dc933af7cd82b8f920d99dff03eef9028f7b5f2314d6458bf343cea08715a7aa0d2fdecc9d0fdc2e0c338e08a7631f65066dd693da7af2b5ea9617f9565801d67a0d37c1694093587077f7f393e895cffafc0dea041c6dc7e28c5299b7c25fa1bd240610c0ce84ff0b2ae5fa24cbe5e6c0dfc3e2abf05ec75aaa210ebab04902e2ade8b48a23f9467538b5ac86fba84d74c1f503c3fed62766754ea00a21cdd0b66a202c9d7bee83202d1f173f49677cd728206cb30a1e209e1d5584f6119174c822e7d52f6319ec5f450d0a7f3598571ea3503aae07531be9f24adaca2da26fe828468d79641abc6d586a5fe34cbdb60b722accc2a177f2c2781359e7c55f11e9be4a563c93b202b05e65da847d388e3112a990da6d2a81a50ee5b217bf02cbfacc3272df32a0f6bf026aaa14f3fdc44043868bd9dc3d07d587d2e1aaa70d75d7c2ea726b59e73d7ff49451f5afb10120988cf6d4f90cf41dee0b979f276124381eeb868efdbedc487fef578c9b99812b861b533a51ccaa335ebe57099905672c3e24e2aaebaa53dc43d50521f4212844b534c87183109c45325ead91130603e499d7cf995856bccbe83aa703d7745144d56026cc4ae158c22acf43d225220ad87216be7465ac14d8d568e9b2ea2882f2fc9204ab02c9e30e16b1969f7dc2a7d7bc723803ab7ecaca4acd13e0040b9257aa68294f28598a4a7564de0a132e0272e82d4afed1c822ac2d4bbdc02f8b9ec8c824b238c0c720f53753ff4daabb2fc83b2662f825c9e58e65da1a215ef2df77d423a83bcd8242bf9c53f99b6a1370f4a1dabf70080433c54a2d2a10aa2bce6798b9c240e9141ea627e4384fae53bc25dc8b9912a96d6f5982c9787a80a4b8afcee83b58cabb90e81daa4fcaaa589e338e9b1a6fc54c50ff60116586e4a84130102bae5c33e8747409f80e3035488edd41988109db5a11a793adfa690350d0c1c9e62f6ba96fd8a1acc8e1c558bfa1f560dd66e6bb576379759b21cae774da163e38457014eecacba826471add89e1d4eebc592a8fad655b9b7b6392f79faa46e6df980354356806534a278336f8cd4137d7ecd80c9bc78d0ccb1a6198aeda7770c78ea5984f1a1689f623d08e9df2b6c8506fa86d53dc9137b78825749800b2c488b9bb3e259bec5dc8e5fbf35b05e34888a62e99c01f920c08d387443ac978d1977f07334a1ac11b0b459aa6197796c3deb351b907b97b39c2ece82c2e9c5321c4d750b2175addeeb45b34f204aa5f02baa7e1e2b48d4a23bc2171725d341a5b3e6c4266b826c8db531832465df1cbf88939e7df73244dc318c16d504250e945cbb50da2c4705f08a82eea7aff5d2e19bfe36d7c03476518be4a35c7db0684ba25a0e46f9130a06a519e878b63e975dce897adde2859f3bbc81e8ed76cdcdc4246feeabcbdfb209ca98d1c52ec9eb62a4ac29622c077a4834189e3c6dc0ad737f190562746b889ac56b1f5c828b8c031785be04bb16bee4b37f6361c902fd69a8c88a686fe39313eb21b8397b1eaf5993db7c9572e98c04f07032f0c9437064dc8347e64bba79f508b05b019b38ba3de3eba69159cb72686b3b46bf2bf4c31d4c8e5b6a10bb85d5040505de56c445eefecb3720d9bb1a9388b1a9175c97a1dcc27950b999c36aec35ab5fa4d43552fd856da9613c3caf450ec92b70216f23bcba850ae972417193eb472e6e971ac8ab5b81f72ef123e9988de3898f3b447e5c77a7d93c40162294fd9f307a4168665a57f3d2949cdf7638d30ee00541353cf286361cff2aeab2da1b3ab15b4c465f60e51fc54dd76551e7f919d1ba460be987cafff3efac451cb514eec5135b7198f3e0a56dc9c240e085f9455d22b11bc2c7a0a221c5d74858090f428291d81ad838638d95fc759186b90e9c02cc98e9fca8a5ac7b54bf82a8d4e87a699f68348fab7a765afc4624a7d742666a3939fa75867496b21afbe672455080fdbb5172a101d1579bd751d61e91ebef5214cdd9dcb3b80f9d8ffb4c9affcb81aee6a54eb3b38cb595b76757671709e74a0fbf54bfdf73214e8765a419d8e93a03ce8b27a75f250ce3e9a8aaab49e8b5def675b3b21d3b506117936b51d6afb24c2840297c3940b66ccccf52ccd8436ed05573c60e5f56f3c635d57e07745c5b250a7317cd685e98f7a27f897a7745abe78f535c14b2e246f45341366b62c34f5ad570ec71a227a355a94e61e7fb7e4290d964cffe89c113a764b4ab1bdc0da14ea42d172f6fc08f8bda0d2dc58060a0ac2300781f8bdf4c5856d02212cb0db0702c6081346ab7a6a85515863ad47b983cd63ebc7e7a874768904a66508f9f3f0e3a5b40bc9079733331dc968328ccbc61e77f3c434037cd22b6e9d55cb5d6e5edefe8cdebe11182ea7d7a6eb19c7b9639452fe77931fd7b4a9694ed1542e9c290f480f126c977544bfd6d24b8adf71e4265f1e84044dc3e7c52c2d46cd73b210790a73f1c994f6f4e7d9227c779245272acd42820f2ccd12f508e00832f62b48affceac99f3f51fa93e959038fe1658f3daa8ab6a1de63647735f90afba058187c6e974b779f1c7e8c2959cbe42f5bd533c26b681274c1136c4a8a005b155aee4cd5bb9554cc46b95f92dbeab217c285b3b651191506ffafb179cbe74570d9090ecc504cb0cd675a22d3b7bfd7c24feb46e6ca47c89df3de57199bfaf77cf11ec8544ab6ee95e1cf3af567a3d96a8b85d7e5c32658d557d0f3bc37e9627bf3d6264167a723c2cf9ef5dfe0d531bdbbb5ac85bab2801a82c10e589efd25d8197479ef72c5cf5867dbced48f173b330a3a0bd70eff9f7e91d391805f94fb1acfd24631915e78f1d30d6b96b07693ddaa6702b3c97f14426b9c4a7284721048282b3be6defa9d404109f8684c140d27d5bcd236bbff21bdadc0bd2a3aa3f4b25d40e9c1b7cb1ceae25d635752b8c7460123035c79b96960700010372fa92e35abcd860d3b43d64b9e0783a730656a1f46ad60d61fb273677de251d6af6ce1df2927a5eca705f93b3f57394bfce7367ea633fec3558ea26f48fc39b7ab2887e1ade6d5ed035674e05c0108ccee2b076d7dcdcac729827048e6d51912d555de70097356e58321830489eae36bd02fdb201e6ec677771c73e5497a3434cb21e67c15ec26221360ddbe91fcf43d28d20f569febc458fe622a48400a8d161ee8afa2ed66f9265d7ab5e6c3024fe0406212deb16c25657056335d1c1bd1a35006be624529ee3d6c9508797b7c84bfd6431c87c532176e3537f48034addfe10f43ac3123df7b6901863611e0575d7673b2ea9ef50b722f79dbb1b5259fac54cae53689c82d9d645eb18581384f20436f9bda2ecdcc682d9767ca8f58d8c4a6f6f96e70f333f301fc18471a086f5767a357b2c9926a763ba9b2b47ddc0a12c602da123d4aed36c9495bfd1a89690f00695c410a4bce36c5a3f411e42de68bdd1a92fc30e1b32f9d930193eb407120571714d6784e85c023b24181be329f26f315fe699f352c1ec2ce6c94c38b8c9da5542cc7ed3342cf65ef4357c49d9882788fa1f88fcc6805bbb0cd476e183000d710221535773f5844e8982200d37bd812650c7ef14b058c43265b1afd592e50f9de3ff32ca5307facddc20752c94f951530b716a7d72dce7f3dea8ea39b48ac99b9b0b433e650b15753040afd3e7af4428d5b309d9bf6d17ed0e1984088805847227a28d415db40028338169a1d8b54b5377a0b96f301e15db836e1e0719e090e9e7474ceb7841c555d62fbffdee91bc85b825880c479f4059c2f4d75b8044f82863304eeec419b0b5999a64c325d69eb2ee9e9732178791949f238e4bce31251a2a949b5098df7a9d37042c3e7269dbd02a02af2695eebac24c4f86afd5317210fdc49e8b962d5feca581b2998c6b10ca231739356fc8fa4b1923861511bc1eddd52b4901316e0049853ef48ee0d54256bb57b1554f112e2df59c4dd4fc09d2b8662cb52cbe2dc308a2a3dde72bb6fe675c0da3488509aacd87e525b2a49566c237cba5d7a9fdf0310aff3eacfba07b978d5a2bc5b79c4d9d1ab708508907cb1d48741dc4708e164dd45bfbaeee7bb69d98bd32b9d190720344b17d8fd22e49c5b05c0f165e620c9213d5007fd1b977e85c9d033dac20ab256cd51c1107e996dfc51203171d119c7367957b3771d895510d3a8d47fafd1add18af9f4f3b4fc6f4e907e591f31c9743f42fb189305a14a9855c4f341bccced906a9c8c10cb8744a187641504ec38899797539959f936392e72bffb5f442cd8f1e441a92d905429e55d2b9df8cf16b6bba94c48018e85e62f54b7597df9db72d0536b1620bb677863a4b6b40b198603ae7c1b1102d438949306d7d36149886f92a7fd628259a175a45451717557be7e0769f87ce0c751d7987ec103634ad1522779ff585f9bd0d7d201ae8b2c3e5177189a355c014078f7f40e8869cfa94a889e1dcbe31beeca39ca51dc03586521addfb3fba6b915c6a4832aba94b4231229f76b35f7f112da8393e62f348e0f2d9c459be9a9e8e789de5879c4fcb5c0372f204c7849ad4d7667f0557c965e1afb4c4c6fc9ab7405609065cd6db4b398bb44f3187747b7985528971cb2685b002050269affa2487dd2055edff363f8adf369bed91d9dd1b9539140391fe4cab3a7f6cf2aa4499803708607fc1734a132cedb601b2006b19264b0b870e7645ae8033fd8d07514f9b3a6bc36ccc802528e725c8f60a99e600dd27eeebec80c84ca4a0f274a395de0a84911b457db501072783e85563275ccb7ebb52b9c731e342737e8db8f28d15a300e208f38d3eccbac281255017f70d8c3b6375d37d2b18bf2733b9d6ef61cb5f0bb9451811bc705f0dc959fafb74098d7bfac493feefd22226d3163a745890f6a59386272fa3da9f61cdac1a7b90401dc041703b3e3196f57d16a5ad05ae084ba9df0359765865a2f81f46d0ffc6aabf3fc149b6fe0aa9477e162b8e32fa5e4cc05dd46afdf58596a71d689452881c3f9fbd90f7872867d8279057479f1011d9dc62340e779a17333f6f155c8117b192779d106d287fc87745658b8aba55f709023bfab1808f56b1a92aee2c4d8adea2b36e2f8e3c25fbd197508add053e32382c60034320989d408ba8c8b945fa2bfb027eb46a536aefb08b43bee2ac14d17fe2d034f1d10f17874ef31ca05df2d5053ecb73538fb7d09509592dc4c9b7086321a6da0d09d4a2b73c9644df3bc67642751780c112f6e21630edc046dac98011b0348b6f389eebc380c5ba7056582f05832583726049513edb3f0c3c0b54d30d2c4aa099bdfde9addaaa4df0b376dde4d3151d9c6f01c14a0b26dd14376ae119d90c3b8f17e89e6996cabe3a54c1ad9332ddbaca08dab56ae15df96a0e12ee11008fddafd2ef1a2ab2780491b96d84d2ab8a0047d5c2bf680cfda758f9db4d0eb23db07883daca243e3750dd11d02da2d80378401e5f904f84874725cb515a178d092340d43efb991dac1411f224ef17d1b9e335afb2506dea3c38f231244e364d05e771d18d9589fa872724837432be2e2b524647dfe1a777740ffc090661e0d873aa4ec96065238e8daa034642a1e1df5769bbd0b98626fb4ce579e85f385c22e7c935f1d31518f1502d85995f7c35d505f4b5869c596581a04d6681f32d8397cc05a4ff833a07fbd5e4c4e73686cb5454dfaef32853ea2b14f4accbcb18bb0d72e3d844f1dfb82e5f94347c6ff3967bb50161ac36e30eaed9aa83bbac67885f48723ef8f1dc4ff977d826fce1df5fda06cc1057ee2cf1bfdadf3816241db0b6ae3afffa64aafaa09742a081df026aa4b9202531fe5e0dd014c6a1f5c1c3084105af94e6149e6b9301d5b3c034a1f63adfbd01d7e31582c6b91ef156c66b8b85c719035023ebe354b6a7e97897cb9a86bd2d88b43199db8372d16d0526b1e3ac00f853b95ba41b5efd10897f656e97d450180a5f9fcc13c0313692d9fecb3c0f8bae15da42d84692a21b2b754b120a0dca629b93330842f9fae4169f22d95ed99aeb52a774e08538d8f0e0676847299a1652da2b9ee604cfd5727e56418d40ac90ce3355ba026a381df4cb2b16afac33a31878367ac432a1f6c93992f14de493e2d9528b9776cb17d6f553555f76767f9db0cbbd93b9ef57bd2635f0f5ba6c8253fc1124d237d4038981612386e0d53da7a0e418ad21b463b25a87f17f1762f2edd512b47f2d236c872efc09a16fc4983e918fa4fa72e54a79f5ccc8387badbdbf79311e2e4e95d32e3bd234d84675b92cc83e6db62fd190f16bf71821be57baeed01610804b68c8ebb1a8479e45b963198535f63e6212ddf5e0732040d039d0f94059efab939a7d0a5ee9f7177324b66bc79d3b6036ebe8066cc7af44c7bb05e36cd246a97bddb15347813fcc3a8b98a7b1eb2ffadb1470b7d1b3803cacb07218fcb66c8d057b53f090349c48000cbb187d00115e38a08eee40f22f28b2172d613455c011096bdd2948f1f2a355ca2adfeec705d18e98936374a2f448da96bba783905df9f4d901a4a7eb2351c123ab97db1a3242d2b148c83c7cc0150eee5591db3e89c402b8d4cca57c0bd7c03514e1414ca481aef4c1b41bdbbf822357479f57340a810b6074d6d3e8ac23c6577b69b33bfe3a7ffa6d8a686645258765fdf878e2781608fdc291513ae249dd2873782c24b382be7fd8ee38260ae0161c2a1d6d689750fe6dcfe76214f09a349b292ffaaba380fde28e134b5a78730f7a9dab827cbb59df6c6da8e230058df740630c18354306d32fd5d127b9d7a75485a5c3ea21697cc58d254e64b16902f9e066f4f2986e0da24f418679ac4936c9c6cb6fc4073b244b950049d419facd637f6bcc6fdf35fbfc25fbb298427d143567d28e3f35c7e77ddf710a99a84f77c9bd0ba92716d2f8237a196d5394d1a8b3324622b3d6e5a69a1fe4ec0d32c2cd97372d7f8154d098c756032242fa24d9d3c31e6905a48a2ee9ff2394b36abc4463d519ceb4534daac1b3f9e33e4c258b3e763280c5831e76972a3f06e0941823f133e93dc9dc86ed2215d1b957d4713fab8ffdba3f6429e1f79405d8e56becac6442799006cdfd2e5f52ccfe18eca1b2681c455ebce6f2471b250cd19d5131817d8b4f8e9a7bda3bc9a4a9e0f9605454b13804705579fae62e27bc4954f1dd5d6dc0dfdb0b424fa70bc91906897f7418ed3e16b0d92de2ce25d246da8a779b86f9b999639e0bcaf801089afa4c39fa1c599660fa0ed59c0eda10ce0e85b45b7902bf9e69f3f6baca9c06f120cd7538cc14994fba416d7bc19a027d49a09ce1dd0ba3aad51560f7235c185a7cb73a2e49c56f2cc4a610bf7e70a68e6ef52608fde086203ea70ea14e82945b880c64e93d499c4a83cc9d31688d30a1debee2f37b09b6298c78e71ac7ae8427599872ba5747b184aa97f9473668e5411983d8f5c0afb288228fbed3523e85906866fb44e62c8370730923e583c32de0e6c41f5e2267df379fed25f37b07b7f95daf014478d47b125f9b1ea83bb1e856bf30ef9c2a0927e3500c275f5b0561e39ded619c4faca28c91547581561ce54eeb5560807c9bfd6ba5de4fc324c95bf1436b984d48dd5cecb6d311ec8b990a22bfad2b8c5c19b29d08ecb62407d6336c0241881094a0270e7c0ec416acd1ad2118a13e1e19c38d17ef1237e496ba460d8f636cf61d053d455937aed1eb40949684dfd0b94d27541d83afa9d48aec9161c6cddf0ec47cd195ee4cbc7d2374af0989db5cf2a52389a2b5d6240d1389d2fe6c0314d0d9b5cfdacc72c13ab84955682079a77f73263a2769fac58a494f29e7387bf200257c0145089734811b2b1e02f7dde09a233508401f5725906879e385329dd93eb6abc1a3df89f26d00c3794013fc1baf383c5d7d70e114459411ac0e22bd424b0b5db2da7d4c3028aebc6359d7c4ba93fd7ad0b7bfdd76ad2503ce58c04924ccd79b69a2ae81d07cf3740c6b499e327438fd5e1c85c91718c4d5e1c80b16104b7b73409cc1bceed8a71e777bc51c3e3e1f0120c17d53dd064734791339a57f006cd1bd26f694ecb098a89a68c67adedf19f33879499880be307b4632a5c8027739fe2944ad49e2d122c15e5df142191752e03703b6a21027f90b0f7d1cbb3c2ad3d671b5a449307d3d732f9e8ef1d517ee6ff6ae749606410903f415427d8a0fbf44adf802d40be95d6e1d3063d9e82944cd1b5611dab12b7229dcd7ac538fdb14ed4c9bc174e344f197d55e93755deeb22777a57047f08d260e27f46b00d68f9ce92ec407b8f418e91cff1052d97cbe07e9597b2620f9af25846572f9f46782bfa379044052ab3986c701e62d9fc283d7937eab2a1ec23d0325d4d18833f951c70e0daa3e2b7d7fe35b971d5d4ea72b6f10997785c59325e8edb246330fa8ee2305e374fa50c943efd2977258d3e2a82bbdf031cd66c2b7bdbff1abd02e1db3e59732404b276f9339b58f2711764410986cab515ba674209392346be74cc12e248b75fd04a5ca3ad7675b9236c4dd3bf325f616ba9827452e8324dfa5ddd57ea6833336bf2b76aa19d36ddfbad6206307632e9d21c3d62720e0640fef023db5c051088a156a7738f2cbd42e6331f6be074cf9f91e3b15dc0ccb6d5d36a43b8395a1d2339c967cf1bde8b32f9b9b538c51e80581933297381088c9104e91675e1325716bd3f5e695a0a76fd2db4d296f8c738714f9fa28d3724e72dd6ad6f2d298f71553865cc3d33f07270fda9377d1dd1609ca14287d6b029791d0344197c125f929cde73c05ebf28d32af0f10af6e120baf33be6000c47d904bde417ca04ea7cd17c230ec940bc0e1ccd1c81936d902edc09f73975461d937a8a4d71d568611148709598b514d3a8dd107bb11874c01f0e66671c43a6a6bad4cab46ea09122a42fd4dd53c6768a6bc1683daca3964ee76201d240e854efe71e229fdaa1ea2febafda31a2204bdb480a9ee779ab9e701de772d560095224fdb0c59f2ad5ad21c6cca2bc70882f082bc15d33fe905a6629185f6aec668821e273487f86f6e78cbf2d2a24e347cc29847b29da3d50cfbbc52076fcb29154bd413d21ab5b14817bfd4084a39ead92fbb1823f3a6e49e5e36ba51e665987db496f60657107354246eb259bd8994493bf770845678a384207b8a626a04b46b6aafbd31f855a526139c19261dc9baab617c6be48d397fedc53e22d342ee9c9063d7f8045e859687ae95fdb0783d4e8cffa1c0270ae08fadd7014f55a56051e25f54fbb72581c0aa020ca3dd5d86e8773e1e4c1b5c0a069bfdff573b65d1656fdd40719d2dc15b04fe1df9a5e20f62384c1c47f162a24ecc00dc65fe6dc92f49c6e19f45c153ba7ad895db8f233831096e12f8877d0d81c86b119bb75379fb15aef82e5bf362fb2bacb94710ade0e10df647f9bad427e7c0da34a6d9aaced3a8b8c53bb37ebd80128d854d9074139a4af6204c74fc7479be74eda71268e28bf05404e8602660f8ca31bfb66f08eb82aaa444136ba53c00a0da302055c9b77e62587d1099621db1845b9471c1e431ee743f03aa653782cff9d6d953d87fe3edea82791fa15b23ad18afec645519c09fd9e37578517260bde9674770bd3246dd7076bc1d10342fcca843db10f8414fdcc7d1678e698f4c03862b28eb02a6924d03aa34cef2c9cb56ce19298274e8195e8fadb352877ae7ae366e47ee1b517ceb4671da10dfda0478a1851defedf76350627d8252a6208d292acf7f193c5d413e5d63420b1dfe38261dff6d75f2d876d903f6aa6295017213f029b83f64fa05b52eb2d9f20abb714157a1c1c39f133f8c21ca3f0166e48a73e3011c7755841e0992427eb738b95ae4691f38da014dd67702f26c06fdccb43dfdb7d4bc8dbe255afbdb99fe3688382d1bbf06471e8f53a71fdb158fa80a5280bc0ba51d8e57445e52926196285fbd48e6852a52780a7d7fcec667b91048a459e28a84e9cb14709f15f6d0c094e66a9060f19a18b977e9715d8dae981f6d17ba5a5ee93641c17bb0b75c732cd5ef057c204b8274f2704f84885645d46aa0c591915ba0de9f636234bb4e8a517a505cea68c03f466e883f14948377701f824e0c65a9b4813741944be5721091074e9cfac6b48415bba4565099facb05549e78e34fa4ef60cb83d7dc598a2bd35d2897f9c830db084550992","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
