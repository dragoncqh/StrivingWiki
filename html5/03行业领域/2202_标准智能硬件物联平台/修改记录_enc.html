<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b121ee8448d28984eb824b2143c69c22ee8bc9310ea6b509d1d79b7ffc702338f462ae64503464144133c3b060c72cb7bef870080c2493c894fc2015cdd4c137f280999e19a9daecbbf26c94fc35ca8c81d86a722b661d11b3c3455b0c7312bc9374b75b31d557d1f62cc0e569db35e2952a18eedfbd1fdc3f3a3beb9d6bd1431f422d06120ef8a643d9814b117c3a1b9db8e846e89f4a35e03bdf08d4d876ce8dec42b57053c11adfffb7f4dc0490c8552d6d1d197fa9bb58bb2b42a3c624aa38a24343579f8aaca35a6431f1d93bfb4ca838d2c97661b9b22bc9bf9e5d2a149cac899b4483fb0c67c9b406dd122aa46786964e492cfae2e40c0d0aa1d3df2035d6a102e23a9b5208b08301027012657e41b755da308b740e6f71dfb05271789b21547abe7571eb7d88b5f7e9cca9f99db1303a712d057b61fd921499082336c9d0e5f35be54c11e621c6970a042475c7a640e9d152cdfa2c5b6ac4a2b5c8f96b8052a475bc86d47ec20ec2e6e529fc82e6e63ef987c89a514f26159c86c8f5df1d08d1232308fb5821ded21c1262f0af5a32958f0fb819fbc32fe410fa61930947ed3991037629c10de8ea76eeb6765b4213f6e2b250482c2966ed1476e26595f87bb235e7dcb52c0e777c76de8fc775296d1ca5066fe909b3a0a3217f7647d1aeb9b12853bdf0ab706a89b3dac69d445e7a65c05101f1fabb938b7e30b1f832cc63ba81ed471bfa4d8ed853bc88c87396bfe600bf5cf51ebc569d3163adfb3c341566c732d8efa99db70eea0aae5e5d72204a4621a310b06f578f8ab1fd1bf4f7c3a65f9e962f844d6bbf4132908328a65ec046fd9fcf844809b5e09030965c91ad01f498332b0d404d8527ca6c1478ad3e312de474d1e3b5f75e91bff22b8fb0b7d9ded209aa4d1139c3a51eaca04e86273ad974561e83f59ef6a816031ed9f24a244ef278ce0da1b0e54475173ff688621cd1d8e863118c0b4fada1635ae375897eca05f56141f0668b99815bf76dec3ba604cdf0acad60dfb2fbb3af6e08cfdd62660b06ce9c43a8944ee75e13a557c7886ba7ae34da14fd6e7d6995ecaa9c114ebadc1c56436caf3d4eac6e8b1e6b30e47177eca5cd89dfb1a9372d845ebde470f8f6fbc378faddf1def7e874eb1f2965270bcae0a099a46db15606a7046ed38777075efb69c26b86c51e8ac6bb3edc49fe2bfa2f1d6294d63c4f7ad26f3c54222a7d8cb8b641bcdde8eb31fb1120ffa885eb642a13bf13c5b9111e1240f984b6491d709a813798af8d5d2708c6e7696d7260705ed521d5422a9002622e86ce26a6f1d6179fe22a5f355f1e14bc99076a339f90e57a2ca06acf9f9b26a6469d2e3cc8411ceeee69fd41e09697c087b879971fa10d4f2a56eb82c931a7421f29c619b504a1d5aaf88068bd4ebf410335c72c339feedf5dcdd4d22c4f7b6ab44af84043a1de9813f60d0335d0b2f98d2edecd01ee2f08b5a430b5167c43a35fcc14de081e33f456c212f15d780f609c82e0a34ce29eaab7123255e6af86a52844e39be864b4b8023e57f0de61145f9970f79eb8281e21bdb6bc7002b77692f345781219f18269cc67276912bb437e8b740bb2c68a29c301a266eb6520ac309c3f23560dca6dbdd5780e7be1d184a39ad6d907b39fb5f4ebdd3e49a5394536379a811be5c6b4005c0c98319c2a52abcb5aa236cd78749dadea927c4daa6f63e2dca866ca7da090ac4173301daa59db2b26f7b70bb8b0dd2b62b5ab8f603b517d22850fe2cecc0489b10cfbdfd9bb9ddfbe30d4c4f3699de2c17a70337798c537cc6e07cdbe069a79f30396640768953d8a0871b8b515f2813491931537ee7dd12842c1042c27f785709e7dde20fd057e8059130512587c5a200cee41b11d306b4fb2188e3fa973c264bc321effa3613f06dc874a7ad701911a70ef7d7885396a443010eeb8b8eff1c4c6cf7be819448cd9e609ccc27494adb956a485ea3c1f882cf7c9aa0d52900d4593d2a562479b7ddbb467d35436713360d6609caf44e2ea3b44495b7a0814385b9c44141dd2990bd2ffe71be3eb65bd216c76c1635dd76b7559d6cbfaa9b89f4dc999e3725b32e3b2a4e4fd542b253016aa839717f60fb705e6b53e8d3a6e2cdd035cb828026a880b18f7c03b46c0cb232745d1bb755e47b3e4e064d07ac9c717b0fcaff3393769d3003cdd78da468729964edc97f78f79854420f3581e451b7ede9e3c250e5dc3c932e3ebb15f9c0fd6d9e6d5c2213bb586b371710aba8933b5c592f6e7e122c0338b392e01973b167cff341ad52ce6bbc8f0e321bb149c925478d035f640a5040ef72b23c0911390cd4a603147a2ed610ee2ed47fcd49094a22464e1eeb7a8590b60d5e70e60b96260e6281ce576fb6bcae8591fbee2f72aa69fca049aefb4bf394b7ce262fd934faa1952797174f0f099be933da3c9786980684b67a847a4c14c979ea550de955d99c641c9e1e490147547561a3389a2552a26484817c28e9457fe76cd44d0d40a34c50dee1ffba6cf1130c408d58a2e934e0c227bdbc4f511cd1e63a9bd0a22a2afbdbdd2da3ee1ecfaf8bf590c02e3bd2e8df549fbfdef2c1000f36aa749a0f16313c2e7fca4e3a0f0a5d761f06ab75e4e666d8b7dff14b40f64e1edfc7739d5e087f97f11dbac1e047d5d9a4addf8dfb24a46bd54ee8d5ef6d189c33d47b4ad3d111465efd4515dd35a42d5be676b023ff10e58de2cb3e18971dc6ca19c145c606007397ac7e51deec910502de7ab5ad1b0d1e7924b3093562bdb50a5bb16e7a173313e9aadc2bf6141b3c44f03e81a1e09dc86790ae0021f57d8dcdef5bd94067850471dec4c105a0ea1bd961b70ade8fab583bdd751fb4c44c1b709e3408ff22372ff6632d79a227fa4dc1f4e15abeff2f9c936cce1bb6b7331acc3ce10cd21805d66559a91150a489a5ddb8005ef7dc7525f10595cd659108d40d8397f8295a42c1ccdb797fb7a2f2641898f7766875e5dfd20f8608b5b6e0b7a61fe1f270be8831ccb485843b4ad95fe045a96bfaa3c21f000fa33493861535b1c2ff429b83482b9aea669c64f72d905025c20038db190162685e0981460a2547eddcf7e37c16d524434ae37fb6101a84dd19067946e749ba493bd4f993bbc2e306f86e05ff0e052880dcb4509ceae37125d43ba98a79af0571c9573cac5957b8a1a3260e8ad9a8340b7da2c69aa73305aef03bc8e2f233bf43c46a57c1647292c7aad8de1551244ee8a771978db26f4a83bc3507435ef287ff1f8151af0872535671a9a75b48bd7e01a7fb8f1683181eb3662f416d8b49e1193e9f90c714581aade1d1193fbcb88bcd994bf00f37ba37cf9304e681b777282343ca687866050f7a8a6f79ee4b410facc13111b62f9cbb63a7aaa0c34409734af18c4abe09d987b21d054e34331e7002580714ea64b22b280392a1235d93d40e0dc4860b8feabb8437123d148529e65269e6f28ba00fdaaa8903792606377d8b510bf36ae42d3b75709918b7f52cbc10cd8562c46e268b7c4d474644106b284698242bae489269196f56d2ea0735d249b08d983b666ed551aaeac768fc9a17b2d122547dab09d0bc830c9b7db41b45aa564d5ad443a3bebb2935d5edaa7e7ad8bfe61689cfd63d0a4a2c499ad10f2b70fc153e9aef059a4af8ef5d52fe6befae719db5b8ccf600c9054765326389bf6e9d254bd51a3f486f2f30eb43b50739a66bc1f0c571819fa61f24b957469cc419f72138fd378dc6398c631179d6bc8771d0b6342e94d1a0caf883e39291bbddd63453e89da1c90a74e41f7e908179eb6de647355329192d12eaf34b092384fbc131460b3e4790e9a8251982efaf6e5f371f0ec74aa1fee4ae9cd99641220370e00d0f983cc94d1d68b11ff33b27eb7445b516d7e2f155383c1c50a2375b81cdfb29fd6bbfffc74f1f75bb3657de694d10e2155262e5375365f7617b0238f43528fbc009696211158cd24d0301893303a0960445b59785e81a1ca331b77e5bb0b82d80cecac2a62eee8593239fee34628bd6a4bf1d645396def307d0718b656ac7b5b023606aef85d8f2e867f03a326731f1abbc613ddf2322e516ae4ff9aba908b9a80b3fc406a7fef5a4b353972d6ca5c14b70f2014b9cde2e86e79b85e2602ef9781889fd1135c8755485008b0dd94133372c8898e56d74dfbd0c4826bf45ca3518591078e64a831916e2465056ab32d3cf8b4c46e6a48678a866617a8a8598c2f78afc8dcdd8f7a90267513eac9e68b2cd2d5189931f8c8162204c6daafd079c95efd3ebf6744061bff4e40337a48fd6675435258a4fab6bab6553b8487320309893d22f173d194df0216a43256abb46a9e175c54041d5c4db9f9c77e38a78c1a706fa2f094094b4ba088b14141fd049fa023d96f7fe201c497c78c30581915f018b3ae246a339eab5a0dd3b99400c692098032aa3fa0151c564b06b7e594b289fad048f6f30681569d710c5b0fe389ae2bae9f3cf09e588f26afd5c3092fbe864b03bce7115f9c70438b97a4829024c0058c47ee575b7ae7131fa6a761943c82f3ef2c82b6cb77827e8f7349446ba8c9f58f89d90c6a60a682946b418a71ef649a17d5bb29cb49bedc9ce66425e5f6078e63224bcc08adcf8e87dc5d25bafe641eefd8cabd47aac4b21fdf0c10e492ea2d4f6372c1962d79573132a7716ca1f53758afb9f7216cfa339704b50d951c83df94b47329112f002de04a4d63ccdd56b99845781c87efd060a78bfb20097b8372fe9459356b51b014d68e7db1974251490934480f3a8806bb840459d059ebec7a78ea9a1d37966d634e3258d08c504ebb1e4593a7c0d748af4d5fb21b70d8cf953c28caa9c12b08604a842f62beb1a1a7fb7a5bc1792c5d8362c7e6c23e8eeb619d8d7d7cdf76173cfd45760d7cee851a0497205150ff530f8c445a121c15ee6cdb1c008e9fe7c7d82a13933747e04d01297c5f02dd6734e14b77873edf359af157a26b5796ac60a3f258e960517ef5d7bbaa5694e2d931000051323f025924a879604e569c6fb437e9443a569199808aa88193042b45f54c55ee2e066cd5a6c7176f8b4078fd5103e248c879dd1acb3b4b41240de1b0bd7697021d2040e65d1147a2f3daa544aaad5a2ce296dbfd5fb7bd8afff8e00389bcfde93dc077eca780a4cfc98fbae37d5f07df5775b200bbe94ad11d60f1905701395058b63ba1d61b87c66b5c09b15b64f166e13d2f02e29622860603c5d6c05c2d4d1182ce7e9ff49894438dcd8bf68cb6ac76da1dd5c9b131c40ec1393d91c80f2ce198b69e3ab3947ed65edb835da3fdd551440d3d35ab3b353c75b38eeeb458bc3788fbd1871b45f9dd392ef3e78a21f27fd56a8282ee418f355ff59fd18cd49112a2e53ea2305796fdbf410263a79498971fe7a14e31000531af4382db282a51450bf65f6e5737469e5a0b1b02ae1f08983f1afb904ebdf31dbab82e1275751c7fdcc4974897adca4cd88bff3096ca21bff370db0cc0d1df24c295d5569057a782b7b602d8deee9fedad9b2a0c2816e8c83565b27108bcd9fc6e27182f7696d4c831abe79df4643363fbaaeb025add01e54e2a29c1e59c84a2fe01a05ca5c1b0ef60a8a616b0bb6bb9e619a4744180d09638575c3e1b5bc82feb84bed2511244be1c054b0ea4465691841b187dd7a0a922a9ce4088061af101be7faf95d63f222b2fec08e574863f92aebc0b173ba45f7620976aebe4a6a177445add4f58f4f0e67a42e2d7ddc033a5a32cda839cb2740b1c0cc0a9548eddf590d4c8773d3e8f700a5598df68df5c0989ef9c8ae634621d361a87799bc9ce3c2b8126a95b1555e4c6b3a73cb6c9710183b5388dc342718fb914d81fc8e5a1b50515085a17c4c39a114e5c15ed9e2fa52edc02d6f3236ef94017699ee9f7c3d02882911fbd4bb0ee3b4f3253200e650bfad1f78219ab7b1705b16d2df544cfeadece22f48a78b28201bd38d2e976a318c972a2e556a9cef2bc2e84c6dbf930e0c9a9de6fd23a4a655d0a981f2d070eacdec587d75bc28f282f71141a08fd236eb3e044dd49884a512783e8e14e884563dfb5619fd6c5b53ae3c0a0d0241863cbe02f14f9484812b7c4e08481d2d7bc6d7cecd0eeae272090ce23281bf46c7ca098dac750054a777551c8f729b6093c5d1930a7416f1ee3fe41e1de6a9a6d6d693f7850d24856a7043f953115caa2a2dcfaff094fd84deaca02779bb351f358b4913473c2086200a66ab69072c4a37eb0e217941c2bd9f0f0ac2fc9d6c2b74ab9d3fe84faa4c6bc3f92fb4089355ff35758a8a437e9c6f0095b665ea72720816889aa2627826b6b7269b6a8315992fd5fe4d3bb0fbb9b3c2500f7eb80f78c0738b4db184ee4373bec99eda869e5c9e7b3a26d16d30637b16524420486e82052ecac7560b08704ebdfac846ee2539db1e546137ec1141cb839d61c9c97889a6f1a853bc9c794c51d62dba95e7ec6ffdad4baca87f328c488a27c045f541f857c9499341c0b44fb822bce39ecf4294f5af67f23dda35b5c6a18135c02e701c405a965b878d3d41b6ad9126d90f9236ee023522689c623f2d59433506e05945076bcce1cd4ba654d14dec759e7e7d68808a0cef8af7f956cdbfceb471b3bc9e8990d17d94530ee4cb44589fe39829ad691925e1c9ac281d6e61f195c63ebb2709dfd5a654d6394d9710a70cf0a472b284bd2bdb2f42c42dfbc27b9de304f02cf7d9852fc71123104a270507e793be37d8179a4b9347d1a9477525ce477aa84fb72e908c73f800c34935cd78c2a272a9803f6fe0b878311b388ac9da759884ce398dbab0c723710f623da815bc5606f53bc85130d5b47b1af823f18c5205602063a36b90cb4db6b28ee9579c2eba2610bc1f3bcbe024475470bdd1a9bcc47f79ff62e07de30d180018ab35db9c2d5e5b617f6e4546b4179a741f5c3709ff6dcc14dcbefe0cfbb70678366a06950f35d6e9ed2f0b07a0c3ea0057785d90b2300e506dce78b09db5a0c4e0a0fd27ef19c5cb102041615f5c9f87940d7bf27","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
