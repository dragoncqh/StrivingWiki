<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1b7f03aa8e21dc98afd69553d11ffdac4b088e34fe65d26a4b7f6f08dcfe7bf767c67df41ff38f4421f4e897c617161dd5d0b3719fa76c5f98676696d781232e5c086982bca00d17228dd742a000d00b89510c60e15955782621e3ae92cc9e899627463e6471b594f85590ea1ce443fa8414f7352e6bdbb05ba6c5668de9b154ecc95b8abe27b2e08979fda0f37fe7273f1cb885a95b938ad910990463adaecf0acac60b99fb0de2421ca71f6aa4558875aa683b33478bf5d1fd56c1e3e7fc7aa204316fde16d534b666cd417d5563e0e8fa2d764850cbc1397d933b3b57c981d35c72c6301170c8b72c0070108b65d6d7419e088b992e77950a46bbcdcc6d80e0aeba267953a12d541a385c7f9310254923264c1b21e9202721f51dad4bdfed9446472b15eb049c47e4b73036b62558bb50802f7ece071d379c034a0f9333317354907eca4a974cfacaf4fd8c7eddb96b00d13823f5c3b85c4014ec8d28cb735520ccac52f3f1badaea6278f1e9d1513466f5245d4ceede54ad1c3bc955a6ef8bcfd4495bb6e64ad7bb4d728053f26d4318cc99345187d9e8e9e599438545d5ab02e84ae795ae16c69eb48ddddbf1b3efb95f5af7cd7439ba40d28a4438d8a4a448702b88c4b71e1701bc66fce5d5f185b470cff9a1e8dd2c802b0e7b045292ab5e009ba1f68116be30d289cd5f9cd8e17d55176ddb60b80c964bf61aee45bb8fabdb9e7941c2350d84ddae806658210ec9153d89fca34105868b5e05702c510bb4881c4e1b280d6d304ab11ee1089b9f1ad5818b650980b89725541f2ed4f45fb03812bd971d80828b73d634972fcc39f2ddecba88427f4e3fdc7f2638d3c94db1e04e817fe640317b9fd513cd09250f62d8911831cebbebf31de489c9b3f215264dd6a5e0d85e7933bd5addf1add71f7592a4ae085700eaf14c4d948648a8171f453980b4139daf8b4aa7af23bd1acb2ff16fe9fd2cc9cf5ebad2c4b24be541543bacb5884a6558c2ece09bcd5f3b8b7273d8a03963b3adf0f48eea86dd01c59f4965fa7bdd848639add512170f8b4df022653a66e646da660a6dffacd61e9b8eb5a1bdef252fb25bfbd377a96a36633e64c52a99e13a24255c47add9b88e1132e1881fb65be71bbf782d1dc1edccbee75cf417735d015924dd805a2254c042fcc0612e37f2ca777b95f2da21837ad74883ede8448c9b8260ae7113331aee1dff3743a31d57f308bea202ef5b12cbd8d188602d89db94039c221e58dd40680b1c1c965f0e5cbde5f4359a0de2cb4f9c5acab4dab251e6adb4aeca981e3bd4a7d33f067bcfd7dc9501949db046ba23f6c2dd6ef7be7071c7a2fc7eb7a750ca9ddb4b868437a0679e89a6df1d92461ef0ee4b1007982dd3d01c235a8f29fb1032d51a8a51851e7e76620301be9577db36a740a9a23a1d7b52303aad1ec912d163fa0031370ea53174fc6cf729ab27fead587d6a1135b0a7432e2b2fe7f1d2916982cd7d7f09126f702ce8600076002d4c06bc865dd344ec8dfd238e3ed6fe0e9996be619eeb657e71398b4939be8d1f1532fce7b4cb487f1e3008edafcad5b73cfebaea94914e9e78eca545adf44a4acdc5dd0a5555e3906c7dee8971c01532c7ca93634997b529b4b08e69a8df9807f746c50a955db003faa0f6abff9c2a7098e8073159d54dadd69facd94f759a80fa437f3f1383396dc7696863af88302d9657aeb482c83f92b8b58f6f4288381bb1be64d3fef403d11a2ed58fa76b3d49f728a32298beef1399aa43dde7f1537fdd6c0dad63a5493cbb99af6ddf72d13331467e1cadb79fb5226379721cc5e7f67ba3c0046f458a56f1102d1dee860dc229a459a7dc2631aeea851dc66e8fb2b66ba8407ef8d9a054c8ba4f708769d035347559dbd21302426142d2455cdeb5cd9ce4e8c004fac6dc3c930352f96c2132a142e440a7d5fa6f8bf59f9cd733df72282b0f4a4cc02ae39d5db06facea2e9696370b44fb762a4907c1c2e1bec520691a6d8e5c371db358f1089b918500084373410807321144f481560c3c3a8e45215b1311189257812d2ac9e327250e066aa4a7435b7c1fc978c1fef0bc249b3e1dce79de4d5ba1cc3752a0de160a16f81502e91d58dbd69ddd068ba4c37d1220705dd002b6c8380c7b677d288a2b051b33f198d9a33fd797a6dea5faba336583c36a2c9264a9eb67d85177f97acdcdd7fb1181c02e0cf25784d831fc196b45b28cbbd87fe0d6bdba30a0c3ac11b032cdf8dbf4be44dc8b5fae44b3bfc3b7e6210744dcd2d820306e163355312918001f94d1a47d2beee68ce512cac4b1023ae22824aa11eaccc3d028619af9e7542b6e61b3ca38e6d56440cbee3789e8a4a3ea19583b2375f7dd25ca7a3e03f009d9bb1b3677f513f3b9a329d096eae09c324685cdeae17256b0d7003d2953ecdfe66a76395b980c6570c3b25571099fccd93d7c40d5fad94ef945529bb36d894602f8d6b8a6811b4f2dfad0a26c8e5a30cc59935c33fdaaa962ba965020f73d16b02082571a6e6b26d8da3f608689e3a5ae19dabd102cb95554f3508120fd97a3274181738316e6fca13f946426b51ef3231b053521ecfaa99993072431ab010a644532157d90e5289411a984a1f9f95b19c732072e374f7b03e9e863117dfdff03dc57ff654e32486a5bd42470ef1df5a005c007c5275317cfbaae1f5c571995c20f544d5604dba70a03cce3b111392869ff5a7463dc73845a4291fac8344cb5ccecb2a6804c9fb35da905cad44790898c8e89a8fd96ab7a888b8f3f0fa83a40231e30605eed5e05888638a67eb807f3c8cd59150e174d490448daa98498eaef1fc059a2bded0a6c015f1e747c4371ecc5b6d0954039d97887a0bc21a50787470e602e57e84d9fac141eca5f86f2b4c99e0a5f6e5ff54d8c9a420bbe03f40a02b302e15f75cdbbc3083a1eb130558a359ac3c51d357677e3ebeb8558d4b989d72407b1a3b5daf54ab5b34182e764679e6da4d4ccb9f3248ad5a7a6733d06763abc202369c8827885e06a95cb30f601597c28338c24a25886e21a4cc6c38144902be493a00b86b324c834c6343252637aadef7d45b594fd6818cca206c1e5c5586672a1174a1f112a61b159f89a9796d56ad5e3bf55f252f395723c2310ebbf47b2796e024094e9fc571e29614309750976b6e4b570c1efe09ba3e676a7aec924b54165c3a14cc36c4160323ee363731be2006f9130d431add813545f6e12d1fe57b36af1a52cf4ee9eae9ff6c9def5720b5a51c6f48922a6fc35754d9fcb9541d9b624481b2c81e6a7e52f8e62cb1a47fab4f3b8bfd26ab1d29ef6a5d582b70a91bc6271a5f4b93aa7ff610984f346bef259b52e003fce16911a8f04b784f8e8ded2dc5866f7065dd3415589506f1864bdc00d10f6c95a23cb2ad0211ee717f80bdab9517309c2503599d0fce583a49f6430dbbf9b1ffcdc0a7da886b63000c85e90d741d2dd1e15bdaed97192213640a3a31d90859c53627065d041584de01a91e8e4875fa7d0d310cb5f2a79066a46d955acba7f77a9db2ce002b1e6bb73e0a5d96c9be59a5afeb368cf736459e1bb56d8949b416b1aed32a7b1ec4209f39c07130f73c654a879365371e3fac264ff9d0e685e990727f742d274cf6afe0366eaae363c6976b711990392827c2862559152cb5bb6d11673240b8821fdd37601f739a194b0a95a208f49acc34d13e05929bfd9a847d4bf4f9f50b3a3d44b86c94dcfa04503f4b3efd07ed7bcf45b1da3973f51474bccf7d099f0b8defac73bffdad8aa26c33f0e6c83e417dded321742353bfd0c4a86394268931d382b6670eef6efde2f4dbbf84e59689a9308d97458c0396114cac05c0709286ab662c511bf10b5376b8c0039f52247d076e72068afb3d0a5bf48480c1868f38840f66565f76da2a13b708c7b9e1e779ae6162abffb48d7d01ea8f2532de7545d54e74ca0211ba804d064304db762a7a88ad58d16b545a076e64032e36862255ac50b580e94f7cd36cbe44601843a1d49ab3f6d38ffe9f458d11cebc140a379f976337349efa4c56e3573d8dbc93a3f3f87dcd627baa339a6686b6f9670c4789b6ef83121e462773e6425854cb8349779fa04cfe7c46646bf70c445d237bf9fe7355887e00a21c82dae0834fdee2cb614d28f245645e8ff7542eddd95ce2a1c2146160590fbe4d6bf11093b4f9747cd9d98ec7a09ec90eee3f2ac10985771b897af9c478cb0473566903b0d1add03487e3ac945903ef89fd6159a229ba432cc5261974b8c4f511bac8da721a37ef8163b3956bf160e8dc022b960dc43cb478d621bc0586ef9e565d288776b49692cbc369aa163d2337b9175805e496b672c8e5d662b11151ab9e83ac7a7c294d6f36f3f25598ca803646930965b320d1c69d0486723d1de47e832ecf977ab7e5a7ef60a193817bb447705ffca3ea9e78ac27b55d1824a89440a9cacabcae35dd607fd194d8b9ee1cfb9198fb4154b9df62c45ff88bdd3cbd4e256187850b6ed616928b373454600fc164ae843f1713ffa4bd4341ad8e9b0cb4ac1bdd269a5197ef0544eb2e43d5f79b00a77d53bdb47ef14d9c8faed40bae660ff62e28c1273e104cdbfe2d9ac7c42629d84fcdef84a1fffdc3f5fe15bf4b1501016d721dfd2c54f858249cd9ac7212a2fb47ee101fabc3cc6d19eecd656b1368b8f38a0954a855a41987ff7c867160ce66bf417541e3092d3fefe4bd1b95639fa23b5a81e10e576b29a61de7a3d1035512769f569b82f5e25070a30b29a3917e181d2cfb47220c93230bbb4d03b00d88d2710e3620c4f7d77c8c087560ff1d63265313e03257de892cdd1b0bcd7f5eaaaf3c7be4eb28cf0f0b5fce45c8da3c58c7cf9d61a9794b010096da777d5d0df76e20cc4b4e79a24ad78702ebb7c70c6de956ea01df0b02c2b7785ea60899245904d110d3021a806667ef1fae08f7e993bd31903f098117cdf8ce5e3518ca667833156bd64673f2745ae40ef236a1a9c19fa72077a61dceea8db463001b4d65bb0c4d7520d02d8d0d302a37c8c32f85bf8d0b44d66ba423cda6efc9f53f76c41324d552d07b419885fd1b28870cf00f6737f89c7a431c9e5c046eaadd59a16923b374a13379e8d752fa5bf7dcffda107cbf9dd581a86521061a1429d37ea1310efb248bd91843fa55c3a35002e91613fe4687e2b650fcfeb2134ce59b4dfec1a915519c8bcdf3c533e8d983756a3751c191c00d9bbe2f751a4d10365215a1ecfe890fa0b9cb149e284fbf348f18bb12219e1a8c3f1b6bf32ba63f4a2f682d99489e15d2ae4a4b7175d89d4fa4837033153fc1be8aed197c9b8dd39b0f12f5375a108bd078511d18cb337191a9f9b6299e8c521d1fae7b90e5a7b30eece42d5812dbeeb492007dd579fb1fe548a4433c6dd5bb236f63223dc6d41df650ce600431c713af25cf28fa600a03d7d5cb93f0892415dae7f150b81b4d642c1b5de5ea43dbb69867668f512c9d4245fa86f95a0630d2855af51823f9c0cafcec9db8188337e067ed098182070fd00d7d5a0e7ed4f7c6c2cd8c4f313d6e9efaeba2a1621d31ef2ecb204bbd11d547eb5e8f108e32887e3c243d5aea0434e845398c0e89acd8fecf09cd0df14968a2eb0b7f3d4c8c01bcd7fec0e1195cb4edc29703603b5056857289d6a7ed0384b187464a062747aef34b03aa897515f08cb900cdbf1779e9522dabbc1b1945538a9918a0fc1e92b0c7c89eccc54299eebd80fddd2091e607a7002b7f7a7ca2aa3b122ecbea333fa7fad8f3103e2b76bd62f3c9c0c4e58f16790469566dede8ba23a1c0fe2cfeea65c4bebb9fc987c7c4007f7a0ddab60849af4c3b1838e5620e2118419e2c64a8a880bafb99b14bfd31001f7db3ce6f0bfb761c1f1a939d097bc0e6a38faf9e195dc9f555a35f08434665bc79d6f7bc82529759c113b7aa9395e65488493854a606e3e520548e77db4f9768e27abed415a59857bd5f67fc7dd28eb2b3d0f241aaaf84fea9f47ec1318b499d00f25d26fafeb74a5cc4ed4903cb2189d8ec30c504cb7c661fb5b24a0291ccfb9338eb503649962add1b4ee97c5498142e678691c527f00db457e0d480c6cd2092115649b870c87cd8eea5231574a1877e0902c83545bddb99be78785ae5bbd6c945d23510d0b07ea2c376a3f46786f2507eed5f5b863dba5ff6ba79250b6f2501118267169614bba44fbb008dbdaa114786d01f33f8d05b6f4fdf18b150502b7dd67e15883c8e3245b968f21f018065a412a1faa4ffc0b5fa1915b013ce81938ec27ed77df9efe7e1ec999cd87d2b580f32f37101bb2b67656b6c94e9c8aadd2ce70debe13176f97f5cd48cc146ed1a8877679771104ca5a39d010f0ce3ad0828710fb3348bfab87d13130680cc6992ec01658be88daa854abf61a0cbc9b174c673e51f4c65788325841b7307f250499dc99e5af80b7c0c02b15eb347002ba7a3a139c1c48ae3c8bea27a86a89fb66cf30f3d91177b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
