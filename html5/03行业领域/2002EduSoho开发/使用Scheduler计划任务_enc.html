<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e07f75cdd0e9982060c2ffea9c1565e195b1a28ea6a5d1719c0a634f1599fbb343e923bca208684dbdc5a2025812620c39dd20741b4cb0ddf977c9f7f6336aa9477d5456cd440e75b88bec713a76508a709d08ae77b5db6f638352f25f2cfdb30bff3947e3a12ed0d77cc13a4eb354e2b52300e6b3c296e7149c58013b13e6093450362e8389d2eab883a17963496edde826b780b26e6abf8971c40330b7b7fff28dc2ebcdd7e966e754125b51d6d2d72e8dcb93b992341c2bfde261a70c21f31a457ccb756c0a092a576dad4b3a24a6fc07e02e3b79b065ffcc3cbbd6d0b90739eb73c2fc05e763611fe79281c38abe473967ec9d2c140861a7651cfae382e084d6ca78d04f3df0fc0d7f12b4c85d3ad45c578410f95a73389d9cd1f268403361b0777e1f13e947d7a45e3afd1c3866ee7b0fb004eb6a68035f308ce2519190a8cf303083dad7a2ae320bd50611ee1a2850a9e6eb1f95d42397f5d2f64f6e0f08fb749c94c3daa0b130a603e390b3cec1409ff063ef579906873d7ba84df0fc48f088a0055af263fdf3d9e71874ad38b8409923ca1cbc274c4c6180613774b33c5eea8f266cde4f4ce8c610feb332ccbe00aed114891996950e02775d1f9e01b3b0bc7de49c10b31c9861b7417dd6592721acd93c24e445a8a279c43d55c03595b4e524a2c69f312e83be48b79ee17391f0aab02f75600c0f62df53b1aba8eba87069cbac950e64813e4fa1a5dd95933074faa23366dd88758659d9b138d96348d4e8d8b3926ec331f170169eb7705b1c979f6f3724b67a57e388bb0de1064cb9e0f916412fe6a58d49f3552bd9c0ad712c97e5fdb1d69dcc5de3dcc251406b7ba846f44270b32ec926b2476e94eba11c86eb31cb0db286b3a1381e2d67f2f08db54813dddd6835afbb07d53d570bf18a0f772ef8a2d5ae4d7dce209d72083111c727fc973a14f23fe41ba8a2f28c2a9fccea4d2855b91588529faafe157b9b2b2bb4f8492b92e901c9a6507ea7ab40613e87ecc39ea97ff1eaa2f218c4e964e287683a840936950c298105857aa98ba5c62028a57eca8d8c24a72ebcf9ae3c1084a5c6f2280f72a6eb1fa6406c766bbe6a5144a4c2110517eb280aab206a9f8d943b5fc03fd2ea537672f95707b75b881765b37cbf65353c975438920be5f5de63a6a71621b9a0944de198643c911832bb80b2d8d679e0119f0981e44a3ac64a0b26b0d30708fd23be57191671cc7fb7ca013a574e57ed15e43c6389cab009442c15a014a445aab7bb32ef739be435b939509741a0c3a2fbd83e9bbc69deb154cd22023ba8b9eae0c805adf9fd69e5d7dbee2e52ee8abfe55f21ffbc40398055190fe61fec1fb22b2a81abeeaad8560b114af81a16ae604bbb8fe37d01db2a4c7f3d48462e77800af70c274d29aabba1126a6a6d34f29da656dd68b78a3a2e4989872cf1ce39de79867aa7beef226693eda3b41e4bf7a9954fd835c3ea422ede41cd04cb76d3aefa0a84ce284d7357a194c75b041415c2b6b3cfd9894aa75dee283681c11c2fe3256472dd1a5045c6d8340c22ce18a70100fbac04d2ecab55b9a02246681a5925c2d0ef3dacf21b87b1b446f7d02eecf010570112786de0f750c1978478963267681d2da818b0a483ac23ef8f7719dc8378d0661fa93583f6a4312e9abab7c870a75ee9180270682e3b0160802a8952c8a54c6dbcec3a9246248d2a730e595c172d29d19d64c87699fbe7ae8a2512a850604dda98dfa788eb9c6e04bf4399909ead6e9e55348d2525123a79b6d9f130ade9ca035f0df4d3be25ad54df3d22b28181003c8d273136987cb96e15f6e8905335dfa946b76187f56ef77c2a291e30783ff6a78925a743a0f48287f2fa8a79f878b6589232824cf0237a5c49e2d158cfaf04c41cb145981b5a8d694599750576af4cb70417f5bbc11c419546478f23020307485b481afa084c04bc56cece8d0ca389cd02c2d0164e28be52159c1519f5dde5bcf8eb370a63fa8d18e1468ab6f4272476480a8539126fd621b6f1767daf8c4d122339d9d3d80941c4819ac372bf8eb836a07cd43874a9aafa0e6c209eb192c4cfae7a6462a7592ab81a1ac4061a616813846c065fe71f6254c066ab621753b31caadaba4cc17a568b9c870d570c913fab168ff3457574eca782de94738a8675a8f141da1e66b8cb0d42bfafef922b2b53fd44748523b3bd55d1d8b64c5409e9fbcc9abf16061b261fec798afa3c8ec62fbe1797039f798791f0e9c409b90604197f8fd04625450ea6ce8a36876f2dd7714b5bd9d407a4142d5979d3ec4d095317e2c0d81df0626ca792f6f994d59363d33f237e6eaf1776f8308a7748651c037b85f2ed55f4af4ba53e274b52b3501a63d91d91cdba21a308a4cb57ac9f2757b3b34320908195d1b3e4bb6891d60900a6767bb917db15fa85aeab29323ef69ce3b1ca22a9d4e39cef17434addd68ec3d446420631fba6a87350429afccddaca840a40f1afd45f242124eff42403256c13f48a9fc1a8a10f8feebf6c6c21a8873bd587ba2bbe10081149b1f8dd4890175a9b185377767efaea29e696884eaa94c656fc92e989cda9f771d8480c9ff91c755866b095bde1863286859ecc0abb5ab86eff6a4382bffeb7c5772a74dab1e6b2f21ea832bd56993164eccd7010c5d41842320f4c805cca4f6a616bd313ab6d312b8994074bb8c4034580787c12ef6716d0dc0957410134b34e9ffca4e34abea2182100770f0d5bbecea3d94faf02e408e0c1e82ee745d80e692c257528eb2e4c1b78bddec98f12ea227982a0a4304b80b670326f2380161d1d9129cb7a56a1fef560510241a914633d35c872a519afc8cd01d901ef7e82b2c0a6a498f503b02cd4d7533dafdfceee4895970fd5100eed730fe7ad4b37970104cbacb4f867e2db81e95910b3b8da35cbd771ec22bc55fba015b7fe36173b1f445f78b39250e375df1bf46f94f6ac6abce24277a35bfdefa8669dcb3108907f3bfe9bce8d6f3ef83a32065c5a7afc0bdfe261d73c5209b4429ab19eebf1b804f53585b69e8e9ab8b150d0bda3bde5171d2e7c5d9fa5738701029c3588dabe7bf694a22d649c3382f960b3dc1f4390158fab7295a40002390131e11878b5b299604308abce3e7780c743ab29a883eaf517e6361aec5369d4e541de7a37854f6073ef4a49facce661aecc02af5dce196301e7437af6c1c5432dd8553c1e8b1cb8836e369dbb279ef85b145e9520ecc2fd42e2ebb7168778ece163aa8d5859bf918e0864bde5803106a53da5da3f57beb7a5ecd86023f1f2a31eb247e07bcf16d42fb00645a5cbf98faeb1cd366d51bb06f68ba975b7b6ae5d5187f1f16a76a3f3a1b6ffac141aa25f871ca9eed25cdc643b00915197cc71f23aa397dd0f20d9bef682d365179c158ed84c9dfa0240fca03114bdb3c40f74afb78d1c3e36b99c2071dad22fc5deb03f9c18b52670bf3fa1805a190b15128fce77477a5f2d67c2e0be8c8817fb204d5685b83e67ac12c60507929bd169186f2176d3ccf3488a404f63297b05aca3e19c8d7c04440c9163de3e62f9eea0e2335333ba7acc49eaabfbfb7db2b6b58415d2a15716049799b576c16ef2f4982a8caea94e71c68b88e4ff50b9fcb43bb819d16efd0357ddda70a5b7985319769316bab7097dca498d1d4afde662265bef41845f11734821ab36c5d08220dc29b20b8717cb7885adffd6be8a4b4a53a7295994aaca492f21c510334af2b3eea34f46549610e9341851c19d1016053a79e449dcd4e6a0ad584b8eec7fcd9e0774e9b737a673092dee83b7c2d0c294684874501f1a1f76dfcaf160a9a9bccf96b9cd95bdae6bb900221204ab7bd742ccd754cb5f72b5785399c241fb3f01693956cada7f7fdab245a691e2b6a9a488cc0679e18d4596ae486cc51025cd285114a41f0d4739e4ee4c0bc28e0435583d5f0f7cc19658551c51fd0c1eda6ebcdfa903cf762713b9aa808fce3ab34cb545dc62ea4968b2f2b513651f0a717fd8d31a76d0ba9f5a5be595134eb1e27cd0af59362688f11b73d6e3bffff5b82e5f617e83d2d0056f6d12b03af892e8a851fbdbdfbec7edc63eaa9e9b2aa5f9db0ee574d2a45a932ee4e833e9406439ac7a5cbc11b11efafad7216ff9bbe361d3dce61e97da18be64b96b521986705a47bda579cd70bdcbd52bca4c725b69b77a0828dcc27028612c725e2ab18bce907ed2d0c587ad9ecccd223bcc37daea79c6b78fae0c7722652d342d186bb033a999063d862ec1054f45589eb1f8acebd3b0052a7e9d8f289037004aeb8e905ca74d8659840e5e50279714608b99a03dc769f6ed00aca097c7deacee32f5578b7fab8320a8655f5a9ffad0b50fb55a6ca515a61410d51a8a8793898d1fb07e0d1a110d15bb789e2ecdf3bdb5124e18669730cfc89394b49825a09161711572fd1c1bdc4df61be938b2cd2a078e49d847d990c30254c8f0e36046cf0de67e6486c8988048f744150c4bd86d573dc68869dc05bb64c3fc258b4acfbb072d6b9e3218fbca6126e1d9018298f84dc281446ff304a82347c4a4287675116c814504b4648c9be09582a563d816df0efa24694da74697ee26332e0c78f3fba1fecc62418a81535092c54f3009184b5a2a7ba29b8f37e2655739d59e6fa8f4e8aa2c986a5489950e0039bd8a7933b9864d80644ad5bac8844b94fbd8cf2752fe9989cc1a6bd3a9a9d9c0d326b8d1ddf938869e8bdc16f3606c4bfed526f7cde270ae57d7dbc205076f294abbe2145e98c0f45cf4f82f5fbb227f29f50c1cbacfef7ef34a8b3cd012c2370332e7217f22042b3ef6a1a0761a2ccbfecedffecc5d9c5dec261812376910338a72210fb8b4185fce5fb176550c5f80072c6f8d30bd1d018ae85f742e60fb323a916929c32c2b4a728248843390e00f920deeac5f81aa1b93db7838e6d3661c0a4ce8857d236d6b6bb7c9e86096dda2d313844930c39fdd321e73a8952c5e7edbe163aa3d4373454c29ef7dae67c1ee76cd1a0ffb8c27611b53facc2ceeb381d42abe5346b47cc9b15e8c86b9779b836dfca80efbb726c7ca86d679d7e76600e31bb73ecb638d9c27c447e44868981c7800494f9f2558a86553256783aa3b4bdbe0e134329d34e254e930ae5371c3775d3cb9604d8697de824ab39c7bb71e97b895ca1f40ba9c064f4ddd58a51891a2ac0c4e500083427b4af8253e7afcb14b35e57d09676450cd0bdb0d10ce2a232d772329eceb382db08fe7a94e91680b7e03cbe075b154edc348107db8876fb54d7243372e2d522372c7f6b6c243d16bff78fe513f9cbb3eec8825d83053ebf1a29f43d47782177c6f2e4afe7debafed56b278708b92e341da8e371f10a66b99f9a760d6768a2ed2af4e94f443d44c37f9fb397aea2474a7de72af6b8a8adb6a118fea4523d8acc9656a6afdad7d8e1cc5b9399af7357c6b59af2220a806574db3a4e6075f612ac837852719d520b3c92da2923fbdd9bb3ad4ff004e6238361681d82fd0cd4c1d68a88cf5a9ba10281240ec792528799b76ad097a8f3100786592343232d153ecd4dd9c5f4100074ecf35ee81ecfccf2767fe9f06ec235f3adc5c8dce8a3e08afe2a7240e401202f92801c623062f1520aaaab2e58ec094fde09b71ff3e2bc13f50af88d0cd8e0a78b7bad76e0ffe4ad20a9fddb8dde3435b42bef4f0c37a59529139de45f4d4037b948e3c3cb7dfcafd5ce8431de85cc744a71eff1299040f8579d2d4f4883cbaef6b95adfb322c32647d4a3112157c16a1e58aa3527825b165abbafcf5f68c2fa27f7c650f9408315ed162485f31b01e34ab498643fc508a42e3c6d1b8b78e01617352509bb4fec6c8f95d4f99200eb38a58478cebae251a11a4c8bbee5777103de71a50f4dffbdce2bcb57acc8e46ee8b60f767f08aab5c1c81c56dfe924756c9714ef7d98dc0982d4a1dfcd2fb0429b5836404a2eb5b7e9c3f096c8085debaace654668ee2f070daa63c439f7b3423a0b1081942b24a6bdc7a3871547ff41018c71da274aef020b61c3e9ef2be763aa89ae37bb372fef7c0c84e4775806d6ff0dae32404008ed2f02e90e8228d3994266a7605edc1f07a609ed3b01f7107874091950ad6d9e9a05805f4218b9e00876f66e30563dcf06ca48bdbbca7d5de1710822bdba7d5612a7343afe2bf997f610fc20faf93bf958aa9fac32e35a42b2de0f3a3cae39b23c1ae4c6fe0fed5d74a580948f78d21a3b10800b330642f158f9481e72d9b67514d3cdaff93c4465df5aa380c5900ad70993ed4d28656a7f11a595262aa018d497492b9efbfb9f6501f19f347cb0962f03c2c346a6cdc8af020565eb270ae98061e84cad52fd56146b16af30edf8d88712ae4f9c23caa275706052e5896b1767f32f26fc555f11cf2e4f6407cb4833c28934f2ed43f03f587551db47927b572dc493c205210c2ca92963bb6aa55c65a2e9d13b6148cb74e143ede2da04c585f6e7dbfeb4af261d363b4b804479a15fb9cc1c855551d3b4f724f9e82cd3b2ccf895bd0c601211b33e9bdd439ae66a52100c7878522aaa9594c4f191762622f6bb99467abc5cd41ffb430f2d35a56d5e8502e7933695d95f99854e7cd0302a649e1cf1e6bc525aeafd960aa7fa8ec9ed9b7af813b8eed27f53b2e91aeb7466d8d0d1e8d227cfcba9a2a6e5accc49247678d74e28b3f4ab9d382510b7d4eaf9e381a02ad55c46cf6c2d56ccf9033f172c595ed0b0fb27b645b3f8e2401adadc4a32d06921a1bff2e26907608b5876ff60fdf45eb4dc2f55accad4b181af7229226ca8568b4b71c9a34c7ce8f7827537d60b1bbc95683cbd224384f0857474f9f1b7eee85a2cd8d2dcc58e9f27bad9b6defb9ef9639f89231e1bc98fc566f9e4682a645ea0e4819cb893018b9b333c7415b3d8c273c4fa749f9e4bb0ae2277ec2705bfb37a37f9908c9f9fbbf54f471dc16574abdbebbdf5ca81835c5fa5ac1c79d39c381e93ec1068b8569ca4ee744484ec2b8eabde2c71729aa64db27624f12f7e1672ad013997be35aedf04d6c1176b221b0f2d452e22652e0267cc73852e3bc774bf687d2687249db85a9cea8da39742ccebbda2accb7e12c95a1de9b784b54a1f00c29d6f2c9a2916f1f054089d8f3fa8e449636923726e04531801c81d5965b6150b753439e96a011fde8cd233f30d1c6a5b3dff8964430188e732eaee4648fa4c7c7ab2b54a4d0e0aa70e7733caa42f7319f591c1e4a141879a6ff296495e1a7a5a5afb6e80fa29d9402bc4c4ebcb09b3f0f1fac0d912c1a82400e5b01f0bc941e2067beda081ee0116eb570b64be3b6c4a53dae36c294bdaee9cbb414356acbf72551495f54931b92c9d2d991dcc22cb25e6df254ded869d17983f979667c9bb104f0f0e3ceaa33f298ec7ed0a603f3a35a0ecb256e378334e2b389bcdc27ece7f89088223103cfb1489a0b5d28b6636576562ae4ad9d0fbc5d63c68f8e4be80a1ff1a6f0b1fdc293b8516a620c47a66295ec176a7529d52126ef428b1aa01915793cb71b128354b4dc4e473115f064921c612c16bbf1c9c14bcbc0cbc473f992403652ef796ebada52f118dc3d6364c7fec5ecf6927ed3ae84a9bee94eec778a9be3166cf789006c3c794ddcb78ba1e8e4d7bc853177fad0c33431eaf23cb30b3168032ae8e8642c2da0c7cd722a4ec16055bed217322155b69bdb3f49c3a8bcff1c8d6f7fc3fb3e443a7e9d4e63703e2ab4711f49d719e52881ebdaa97045bbc04f93260d10292dd97c72702898a053b1243858d6bb8598288faff84c17c6506455e119a3a4ea15fbce9ba05550f6f3d40c2357908875e47b1de0e61d4ffcd67a5d72bdc75f4c837226ae455147ac83d87793f079b5ffcd1ef540d4502c79f93f62710762f5a05548447dafa8f39e4f77fa83791ec2dab3e43ceb9ba8481d2d6d666d367c9477f837eac0ace6dadefa74cbbe772afe2a40825fb79b967a9fb2a65c56252beca36a865758ae7d636ee638656fe11a22ce2899e30343a69b5c3ce35ebe7663c7fb0e3ad26465ada1d63bfe8668c94f20a43c0ecdbc2277cc32d888963f970769d5d46d6b4bca91eacc3ff021fe9f6e0784ea8796abe4c1388494875a765c4eda2b100c23677985fe0149831692b1178ce88a158c16524c0a958f4c64536b2f1d943abc51464b937d4b280a8835f2fff1b173fe03fe6d63c05d041fc0a7e1c8a8d951a2595139faa7dcefd321fce57940c52d4694cda9fbf9424d9bceabbcb0e619339d0a60d2401adcd157a59f62377d7075a08f2bb9eaedaf5c0f326e760330b02838e00b19c1e474b56810e55db67219254a6bfa7a37fdfa4fb08ed06a22236e6b269e597195ebd274a6604cfea8e5c4e931ee2c416384f9e1286f4020541156dac9de85ab3608da86db323e2fc9466e1d23e21fb369c0c2d27b2f3d61fc26984715ed2e80db28c681be28d933b86a18b4eb79f1ac80ab17bc5873cc745a9a507a62e6f6c8f7a88c0e907cb632ebd01e6f326ed174777dfb85be3683c853dcefbc12c5949c2407f1e0897c276762cf848535031576ee20769914091bed9d19ab6526488ca2a63cb8d4c7c18678cd5a0f7cb1c715985b5a204526f4f9a261614def0d534c83571d74b4ca312f9ee58577aea574aa474fba46fd5f90b400e8c78023e294be39a712e370aee794bcf8f03ed483309aecedcb5e9a8ea817513e552ed10da2bc9db75aeb3256befdecf966dfcf7bb184376acb34b52fdaf848a9bfe62b17def444b529fb09f8bc1fc4eb5b7f3644f0a861f15fc796c15d9962693b17f23f8d2bb21ae32935179bfef8acf7b933f0a01ddba4556e9c54e6dc2a952d2c845875ba45f59e3260e67bd05e73f62433afa65681b12bfbf43bdf68ea233ddf4a6e123faa4697f6c04c87be7eea1f6197a80cf68d18c790c4c0accebe47f3446e965770833be4190cf9e871ed5ef33aa7b75070a52ef59d73330895fc2af446d9ce3a5c136a5373bfb4c5b6a0e69ad32476cc47735aa94aff86174b4cbe05066a8a8f54f25c4a058c7f4d7b6316df08e61ec152402d8b8d99f8c59952aa132fa64dbbfa99dcb11d845b0e725bf9cbd13aeaeddf5438a8a22ea1a7094164269435a7941e505f97713767bc08851a76ea8d11b31defab53cddb422e62b827e7f9e2d4271fcbe55fb6ab2edaed92b7a95ef0ec5ad47233ff7bb93a2f96a3ee916fc34a3c64e2c7ed8577e93837ae9405edf0dbbfc7a152c62d79fdf19a707b78aaec6837bc87a0a81a1e797c021f1db2cafce6eb14bea7d55577f3c082a6350377640427d360747944b72678d5c99a7841d0ab1d5c4245d8d1ae6df9e424b8167fc6af3f046dadf832b0c2165e6f7b2cbaf222c252eb30ba2b15be120634be0d24a2a14721399fbb235a2e8d67dc1719bf3d1a469260c2b5114a51cf0458bad6c687dc9f1bc3bdfb89467c6ed66e5e5c2ce88f317f510abec15789790a93b429eb56a78eb5538aeb937fc0acb74ab45928a4640e6028c3040999acf7df5b51afed7cfbe96ebf906017aae834c19cfefad7ed0223481dc356f25af1526600017d375488cf0fc8c51da9d7c347177f5aca2d4ae8ba3dd720d61ed70ae0162fb6d95ff30ae13d673df70e42e5b605378160bf5dc6a72beb04ac046c6aa46146b8db0d229d41df7702cb82d23eac0730d4839b878ad50424753dac6ae89145e5f941f7031e4c825be44921501d91803bacc9fdae90b377b7b683cb6c884e6b85935d619049126852904c837774a35984870a597784148e650e987d3e65196584f50250c701e9f40f88615e40243e49c7b36e11f1ebca134a4a0fac64664398bffcfa6fc88becca0a38a00f7054222d7e1d3ef01565774b4bd930237a315689a46795b57be4d6f000cc8244f38ecc7a6f751909ac7460d82daaea779ffe3eb9cc746c22b45a430038e7607d3255b253724cfd9bf747f3be50b11210ff49515a24a604619315f28854e8eb1a5302e829622d08538d5b039a55771e8043fce2e13861089a6acf2500e47105664f18083f194c783c59e93147b2de0cd870bd6aaeb52fbdec268793cb4a55f53aa0baaa4281166210a6a73b621441dbaa9971be15b999c2e227a382e0f1d0537aa35feedf6f5295622003dd61feb95a1d46fcd3a512a17d08aa7fdd96b3570e9d78babd9afe5c3de95aba903679ee90083045ee1a6204af5f9413f3ddbc67fc5c85f1907b8ab0b937298d1c874e58f783dad3f55a454f76e08ade89593a7239b19c161e69727b8ff1c09d2c82d5852949071cc61a9e8dc9f60c58173cf04d943261e794226cf7475cedde245afd7f88ee42e8aad8875fdd30f03f704f19a578f73ed0eea92f9356754a53332d25886d999f5b1871b8d26b214cea10c49111502c6f3dc8b8b8b25714687d02a6800589e5d2d9a28457b86d047c83d208a2e140452f9e48f627219ac05b7bf2cb5bc0c22e7fd2cccb2528de7295792d2f8410a1f2a4f954fb48fde67111593c3eabec596b54fdec3ad7d790e6c843c8d21cadede792bbd448a7a8a31386b55e97f0a9fc0c7955fe10992147e18a9b68d8d938990dcb1588b9a047aa00a5a0d31c59061f4b5dfc8fb5dfbc6e0564c0bb80025b027ace69e7083b93470e44508d7a39a7bda3ee3547c4d07ec060e38e5f1911983ed4f1c997994c66611d2f9c7b4be0bd8aee78cefd30f224c3df12d99e2e875ca8f418e0dc852ec2cb3e00edb10e3c43e8e26ec7c6594916540c9b046b518e87eb7ddb2b09473d10e4b6691ad02cbbab3dc028d0027a334cdd3c65ed2db7cfcb4cedfe0c4d11d31700015b2368a0cd98400bacbaa714c67fe46bb7b2bb0785fab194b6e043547b056fc2ea9763f36225e17de47087563253d9945154a9336b3cb35137533c3353acba65509bdd347b455533d15479e90802b376886f1c3a8aed08732715a2b812e9ca700a246e7b78f86d0dcfd8d61d3007a2a1d40f06139835a298f44699c0b1f0af7fc723df14ccf3d6caed510de29596f1f03879aa15eb033880bbfed34f42ee02ff85de494b7450c8f7b29ba8048c11054ac7e4d8a8b9d8a91f6ff5d210ba9520b8834f9c068904f4fc2acb015d7666a6f8972369032fef3b18ca13548fcdd786e32621ff4fa632d0909cec39a85bfc2d17f4d450dc2276cc06f255bc1641a3401a37fc3f0b512dfa6cf46d25c3cae7339dfeb5621f5d00933ac10d5bb83a7d9da23270f69c2b23ddfce146eb560dd9ecef43becde00dba3154c848b6f255a2c8c80d20f935f7c12e58a3069ff6ef6fbe40d5a6d68897c4efa7079ff10f4651cca2768bb9d52d5fb4dc789a2bf9555011bb76acc2c6d0f4d3d90f7e761d7107cb7ca8f99a6c2bfcabab9073bc30739b5a2908f33d69a8db62b31690f6d02c22cd841efa9696b5571201381d9fddaa0f3230bb05751a1da31c409584a9c643716349b1d9ad0b8d8515c95c783cdba80c21db50f4c3a6dbf6fd152f5d85e6bd13a6767a7a9518a8efc9138c8d88059eefb2812f2e899146e322b1089ed7bd54405e67b67ce9f135a91471b26901f514825c9dd7efc78d70e4ef2980a0bf11b6fbb65d2828bcc412a9b699fb35413765c01549a564debbd3d4501b0824a82ae31ec20eb2e9ecf9e57b1e7125d2495ea097ab68ed235233af58f4be420828586ff65145fcb85d8c4e1197865ecca99075879067f264f86eeb3267021175df388bc6756172ff1561e87177168a0f1211bb9a780f93e157d331ddf86505164e7427e0df094aa21cae3d95aa1b1d7b3d4f7286b564b903dd9065063298d695feda4810e6e0b512cdf118fb6c04ffe93f733de65a3b927ea537fabe3cc8d009233168206468ae73aacc265b8cff9d628f4e3728d3fd9ae7ca790e6550914b0b8ccfe4c6ec9e050ba83feeb71c8a1e5ae0fc4fd2ff7aac1a73223fafff70108497246564d3f007983aafc48ce321289d038917e31db5f108ff375fd6bfe6f6c57fd97ed472337af9a30fc62b079b94fc0a4436bf3fd147d765a84091aa5872311ea2e84d01ff40c4ae47790498fe74fd218331d054d2a2d6e1a1ade7bf188e16b435f4923503d24e3a7ab172113d9ed6fcb02fb6a24325a773ed279720bbe74473fa3d81d072a82a81dd9da255924a496166b65fc2414e7ff4a9d189a2e9683e9292613336cd95803492746d0744c03ac08fb1cfa719b39b1cd29e77c2dccb2aae3b14249f1751bdaa0ed1a9b7ddac23eb4727d3cf6293272421c9c72a85bd241857b6aaede10e3e9bc61ca73a2a1fb9be8bced9771c18d86856384e44d0af0f86eba54f6c51f80857ec52dc3888cb79511a009f821405840dfef5ffe7a501a2e2b3836922716a7e12cdaad016c78b9af82a4a456447f1d87bcaf04c50a1659d6356a336a61360f4b2683357f9fa2d68dc29b484eefa35ed7c009dea76569f4087008734286815cee2054f93c7a2cb962088519e22c08f7da90c137b892cd175d8704920e776e4a6c725296555597d75b26b81c09a6dfa847c7954784e6e24e0b13245b70c6a8a18ed1cb7cca2e47d7f0abcbbaf3e6ee869ddfd490c93583da9dd349ab306dbc87e3e7ec7449546119e0550f4be284d19cc71eb3eb24b7fcf277d76ea88403c5727cb85907e454f249b674bdb11606792fa996b9fe8a42c2c47ebc402b245b21d33165bc0ce451a7d94934a5ee5eb046f84aa5256fcd7320df1a5a1fa4c87ad245a2b03de1c3f0a01f44dc778e0b86e4967ce37278411d479af3ff54bd9ee54646cc993e9e88515f49586e14d8c1e18a0e11c51864393f092c3e8cfd3cde675729b1a1bff0c2c4237165f7953a32f3a85030c3f894f19ca9a6e6c1f7d2b71eda05ff9815abdecb768562882ede2a612c42db7eaed24378c6274b1e42b964be144cd3baa4f31a876dc6895d06d7359f5b6f7f4f9491ed7830ef2a3cfce197a1b613ce7c0ead2781213c312446c563249a081cccada2215f0e6bd9bc26e1a037dc3c99bf6b24857afb5ad2baf514ae635e2274b02fa48a9e27fb7252fb1b13835766f055aaa63e4ebf8f4f9f5955bc5f64cd2fae9de8edbb0a4198ae0de0c07d2afafa006c50a344b8a0e3fa0a7c375a855ee0c8f532384aad9b337280259ac0fd644fbe845037d7f1ff813e790d2ac55e831cac03bf11aa0e85180c476518921b6706135962aef1780d54859de80f41fe80ef005ee0589aa48a29546ccb960e7e80762bc065b29d084902e6f3cbab88b04d4b06c294e2621c06e3c8b41d91f0f3b7470a4d9a5ca08b4c4f971f15e2c9a7f73f7a5ef043a1dabfb4640dde18a9b8073c2d12edbc89f035fea031de336e7375cdd556718837c7918b50cf87c313d3fdfc727ae37544508216763c5317c5093f555142d06b02f90600ea4bb25c03a67d82f01c17451cdc2b501881671d1828e5eaca764422cb5f5eaa02916967a7bbd3259a3a470beb5fcf942dae175e357a2a44b7543575f320888d7ace839148992218f4fc3716ca156a6c429dc7217daa2a5ff74d18164b73b2cc9cc0df89abd173e3b1e03698b03a7d6487cfc611f8cc6ded7ea6db89212d32bbcdf18babbffc47cfacf840283378a8d391326e004e3ea735af106e667dddaec8398db94cc9a6ff3a7ded185143fdec6ede5696cb7666abf7bb288405e856157d22b955cef730f365baaa575d41228df8177a4cef4a3d1f5c531f2696b5f56c1217c8bb6239b0d17c51665621cb90a1152fef7b685288c3d1882ebc851538db1ee06845bcc9d757ef85d8b8f743e757a1f8cdf306afa084fd63ede4ce3b88295f96d979af054a25a9e8f34ca215dbeaf83d229d780cd7122def60800b60becde6461c124fae3584af6943e5b0cf29351506b2cc20d7553e501753b547bec7c43027656cd8defbce9f7b8542d0c4f44aae31bfe156aaf62493fc65a680d1c5b41077b999ecd355cb62d9ed52455742dc42e43a469f1287e47a89dba5b6e7615a46ec2f75f199a56056f11e376d23f645170adc4cb85ec912216ed7217c1d5dffc611fe587d8106d10cef00d687a63a60f63a369ee8bc1215d734d85d2fab6ef9a5540be0df81531599692c927a472f29035ff2f0c1f1a321fbb99433bb2f451d0424bf5ff637e95dfba9c6ee74ec27f817276d457398e94a553aefaca0eb25349d9ee997c4a3d435f06bdcab7c3978114a07a03929808b4200ff7c7031d870d16336be5a39d50e50297549e2531b9e7145dcec2f0cb36696f7b37cb3912d8e86f8261e3105cc92db6ddcd5d8ffa3ff0b8f9b7bfb58623bb8169f06113a94d3be922b73d1d615aad3177a1e0693c95b5caba2fb6aa219442482cf96160a996797c9bfc08580554e38cbe6240b985994c8b803194d0f008ff8ec00a967723d9646e233566c77f31a0117968cc6a73eb5502030e99c378e2996806994698088b8c4797c2e0c758841b1c80d4cca1fb95ae7eb690c761cfef1abf868c0cf3eb987436dd2bd0818adf62c2e081f05cf5d74780827a1de7cb4ec0a9e3f13b8f2a0b90101ef203d78bca8d91be9a7bc08f84899696b4599a6e1d3a86da17a9f080b50608a099a433a8e3782664003fd5a8f43008ee40d500205d9b66c8baca2a4adf799e5a55f33083ea487f4d034a91ac68e87e1fccb9806f983e33912f2069d9638704ede81e1d74ccc25258095a1edd950676edcd71ac79d50d30e66e025d2e8b920c8c5ffb14422ee15703f292907eed985567abfcd854dcfcac39d079ccaaa01ff8e5fc28a429b960b248d3cff6b8c6346fc0f1c0223a97f43e78e94a9816f33d145a2999290f816ac6f966bf19a634ef988f6e5c8d0575bf7d0340e9fe9f41b420c5ee81b505545118ae998180f84c2f846600974c42f9a0c7cfba66d256d99a83346ad9826d52a0ccd6a72578b8858d353b5eeae681f286d15705a6230347b7a004090dedc4f130d4e6c1d069e3077048b8828739272a1b4c29e8cf9be3cd4c9349ad8dd08335fad5b767f80e86ce353e02ab615c1ec4492c960747f1a820b91838de87382607e6dad8e78f53f21b5c93b569697ce1be6971134564da8d7c065024bdfc333d53e3b20804af73dc8ddad485caf3ade4f64515dd435f2c91c7ec099e55076c7e7def119d3d747abdfc520f75ec192eedc560f2b79589309776758a6c1f7c0f60d7106d5a5a4d3fe82f13018987a3b282e5c6cdd1064180df7ffde0a5708dea8099fdbafe7bc1f8718bce40460b531a0aa62e0799cf2d57e42742480ddc2f99f3893c9e62801fb5c0646851a9351a70020ef88e75451994a0e8da8862e435686326e870a1bdf7476a686442afd0e0d3c69e771323b4bd2974c7ac1585514694f3181c64d61a396b75ccb441a4fbe0c3832988f88aa06e4f8f5343d760ca4c4dfa125a835bb12b1ca5e159f94adaa0800cba2a883ac598a687893d09cf47adae9fff809dae80c160147c40ef2c8e9a4b8728740a659a9e0b3218d627ca75966beefd8d582d96111931887d1dfb1f01303570f9252e37ccf911b3d42d14e2751e7dc104462bb973c226dfec2b97b59ee45022e901edbbb5d7c90b9401c97fb7c6ccd6967ba3e9a024b222069d5977306f96cb1b91da22b0c4911735a4d6ef44eea7b2c75655adcd985ce16f7ff8c38f99b08b83cf4ceacfcbe6dec0fc78f33df3847d1293b23917ec8221bfaceeb23d6fad90b12b0e89020bc2ba2231a75d3d7e08005c543688735e914e5d6ac04f1b607970ff91987c730d4a9fd96764a93c00d3149a43c4b2bac187ac12552f7eebe504883ee7f83db45b7a32c854515201cac66b8f66d47ee76108ab912b254c48cbd6656ba0bf34f8cb4955cd8351603f6bf4d438ac25cf4c6e362bf1227ea7f0e5146961ea0abe42bdf0fcb1281fc61984c90c83eb31bd14243e0aeca8676f45234747c74f106c1affcbde91b9d0bb76932161855f496dd4d504e4344a9b1b566b27f20d6df4cbf3548a79a59724b32a74d2e61a068a73be89509028979ecb9c45cd13f7c096989694cf3dc9618e12334e30b4288ff8a6b18cbe6fec2e7b22e2cb59cda309f2527fc6872388b2fb09e61492ca0f574079edaf8158e0e9c226b039a6c6f930a2abb08275b9e7af12ca6a86b8d2d6e8ac1e39bc6a0f6960fd17a5c22bff115ae4a995e47b0b9bebf6f7817b09619900be0ffb36d8323bee07245603ece52547fdd1f99a30afebfe0c680eded98a51ee2d7dc3786ea5a01d212c92af80a9a6cd3ecdf8c0cb6edb0ab437f199b70cc34a548f407d74a778a54b90d8815d0eebf4bd2f9476df14b2523ba8bf3b7512442048c61b1cf23e3b3138a0a92aac19397f7b03d2b1e87278d58639599d741a4efbd799d3bf355fd13c339109172ee792be8be7e8ab7cca05a68a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
