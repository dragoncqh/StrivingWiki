<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9ae622729a693f71aabf8c622e07b6010fdbc8c283d6f4ec9ee056c91ca8479c159473a4ec441220aa539ecfeeb073a6f80e3251758547b9db0c03733f2f07303b17471159e293108d3b15b369aa29cd9b127f6959a6e0fa1881aec4686f1c9c824396a8bc204627ae32e0b3f06771fc68ab4f19ee6854825850ffc6c22c3432f23e9bf6fd44cd2e7dc359cf8f1c74766ce7981dac59b327f863cfef1e5a8d0e74925503ba7176b502a0e7421b4a008061d3d4c449cc951f1177b083141ef099ad2b77ab2cc9cf20004a8313fce0f68d69fddf290cd5f5ef746c2de4c790e3b73cf98d74887462b88960c0bbdfe0d0adb0b165493b5845a970da2469f8983e0f4d382bc4008f21d734f34f6bef8cd643faa37fcb4f2c72f69fbde1ff5d6530a63d7bfd9516bf7a61a710ec8b08480b7c4713e1b98ecccfc816d6e60e321e91b821ef9e1a0d7d88b142edffbce8ffae997ab5b4918224daff1bc187670a24564389ff41430436cf3db86a559a38b448426433d236850570ebc0f0a87cdd8c0489b91c1bf78817c296c412237cd0540747c6e76ecab13702589ac1d1cc16716915b1e64669accdf4338f3c76f9e6279fc2cb5f94918d6dbf964fc897862f367b5a177e883676607652364dea4de456d62d1f14a310d506e31bbec3c0fbf3f30ac7669eecc8793804be9860625bd2325f44e299be64c8ac63fe81beae5ff40e1a9e5d66a1f999099aed14128b740e2b38a21df16f16edff02145532525eab1f45c013dea25f1093250fdbcb338f3b52714fe221c9ef568e7627f8cd703e2c47d0d1064bdee43e780e692da9db4f79ecc1e39ec4806760d2bc357afaf68bc840e598822e57e98d8452020720eda38105d691e08edd8fdda444a382fdefbe4e8302890ae85baaf4dccce73e4501b4b6a1be5bcd07db49739420a6ac4a200910c2f9a8a66457a042db9446892f67bdf4350068bb7e0c18527ae00ca5ea653024bd9b40f324bd19c172f878e926fded17333d4993f3f9ee24ac5c2e213bca2994bd29559e8f52617f481263d9a85510007d0302413089522c407fc2615fa807c73d153eb6cabccbc3cd5760c96e99fd2412475693c1545932b9b3889e8ba55ce09de4d7b51d5fab58cbed9aedac45ba0588cf9ca0f7b91f2f71d2ee10fafb02f8437282e6c9f49dc67f587f8b7907da07e7f00836f0aaf21104365a81ab94c7fa0853dfc72445b368a9e30e49c9c87d9e0c8ab38f1a8b013b25f103fd4fab97e3b8b99457313af80d2f2107edc8fe1e1c127e9bea8dcccb060be1b0ed489a432b74850b3ee6e132369c967a72dfe1213773becd2fcc60a202b59365579dca31df3a95683e3c0e84c469deb538d53a5460d51cdb0d79177390fd7f8d81768c3c484754e40f5a636fb0687b806b937fbd5da13e97f494b93fc2f937f894a4519fb9b933153882ef3b59460ecd49fb9188b9f9c13b7611e5689d95714ef9fa930f3a8c5e70761384c0b6efc91ea57307e1fbefd226601766bfff157ef3518085a08dbaa7be5223217495f437af1c3e13446124b313a32bcb6b2a7296b93f923642e2099e4359c761f45c5017bf58b2184898b7dffc1ed6dd628dcc84f587ca271b042d227460ed948237f7c7450174601cb046261e99a36a423e13ba2e5a9fbc19dc1b0871ebf539f8074584ceb8d94d9b0ad9bf5ae991fc84d141bec70d7f5626d15d023c446398ee186990df0132dd532aa78f81df2702cf3cd3b583d4b9b3e9e5554dd8bf77745c28cab131bbc9d5b80e61e90fa4cde927c9fa0548e344c82bae88cd52651d28b61a38dae96485c12f840fdb6b767bd3a6edc3c8290144faf7c78e7d47a5271ea0f7fb66313ee8401d5ad4bf1f7755c2305587bb754b35e56067227856fdff6dbad1c8db922faa1ce869a88785afb09a35b720a7a28d461375bb723ad5c2e7ce2c875f90ef1b47ccdf59612d62a66171cbaf2bb192158563b3a3fdec04fac21e06ce8854aca9acbe39bedb855edac6840da9f2e29f5453cd826e191a7610e46e9942be21a43baf9bb6df41851a371a0901c12fd8eef4b2288e599d49784e6e2ce2fc6de2a4c64d08cea9e975618cab3e03bd3e967675686e2728fe967b233822f88cc3d578f8d5a579e21086e08ab919b870479391d9060f19e7409ec09a7b025657b82dde66a975ad1fb298e0107a11751496d90f2448dadd63f7f28c6a700fbb5fcefb8a31344cdbf567f6af5e510ae9d3a8722824ee40acf651d4ab8750feb70cdbe1549675f73cb1f9c975f836e4565e894dab875dd19072fc3befa7cc3ecd4ceec6678568eee7d73ca1599f41b27d617bdc14fdb866b8eac09357e4f6e313b1748499764e1379db5bcdcdce7dd39cd3d624226c12a7131c6445b524a7f979f4893a9ea638500f580f70632a15a09c2825e6a839cbacaaaa547743c6b1f4f1df7403c383714c426c0efe9671c42c4236bf51a3b23ca75594f700d4dec3ff037fd7a181bc6cdc24334078f825198767cc7c39eaa449f56fca9803044fee1c1c8d8c08e50fdf1e88151291cccb4ecaa4b505c7a05daa386181c1039ba579b9602a03f90fe4c17ed2afbb3025a065d5b3aaf39bf88e69bd6c980460f87ecdd25f22b28c9b35bd91c4fb8b64b07165bd6676bae42050f3e39ef050e51d62205bebf1f507b219a8fb6895e6d9f9d8ad3878844039d9d4e6bdda21f2866c5d0a1f330ba4f41c8b673fb1d5289fcd855376f9ff77738b92ae054843cdbd31f986f555cb0c382f7c1aca9ca04865a39db2c04c1e4f3ccbfba34b4815e8960d2e10f8593bcae46fc71240f719b297db3229e22901b4d58fe219bb73e5c947b71e8cc04ed4862e0d0fed05010b29d79d1c9cc7ce8871341480ac6dfe3f11530e744890d11c41b730c2b9cfc0bac15eb2ebe775955246678414762191b57cd54c7e60df0327af5fcff945bb77f085a37e8e27980e897ebf22bc18966945a0730400663873349ea6f07e4fb4d410874689817dc3270fc5c49deff0059995b0c85f8eef0bcb7080c30bec7678cc77ff7bbbcf8e6faf1e5b61ae628a7aa477223d7196b36a3007b5507ca6389dc8ae760f07ff41949a2b13907a56d062ec7b535a96b11aaf3c942f91b811465de87f999739d40f2df39ef47287d73b0cfbd6ee3c645c2922fb482c1c42dfc0b64d313f4c2945767b760eec368c3095d8af6e41b4aad5e32c23fa4d36434dabb9cb4ff0c359434ba5790bc064e01d3c446e81842d40b15c5a2db4005116093b2ac4304f2ed8104a8a9ee3366fc032540bf90851c9a77025e0ea3789ae0b8a7255c5456872e5a7383c13b9c65f3c0c784192a0e797e82d5accc8f3db1f586133fc9aa6bef20598a9b958377039f168c12e5937e1f1dbd408c4a157e010e2ccc76947923fd7c13f39ab4d2f1e292ee7f249eaa2faa5acccfec64aa62551e1c4a1fb0a5425914a5c2293e8e189466f8026ffdfd67bdd71fd9a4d80aeb15ab03480c04cbc4ffd2e6667811186e6fdd6e673305e7962764fadc618752c88aeaf2dec15f730303844fe00f367f9516910e3600e90b8b19858d6a5d448ba78bb6937af43fb89247d980190602d068c9c1aebb5ff2ece1b7f020585571ac25b25f420f0ba8e5ffea586dcaa8a156a5ef86ab515bb49eb0c40a9d1d6f36e57d0729eac477691fbf3ea6e3ef84893ae83759b7855f0e3ad8eb7cde21b69387c438411221531acd9a2a3eca877750568759b85908f0203e2b17194866b1efdfd03047e219097620c67b92db5322f6c28426485e61b5972dbbf0e962a5cf9ea5f17251fc8acd314626f971d1ae2a68d7ff78644220b41f33204325ff8edd635183fb14ef28d41df25a8950b3d0f589548f1379af94e186d55e9a5e7d8cdddeb6fc10de1468430ddd4759238a604a52a662c96b5b688b1aa3d146f52d75381e4d9e6b747cf78ae300ed11d72d8d18b40be02ecc09bcfcbe3a537532d9ded6ac5bc136d8996331d8c6832eee20caa9bde3786b590d568faa5df8228df75f93c428cf4cf1ead42cc268184ba437093ecf42ff00b5c946056a8dcae6629918e02475133d6c893688fd75bbeade58bd926561c1d5cded9b1665d6b31da61b70bbe1d6a963a731aacdb53f6420d88e9df9fc64fb77b98606102a7764e4b4a7c2eee7619c716a844fd855193726e4a010ded4cce5b03aa97b0b979921d774964a4dc4e06b9f16fed9b9d9eb824b22774b63154ab44223252581c8b93bc494f33f5c6a8715797ef65f03ecdc0589f1c53595917cfd2c206368b61957b4b54d5a97e6d5495e5544afd739626797803139088d4eeceb565a6c63228c8eb272d72b29fca35bbd1992cf720b903bb5ed81aac477c13905527ac8a17a34f29ac893ba419d33177359456c009b3a6d11fda04ac6e38bc0d5b728df45d7d3a616a5cbce6aa2dfef8fd72179131bbd6caf279bd5a70a8380961168db42d0ce89e4c8cda5c9eb41316e4e301b2bbb45eff724426b4e4cd2e7d82dcb0734436feedc19d08abefb84eeb91eac05ad124d16a463bd3b94641bd54c5527a930cfb795d25768ed9538055c03cd546a0f7856b4ebf1787aa4a8a45e92612c8f48342a46e69c15a6064ea43c4eade7c8be1b6ff46ed944a47670fca205ae527321ba07f70a3fb9fa52ef5187af22b058f0cc627db9bf309d1af2647c6f6b605addd1811c0a593c456de4521817230a69b6448ea5c56778e1911bd31ae8ada72408037b5ca57065d1449c8562e741e92dab629edaa2f5dcf341fd99134155c433ee13bde486832c250b32807ae62bf72bec60bd06a02e451a3fcd44439440a855c3d098da1affefc94874b84fe39f94c1c71542d0c74aecf0590c1ed88f8a1e59a2a8ff5c4245a2ff50237833d2fe8e914c712944f9302224dbe5d02d9dfaed500762da922e48ef7744e204bd95d776edbd18c13289d180003ed983872043ad85d663e59302d3e0453333eb1ef1506d5bb00a8675246e0ec5e71959887618b80cfa06bbdefb4fd42bc6d8dbe9e31b66ea9e7685fb93f434e11065c44cf019708821a47b9ff18195f568abd2858ce5926519f990562682bfce3607d8ae52c480810aee29358c4b2c24fb76d2f26af0ed037f897df76fcf90c0695245985b430d6376102ff25e186cda819e422d2ef8267a51eb1037e70a8ee6d4b52052ac057a1fb3089c1bea6dca8602b51f1eeee2a13b4ec3cbce5c631d8b31f3827332292354c306e3fe63aa8ec2104ac85a7c6b96f26548c74de8bdc5b8d0760757614183b433283d54153e5651da5a343a6e2095ac00ed5b9dca7773206c66c58c873a77caa66acb070e0b0a52de303cff306d11477d8c238815d317a276a8dd8edf976ec013875f0ab29b3396a52c26ba3486b9f6afaf80a74a08c9a7b7a7fb829255b2045d7ed9e423f0c582fad1c793e9db1c24737fca735087608b5db8272bee9222d476793e0a0edb6dc7bf67aaaf0745fea4fb60330d83fc7875c98eed8aaca7ae4ea75bb49d42b005850bc55d3e5ff1c2778f07dffb8123b59f81e25c092d4f3e71221bd9c37710a7144c8bcd1b286f85c48f57e69afdbb6cb32f928ddc44ba6fc2483cd63dd56276d6a2b79b9f36d10eddd4a46b1c0bc81b1f2974f4fcafecb288a6ada7ff0197f196b71904d466694c02645778420e63f7ff2460866c6532e693f63f6768123be8e88e9a31a15462cf9ffa71e03953baab0ecccdb3d45e8332f6167330da42b9fd8ae02f26b4f794e86bfb63921826cf783c06b764409b27c37d98bf3eebe7eb9e6705d11471e3ce2ed74d3e2a04c7ecbd80f67c4681942356d68f6c2729fff6ccc524701c9af764fd53dcfa4320257ac9aed9b6e0dc8c2343d9709ff682e616fad047ff57fcacebe7e0a3df1559faa3397d0739dd83282f1d7e7d6c5ed4181f87b5017012ddd2055dcacbcf8071f1984a1a5d26857b71d69db4481721d0b565ca223460bb7c1615c1cadfb26ec473867c171d1fc1e37a76b1958c1109255a3887d15dc71be467c0db463ce74e40ed7570ed2c6ae1fc08fc2f0ac946ec95fe61400ba0ad84d05f6e67804d1f39a3deff3828d8c69a2ce10df55b59ee0ec90bb696ca1f387022c301275101dc813d908956bbd2cccaab669ea2016ecca17516655911451d3172892fe5469f81dd559bea59bb9de392e5e73a6291d7f43b10c881114a206e8ee886f1c026619c8b80b96bbc5ee339e9fff3836ffcdac3e235a847f176698fe5f1466577ed8f9727924393f13331f4ca543b2761083a7069fb0bdc452c9e6eb48f8d1cfb96ac740802744f10f56664759a78a13c8c22db3573f0ef2c7af89fe48106db62c64a9d3df8f870013c1f14d85ec83124f06381de185f4e126b9bfa8b58a42f0f190342f68031ea2e7e7b98e65fcda3a3f166ab1c79ee712ff28bdf1714b0950e9e210f6a9b0b0cc22c3fbc886042cad57ca7406f0e804a15232475941b71316aa327d98d579849e806c30968928018dd496ef5bce32048d65f6d2fd302ab0a75ec493829af09d887698eeb04c3a31c47e3f6a88df05e6d23ad77fb3273b71fc27ec99559e9361e9695279e3a2d72e340648eeb6c0a64ef34f3ebace1aec74a963ecab7d96dfb20dbdc65147cc1bdc36354c0770918f6a315b6c9f4518615a832a46645a39054212e59f8b698bc6c9fac29fbbf1f269eb1be7e74581ca47e2d7e0fcf16a0baf4ec4b5dd0d451535cd46217e9e50070d4b4badab0ca14674d60f4c0a001d841a710ce6d460e6877910fc481efadb457e92c8102eaf54fbfb033dbb3b3a82c9f15708f2cfe215915e71cb03f6fe3b5d49d7f95a11370db83275165f9e463112ac8af9e48699b1396921f4e306d58c641658c65ad3bab563555fc168fa1372c23f9734a911b57a1efc04679800c675d0b9f830f56e785cdd1c392bd3ce0a845e9922fdfa588ad7766ea2eddec7ae5ce9f0910ab5f40835789f746f896ab2acfcf4c3a7c9a2948e181156a01274c8422434ba9f4e6bb5830c826f8836f9e45e2c22372337fb206d7b3568632065198a41bb661ea30aa68ce658b88aac3db6fd7f39933dc5b59a3cba25b41fec7ba53b55aabd3551c1faaebf27f792afdb0cc3c3a64dbb6d040dd20ee894f20f6c08076376ce7633e53e8898b0b03f00abacb24e2ff9603036f11bb77b0dce3412ca14a4b5fa186d1222389c19ef5635fa4c8e5ec333928a6beede7fd9672c07aefc0375ddc6bfc2084113fbad6e6658a124e52f9accddef361e1b097a2fab23180c482ce364efb25777bb07c2216cdb9a7945132f5f935da15a6f876823f642cb6880df14b4d4127f7b32ad6e60a5fb7481bc816f22aae0595c0805fc3096e6a7e270b13957d689e3f49d95fc839e6a5247612d2053bde8739e3dff6d3383439bbcf2e8b36be47b1178c6e2a3e8c8560ab0d095eff0ad1694c1b450367b6830d4e22dfc44a8bea51bbc7ce488b575bc41d9bf58eebffe5cef61ea922827b4c6e9c8f9fbe96bf8b6a1d1c3133fff7b7396057316f473f841e171e1306775128f3d72803883f5ffdd5944a6153aa6607052ae9e9a5e4955d070c53c8b9014d17b4a36dcf6bbc8b5b7428c708966a5a10348e23f25d9568f10911eb56c1eff2c65f55869de06882ba5e25bcd3fe73362c8ed1656b892ab07fa745419e515ca0e6f88c808edcf6121a888fada734ac568fab33083afcdd4b4415c1eabf4ed494e7ee8b9ede8eb3f72e15959f46db3e6bd4b196faf7b9803dd21b07a6704fb1e9bd918646136cb14f546fe092d1e2ed4bbb1b5d3cfb28771b689156a4f25fd349b3546b6ec9297f212f023c1318ac936d2b37df7af959d7d9f534db0b67df80f3e8528dac6ebe46662a6fd32b97e51431cceea88d6548627172884711244a37c993fb0ea7608dfda1278bc4494c9c91b660bb515e0bc4fb2d1857e5a0ea474e16f70d6a2974ca4eeb366a1ea45040f2c51713b00811c2210c2ba98bab4f16e05a98db4efa1a11e562e210e4c6eafebe7b77c101f20993381e7c015259c4e5a38df8f767f52e15e6d7b892fc027471cb79bd28f9b73f9153a9ed6c13823e44bcd79150c57e6389589f0f4b6cf77bb719871eaea482f90f3fc925366f28e0439c14e94567e19f270e2b58a706dc984fe5f5a5d3078bf6c7cd126963d00a1ed1a5e62b84e7fba2fa5d636c42c420b0155c5b3fa7a5a821b49acfd02e4c62529d67260fa9054d0a72e73c7836541106bd60b132b4b4ea38bc12b344a4889ab03cae6467ae638822e5e042e04cf0183b597e6400a06d527a492dde0998e0a04debb8d78cd954eead2f9b4164ad9ef9107484dce1ca7f32d378872da275003846c097ec9dfe958bb964acb0dba82f603cba25a7ac8475bd65aff7d756c450d832cf51c9d9c2f07cc8d885de42e4e262a8fccf82bef0ea68d8a247a2ef03910ab59d5903424caabba72196fdeb82d963722d93b938b6ea44e57243db4287343f165950f228287d1c4e04e83decc7f08b342c1185bc1d9d109fee977c5ef103f07f010201dbad2525effee98f4e582b95320e5e560ba0a9d66034c6bad84fe80d0554c633b04d8e8b8c8744fd0a0719298dcf0002237f0bd09e650627492a398bf89a0f5674fec0fbcb4f9beb87a0b8ccb2dfe68c976cd8af12f5d8ac8cb40badeeaae4f860891366d88c21df345ce2e1cec8c90c0057619dd7b24f8816ee51ed7ea8416339278e8c3b07bbaa8b5e6cc244a1e7313fc06497ecd1111f9a39c7bdb72d2c5ed1c88f247f77a0faf8cfab2b57d7e55a9a6eccd994d88088a148ae0715d64b64e3d5a7df2fc0860075f82b7f3d1259a0b38efa735e31a39e8ada24f30263dd4678708326e6aadd8ca4fad8d253ac780509ba320f1ab45bfd9a18abb41dcf328ef1be66fd8d57e7786748ffdd6163652ff2f1df0c3ecfd0f066e8da726e4657603aa25cb9456eb9b50a666b5e8b6318052f15735750568dc9aea5672e4fc90b252615f9c673468112dfb165996ab16920e2d137ad0f6b9b6c764ab142ca92065c62c70370632c08096085efcec8cf8fe653e255f7bab995296f3346859d1be46a65abfed68fd2feb4e58359ab0b11df7a2b51d2b41f4606660fb911fdf35c74c340bcf2856c73bd0c34c4e6b67aa0eb6d7e91a423e57c2d1880855add0866dee8c17f7de1ca319ce7fa87dcd0240ec8c76b05eed96606c3cff9622ede1c900b31349ae0e03ecc8a4c788ef22173fd6145844929be2fac945b871474382a8a3c73ad81b7fc0566a0ed78642a5258c39acc7eb53289d35a4d3fb0fb67c3fabd1e7e29e14c48bf3c0d2d3cce1f9dcbab2c4e1118dc3c0036cf7e174f994e4c4686b76ec87582264dbb7786846a48e0165089eb39bc538068adfc73be3e583d1685ada798e70fbc01b53bb39f1bbde383a251f40ebd4e4d655891b0b8dd3b961d6c168f4783522c391d0c6389efc5a4f163ce916ec69f28444c74a5649defdd57cc3d87473c521250ff7844bba7a100ff746939a4a4bae1a26af0321e7c45eae094ea0afc3e1b795060618f6f2e5afc4b856bccc60cca1ee7f61db96afe3de0540effe2a5ed5060df3f5414b9c8fded88de9dd8b4f865bbe11ad44b5a127d8d85a16a87eaf92db495dd6b368d1533e724c5b7ffa74447cbb72bcb2597dd51b7c178cfa774db41dc5576f002125e3111e1891724dac135298d97c64b227c4e07612b483f50c293b4f34ae1a2763f769cb1100d964032e4bfaa2537b77f26893136f25e489e6c5a28cf9871e56b01ed8e7941c092bd710519c935148925a969bb4a75e734d25ce32a52143b6f12aac0eb958164906ab009a4c7a064115d0d1b39ea0cfacd8af86a0bbd792f5acefabd3c0bd83ab6ec47f26e4cdd1d25913f3ee74b805bcef3926c7c561e20749db2cf2b86b58da19f3aea33f3430290a0ab1b64fd198902725c4d95eaa5eddd2bab4a61f9a5d2be561d5030e37e9c117eac9f1034bef3fbf8641048050edd20c8f00e98cae7b536321f0f87bd8ceb7d9234cbd0e9c27e55696a7ad859b2fde9d5fcb1cc9a617686f710a2a6db5266c4bd9ab00d72c9006b693945ac8abb951a8d14ae0039791551adee980d0d1eda9146cc27b1515c7036ae48fe45987ec3f5d3ea955b864cd2d35f67f2a01b3a94536f65951da17107254c9b3f4aa6e9a8566741a1a40cf188237855d32a885e0792085a2e2a4f9e393ebf5f66706cd0e1fca2ee90db1fcb1c2a7c78cd36522a365a4483eff2b4861430166a7d43858db130649a41c30cc0e2edab80de5bd6f090a17f6cdfc7ba20fc10cf0a5e01ae7b32a0a24db8d6884246ab9575dc4396ba8ca45ed429e874d74311108bba508be50b608cd21f0eca1b956c8d788c73bb75deb7ac26ca2d7aa98bdc2f8e5aa7ba039ff2a5d8bddb4805487e5a9116c602ca547aa9a8171c7843ae250543feb54f3349f78a6633ac379d387b328e3d3aac368740950f7bb8fad8e2c5c8547c46444291713caaffe50c731721e6606f390b6791f4bad0b5f162aa5e067744787f00fdc192e6236c7a5bf38682612296471af73a8331141901fde0a5e0f7d963d37514b853b894b6cc6769e7104a657e8a0877297e35451ac1c8407aa4e13fa821a083a7bcc69396d3c60cce3d2ec269cc16aebe0fa48404abc7c037d15a42fcb0b33328775db49c11ded7aa76aa2269a2457385d0e1362a33e7f895f563254b8ec21426aeda2b57914a51a9b47a5b3eb470ca798f75ac272c18f389eaa79ad2c55d589f328009ac1053b2c9d58a2f180dc608e1a406202b122050b3cc34a1f95f73b9193821e724aeff4927abca7c4c459024b5af4b87097190c2199c50acd8c2a7e5d1f1c6e18b78072e3f762a41798ba1fb2b46fafda691f531db7a814a5a287361192cb42ad4c112c4faacab3f0197ce3fcca395c18de72b556dede8be28f32622f7fa066d17f3afccafc4902911b2d7c1d106ac9470d09149f024c755bcc8a9a292aa17319f1f85de87080b0d083e60054f911d77e44a4e9c194391759d0f0eaeac112196309768cd66838aede1bc694c9577d260b7f24f7ce2ebc4ebff5a2a1e059cb08560acb2b04f21d2b277fc5901274a8b49ea095eee75c42b59f5921f210941677b3eee6e83427f7c5a6f01ff2fa31d655a12f4d13e02b87bf99500330b7aa7d35d5b9c5ca6be3d69a4765cf13b5055fe55663c9b91cf8ca980c91f5c2401f701ae1a35401dab3f271a21e8c669a2a3fee2e60cfda9490be207fdaa2d137197cabf91b6843670857a9081b92755d38d416f969ee0ad0ca48ee9010c00c7e2f7f5c124395961e5ba9119d0e67d41bb44d1d36317d5e499176c36341a61e6434c92c126f42c82c79b7e1b3b0834737e5f6f3744be9a38a75f16d1b0067a1324994f5d4ee36b40b039385df6ca0466ba0520e0d9d521ed5a02916283c76e52d6ee95a88d073aade9bb23356d69b0ea3a14658727fb25b0eed9dcb552c6139af57087b35f36ccbf7de81b4e2bdbf710baeea62bb1eea587b828eba05d93b0ff25ef438092b7ff465f1e894e742bd098517e8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
