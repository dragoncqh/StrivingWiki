<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"082aec836fbbff92069ff9199d992118300ea119fc641b500b93e149560a7ee3e80ff63085b67798d2ab8dd1cbd706fea97ae60001fa4f724785b9eac5cbec8aae1ecddd0cd888f682945ca3e97b1de579773a0b3f0496aeb301684b73a20557e0a74d8d840b061ba4b70f9549b02964f933ffddfaa234159df2bed45d0552758589724048b4ce9ba33c6a3e2cb221544db53b80bc1f4a8d415a466df66a673cc5df27fe203a1651072a613d8f2938ff9cb8efff9e000d6a67cacffe96b4a44f9df19a90e097be61367587794603962a5f4738350d2cb458cd30d182881b636436eb6aec1c4c6e3499c79e82fb532661eac642c67f8e2a617d08b759f12b9fa1ced0de3859347e9b834c202bda1bd32e8c8f2801026a12582fceca16b79fcb3a7fe5fd128437c45acc0bdcaa3a96b887aef6500a7338c75e539ae6807d38505d5c38b01353fef414b3ae1269b914ae3bbd97d6600a93229afdf550cedb723e9a69d09259b1b317c54821df1aa8d44ee711f62eaa9a666879eb5af4bfd73e5e19dd7581bf11286fb25ff0b0eed078f9bb05ffc17f8134191ca3fdb32fc8baef32b42ba868113befdfd06d9f85e87410e756cf6f00da0ca63e0df8ebbb8c9179a474a9e4076a7151c7886d2f647d7c182bae48bd0c456ea27c2575c5c1fbb08bf5524ee840be20e1b268a09b005111d2e6594203192c9c0a6b47dd448275618601ac85c126982cd647910ebb1e32759704f988df32355c50f93da775c4bb039ffc0ee21312c14103ebb9fae4ae1483f890d583d03526cdfc7109b4606c5d15179f44b07b00dbf28425371491415670c79c14e723b0b892fd22b030a95b4ea5e8ea469120acfbbd8c95ace8fd3b2316e726ae44cfdbbad6364f824b0dfefef624f77b1d0ece46fed561e1069de3808f76e87b1dec66cfbaecb1ffacb9a6acafec6f3790e77b23758f762124f8969a27b7f6b8ed0da9ac518581bf2ce693fa174ae7accbe2087fd6469a08c1f2b6bef93f6bd002799dd1e4955905d4208b7ac6e8f0cfcf8548b697de5079adcd3b22de0a27c64793a6bc608c5307b20ba816e5de473d4fd990e7b88652ea9f9e2d99cb6de2b48a368a605452d2fdb6e0ccd1a2820db085ab00b832ba18c6e071fb3e30ac779c2fc0830bbcac9807524e1e5f9d781abe025dcf587b3a9be530cdff6d42e82d56fe54531c1550aa57082cb4b7bafb53ee47a4b3011d9e08ff9fadc018468f33012539953b6ce39f925849e1940c2646074ab0b47b452b8c79defab582fdcd79af89373fdcccbccf8b8512e1cd25f6d6a33ad27f8e56f6f99c491baf3ac92dfaaad801e68b9ac37c18baffba9898c33f77ddd1b2b3ff02876efcd7f687182270e2443ca2cacd0afa14fdeb30309eeef6986a63808ce860b821e341b6758318707c6e6e3503104c0469c5cf68504f9b891c8b838825cb7031498a0e6ff9bbf8f980e0067be9dc221c68ba9268b46b35119a604efdc7e8143f22cdd4d2d44018a74b7ebf2b4099ba270c5c9d8e5234e9ffb8ff0a1c99b09e68f93508a5551f261654225d40168de9f1c217745109122eda5706f2c613a29fb4df756a155c8ac344a522758f687e99e7f902833eb4cc46ed1a51465584e7340abbde71cc9c3638a435888eb6073c7d9ab28262637f47a0b4c645d042da1c9a4d949aeee806b394f29040a261b3ddac1569ea0dc2acf69516fb2c6900ad571c5616e50d1e62a116deb04008f1570c6765d7718a5fc0091f8f6b143d0dfc4a35694c2764f35f04c2ce93e715d33bca2f42ead67426ed2cdddfa9741ebf47eb8d50e14465249f8aeac8cf64cc53047ca922309e0a2ae1961fb6df55866a57d3c1937894788b74aaed3a0b2c97f3b4f9d84798d5dbecc5f07b4cc83f0ab92a492625ebe8f535ab60f0a81dd2a4d33c577f6db4b3ea4dac6a720d239de3bdd9e3140174ece8ad7e0b89cbcc5820e598b5db033031b5e05b6f492a1d43a6372e68202d7c92868628312da80cbcf4dd67c2255aa787bf45001bcc4cf1412c492905cb27ff0d2bb61d778c3846da19f1b21f7813023385d50bd6afa8997458be7259ffa73acbb23514237c99ce4f7f157becdd39d5a15f8f13620565f819220bdef93fa9773a436bb841606e42e71a11cc506cfd1d81b83c127a9c7d610663ab24277d911fd9aadf46e181ce9c739735ced99d64d10cae3c4b67587835b642125bc67a492f7c78489fb554179244062fa2f6a5d9366d34397ebb38153ad8a1702ea3fc941863f7ad21b302caaf692ea983af74fcc4cdd764535e2bc5fbbb1b65f8c0d4a9adb8ab318b24cafd2c918dd0914161132517707363672bef61b60e3c84460d1e7e2d47bc6c010f37281bee8174281702e8584ac5b0ec12e8bd2d2370f63e955eaaf5747f8eba3a2e488a446d3fb217ddd6e48acabd4942a10f142fe48cdaababef5c06fce4a2f84c03cf422c9d391870fe8477fd4fa4fdc2972c6116b9a89ea0237acfb2d4849e00a070b535d867bdc613fe7ba7cb372f875e8da8c19976729039b2d9c5283d1f3d5ce8b40ce103c8712949d8b8518fdd2d2a389b191a8b0ef6f573aa0d4873e952efa4b5a4fa8ab83c0bd38331b521cac9f418e562e59a41421741f681a1cd82e142a64073886a0a4cc0ca9bae924047746a1d8fbabea4d02808c066b815cde47e9bd99893f7a76104da48b0a613a2f9cb58112261f026e7c0501e4a57e330a8ab0710b8a575d3e1c9e57363b317fbd6c9a6fa5d5e7ec6abd4890e04f2ec65f8a215d50a77382f2d366468c2625cfe30c4759c5d76b2895f4255e1a53ce48bf2e183905cb570aa7e61868163bced163c82875a23d9e9f5be926ca3bc25520000513918eba66d22d2c22582d0219347d9e9a8d6349bd35b09be909388784b85ddc8c333f579db15fa595b8fbccc64a974abf902cf7490608665821ae31d0adf2d0d7784bb0d9a1d15b0ebe6a676fbe2ab76784517cb5e9e162cfc7e4c25a84c20429109d9031ecc13528663ebe67434c07683b82eb1dd942cab27ab3c5f9167e9111bd6587b33f900f54637b186f03f3215d0df471377c53277863a066b9ef02ce86d3d33260c0d52ceaa47ba3b99a78b773a0de692817982981b9f430a03a9a0a3566e1a2939dca40ae59addba43f278030d6e32f9b5c73bb894dd83cbd7f56078a4c82bf2a629a23eda19d3d5035fcf2e7b4a0a3b2ed9f39dbd2d9c0a8500524942b22c1bbaae7fb8e9fca807e2a0e814db02a11789701b330881f816d9d9e0f58f2bc7e546450facc78eb20efe18a56faf2af37e4ca13f16be35299bac850055d26c8917374db02475d912ec54a63b9717d0b80a9d8976d950fab586326a4865b6f7a9999dcd20e9976dc2ad2ee8bf5a87260f8b2e7bd4423855057c69a2b3491189ff7d87c5fa4afa15f5c73963f479949c90642f8c53321e9d329036555867b253c9c3a8ef8a31d4923924f6e68f8518d0768b067d73cbb65be60b94c195b8716927ff93aa06ab3e7d5ed9b752797a0d1241554f996d98b39f43ac6800d6d978918a0d4d18ccf5a4978f631c28b2cbd99cd94748da990997b4acca1db3dd19823688cf2b1328da5debbe9f8d5e8f38a04fed3cfcc3f0e431e97fe63ed58e7b347dcaf8448c24861163c4d3aba9b0cca6e97de8e9421b6d3ad67038f9b113314f9d6f95149def447c5efd4c00d828000d726e22cfa1ba6fdef20abb3a755e7763759b236a27c0d567623c5e99f6b8aa8138a6901082ce057cc985ed67041e85cbfc65303ac238af94a51acddb96efad6f2ed3dcfe0022c6d8b71a7373fa62af10ec413589f02f05fe4db496c7ecc01cff6f7a9352d84219212124b8151351ff0d358fba5fdaaac51025ff210972a01a1c26becc4816a218063fe5fa826dcd50c2895d53d5a6a66eb3901115a99b4925c1b928a93d8d6d4b1a8cfb145d413a64ac397176fd49ba0d2df8907c704877f187504a9227d30c6ea6eb9b27bb071fefad8fc9c2bca1863f145dbdef375e5d59b348c611a2f9ffc006fa54c752144675812a171d50b5ede7cc48d10f8ec1a5a9443fd7945390eb40f9e1dfd0341cbf0f4d454be3384b877e645150982b648b3996744b10d216f7b13ad5c8885f3d83441a8a5b31884b3682d04da858cb1260b18352151faa51225b3d7f4c92747c99b3940987fa949fa34e18a44b44717d37bfdb89561de3aab7ca2c5fffe1e051ab736a6363ec04b7a99ec1a33679c922c7db909a891c79a76db8b4a411dfe51f26030544ae7acdae442f6aa6a8d861dd967a308627dabf4ee9f77a3d3600fe0d095e75fecb24cbac99d9976b07c5f65ccd65bdccf94b539bd0b50cb70fbf063ea54141446564938ed77932b9525eee6276a7e08044f63c6bd3edee78ef2b00701be224ff2c0f86fcf7af65c3f39fef3d6649ae148441aff982c8aeaf1041ef7c59afffa0145e90a5c6963514d9c1e820efd2853b598013b82d6e092e95ff2ae6c23f3af369aeccbe5a858e07779016ebb182fdefc8ee76ec20e12c72ff8875f9d74f6305a8458af6c758ea1f5583e461c5e7b8c15d1d2730cb72fb08f9ec237d1b9910f005b02bdcc27884b0b34ec4c7105dcfcf1f340acc223040af4be46a7ff2728d2ee1b73823fce8ac262151781d2375b4b8c0105b58fbc7b83066c3a644d2916638b6beaef060bc912ce1fbdf5042caa4f02f5603e2870eddc9bc6d62251f7255cdcd91525232653658fc3406d09598be6b9a13b7359f868d36aa398b900fe58cf5b30c915694058372929478e7f53e3b399dd93ee2288a07b80b506e68c489a559c7b80b7ded5c27b503d5fe23962c01c11177f32b4141028b6e298a2fb3bf4e4ba5d88459d55e62998d5d58f84a3950b0248ee4d717dafd632131904504636110cf2317b88b8473fd7daf11657d20a0365bdf3ae525009240d845a98fb5f58cd4bb71dcbe118e30a953577d096f8b8f23bc113c585f0fae22b5cbabaa3077b30184dc7f7d170050686b88a56163d68b0f453d9ac907a7b3b45aaf80ad727d1df334188a8dfde9d0daa344ac904f63cae0f1075aee0b3f8f1ba6ff1b9bb82571881635b5854f8d1c723e010d5580617b9df7e9ea86301bda5aa9b0318ca141567e4673ff243e5975a98de8dfa681e612c77d76e30a836816445fc99f53f9e9e9fd36f64c1f0323e5934317ee30fac07e510b073392c8d7754da3ed9403c53f59b0b0e0c46c79d3f484478ecca7425c13a394f9e4fadd17aef6ba8cb9b009687301ea463022578d4cb2e2e2926b6b967481d69e293a08386d031ad3b5a1e2c9a513ccc07b7d9f70fe8e56a7901ce63bef2cc90793b97b689acf355fb4b69f3955b3c7c2526cb99aa683c240098c47e4397870ab8d4be0df1158922d22abf6aec313f84aa9738a820843b6dd67d54a10d2805466df767a738aaa4fa536afb665e3e8f8c1c1900d6c4cd3f6d24574c608ca0692092f489b0eff5cdbf1d38688fb770a037ba25bbed505f9cc93431fe8d4e96e5c271063437beb0b8f9f1354ef46240e15bd698791fc0f11faf9cf2f5a3d4ecffba0cd99d2e9e2e965f0cf3f1e89ee4e398eff9f4a6963c7cf57bbfb8cf0a6b83414cf9521bb73898b0384bdd39e71468ac16e385b3ac5382b3be759445e8a144248d83259c136e2f0dcde8c48ea2c186cc54d3c0fb03d7b23973b7cf039d85a2e4c7cbf035f987f770ee5f721b160f3662f8471cf417635c3834f522b8c7ea35fe93891205862062aceabecd105c9a7cdb122faa9a004fd6ce166eefc70ea958a11be3d0f4d0fb1080410b7420c9d2f26ff487cf40d82b54ca683bbd670cbd0eef107c4f9234b7ad2c3637007da36e912162a99121ef49f43c87430747e965b8e02f2221a4498197f489bc652c4f34ca3ffc631ffd7a60d6fe21cd3e08fdb800ec51983e56ea99e31d7c1d4cd72f984a2d919ddd2a320f42b3d96a2e8d684a8b78c73793a69d968b278618feb24bea178e36b029a6eadc09f332b14b7f09b70d8dab9f7e2fa1e41db4ac2e42d6dd47bff4a870dcdd8c870c380be56b045b5bb0998cec0af14dfd9d05a2718569bdfadd0c9069c854a736ebb1eac1e322f305201da9ac26451325b06bf5d7febe1d95ab84d914c56643d1c6fa97f78f1ae37230caceb399e1a4ce4d202b7b574046fbcd9dbcbbcddfa6f38b7ebb743eca6edddb96fa01d4c6bcf7e55ccdb100be6c3eba564c91f7ce82ed3b1d87c570285dc5c15203ca604284888662280d8fc3711b594a1afa1e2bacfe9e3c6036c779482ce3527543d6cf31aed17eac3262fbedb7982318c7a9466229ad3ee32e3f880e4b17d5c2e30085789c3e18140180736d6a9548bca89083a48acac4d3444c1349520427e35b3a8b8b01aa18ee6f88fd666a14ab843f39768120cb1f9e1928682bf4fb28ddb4a0a07d386fb4ccd14b5982a7008ed1d3fdb9363cfce4ade4fd824574dd40a3388f487b986eeeabeb45ae270103d1f7e5c1789637317daa66e7c5b34a65bf04823f28cabd7c70d1f232ab674290e8735d1aed06dce6d70216b7868e294bd04a686ad95c34bf48b94ac84df862aaad4703a4a72279beea8eea5736dfbe4166e642e7c8c48bff9841e49a022778870dad851b0e8e37e9281e01ba71039405028f6a957a83528b11d99a55f15a593a128b08640e28adbe952d89554bc2631d9688e23f00368e42353652a656ba0506d3441258ce4d7b623f35fd3056dcf0cefb1f6aff0faf07454179925edba9969140de263a9c8230991fb2f566f543d002571cc3f91873920b60b2067f9dd69e02f2518874d705a3764f8815e7ae7d27c001bad795f54770b8987ac59053e64d721a3c1fe31ec25febbb4df26fc338a8b5b8a3d069b79ca5841f14c713be38bf1a43f3fc99400082b062dd43fcf4850496814355d0409e95349a0e13760f11ba95f8cca1ec6ace1d2f48c0e44edd7256f4a3d4c5340f1cd17985ab82062dfbe0e0c33fc0a7b2a881fe91fd4ac3b7f869ede1f7f6b4fcf72fcbf3fa5c299e09acfa7808e3fe6c7bc549c2f9b558b60d57d4b298ac5772b08de2e285cbf78e4e5705d3f540be9d317bbba19629f8f81cd124f3526ed18fbce285fe50f5b9ea8b52aca1ba50c5a9188a2ae4cfb958d43fa0caa6ca8d56d5991b62cf40e25ae49ec3d771087de1c7f4ed362210c50cfe1a614f2eadad9cd1dab3a07f1d588291089c3f2f6ac1b5c258ae5bfa789e718575f841e8c2a5b3b4f529a680422ee0613bed64a59637d0480e4b4e005ad299abe29da9910616e85df6b0b4e766021f062997202bbf89ea1280811cd9aeb3ae9888802d12eff239e5f2d6775047ebc7659ad16cfb971fd537683a2abdb38fcda4409f54f32ac742b5d71ff558918e2a181b7bff807c18ee265b8ecd7d51e206e2130e17b1b3789fdd1c0827458fae9c01dcf13b0db13ad15b94c2b0d4b3a132593a3c9721766ee64df8b1820593330b46f9d4d9637e501819dd7eb112f38858657fd69c340104fe134eff34a946f49d860b0aa00108ca27a98286cf68ae08e3bac96359f9a0a9b21cc73d1ef82bc79e4d14083286c585983a8a877ca77f7b72acde4a5b379953471938f0fb54f430cef953b307f2674c49542ab00b5340279498b84283c313f7083b28e308564bed6ac1187c2d9818ede96f5378ff3cce028835d5fb596f131b0da5378c633c702bee3749175681b1c36110bb8463f4a9075d3272aeaa0e147900a1ff6ec3e63b1e51d29aa11c2525f252327c28d1fdf18edb5a523da7f7f0ad1f6bf78df03338ff34d6670891cfb5a54e657e97c7d50ee36c9e723197a0825cac02e9274b9f0f05870d39b3ae523f92ccf367a38e6c630ca500ddab0879d76b6ab689f8171dcc51a0620105813e5cd0225bdb3315c20a8b4bd07154cea42e1903c33bba1715f92bdbc789e966b4675aa3cdb093b8c53d3cdf0b7f261671c383740b13435b61dd3044d5913311e938d67d954f238d083b6c3d267e0a94bd1b83649edf6f6fb7d82564e9fa5fab15614e4e019a9e465eee0e8a5da60861ac16845af10e3bf429db0ab7a0fd4bdd38d04ca6fc4fc0077ac4b45fcb8bfb6295838a9b4fff87d285d11cbb45dd98ac578fa53d24790ab4762b08e08eb50400973155918e1f9fa4f678fd0bacb40ad141094619882f6b870b4019277de35b5cefbca41d353528e225339b082dc9c23a87278cac4c8704ff7746b68c965b39f89c04820627f87110cf65ad74e636a0a1506801ac8c598b78b9d1e91e7e171d27d9d48a2a77fbec4fe3ae45f967e221447a787496420b86ad6d20bfc369068b7314e150ba5a6218c36d38ce51f412884bda9c8e0a253e376a1c7bc9a4e70b99ca8954ecbea128c652afa1a85fc28cb168bf0e5a447e8b4be8514d39b25d9ff25571d991e706d67aa230d362fec7b30d4d81cd3f504eb4035ef8845ee90faf4ca4e2a1314f7c3fa51d8d210642b68fb771d33e71576b9055c3cbaa92f5892824d9a3f27c730f7f1eecde609ee3b036f10292da446cfda449ad1410d769495ef845ec3139b4ff99adc088f81f5c227fd45f17cab8b6536b07f27ff1bfc0fb563c3514ec37bb37eb1d5adfe911fb0f160d2f0574fb72cb1a0b71fa7c496c80b727a20a7f4318130e9f18e9aaf824dc64b2eb70d178a76ca9cc0561b24878c92393c3857e9224dd74ebf0cf1b03e0dc5997c4e04c0719501d25d4f4fe708d35b4f46383abf1b0b746d4c0cd9edb2cb2b80e2850ef5f50014d9bcbc8be1b6bcd5ce9e0dd9a9e17afa0119aeb033fe8778b18a48c3b42c17347736c6a06170742d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
