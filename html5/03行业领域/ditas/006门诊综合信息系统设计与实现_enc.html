<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1785729a07448def24c93041b6e4e7f10deaab9b752377d82a5c11d065a6c6363d801b2d28616a9eebf0715a2a2a2c2aabd00c0bd5ce17f2f161b3074b1d36a3572785ee5e2eafac989abe47329c3c372359924700313ae33a649cb5bb1c1787f3df0aeebc3d78650fb2af2c931c8b0d2e57950e8137ff5364a94550f0627c1e19c0973dbcc7f4914a9570822b654f43ddcd66f4f09411ec78806283242d50f6b3f81c154e3dc6982ab1d881b40bd0fe2afd2c7151a378add47d4e48940a2343edcddeb6ab8eb6ae7b19b3cb93410127bc4d10a38e8bdcec507c899847156f3eac98e614e6dbfb2be2c83a6beeb928ae645b7ac74703738becf19d052ebb65bfb7a8f81392bb123958003ae408ebef678c780ac13395e7a190d2c238ccc1e2c5b2ff8a2ab6fd73c8ced8c349c3ae59dde23fb26b75fe0ea30595cc4acd389caeb65e51a76ddca364254979bed662172004e30e8124ab4ed777c90b1388603cbec96c776581265ce1daa5e0dc665dcbf41b065571c0d685a0bc66ec035cceb61fa57393b22f06feb161fc5a7076ef2fe62de6ebbda7e536d439a7750e8097f4cded75013e8df14332cc680be20f5405189e868345d92f3e2f5f3063eea368024afec476f3fdd4f826eb5a1ba6deabcf458993b9be19c1b71d89e76851c7bb88757cad44b5a0af0d589b88b5ac9d02ae6c979e890771b6a3fd5c605759582c0adfede1baa1ca9c6295693d4d348be5af9152c7687dfbbb9f7affd17948057820a9eea7cc4dbc052c5541ff09e2f5242158e608ffff95b63cb5c8cad0e5aada1da9af5397f32442b3d5dafed8dd19c2d6e788a45f93e13f2d251bc56963cbfd669c6b18f07df67a2390c1bedf6938c3a5875a9d5ecab20ae14867178dc827beb325764c7144287b55ce7012a592d5767e4379991f425716e696698eed0ca9594080e82f0bf5658627f4dbae052a94f87d3f5e7285579704bd0182b137d4d7636dbe0fb52ea73ba62a2e899f6ab08230aace8a55b2d32eb9949d30cbab91072a51df56933f7dfb10048fbb436b6f9cc0fdfa9ebd995db1134702062dd2d18069c974ed10eed4455e867936a6c16345bb8f9b8bf69e4bfd61958394e03387450004beed60198ea6241d2b791322e62f4dd22db066725affb42156a49047422fe0bf576f0af7c3bc9ae9776edc1c7f2e537469d7cf0959f544f2c9ae89cfcc8b42a760d1928e141a1452f4b5471155f0e43c41e49dfd8ee7a66712b9cae2a05c8e0ec43b91be1dc76f24e563b985c034b2d978c026c5a840b8cddfdee970275d4a236ae8b20224f49cd4c760331eb6e86c2df0fa8cd5427b25e8d335dcd8af31c79da043ffd3b654501659190073d60b30ed4ecfd953758e142df7f17f45ca7c129edcff091f430c806c2a4ea9149d6eb112e16219154a058984535c1c29ef69ed70083b26f07d19042a296d8efa5e1f781b211fb600c039584c25e9cfdfb4fa984f956e604d582d0652c8ef5d5622b0aa0db4cd10f22724f00615dfbf164a210fe60fc7b8c5bfe7d876f9593698c51178afb152d09f70d46107c70008fed624bf6448a535148a944d21362f8c7f8b54d3b302372cee5e20eac0e5c825f8bd174cb6092b77d34d9fbdf134cfb0f4bf023550bc0050117163d4c95435db259c4e671b9bf27d704f60c402a9395200bb08acd4b73675a28e662c836ed102c0e72253aa1358345bfd1ff08b023adc8e739a09909fdf86cdb8c411f073cf95d6fd6b0743f463b00f50d19bb91bf1d620276b1b2715de272bb27b991b535442b2bc2abf1cbb0afe3ebce6f18aae71075fc12da57b4e949667f7257e996d548d316bad9c0bbeef842f3914b1a16221053e48be4ed18525c2cdd6bb47511d2eb3ae053789c1711672dbc7cec6bc790fe04692581aa0ab0b09b19596716e14597fe24a38aca2e0e2e314ac40274859f28acb89eaa1554a5f65f29f24b5b8ffc7f2b575f060c8ba879d25a26d63457304ac46ee645b0a07f1a308c1d95cf48a115aefd446d0944b0c2414eeb6cc7e1f83573d5805532e292ce68e4bdb16e2a5c6d6b71a5496aa92bd407e22c3be6125e4dc43e04e6bd7c9d3c36d5d5f409b9d9de8e3dd65d543b205715a63a1ba8800e6c394fa57c5b2e7958cd59c59948d06fcc14d2a469199f34e79a9a652f599eb830111d6a25c0ca3396ca616286b2be993063e766060028d5b360621eb1cd708322a156b63b9a8de1963a04047056f5fc56a9165477f141e88152067fa37c5ea90471def1d500b3b04d9249e5e3f23d254fc3e4618e6622bdb8ebd8023d8103e0e65a3bef2cd36503cd25b58b41fba9f6d0881194627f3b71163a193f5bf1e8002f57a2e007d44306e859b118769d62157a46be50b5dc25a64464e79c67d8b8e8fbd551aaf4677d21ca4c3fe925f0d4047c786f18417fea5fbd6018a362588f4953517975f2aba00cf0a4e3305755840bda08534c178739002040b8422a21841ded07bc8470d162e6f342de1a45bc0ea036f570cd03b7ae0f8fc1d66f15d5714dfdb5def38365d28a365d25ad7b8bd9c3b73a1f37f2e5fc6bd34831ce0055b3969702e598ff6d763e63775df803cd85e5b5054a7cc87513c5f2d5f5545d103e02c2f32b9272ab44886b94cba12039046dfed9195e119dc1f0b4d8c83f57e5d9d351aa7cd41bbddc83cd661fe2c3548b87bd004d58be3392d9558b13c367d64ec31939b85a06c2fad230c887f0524a403d218862593221533c81f09c726d1a5b5bacc5bada0bc9c31a0716fcf59016dc4b72b3e37419f372cdfc1ff0fd98f24099cff8c04556f9efc2b84ac0662105ed497fa5731352c1a5d3116451386d0de7bade9cbab9fb611440db5240b33a169aff3dbdcc26d9c6b1a3e217a01a9dce15f017cc177f995ad690dad0f7211c15904a19d0f5ca2fd8aa4d963f986fbb764d0af0371c7a3925a999749515e1cead2f33fc6acef927165fed0d4821b52fe937d140d92abcc78e6d664e11831b0a0985123187c0a20b1526d10d8466667ef12737ba95ad1f12e747ae816d00096734518321b56a7363aa628928dbbee1798b9968d48ff8617d272872131138eea3879a81b7ced083106b25d2357c3a238b5c59dba4dba17391885ef5371b1e159eeb5cf5f1dc522f5c8acf4185bcfe3795082d58840f637834646f06ba6f7caca307e3568329bbc24a015e38785fc91294506a59d7e822b80613d26dd18c5e50336b7d741ddfe6cbd240dc632f72c8fb65bb04803050b41e0e8c46f08056b40d3374d1005102f77a2d2c931db63d066d92c0f7029d715b3cd67aa9b5486c7ab3a0e34697965adf73d23ce488d77bfa6c1e6e8a73472a53b6b3d678765dfef67384c7a635073ac1a70710cd570e84f57f432e1782989699b2cd803aa3670b802e5429d5ea8a7f378636416ad8db7964d999515a4d6ecae2ae96b0de977ba1447b06911ffc2cb8292f1829985f063c8b45aa05a9a073b47dc7682eff39e31688f764d4123bf4470db489570a4f2d41d42208cb1c868fa24c1100e39994e2fd148e9b4e2fec444e5f19e308b3c0830a5b03323ba5bba6500b60ae6772153e291b97485414c4d354fe3f1fee4328e5ec7fbbdc9dc8d76cce71a9167b5ba2b79cf0876548bd90087d0f52b03a1bba18f424940e64ea27c978f82d5ee58ac8477c7d1d7cad847b626aa10b9a20d5ba2700872e6001a2a34d01e072664651a33dc5b925405a629462095132a25b4f1270b9add74aab3b46ed8be6549510146a296f74726a06fdf84f4f78175d2dadbf4c45c2d8403cb8ef39c5031d4fd3d6d7e44a79155ed3a680f39e29eae6fa52ab67aa966e6b7893958909277579403402d6f63b1c5143176329b3c2e6a9982980b288a57208243cd1df62fb98b188cd84a67c000574e7bafd96bf7d71d09b06606cdc2a0107e38caaab2b94c2fa67bed46b5abd4711cdfc2d0697a27c935be5b41e171be5a16cd08a0962b281a3956d34cdfad81d8e2ad0a6c84a00f36ac1577e8a7c110ed40832d477149437ca0d438ead0b1a53b5e8827a0bd02a08f2aca5ddf41d2b698c5f777b4f28285bc5961c9af57a034a9db799bf1dc82c3c26383572cf861f4c2a3d943b9d906dd9721f80b8b3393885c2c8cad3c4d200e4cc5cd5ee6785229ba1c61d3fcb279351cc3bbf7eec6f60f53ecf119026425174d80aaf7317afb7bbdd3b86fb6e77f570cf9a6d882a1350440c42a88550c981e08973a9dc5e4a778636018d1e6e9fd82d614f94c26a1d334ca69addb6cdaf2a206809e159e20289d39d1eb20a822159dd270d5e58a85d1f870ee176c2a7da61a75b4af40792c639ddd8cfc0ffabff2817bb36f908bf69f8250a806b24a5542dd638060e260e2e213680c93e9545df0e35c44038371cadc4264fa205a25ebb91728e41a22599383f4578f0cbd1de3a1364e1365df4fd7eb84590615617a12e8bc3adac087a0b4be7b6cb8c6e4fab1f4efc05f4a36fb59b1306c7c77bd3a8a41a291c214002d6b428664926da7e0c61c611ef21a495ff47995e63a8ef8dc6f7f363dfab3f0200ada3cf42041161e95149260fb7e4ac02e2c743d3d2c21540ddc2cc7eacebecdb9eb57a4a988d35ef940159137bf8b60bda4980983ca08300f6605131bbb489a189e9427cb4c1d64761f05200670620d3ba793c300496a8bb3a46c71d60d0dccfc5b5e657009d4efe766710c808f8883c78861432cf3eabce6b6fe0dcd7ab2bc85bc5b3bb1ebb2af85472bf85892f68db166bbb74fbd9522ef88e5ea2ed83b253eb3bf52e5ab687715f7069600b8096a48f8e9445d59adbb1c8e73810ff437a9a3031734066a781a82aa9dcabac7ee29c0aceb815ca58411f3408b396a03481f806841c0a47bf6df0d7f319aa9e35f63bf18110e5b09c7af8def03dd36ac783abeece8dbf37629c93d0ff21087b0ef075c3df4d33ef241930b03d24bb19e8aceec2c8190bfc05ff39437c2867996a828556a99252a34120775a0f354f41977a929f40b752ed25eca52e5e147a9aef41bf81228af6c168d00fcea9dff660a5ae2142c448401b27d6d9f8a09b2917c48fd60d3086426e0648eba7ff49e249bc17dac764a0cfbbcdacd73dd082968d5cc45f1d1875efe56498c19161e9c2605c6f4b233fdfe092a5091e3b51800fd0629f325424dfce33039bbc9181a0f3f0b435de83b54123ef17153604f7052580599ee2508ea6f33e5e14d1e3d56237bc74e82457bd7d899fe72ce4862ab4761c176730f1fb0236212cc71c220aab1c53bb50545e3c3d60ad0a32c6631686a425b58f67091c3a890b8da976f251386cde60743cf1b82a5cbc50748a286d6be8db792f2347f838e6aed242b87f4e57fcd7f7c70c914c176f36f6f5640f8ad82a9bea3a2a44e2c9e465d6b824c8b237c7f809e9041f8ea5412ffcbd687b88fceffebd2369e48b383f998a0cb3cbc19dc8f56152b5baed8adb329f9634770c250fb4b9448b2e42b4de5310ecf72ac3d8b2e8631a4c6dfa19a7d214b93826a3e409b124c38b4bdacb35d35933145fce03f8df6657485a6ecfdeae4ecbd44e02740051b803692020704d87856f0b866177e2f5f53064e90cdcc7c58dfc063246b6565dfbc1890c6c9c294221257b4a9bc86e0206627b39254806a925c2374274d1ceedaddffbace4e581ba0687099ec46eafa4a1321f3e72138068de02b76c7169b05fde72acc58ea139527067224b38d35735b1a21e68edfe417562da5f09505f2766f5ac2511c496da26ce640a992e15aa16dead977959510b0e3a775387476e3910042b1d049fb85c76d2db45c49edd6339588b3a43df37013de17ececc01578b1e472c1b757c7f8d3897d68b4dc32d1a6e6857447c013d465237b1af8e530746f5fa8de62d200f1803e7f34ea5e0eb6efed68652a9fc57421c9ea0cae95fb41c41756fee033088a93185eaf7e3b7fd3f86d17c3a64eac2935551c8082c7cb930a02897fd0f0cdd8f58bfed0dc3bf8318a054e55f87a541dd100792aaa968a5b5a45e1f4e01c50964303d9d1f089bd3ef05b27d85647bb90096d84c927ada20d4dc5f2418a24d86ed52089cac85889bd6a13121bfd3e2aec574419e47007f5718307e9a88dfe79dc549b1e3311465a76ee984810caae134c0553df50070fa5b326b5db1b1d6832e6449edf2d6e9c4e07816fb1bfc7161676f45bfea66fe7384fdb645f68c13b0509a8ed0d225b7533d33057d5a2098577fe741047971533d01b8604565059cb6f47bc34200d0adf325e8647374fa5e4e5327ca4172e8b3239043ccfaee00f590222e32eebffe1c22cc1943d79c59b5ce72f2214d9433b8e0b0ae2c3b94f7491a33a3316292d2afe9cd616b05b036d3e30d6da98940a20114abac45187ba05636c6d43b5de2033931195802be28d356b69a1b5a66e721f604fb8531760bdd7a5067ed22661ca62a70fdf066ed34b4e0330dc83360c3b3f172dc7090ad625e1b6074106f8b83509604031ce50b9bccb8f3dd20b4ccca0480e28ac153d75059e94334892006c753278f87a2103e7fae2fa8796c35e31a4a324cda76ce9b6f151397056a3ba4d9aa040f51b869bb5934924ec1d6b327dd33aca2a25c2d6dcd7801f961a3dea93d4dcecec5d46601a882c86b9b94464345a92e9a2a3dbea0ae06b98920b262d36af636919bc22ff54310fd6bfa156a4aefc59dbac862e35a67cd3c3ce06dc95d6a082d5c51b2919323fc71f5de44c78cafca2e585565b4ca7851869f0d3e9a7523eb2f6b4bdcbd35bec47520b30996f1849863a0f84adbfb18b16338f746eeb489c6f67281bf1f457510d9bcbf6327b01eb1c2d3fde6225d68716fe740895839277dea5811819d0d7464844cd945627b2215c7f3f90bf0b7e337c288c5f2de52e6c885c22762227c75e122271116058bb01a3b9b9b337a99b6007c3f0a6d3e708bfac85a986b45f8d38f54882c60b8e2b1e91f004747cd0070edc9ce2b0dc3fba74730c32b4e624fe28a4b3b07c21fa98d4368a4fe5dec6af306b8b0b6a9eb2016fb3155fba9b5d7e1191a2b52f374fc3eee6e725ae8d81a93f9a8cb3641f34d7787bae90f9b4622a4917e4b61712b6263adddb2ed4ea8c4ab09b3a2a96eeae6d3ea98cbfc49f4d6d1e17bbee3d490c9e566f27cf0c649533a1ffe38535a7d040ddd1cc00a653af3e7d550977ee3e0cff56719829dc895325a003fec12e930c06354dc064f3333052f43bbea2f6fc56bbd47cc0fb780286649a025f671bac980b197ac5e282165e4df583da44d3977c70199d286a1b897876b24fde95c6dd87c39724c94921eb0bd2b39e446ff695d9a66df8935eacb0032d98a964d9ee4dd950497c7ba062b900f9a72d148a9568ef544adadb0d321214bc3d5c2f421eb5ea599cf7e77982e22f78b4171bcc696b910408fc2e904d02133f3b98d7af864dffe5048e619d4f02781759b76f86d1f65423db53de32bf17219501fb75868bbcc8b781c1bd7e1a3a2feba06be499db077d86037e757f275f902ee0d8628595543de7451e3739454d3700b95778a2c61ce80ff868c667f376065dc85d0fae22e239eec77bc6ab33c37d7f42132fafc9d80c6ec61cdce1aab24f31092a2a437bc3b2a53c2bf4e719c9ae890541d6ae5db206479942aa56d766cf5712e94502466180cefd6c063ed4a43ba6f141dd25264384afd6311016e6567452943dd9588e35bc59a58bcc81ff47d71efd44dad97d7791d48a6fc45ee05d3854960712214d5b3076c60fa754dd0aadc42bd8f091707db48cac55bcb1cee10bfafdc8e0a32b97107ead1a1704d256ef92d504c3704c48873fcc9ef64ff6241954a4f3f0d6335665a52deea2fd7921754a70828b266aed6705a39ec3394c8d5104742657fad1ff3dcd7b44a45dcdbd948657f264f699956ccae6b2276a48accb053cfc199d2ed82558fe91a2a98adc28260f31d8a0f239f6c063c777b11666984ce555ef9c383f72ac5f246c6b1b62b508084e900d79d3f6e1468a54f5c53699e1b75c48aaaa74153fd924d2046ef915eb0e4b84cd1e41d52669ac3c856ff1dfe19226440f8824438ade15394fab152a9acde00575946388e30cf62a2442180acf713c60b1987cbc025ed31d3f13b51ddbb37505c81b2049190cf48df4f211b5a3b8cff730f34854597e2b7b9e3391460cf0a19354018189b085e6214636e66239c3f2a78df3b185d1254e4058715851a6bc90718c8b4537e38cf935ebbea3b2b081cc959e7099d6803a7bb091150d571f25840414d07ff00017d5fa0df6c1a9e78095be3b0723f805dee4b813d7933903eadb124148ffc4cb3ab960fa51175fd27d1b7a0e2517c2cfbd2352e0adb277f747878c2a0260b0b6d7df339f95ba518ed4905e3082fb144546a511ac77257ac364b4fa9e4ae84df61ae98f4e539ead98a236f92815553c4322e814fe5f209e1dc5203e7b6ce3c56728ff6c626aa390a7d3115e7acb8dd5894fb21c80fb61145a1b075e8a60e91117e46f1a51f5280c9f84e0c265b5997170b2da5d5b04528c239b8a9e40513288099eeaae22a19a238e5ea8f1fe171dc95d854d9e73452a791b941ccd518fe99bbef17ad9838b078f7a1a8277773c6944ae4024a2836cdbd270","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
