<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e601a851403eec06f4a8c4cba8c57fe0f90ef499e5840f5e22a321c922a5a9b87829645e64d2d0b82f067bb2beed23ea1f07d484bd4f6a93c63035eb1056ff9e1ee8d34a90f8bc77e63ae99e923c5e17b2620733671c0cb57825a2be9f0d023a22f92a5ba767ca5429ae89f5af836674a7f61b6d0ee1d6f909bbcebd525e03a49d3a2b69d16d6eadd5c36777b055f1cd1877bc324679dcc73ff2e50328505728b9ee938930b5fc480b456a34d6f547b1aabfcad5ff0d33680bf0f61fd2953ad01cd0a4fad557ba86341c0fb86b0fe1934b06da0f3590ebbdf185742daf19364505c956b6ae7b692cb0a226174fa2e23854bd0afede491639cad189962a51c36128a1c8a126462d16b2cb95f1c57a4b651ddfe7b338548b7d1e743ef8bb6d199163aa2f87eb70d22a561e3227952eb67d9099b363cd8e48b0245a46d54032422ddb9f84df6d702fe8726958ea41821f9174162bdf2d95ae58f483b1b2c4201c4ca6e9416cf974d70db9004959ff7709df33799b353a83fd3a5c28dc5e22896139d880c1052d53f17b2c286a191d1d07803362ebc940180ff469f08c29979aa1f2105bd793fad2b210c7ca867a9827201fb85a2f9143c795fca9afcfb9970c10db6083e6363e0e97ecf1113cc6803c96e181b8f24fd11035bb1aa6db599ce45db5d80710b71fd2416bb5cfef1ccfd9bd558cc68da0f975f2b35afcfa0d902908cf66d34fbb932d7398de2b300e6ae94623ec88b1dd001a5351aae14d54ebdd4d5acaed7ba6b66c832ef18722cf31b61a1818cbee3492e426b7fae121ebd99411a8c446bd30416381f839433333204c29a18316ba574a8b0f4d8c7d18d35632ee168936e496adc06ad843ad3bd57d30942595598561e19a90e5e45805552a03b9be1c4dc23b5498b21e2d70075f26f2f9e90706780d97e86636b7a8bf243a88a137343fe6494da8c84b4c2f74623af6c5c51347a827a9709ddb736b58245b4ad0426852d8cfc20a8329c55eaf7f82c5b0d79b989b68b36504387cb44c27a67f4e83b205a78de625669c911dda7ddf47614d527daf6d8d8d24dc2d4aa2e32e007b12e2c46304c3840a9463a26028e540bfd7fd9cf3bad70f3d704038dae9c8a7b2ad48602d6ae31d88ff138295fa9f2b62bfa51496888eb8daba4e887ee27bf81b239c8e99c63caa6996449a345a2982bdb3e05d902ca5623caa7922fcca86251f8578ec2544d07a0be41a18a81351bdfc3ec2db62e8aa4bba96d0c6046cf9aa404827efe906937016b528c9e3553983f8263787a425c474193a0b755e3ab995f03e578800f9ebd2f3ef27bf569fd733f131ee9f1c224d0e6f6772350a69371aef8d00378290e2db35571cc632a9ac9d855eeb1c35df0af6ab85387ddba005832c8cb0766d06b9b8424ab7ddfe21ccb14a024bfda6e20d0287504cb0048896c0d54aa8aa00161ccc06b82c2861cfc3a5e4b562d93c3afa4a4332548be667d8fa7f44b4f4a40f20e73e85f50e7a83a27db5b7d7205772d503a687c111c407f5725be4b43353eec47c756d6c66933e400e811a6da69e59c977e2b3afaa97bee87e5a82af1c8b0ed1ef756a656785f73e44a748449b2e244b40c18117ef4054dd720c0c439fcac8a4aaf2edc181d9a2d52953f8cedf3558d1b40f5467c9e2c4208160c1ea357aa1ce48395832ff9c7566909ca1af7eb99dc4d37d4a890b6ab8c38044c9bf28bf2deb6560f0bbfe97f3799a6fbef4c69c3113810e9d98c70578163d3b1cbeac004d51c6c43d276efdabc1b756becec65753bf4fb296ffc063f11ef89be6121ef5a15c4dab8bebe0a51ecf489dc8ca9c0ce4b8d3398c548d052e32f8ba85d9522ac4348ec34936ab6d142e61fa5505dfcfb5bf218d863cff4ff67941809a8c761d8e345f2507044ea0dc8bd5e2092e0438bec7f896ee370f09a162b18526e336321bd5790d40f74392d49c38aefb90da2b2a37e133f55540fc99f19c77f8dcd656717c52804b9d546318d8f7a9bcf88a32d46bb62ddf95fa3bde35640e9f7fd5721d6856d7ad532e8449393a440ebbc31305387f1006208410afce9f2fcaae02f91d8d6a8badf89fbf02a1702a5f9bd73e6abc095e4cf3f9d63c1914fef084a88242e630dffeed50275dac0b60052d3e07164e2d08489ff4429b7ea7d3eae9eea195d485266b817a28a68d7fa638eec1dac2ee7cf1c06f6f4a22157c3c7a641a7fe8e56c0388aeec66ef8426917f0a3cd07e0743788f49f996f5a43f6eb0083175525f94287ccc9c6940c188f9600ed3cd3b5196abffaad48e4bba9873f23420823196e9962077f41e2d71748983cf7046cd6b7f8573a5bcfa1393703c9a20caf8f83038e161d831bac991ac5c660e22dd93317e80e36dfa78ebadb00b36ab2a09e4b23cb63d0ad1480fb0151aabbc66024c66f3ddaf2969caf35c98abf1080b0ad886addbd507fdad7a826a6b760474892a48cde7c6c875eaf04dbea49228e3b107159a141d7b015212677b2925ce9b7ef6edd7ff0dca0a21c5fce53f90807787fb74008c9d4394a2153736e577068a5dd7414b8347d3c80cf284088eed9a4935f2c63a55e777941460dd7d383da368453a8707b4a51e79616877825d087416c242a881bd48fb2a603baa334a49ea37b2378640ec18e715edae82b783237841a959d87dcfbf34c804b3a3e54922fa6d64f31ae00d2a21d9c76d935fbcd44bf133717701d56be664621d2b81569d75a1fae0aadd9fb285f8f488c4ca8bed40c96ebc1a3ee4fbca3479cbcab54435d4458daa6ec01b4932b2001f274c29ba97ef3081640ca5a956dd51ed5a21a5e576de19786bb35f4081998df2467f9fa0158ed9844370a51876decc401466570509ff7c86eb74f604366d31b68edc585caf0704ff2ef9d7bbb18cf9b06f1594d9131d03306427411ad0ef68fb1ddbc274450e543445db91b79c4602ff2e2bc72bea95419b04114c4e3170e8948817b78a998f92c32c90221940a2dc04b9253625c46fbcac70f99b13adb8c64ba35cd8cae651b984c3f45dc909229ab78969099e5e6f811790f2b938691d558ad755ae30e3ee544f3c8127416921573634897f2c0cb1ca7134ab337ed03bb0cdd07ac257f134ac134f333a8ef1bef32f209fc7889fdb2271ca3dce5d5d7da22da614e61bae592386d0eb4ea80675d0a1871d30fbb29a2827345254ee8948beaffb85a8559a027da8e10c46d18e4559b564c6f824781e7186551556a889024be81a41c8691e2550cf65152b43a59d33451743a3c69bec55fbbb5a71ba88e3b600fe790a3d4c13a6b874e8dd6e9f022aa425940d2d5719155c54cfd078a0ad0cda3757ce60a2bec569df9e4bee8f6a194818e4a2b9d5c1cf5f1fb4fa8bb08a604fc57a7499b95b7d6612cf1e27e9578e2ecb1016bfb07a2c5353326cb680097f0d1a04930eff05c332a2ade13b426a7df72cadb9f3a4bb89cf6c971e24d66a30819c9c84945899d664bff8eefc7c49a5ae536a38282788566194a4f49a227455130847fc16094c8c99e41efa616e5ae262b39b0cd34ccc9095672823f3f4cab7e4a6751fcc5b364be3624820ed0f4c434b3e5ec6b9d4f1f94f177b8b9f61d73a7b257a616cae0eaaf511a8cfedf86ff3c43f2ca6b6899c6bed73ffa2e8da959f148cd67eb3a541286e379d292e77a2c184f18da43d01546775a47aa89f64500badd55f0f39057c083d2eb2f6909be4f349deacfa5daddf5b17bc33f43bfcd3212cd7340421a7dd87b55f2ca1cdbb14716b179a21aecf2efdeb6421b934a8afa7929d33086f906a854f466bec7ee3842c6f4871b1c91ada5af8eeebaa630acdea992ff625ef99f1c24c02ae3df8761f1500327d5af221e1eb7de047a8f721df21772afc22b199fd5e2652027b87242e578b2266f40de9fb1277056a6da9bb966e5128f194a297cb7c3869e7f63b609412c15910c714bf66780e5255270b4445e30257b765ab01f6f3724f532f3108aba395fae6a624c034fef23f1adf0af7f22506253e281ec112c4afa712f432289cc0da5f90d749947c1d6f62fdd2f089657def94dc0a716f1441f1fde12c1929f133ae920ca7bd8c2c915b683f7785b696830c5ae0b6a014c0b61f6c0a12898d6de47c58695f2c91d56fe8b95a84e607f24b01a5fbc5f13389feb8af34be354a5cbba1e6e38ae1086fd1f143625248190231b1f1c507ce37c5e4c46490e3d8c329712b0b29789f1e5c6215070fab3602742eb1f1c32a4951e8dd8c089ae35714c536cbac4175493c5b0a2b37cea0e7713c1dd0696b4035ad497d4fae668b484bd86f5d40391de53e7e13377d2b7b5d20519e10406bd495334a6f1937b8291403f8378944f83f4c49a628aa661c8439289f7d76a3b6beb90aaad31e65006df14e66ad7ae70228479b3a848adfcd089c34262c3554738a62a438f58e0d03b4230dc7356fe2e8d6951775b2e73559eeb3584429cd4c90907550a577624c0c926f3276dcbfa32e15ebf4178342b353be2b1a742f0a0c91a8f32837979f99eb650549bf55300a00851a2bea25ebd923da5e49acadf6745664e1a65f059662b131402bd87ede7d8d55bd0d6406bc55e08e1cc8e6fc87bd3507bfe571eacff16505c2d93abbfd6434704afffaa064050790209218867e414629f997ae07cd517dab96b9f109e94116ac679b1840c0bdec522e515392f52e8d49301a522981c196c4a0284b5ea809bcfbd52a372bcfaf087c6f5eb8277e161624ed9d209ecf023254fb629f053937dcdb14fbb1139ea505cc25783b1c19a253311a82d77952f704f21ca1b6ba6f3f32ef8f266ea6e806240ff8979d0dd1da898fbaa4c004b4b5068cc9e90197f8372c5fcf0ac6bb6f5349cb71da49d68304c001a4d3b2c9ec23d41d69110695c3fca8b798dc327f966f29ca3dfda9c7c453424321d68c314845d0161afd84a2e81ba8a7cc99b9af2757bc8094faf447435a0bc27b342a9900938d5e516dcc0513205bd3c865532694656e57e34114b387d9e6790f4185e8e28161f1c1affdd81ad929f874f8a05fd8b1ab0b0e6fef77c61c3adf0c2b1639c2f628ae89bd9c5325a44a41448963cc89f9151c0197a9da35095f2867aa775c39c2f98895b1dea4cf223a9a1e85c7d7a8b685e557b136d45b2522b625d0453896634342007464f638cc2d0998c054c8f1b5bce78ad377522bbb4beed4b7af4354f698e39a2646b86bb317f9df306d63f60f530617fc8635c4d2d68bbe4b0de609a35bd8d2b705bf7b309f56ca1a026ec05f1506949ede616a42185bdd13f0a066028508fac42ab00852c5260f3a107f4b6e17f9350dc95a9d71fd7b71c6271388d6bc403a658b6aa82cfd99f95583de981c49d848f1d7496e6aa2f7d6eb1babac01e2d1f92b8057ddb61f66d31d33bc75c709bc2c70ca4f9cf1c8db14645d86eee8411e5f7b7d29f77271c1cc87c97a5df88caabf0d82ddc6fac3d309aca1b15a5cac90cad1ec5c22887e4bb9ef8bf7b92f7cadbf329cd5e1859d5904074df66a1a3c6c5f23089284de5afc9f5a13dedca5d692d62e9b02167c7f769ef7b435c23e87ccc88231baeaacfbad3069d0e41dc84ba4bc2931c40d4d18fa116c49037220d399b728b0dc5889f5e5e961e38be5f8d931799731361b1f765f867076fd954da2d9bfde805f0dddfb3ce73a4fac2eb06d97b7b8484aa7d6b4c8f8e54b569e86b84592b3d1d8a73a5adb4cfb3b9659c74d25befde0c7d3d400d3f5fe17a09c9270753dc99861f671d6c1a2999e27842872d3fffc352889a4df6ccf9d99c647bc686f94deec5eec21de49bb522e3ec0d59f5784000cc2b8ee16edbcc67af327bde3a3f8eae32cc393fbaaf765fd471ef0cab3e81089039fc92f05d90371dad0ee4a85226a06133cc7ebc5524cae5b09c66906c53e8523cb13e88bd847e85360097864f2dd1e0bce1a7edb772cd557d4e919440ad9e8322c74a11c7187fc7a3c1ff86fe9b813cc9ae3d4f153f172b0dc2483dc2e2835919287b1b7da59123e82b91ceca2d1d25a21eeac036ad90a7acb5bc6856811b9e750d74caa4dc59659efa8a75a697d5199e116243dc00d409b2a0ad15c7c260ef72f2b243cd9289eb043f35c213030810ea6d48a0170df21eddc120fe43daeceae424fb07aa61dc7d71c1ea8d79e41f65813335622a4f14e70f4d7bf2088ce5cd57fc99cfebd5dd388d0ff0813feadb482115e7dd0abce409312b99557288de94e7e526cdfe2cd2e59947d4d79cf2c8d75ed32b9aed8a32619f0057dfb50665e95fc7c819667aaffac3f752581d44f272d68df1f3b4f22a7d865b7b5caeea7c4328337b395aa23afe1c48c8e9abe0494e2922f4c8f45d0f1ed3c235e7db35d2b5288b2f8596a5e9fb26398d31112411a251cf1c747986d41d415847468213f6952acb0b9d05c49cf35945dbf20083e10e7a223b7fe54d94cb2a7d75d51cc418157d1989fd121cee9ffd89eba2cb0cf3144f2356ddbd3f923a359c3cf5961ef219e65ca3d92670c2563c5987c5c75eab088b4e9f1aeb0a53d0cb0e5e97e3ba0233371cd00592663d358995af1a8214183cea0b299cfe47ce83ede778d1ff3062964552e1717874b5f008dc694c98c4d6f9de6d351777ae3e8860cca1b5086337e96e57f77d3d07f250775958ba450fbe57fc1e1731f06e4796fee5e278f5d392cfc3d75e1c6d873b2bc3267ccf402724e0c3bd3fcc30e89c7394fccbd5ffee1bd1e498535c719a6e3297b54e2eaaaafa1c194b041fcb6d054d0b4ef8c5228dd1945bf0691624038dd5372e18abf51bd380bbc3e52a46aec37c9576d87327eb6ee063f2ddcf8a212e6f584060ba6dc1574dbd16b7df7bd7a2cc90063a7f6fb0687a70183dc7dc2c600baa76d03dd83c81f228dd42fab800c4ee003a98017a9c45cf590fc8086fdad81e64c78323ef10da1a9b1acb55035d1e6f30fdf9d1f66161f96b4fa307a761dba20754cdf17fbf62db4fd6aa2c3189707ca805e375215dfaaf5a21e1000078bbeeefe955f4873c2ff748af3e32c257876dd5b04a9775475ea5029fcb30d057ec20745e1efd168fe97409bdcf03b24514976f103071241d79c586fb104818348ae4fb5ea53a47e21a2aaccc754c5511ea9bb9d604eac2bea30e060d129d6a19ce61f801faa42afd894a47bd71fdcdd0800907c6560f1851dc954cb99acd0a9eecdb787a62829440f855b6158b853dc77ca176cd38ad5439215a9086a9b244dd5cda71b605d74f3b20fb7d0448a61b280f32715bbbbd6460b547278a6b092899f27d469979042471c747166fc3aa9b15a0089f79eecad9399ce112b0b71b12a4aef2d70aae68262abf407cb9d1f1a47768facb5fe673333f276997ea94e590222c38c5c447ddf3e8f1432782006800d822006a36c7c3b8cc17d8d5271809f04ff75c793eec2f05f80f6e5443d9def76a7b20c460bf0a489009084a548b4ae7a4b28b67951686e6b492560b363a9f74d2c4b120d5f879889af84ce445ca6799d78259a107696c3a2fb58c5aeb86dbd42c143944a227f066a2c1a9c2943f7fd8af026123025432b9bd49ab01cffebcc64007675120b6add51f548d8bc49e959eeebf67ac0abc950a7129363306fea92e5915b83546fe2ceb0f631d22900121deead83719c8f86e3ee255896bf0548722a0a10389f63e8a946a543075c7634010c59c0200dfc014b1fef890dffd6c0c1c56270859780daaffc539e3d073aae7bd5f9d5e0c1853f181c00d997337580d34af655224b5ab0c4bb90111d6b74194665634a5c12a5f490625d7a70758fddda50f97b11edcdfeecad1bcdd2d9a825de5a2150e6d7d444101b3a4e9b1dd568c67e7ac287f7b9dc50163bb9b82b87cb77193c691712d9972bc86fdf4082fbc6ac39ab11e54975e5c58d6de24200e2996d4e23e429370da665a3bb1d3a50ea6d81647628b6157f8e5aed3f8d424d21d2dfb03e7c572d1ec2747263dfdec3d99f6f7dfb7f635e891c84237dedb4912be5b0bb39ff07b052b6b789c3666fc51f101a5f9f1c1fbb80fbec21d650c4fba5dfe0d8ed0bf8858f582568d36bf4f2bfdcaaa6d23fbe9656271995d03c7a2961c66ac252c4a8fd610067fb24f64c25339cec8ddfeb686c496726043e1ad77b22c8b8ccd5a12a345ec1246ad37cb8d86fd870472065c6fd4d9c179430397a1a45437addf582e385e26883430d1ee79e17450f739b35699efe9b06cb0828e66250edb9b5c67024aa599a2e6b8a7e364ed5ed50b850dd3437c8244b5bdbfc2f64d9591b147e1d5c765cdd7d3fda92877f96273fe65b63b74a6fa90566cde062d02c79db1c7cce79fd44fc168104e936d4d9fa4c6d3cc432f61cd3a8df3526557ebb01a7f022ddf9892537ba817ea1d9b25fe243f86bfb80ad96801c79e8ae9a8274a678abab2ea0f011f70fa40b37a79c65073ee2fc6de1ebb5a68af8d66e9c7c2e826ce12e735ad1d88d8cc84be288d8f86a32814061d447e8e4c0f271c16bc7eadf4b4c3a46df2e794f478375580134e5b316195465599e50b20da206cade3f8c570810c8319c8afdfa84c62bf7dc5fd9b50d4eb8daf97ad2fd8bde243cab1f5a9a0e2a1ab5e2669cb0c3423ce8ad8cfa04a719354e5f4fa612d52e1891d98fbacf0e5d92d3559314533f9ee519c35c43064ca5edb6d1f1c14b9f727604755995578c044134a4453dab03ba75fabeec7990d02de9e71cdd153d7ea3fd4ec4f73b0d12f8eb8f39c4189163715abbfa634fd9bf581aff6d0e502bec8465c0d813044e8cbe09babb82c36132f081dbf83578ec20b30439e4f97aadb80a8698313283baef4151e7a92268ae8b47a0e70c03bef65ae9fe24463794017a06b56c05868a47db895053e44dfec8cea1073e1fdacffb6b3bbb62e2714c6bcd72d19021d9313f108df97c306108dcf01511a77b7cf0708fc3d57e5bcd29f7bd3f4f4b6293561c26904b817bc650387ad76595b4e0c1e1199a0a401f2fd55d063191281344b6b94bcc47def93715d73e72568986fc913c76413d1201c0ac19103425dc477d4d6e14c5be667c4deaff29eecd6cc2964e79fa5944cace023a488cfdcd7c481e1b18808d03cd0ec999a44ba45cb1e81faf0bb25c04b20bd732f7f5ace365041a2a337f160da96c468a7ba1006f3c07aa8c0458257f49c14857ddb385ca3e70ae0c51cc77275b4ccfdd66e4deca9a74f150238fe1a855d252a722921590b74b94034c2ee8d54d34855fdb55f2930a5a2f085b14d3f1ae4ad105b0ccec646987270b514939471bf4316c4bf97d8e44743a6d69fb5a27a024506edcac6fc45b2301cab8c337961e44c573a20ad195a85a5d7e8274656c3031cbd0b17c0fb39abc9ed28f2eda8d405479d72e654f007d0c9bf30355bfaacccf389c77c320d0275265d3f317ab11453818c01af82d6cc8fa5ac696d0ad91650bdd54c2a1c322b7f8ee73e3912a4cbcaeb2d4cf3a310e2418529a8cb2b94ad87db88cd63af70bc7cce97f9f438338d44c7916e6c786772b87f8b20bc4efcfe1633e8e02bc21091f841063ec558ede3ffbd7e08a92216c5ad2b95232d4bb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
