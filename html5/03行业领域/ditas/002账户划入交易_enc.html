<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c6c6109bfec35bdbb92d4d37cd60659607c2dbb54d0ae66ee106a73c63531b1bfb4b21ba565d67099ad1424a8601ffd711284207660b360b3217ed7922f367fdbe4a830046e42629bfb8f23ff44f301ee3520457d8a44d3577358a7b805d687c9da40eb123b808cdcc21bc8fd21436cdc2ed5bb23d4616d5d8e70ea400db7d2bede0b2d86c09573074de94054df44711b01a88bf31731ab5d7be98c2187568192d7fb38546ec03e6bc1fbc5bc0f7c830239980beac2f4659698e71bb06ad7a1a5b00e8a1595996580864369d896b476cf33b97674eb92cd0f973928b949ceaf5e0f76e75b568c27d6e14ced8a61d91ac7633d98830ca6910854571c87c153c9637c8b4d793e54cfc40149f2037b014ca313875a294b4ad97cf8515b6c48194a77cedc2439c6ded251ae095a439ec4fea0e6d2b5f1d60b0bade0f6ce35ac42d0be98fc50c3db524db150156e2617288f33828482245cb885226e8914770285c4e744baafb8826874febce714cefc6bfa855e3d4b27f389fe890db936b41cd00174282679f385eb07b1cfd737a34bbbff5796bd41f8ba9bfd2c7990b718ce7336a482b9f955d4842877d3b88b90c2473eab36b2f119dac9fcfc2b3522d04dcb428bbba9b7edd614a3a6d8003f43aaba9b1fa129046a58a52aad2fcecfe2061f082d6bedf33ada89911eeee9f1146a0228117084af973d0cfb3cffd1d1b4f516e8834f9cffb39bae562fc67477893e47c5fb496e0bfab9ff8dc32f95f0d531f3e7b6f0d5d97a2db8881996450b5cd9493465963b450bb855f631b2bd651c805ebd64595ad7c85170550f877a7b50ac70711bb1bb965f4101a30ac7c74e184dd59bf89614f600ac368982a8c1a674ce8e3a99d6e00e3b9eeb6d2d8fceb8ec78f3f83ef237b4f11c856d03168ba11a73233190640f4ecf6531faf2897a38f2322982e1de65fa84b39db279d4cb4c65a41c04d1fdbb2fb99c072be770d5cef505cabb531a9a4cf5e9a9720903dd1f4fbb833181aae1b86e0980f55d9e1b8fbe35d4dc28b65812b82114c661ff9035dab2e9a07ec8420d866942e03b982d55d06c38df45649088f6e1f92c00511e5d1d49df254c3a14b7dc2ff485ff05cbf868bd249531c79625cba0074eb683c1565924be9d9b34d8b1305b8f4f387a3f6f57ee02c84f0ca596195af6a1a58a42ffcaa8f009171f7f549f338a0990d53bef4a9b9575bf8fe6477c39c590798204e236da24c24078477c87e2dec8f609e0da230bb5c5433bf0d2f23774f0c04a3241c6a17e1613a2ca4ba48a5cb6e76af3e6d81cdd3feb500df7f594c5cc1e07dc78ff248eedbffe99327ffde958f1227314243bfe9ef643561a58503da8bd3e6f0a44cf405b0b9e2a3a6cff4cd3e8fa21721c1d7d491a9845b40cebd017ccb209a58343144d04a06f7d7b9982db876c1e74edf9b669b6cbe7fa2adbd1ceda540a0af5ba81178b88c2f2715d1661c5d48df49e8f8d55711520cd5ec47a181eca6efbf3c89917066cdc65d6db91b263a9464706a6d79ea32ba4ce9c6aaceadb2ea81754db4142833b08c08f07a2d6495d532909c7c686be23a90c2fae105c1a2d88c4f71c3af1e2ec058c790125004fd1cd2f5f3a27a2ffd21872c2d7fb6b5fb2ed349c10b0e7d14b7e97129942382c70ab15fec7d3f88b4141d9b11f5fad80f7348666dc9af7c47982cb32437e272f4670bb1c3dcacefcf63300ce47c15ddeddaadaa82964974a8869869020d86ab4670bfffef7188dfc6e764f22b0453b791a4c07535dd0b415aee866ed900a48d9645dd1f48aff4d98e686b0a159c586a4dded83bd8bcf79f87c6bd7efbab65d5022dbb7c660acd2559c916b3bbb9fbb39248e7e2b116f532992cae162f3683e6e7112259d2783ee32577da616f8e8bd55b0a32d7719c8e9b0efe74463be8b06a14e115863beae01fc1799004c140bd7bf25f1e0a3ecd01666284066a71c778fcf40c2c8415a6383fb890bf0849ef02670b5c41facdba5d0b4cb46268343c5122d41edb9edb2b5e084ddc72c4e2d6c8aa667c3511c8314e0f0c0e6980851b7707c3d461bf1e9258b5e4ea770d5976e3a9c99473d8e1708acaec5878dc278659a844ff8ef0e7627456296d1c76dac794d32069c275b4f32d3dbd300f2b079f0b050581814c526096d0dbc009002fc3a09e9d1d9a29736cbc63f775903d00776220cca4bab80491400e88b41e3986d3391133bee884e00b4360c6a6f629cd5d3212934239db36583d1a1b386f7baf26b6f2bd0df9d23fefd7503129fb5f984485a105fff7e70a82e122b44743423cc724373b420f63b5b0ca4fa7fa6da6a91c8a4acdb2d79043574a94ca6087bf6cb360404843f9149d132e93a41694ab370e02ea3bba6ac95b7c5f014fe9f7748a42a7fb3016dcea429b5f4a83cfb7d067315b7990e859521034eb34833706a8606e6b993e401905acda8f4740ba2b4c9a8ef9ddf14f460e029f7b4a77182d8cf149455ec99920db4bfa6c4baa76470e65a434d84f7bf3588e58e328e5993e1f0cb3674e2eb30d67e5f45b92c71688dbfa2d297ddb9a2e9e951fba01101bf8b5a8ba76ba449dc198599697a4d3086b0dbd956c89181bdc81ea0a64ce5040f28b185f9153f20d82020f4f0c845d0fb0f7959fc0333e3e0f72f3245c4d31ff181695c54c8534567a309a103da4f2dafbb0a45f9557c2ff6ca773c77cd4ca3a2423d54cc98a107f50022ac3dd30e3007e273876e4fcf173cd92771eb079bc7321c9160c269ed2f7d097c6baf92e802b20d3cd10c711a43af472dc95897497381442365eefc90a546a8794da8e678d7d12f2e2e149b87d357cfcc5286436ae1609ed074d52ba35e960cd141e4a1ea15d60f06bf0aae596564e817e5262b3f2f508a12866a365b01b11fdd87739e83bb856cc363f49bcadad4d1c2ff48183069c3734a5fe1b68b0126b104292c6226cb0b76c4d7a672946333a4c944d6a75e34f7ef13e6af6edf7b0ff43bdcb2ab663895d99bd0e98ef6f6fbef0cccb19166554138fd6fe4a5dbeec5970a583de94111c41f9ea1e0dddd5ff288d4d955cbde6498651ea7bf38bf187361240cc8b924e50c1244446efb03a78b39a6a1d118d4f7c7a3d5783f92f80ce21104839cdc7e79b3f5148477b64cacd4c0be14610b12d7edc5227c57fcd9e754db218357ad072e6d5f2c03bef936a06f10991824d56a45a7d6859f7198596c7811a9617592c37da4751201ca3f8f8918863368ada5867c93fd759a92ff1cbe9590345cbcb3708ceba610095f22edd4dcd8e948294e715554e6dd0cc4911635423b9c0b8243fb95d28466b52334117d048cdd8923235326268d78e6cec7575394133262b09eaa20466ae0663d61942352186aaaf654a4cb4e82bd3511de4d129550099587b131fe8850aaa18f09aa36e1dc396e1a286cd61814755357d1ac342265a0cf892ef56bbffa8ae46cf0c15ae54b1766204c19f697507af526e89f43d56509ea3d64b7d9aec15b9569ffee6549f2534e3775c70dc33b0a678d79c691f6021e6846bf4c1c286278be42ee882224d8c1e57cd02afd86f032863b5c38378a96035f3e68e9c5d3dccc6aa1e7e6e93b58e14ba76d1360f814ddf32fbea4dcf4b85b723919615b13d8a81f4a8609487d063b4ffd2bca9adb841c0f2715a6d8930c714c850373a221eff7298c1c91fdc7c3e25d9d4fbf5642f713cf85b5713fe1c5bffa2f52b24cb930a3229bb203e9dc38c0e288d0374f97725dbde0b8f67c4a2c7beedd934d92338d4d270e3a7928ab50421dd4c081e4e103e1fbd05c2ff4d72a87725aca0e56a6e90cf931ec6af9eb06af4d6eb3ab701f05e248168559f3142bbdd53d9e352b63a55abd86b5aefd8e4c7d77bb59da289810699e55be2e3898665775fe6b178ea0173dff60feb5752ccc67bc25866a36c1408699f4134daac0ccea65132d5bae2d2aa5a56933e33c44b4cf149ed3d2ecbc199e9fc628797e900f3774d0a72a405469c24cb35f9d8fcbf90c573729e233b0f16c21280aa9449552d67a87cacceb5baa7f7881612fc23d5cd7e75c14aaf1b294e34315905d11dac488544bdf77dd93dfd72c7e5aaa1cba446a969d5f0562c1839d11de66e125e9f7c4959eca4df996de5c59018946d5ca2945e1e7b043b9d9773b1dcfe637874d5be59c066c8240c6f701b75c52d668b366f765546ed4dcfeb8c94c0591e01688b0b58245a2b174e70c662f560e8ab4994d66fd715466d635e9de5dc589dafbc0339209d81276f5d4a5213212f048ad84aaf144a9557e4aa1065e37cb61f0cccb58df44e1ef5dfe0e9819c69cf0bbd73d4f17f7becd4b743518c6e9f593b00e7a28f959a2a034852a569fa53ff530104e9b1977330779568bfd084516430e76d78fe3ada1c812bd3b315825f73afa36725eb32954ac1769393b90095a94952ace561f012146eec4f5a5f42ef4da5f343a3ceac42dcb95ef6891d6b5eabcb56196156b61ac88f77b0c5d040292a1277ca71f14b7e40ec45419fff599e59405445d60d43b70fcf5f6077589783c4a6329d20afa5bbbab07fe00939a34e613a82c035aef6368e998b7738bcf72c01cbe8bb4b50f29a2722b0eb09fbdca6aaae302702634fe937d9e3225d17c6385da646a361f38e89cc7e8e03d7e1f60154a0504a4a3529f45f6a0e76bc62eec8528c319c6ba43adae1ac15b5461550588d8d1ec760cda6508e64b53e30894942170e8e44b763ad07e36ca24a6ce27755b42f553a8322d60112f9814c37118d04236a6dd2df3d8556c9e2eddab430b46942793560afe506dc0d78056f65acccc111175c643a18d9d49f0d25a378318db4961d64bcd77dc9051c2a6b374d09bbfb5bfea1f8d02e67007824bf318a8acec7de5af94be2dc992fdc78e17b4b6fac53d7a45e5e53d45b81d58d925e7b2db9772a1b2933ffd242ac79b6eeec4eaeac758ecbe759b9e9f2d74ec80c2918efc15058b299859bbd0aa7be2563d4ba6ceeec7feebded342dd10528d3bebc830815f3439a0185f4de6945843675307ddcdc981a8c607130533c8209d2973d894e9ea8949fd75813657c35fc146f6f2cce4fe0e58a05129bbe45c74acef7939ca2570281dd162bd884fd755460756268e2ce65cd499cf238613e52aac9fc2f88ca8583de8a5a7c2efe2b6675ad6dbe481cc8dd8321fa7c23678f6a7cebf56909d2d28fbf28554952a365b62e53a13c090ea59de5bd483f558791f249ced26259a181fd1a8c8a28e07a9138db7c6b767ab429401bae253f0c7add550790d7e87153a6a854b1c5636235e9c06136adba1c6cfabcbf14701c3c4ad5d05a77e99cf501eee2bf25dd02d1202626c18cdda8304b04b11b11d2b0ca1344e8e0c414be6cccc492b10fee8db15ed1c1be51c04877766c9e662a4f06f92bc667a994ad846a0cd0326f7fe9aced8a33249bb5c996f7a96256585bdae061c0890423c40c81eadf546b6b358035f8943bcf6344bd51588473280e2cf0baa1dcd8c20215d72b36e4f97a91de9b11b553fbf92495b4b76d296746d6ee33ecd93791f1397f455e500c7904615adc02612307d28f1f3a6c8b00ff82e807a52324882e9b2b2e66412820bfb5ecd189f51155a0240c07cc79f17d24eb40926fa38b2539fe204905c4a12e3052103d3476fae73b6b3273b05380f4f0e075a824c81ed2596656a770445126fdb241d3c89198053a723fddecb0c2f192f9184e9684177819c7e3a118a8f26966c09e91024710f6ad71788e737ac777a09ec1d73fb4485445a787b90363c27470f3daa2dd17b10fe0de679269b3296a9ced29e15794aa5a65c9aa3d12de8789c180e2e2df13e8d2d872c2c1ce4af5881df38a39892aea0417db76f0b5567dfcb9cff417412ae699340afed01205a92117ddb2d794ee9018b49aeb8871c10a3942d2d2199fbd82c5b8dabef81b95856b0a1e606b545a2f31c93733c9ce245b4ba66046197af32222016f8cc950b8035db370db5d4ce1a4790861228527a909f096a869fb496c005c8ebcc4f62f7a2876bdf710b111660fb8d43fd826a5aeb452b8fa9cd16b277ea9104f1f0206613ecea432f0d1865a1d2c56b8c07b5ef89835927904589c8f8c6bd96d57ee12d0597b4135e6bc815381a572f843537a8fc0aad10702524097bb1a5c86babdc3f9fb809039c0fd60bbd414e8174e8f0e57460d250edda007957d81ca7eb02d553cc34947b29bd46e060af727a71ed8938108012305d212d6024faab4ed53497ba41d91dd68d3b3325e5cb93d735f01c858d7ea92677ff5a27fdfaab867a567cd8f43e5b975132183a76d25a8f2e0c015a73f1fe36d3ff087895754700e33ff7783304c06923b92b878266bb12b8175681c9aa042d58ae947418e678732d6b58327f5c4b072925c790e75ee31f0bf45f44d06dc45f9464f65b021a39247364a288bba324f2b3727558799c6dd87f13ca53d2646f46d3cc2f6deb1dc58e47420d33464fa2d4ba4c0867b0d1cfb7c613e3c2087862acf49dc8a6e4b4821eeaaa622234579207251bf4c13480d1df39a2150e2fd211603762fe3fc0a281b0947fd75dea3ad4bf31fc0ebfe76a3d7d8688dd0123671add77990983fedf7d57d8e99b248d94059cac19a8c78db85cb9cdea49c2c81fd280cf371836b4ff8969ecc74421b8bbfc07faf259348ac2fc8cfccab2ddbdd40a6b0262bef0404dcc24aa033c9c0a11ac12d19bffd0de1dd0924087893207ff17c6dd98f6ddbab9ef2302a7851a92b630ffff8e27e25472fffb15530b79e1e834933ad4fa26ce154d4cf9ccc3657cd6d1f5f22be525f6c7946e5ed226ada5de0debfd4a4836d0e6cc00be074f21cfdb6eff10bdd394ff370da3f81f89d83172501bdb9e01ddd37d513b3f43b99b24a8cec1be2e79ae664ec5f4fed04d4121db8d5777ba8eb99cce7bd06f09d1c5c9e227671d179ad04b5ced6239266f73c26a30c300b7aeb4240a292e58e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
