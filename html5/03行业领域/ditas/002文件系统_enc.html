<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"236b4c619c017bdec586c235493239ea6892dc9f6845455e3f70950bb62cddd37d78de9f9b8d23abdc6baaddfd5e7e5971cd2c7376e0d6d0743fda936c90c31bae2a6fa3245e75117911cc577025892e1883c4108d66562b10f037492e7aa19fc247e9bcd44f6240abe2a06906342c0deb85c4aca2b0b49fe5715ab4d9c0fdc50c61e01bd059d25f1085ba05e8ea40c0581a3fdf0d1e5fd6a960515673c02e4bbccaf5df08028ea9aae665dbb8f6ae5152c481f79c3edec58f94c115a2a8d6310bb17dc1ab46486aece286c35fd40401df735749974856507b118d146fa0c97b226ec9e0331c6f60096a7a1abfaf4f6693b50aa50daf444cac9b29eeaab2562c60a28b5a440cca946395ce74fd8f5b6f3b21612733eddffb5fdfd37616ada4d807b05d65f7f2793aa6e11bab8d15024412635a6d923697caf558604f0dd8751dd2a4b8b8bc0d1d3c2a94222e4ce2e13645dc2f0247ba5c3e26bc5f5ac0bc6434012de0c132db1dc2ab13410feb048eafa748e81ab248ee322558aa999f3262a287f3e85fa14625edb3bbf0fdebdcda1171650c0903843eb884098677b188c0a32cde99cb38fd06100bf8c7cf7334d26bfeda2d2e0a8cc640eb0952eb97124910922d73c8dce11fb0c8d8563f36b071d26e1519d51a3cf8f8e178fb8c6706605223bda74de43e70fef05c72e9465a94cea7085a5e72a9c65a21e05b3f04e1e3661acf278e29ce9acda958cb4d119bc082e6de963d11c7e316751bfa7edbafd5ca0dcc08a290bb6681aa69577959015b76096c9433219dcc5bc3f103a8e1d4e300cdd9d399de5126286356bd4c611eceb31a755b5d66265ad127af1b2cdb0fde3d90e53fe9d2621334e76bf5a241b61d1e1920eaefc5abf4b4213779376a66a5343b1c2575fa4b984e05c33e60014f2d934ad40940211f9fc1d0baf310ef4c859ebc858033548aeeb6e707233f6e9ffab460a6f84f3efb479dc7bc14119c40aa2eddf807ffb8916d966c377fdd9b551721adde18ce0c78dccdde81f464c1b9929c163597d867ad8a4283bf98b80cdb07831fb46d28c279806e37250bd48716e6d11fa0c390ec60a225d82fb9a2936086f3aca85ce290cedb35a788ca70abd1b3403a21f50ff942b45d0f88955acbb7bc1326d30543d2fc7ef6e01919631bada62fa7bd5c0426c7d3135b9cd1330529ed5017ec863a3fbc5a3cf09e895ab436b62fe78f5ffbb8086848b1404c02fd57576a0be5538d10ff75f79d19128f8384ae0b9162f8dcc2edb6585df90197e6d64030b27036378921c194f38cf7d9058cea25e65fcb47449a58aa8f7f46af2a60d22f2306ddf438cd63be53f2ecd710b1fafa0c1e040de4e6056171e59967c63bc4e050ead8d5cf627c28b3c92f421ef28c997a85923460b232e84cfccc85237a9abce74ffc0a6ff6e9149e072e0c7b0febdca4dd60f8658ff5fc9887e31fc5e0fefbbee48b87ba6bdc22f9bcdea8e4c6e2276064abcc9709f030a678b87c0e206329681ab01e9a1de68e29ee151e8e54444a8d56bb993420a5de8387afd9f3e5a61732076d44daad8e68ce059640310e6ef1ad4c4bf3bbad9400e8d61aa8fbe2bfd7e06747a83a7eda1dc7d95f2d97039bdc18cba6c6fc1481c9cbcda453d4cccc9ab2667f41d6b7e6259744657b9a877e200f34633a1b9449b576d9091dd90026baf62ccf899b6249b9184b2479a8bbd83bd9b25f24ee00f8b23a540f7127441bf3a10770686e46b51d5e0e5b478786e6c3cf8e846448e8587fee3757f2ac66b0349b755a12eb096b440b686749510d31027be2c2fe6ee06de7d12ca829c8e218e5dfb695c05a61fd2affd940a6b8d7d268e4366f9367149e5cfafe9e9fe52f318b093e22005c9b83cdbff6179da157ef26862abd42d4350c39edff3c743594b96806721ef1684f73c26f0895a96c14a4dc20c34f707e06f38315fd62a43b3aa2ba5637b803c95c31973960097ebf6d9c50bcee3676d0bc0177c7ef4b46aed41a7ac7eb37d0c376ffe3a8fc344aa7313291428c78d5e5a24ac5a20b48b0d8463e06d2d2726eeed043697bb81e5dd3318a4d656aa4e4fc3d423f17fcdfaf90c6d6718b47981c87011bb48de7d7b62de316d6dd59de55bbdc27001e779c8aa2e23a7dab21a5d296148b4c3257ee92da1e26fd1290e3cca8193b041a6715b2d3c247cae47369a6756df7ac14dcc3d327c6f6167cfdda61be32ff74969799551f536fe5c052dbae94348089da8db8e1f7bbaa601d1350ca1f58b62a435021d8090a72ce36839a956978fd525bfa13f0e855d5382c46c32cccaac103511daec4edda0c900210a4153691a0d27b5e1ae641424b7f9bbcce8e986da3aebac76ab13121fa43058dcc4a45618af8f238ae9c305e517f18039fc68a79af188cbd069f55e54d437f4378910c6dfafc932b8555a31fb31c2855abb267f8cf67ed20ec953b319ca1b84d89f545dc3f081435b1efe41bf35e1c0819c5d17ee8b91d51fb82e9fb946cad3fe10f9d59752f1088513898d1f1753ba41870db8b518a7d6270b98d1719318a9a95b187d25ad4d8bd1c9a4c263ceee4a9174208d3023a5822fc930dc433089cd67a3a3829d890ce5fb161fc5432817a8fad5752411a3d8376ae8cf31a628b9bab7ecf99f68a889ff2b003f4d37362df1fc644da847693367a2548c95252933b5abcfdf5073a1ac54ebf0abb3c66b814154897fc48979092f30dc12d74804d46071805335b0b30ad8f63b0d096fdf353cbdf204bcd57ddac8118416c2e1aa74126504d9d5fb6b8892bfa282f76121dd6497749af667d582403784f5d15b965cd8302658ee895b416c70784123b9cd8b223d71b1e7b26743434d280e0ac3f7336f7bd44f92f1aec945151e57571fc69c46612c906737d9a4a8e9fb501db317b1888d2092353189bda36b093335278c4f1be7ea8d3a4a6f4ebb331da4f63b9817551e389f8ba71ab705e7283b908203070ead0185939e41f5d4a91164977b05db928e0c5f31927f4950d63fa90e4791427d704f03db7aecb9f7d8eba35cdf6bb6cc93bdfa56ca1cf881f890d08aeeeb96e7043134623842d5752a76642205af73b14d918054e9363261704181752e5dacc8b72aab11ce7644364bd4485f8123b4d94b38d3d6abf21835b3cac1e6e71b3035bc1d42e0f9b20513b4352a9b7a0cfdbffc548733fcd231fca89f523d35fc9496762cbd63b20c7461c5536998e05a9211481a0ff77c6086f51133b2219f489608e92fae7c1449663d751c9f2ec4d9d84f0d31432b42de421987d29a117f7741a1ea139ff182e0fbc19438430571b993f51f6f5297a5d7b86d832098f101f332958f3c35c96ab935af4aa1a920eba275daa6491b45796a30f1af7e22e84740bb251587a299208b70c1a1d0d7285b88bac95dc5e6915446ea6d6e6eda46ab31f79ac8bb04fd12eb587c1c2091e1eb95c4c5dbb4b755f8b74064b0d46114216ae7e560c433d0e2ced9eceb20c9114f71fbb4bb1cda8bc067e9435744abf8c1a4e33c6b548a809a387eb6f78478fe7d566c384ff973ac240110b12b93f168ef4c13b0d7e34224fb99dc6329c4c8116ed3412414527f872d69b258317fa8d3571a1288d08ecdd58d4dccedc7b347ed9a0b13a4216318f9879f202d6e49076854351a6a2367a740ca4a93b5023a3fb1c3de2fe7f6a995e2b6fac0fc73be5322d6fa969aea9f8889ed5d1d440fb5b5212862e74a798e4d916a8ac6a1c8b091a987770e61f3a85648bd2b6d010f7392be8364b5fa37ddd74ffcd3f28a8608211a45c41ab6bfb7a0822b23df7216f9ba88e0b4c609a5e243fa32b71dddf7397f41efd82206ef5a1c2bf1c90c944cbcc7bacb7eef38e187b767dd33dd5df31848d0bb7e1353b8df2f5ee5db376e8190eb9740867bdbc8fd56c7eec2d3b3911831bca47a5f8693dd90fe5d8ac2dc3de3846ed8f73df19f787849053d6dcdd2f334233a821689d1eb2b14cdee44d7747056a64c475d7f997404a6fdf3d3592c461038d75b9fb93ffaa4914820948d6aa00deedf0cff2ada2fbc1ada1434803aa7851cfec27a4be822e0271946d60196e1f9a90d4a25fb56621a0d9ab4e4eb626c203ce07a5a176a440602144114ce7a514523df78e3b150dbe12e27932a631b95d2222ee59d9424fadcc94347c0096a18529983b15464fa4ec39009509c5bf4d3a5ee4ed1fc0fdaa459b9e88eb0c02213cca66b3b00734c46ecc8aaff058714fabbc90daa5252ea54206711b1e2c8e29bd2a25e945388ead7351a53bb5e65fbf53755989d7f62a6e41dd6b1afb9e418b9a9e639d69ae63983e78336bd66fb582d341dabbba51386c73ef894443285aef1d3a5f986450eb53fadd06757d1e1e61b5b32499b6857edb38134d8ab0a2771ae16360d0cd5e5e545f0f34333c3226865d89c8271e86d1efa8eee168de404a60069361aa3c23068dd039c5894cdc0a3172b15719772d6d1b00f04d72613e4b5c2893aa3f0be609445d4e0bb58600ce5369c8451885e5de7752b7750af78d8ec8e0b8aff55c291b000dd38962b838e30dac40d1ebc9676fbdca4266356fb3365653c1a3c781adb68784e43990d100b51e0e82c5d3170f2e2ace17cee969f0be79592eace15d91e4f52f027086080c9e88939bc3ec81aaf52da347c660f0b9c1cd8f44f4bdeb85379f669399fd699febf3f56996a99b142b70942ee692d1fdbc6e25d088bedd91a9a5bd059c7887a15bf134586e76abc1d314c9b64ba4dd53190d651208f31645f0c9fc787af26f56e32e0003a3bd518296bb1b4e93d6cca792f49448625e82565f7f0a12ec3d7b486a1448a55a4f3abf74f7eb3e7beaf3b08e0f175e478938456b1a8797a6b25e09d9510473a0ab280d7b0f2e38117cbb46139721bbfd7dd295b1d7ebdf9995a288088818de436f1a64c1fd3110eeb3de4e544a49a26857fe4b4677b7fc833d81d4338e3425880d8a4f46c6b8bb1c40d3ab36a592906e1b0218dea246a8620bf91b9ed35620f257abbd62bc4630ce028a4c57c5a3ed158fc0f5a9bea5ea0c384d16875fe925cc691ca090d77c27511dd2001a64a10ff5da145bfacec3e4746ee8edec90b7d2b7e28975facbb6b37ab8b1047e854b8e12a7cbfd162a3a379717206f3fc70fbd063761c9c6f138ee1ef39e6b0a1aec29e30eb2cbe1179651d59ab7937a7ac6c726b481f6adda5671da03de3f3834c97ff5c97349213a1e08c90f749bd7ef9b6e91e29fd659fbd61feac5a5890987730344e1bf9e4e05056ee78a75cf95533781ea9b5a68d1ab26dfd3a7ff9712283197dade08563ea2c0be7655fdfb47797391474fe433d7c0ac97d74813a463acd38f39f8edc35ffe17987475817e5cf51ab9183dc832aa5b7a63c3aaa538f3a1471d4d5f4ef033bf67e61be2b5dcdc5da5b29dbeffa044852e4d524edfc7cd242a45c30c5edf0a2a7524e68e078932a60e50915fea0d307683241f93e078a9719e5b1f868163764aa9206f96e75384f0d2c9e748058e78ab7fe8210ec42db31bf6008990a5a244c407b64a603f69a12c34ed58bce01cbc3baa38987196754a4d1d332caaeafe6505a792bba68db5842c5311e9612a9573e4c9871c44cae96bc43db21e99f0d122b56d21efdd8b033b82fe262c6633803b8b971a1a7420f32926d8cf207eba0d4281961029a3ca5484f73b7510b2b556ff4300c565d864c8c8d4ac0f758db3cc89c08f5123414f5b8767d34b1bd5f5851a6cfb19acd9fe6380625b78e2c3dc94f70b0f96392d0c1d1174911c1af2f13c61a60336ee373703cd794092e3181fe6498c7dcd96c79f273d40bd865a99f57503ba6829c7eea85bb2c37bfd95716725b2ab5e1c1c09edf43bd5ee936e8b078204c068128d3f8be52a5b3827571e521659c0ea6ea9404d4f116477cf4a08d77f0f956a9c75b151590dc14d7dbb1a0256057c49a965ec42b2b9a1c24f66743fd3cb7daf66f1cdfe180f698893894ff0702186aeb93445333a61de6e8e411b108d25ad486a57e84fd3b6ab574361055544a3c4650ec154df5c7df08a33ea3c722c90817ae502290dc5b356c13bf4bc30c6128111854361fde6efb67e398e14a8580e3f9fcafdd5abc7cba5e3138a3f23493f94e406792f6b1d5daa5b6aa10dcb2d3795195386d2f48505178d238a0366f87bf53c7cee0dc1bb1a125e27077f4d2c8a58a3a5d9aa2be9008ed13ec174a133fea11e32fe5eff16df2192bc98a240761631380da2be1ddbfa7b35aed20b3e1247dd8923dc7affe48973730233942fc11dcc2699bc611bf0b6ac97323f6bc2f1022d4da2ea1a853aef757c63639aefd0f31b7cee02091f7da37f1802d09be2d15cc5b382b0d03b9e82659d4a0ea7061c0046e7e4c73b8a02a2900fef53f032289849beacd71f15d4a36a6f7b8949f1504333ea825a72379fc0fa03b5f5045c6d8fd56bc4afcad1d2759831fbd22aa0dcb81d2747323c2b0ee414d6146c5c8defc6195d1953a51220a2117434b5fca9615022dbb2527dd0ecaae4d7f12b20786c99f3c815c88199dccd1bea4764de28693db062c4352b829c940e74ec4081c36e9ed42408e6b3fdf1b5bc5a397fea933d549fd64d0c204e6491dc91d4979fd8931cdb4ce9cd70dd27537e91caee816933a8b8b637f11ea3048aa0a0b1e493781956c9a90f427a118ad6c2d4d57630fd2bffd025189e4ae12a716d76731dd6eb3e88f53851de08c5125df218a6dd8cc2d8524e9f882359f5c6f27299e2f6992e38ca28ceb2eff8b51c486bbbf793b1ee53b7edb24c97665cf300d8adb6182d7efa7773092a920533417d2c01cdaa4d592e78e96a29bb2d9231f024af67b93c599dcc327f23d6c1a256f9b10183e70779612f4a634b672eef2b12ef7eb4b03ff7cda0f72c537a673607f9db2a3d3089ff3655c1e37fe6d21d909d742a9c8a5fa2e98a7b9d8068391e111543b9370ee16c9c837ae573a6285d492daf4e4d63c4ea796138720ea1a254c4b7167f5d0317c8d22e728a2cb760e94a823a70a74d7029c2fce7a08dd764b7dd7acce61814325f954eba598b519e4efbe0525aae1a17dbd9da57db5f13383d9f5bc4827c62787a4c2142fa2fc4c8c2950e8c4b5777abc7ddf7b6343ce66d25a12c2790612cf53803609b1525474bdcf18cce2024bfb7cf0a9318521f11ab3abd9c8c1866312ee8b0d110e85db6e7208abab70bb1f2447898d96803da74aa9818f9843001a372b9c3579a8014bb7f5032c6345265280d83040f2e4ee414528ccea00a1417f91fd7acab73bc7388fff1f4d20c3ee37e1e782b048f8988ff9f641f0e950825deed9f262b8759148ebb88267e33979f66fdae7628a2293848dea1b6f38e6d82f38e3e48eb2376e80c7bebde8ac197c2d1a508c21b3621aa13b5dc1f7d03110278c362ec71df652086e2b0074fbf28565ac815771b718e649a32ce708f657afa2cbc24fd5fe330a146a7cb4bcae6e25f83da12d3ff366009504f15f3c714c2a43504baa732fd3486de5f1ec627ef461a37f5c7172268fff1d4a0ebe6209bfc4aec026251a2b74a8cd22081fe987e3c2ab3222221ba7603868bc1746ca7ca8157117d755382515ec93b9dfeb51814d0d9609bdf8b9297dcb52fdeed22d90a2d7f3b5a8141f2bb0edc31e9cbaa47a7bf9c8b69dac7d63f7eabe5dc36be2d76b90b6cac315a74270ca3d7239b03e50513d6078f477eae447183bb2f03e1f4d623087436ebc0f843c9aa1256569da70e2997f21b04fc7df983eadf0b737d60b007477698497649b0250aff97b9ff8f4a0b599373779875774e7da235b091f505671edd9452a62f55b5122e81534a29e0417b49ed40acf1f8b16f36cb81f8de6dc491d64adc2990d1c82c588e11889433556cf0783c8694e04609a184c8b58489734e8b2d8b79454c37c5e364930a2dbe464e0421481980331cfd34d4e2248c2ec3da1fa81afe6b74f6e2197f20a86061e0d47b47937bb98378ad4a74bba7a62389efcc6fc3107ba8becdf77a2b057cf19367bd55f45a9883968d73c08df00c00841e0f88227eebebf819b745f2f16104475b3029918388bf99d8b23209976e6660fff4611e9f54e059bf69646fa6e5ac2743d2c0e537f4753f4e79f61a70ccb3adb63f13e4465cd2fe70b8a4e323bc16e1bf7ec18271e1ae0849a7edd89d24da3e414e3846ef746035d2d2bb3adad41946789a4811274d8c77feb794ca1220b43bfab1f07bdead7f30b3b13bb122df2c6da0a9462bcd655f96969c6210af8b19ec503361027e5c1a93b5a28f1fede3975570d94df75f807ca7e901ccf17caa55c82c8f61e497c782e19570ec76cca337d3133a504ec49b60c572ef377deefc232a247400fa80caeb3d179606f4a148c0f712689d3951caa33bc177a7c8021a3e2bbbd4ece5b25b8436737fc747de221c4d55769e86d70fce327293b7e075b994b895451489eecfb4e2a9dbf49d0a770310b91229a4c6a3f46e9032688cba95873ec62e1598ec39a55ceea38752d727ef5ba3d122f298bbbbdcaec5b8f90bd33e1386f5649ef34565a1dd482567a8e448e6c45bca60162ddc9513b07a778f47732a7154b46be190637c7311f880c7d32265e864d7eb1517fcfc55dde09a744e508679e691b95a178791e8530e7668e7b3da82d452949410a4b936563ca65b4a771262ed245ce2a95b515aefc26ac27544a88381631309094678dc0b30c0f88b7397dea476b74eccd950d0d8f07ae60a8aef2c76c2a9d42abdef0604fa1eb795fc96cdb28d2b0a4f194ea8774ebf97f394bd18b779606c1b96b89f448fec59d49791177b90120b9eaa0aee78631d4fbff2947364973746c48025a74f1efd771524bbd24c3baf06c36f3c8baeb9d288162baca91ef0effb3acc187aab200e6b2c08ead7a19825e52166febbcc6422d9aa007895ca7a40b2eecdfb1596ac4c1e512bd1ed4087521f6e0d3b8bdf0b358098c9d6c730d79607cb35579133af9fc1e39a3da37961fd09753d5579198bad926bfa58d00f9b6fe4b6f53ec781ffdd22ddf2b5d0d25e8ee75419412ba7da87eae731a861be257472c10c4b795b3e6b0ed873434e3795f129c2f5e28de5ce966828f4afa93532d130afab4acd2304e9acdb1fbb11b037b062f1fba97b563b186779ba147c1b6f1f8f86c5f778bb3c4c632f09bf28774cbf997a1ad382a34d91646ec38ca98cd7a72ea9ce328933d6ec747b0b078907df4f2a992d5e43fc06bb951153925b56fe7553418dd3dd1385ce9bbd5169fa667ee8157ee43dc5054b478726fdfc0f6f44f3f5e3a240d00d0b0d190b72a0b6d2473a452b737f3a6f1218ecc292e4a34169d1a7c65462e545d3d317ba0c7f69c96efb9a8c093973b5f190ebc16093122f19b25753e8fe3d4cb4ad97387c876e61c844e3026280478b1c75c9784f2b29df1d80b6769c82cdb3341922fe0dfb942625e21ff3344c00efb171a3c49677e3135732d159eeb2ab9b6367cbba28c55557a00c44c26cb34e74bbaf51865f2556c113290f9e4a9505de9ea5647f6f59e01b75738ac34992d9061d5bc429170acbc2865d06126770cd4ef414e70c33f9c4499789b497aa60bf6c223fea33e3294d0d5dee9689e9eabd6c02cae8959ea0a617d9841b8004f121dea51b8c1a59ff8c955d07030f1021d3140f2626cc7adf0d385d45574b448b017522d78da0f55bd2b4adfbdfc1ece3504688003d4e28b969605bbfd6d282caf0c22c22073baab0056966ad392f46a2d91457b0643c84f469e3cc9590887381873b23c7d3d34fb0a3c577dc62e45f44c3a0e74993e477968b3de6b26c6724469a30b482882df1efbdaeb9d157a000bb371dd2cfed0a69cf13345917d80f5654d6abe10a8b294fdd7453b8324c6d4e52655416a271afb43b39214e1b7b6bb9cdbe56e6aa44dcc1e910dceab36156d042bcd878d63766b8aed6462ac7cf5a6de4217da988c38659480f137c0d8b745ef69766cad578405233115682ab6b28659116580e1ae649254eae59441e3f5912e96dc74190db105c25f22716eaecc3ef14da8a457367184ead826700e6696aa55764d17a7ba0f5043e1ff3682d72ea01b02be66c60629e8b7972433a05873eb37794bfe5827ab119d94ee9a3ea84817eded2fb97322aa56f47fb235d54c8e69be0831cf91579e90e0ad07c00aea1ea58620f0d26e1e157ab6d70167861423290c825b65a9d3b21b54276c9ca90141f7b0bfba67ba46210988f8e6ff0b610d4897b010a71d13d20a08ba540958525f737f783613763247569da2a7c007f5b787682aa28cf69b1ed56cff85bfc9753703dcb213f3adcc687fe4a41bef8ce4465b04baa143e25ec635610f79ce7d44884e8bfd4a6a6955eff14e213b4af01180ff79abd131a6a20a3cd2529ef129a853518943d3b8c9fb59f34fc91811e27fde5cdad0f4adbeeb6d572346a77b6d336e1e271935ef3a1a37cfe78c3d07a6ed118af2cb7c07c0b5f108c93ac677b496c08ead685ef7e357ad82356ff7540e766298458fb5649f1f2dadeeade43426a76c40bef60db37b06f0a8da51c2ae6672586ed64351de2cff1184c3ae1587acade5bfa6ad0d9ae73fbd105e18c94440d1fa7de528e5e0dd57d66ad3888747a8ba168db759e9895dd932e34bbf6fab25df20559aa0790bf6cf1a14ebe969a659d3daf45e25bf551a8237a4c4cfbf05c570b5a814448b84b49157f84968fcb7a81a849bcd33944a25879a3e1c276b806560957c7dbbaab775bc3f768bb68deee73479abbea6bfd64006978feeaa668f334fb4065d6e08cd2b00156b5bde50df526aa1d3f30fe8bde96ff49aec16a63851fb7ee339b674c67247bea5b2bb4eb8c63a5dfb0fd13b459be6aaa57a4b71e01fba1b8c46d40a0856089fd8407a130a3639dde16d4278f8e8c04a954097fe6ac8e4259ca6c9f214c83d7ba7740d0a7d7dd6b645904719ae17d948ecd307f2476778df614c780de0f430253f70488229ec11860facd45283a0de3a3147aa714559659c66f3021a3b7a97022001dc5f6ff972600c9cd7b450bbc3f50eab6a67632db099d063130e7cf32d057974c305daefeb91c60015be112e04ad4de1101ea11a5e1a06332b2f1dfe104a53763b225c62f62d133aaa79bb7c5fd751cd91c33cd0b8ed6df37e4769d17c9251ad5ed5b196c5e118aafc99c4653307fc226da9457b22319a95b7bff8a5b01282bdda2c84aee71a64169728846c193489ad734798f10fd799694a8e57dced8485936a431e014a3fdb5bee9bab17bd53e8f874ddad24b55bfee28291174bc2d74b1567e0cd32d9cd1b24d00a069548d875d8beb53dd8d68aebc6e69d17fb4bffd217b37afcf04f86cd1b07ffd1fd2ae5717bf1402b1f732789e5f4458c5da9e6c8cf5d1c48e0553c04b4e8ded5703078b0de27c1328f73351033463deaa02a59ca577d01def8e35e30cf0c4ff12545ce6c245c66cdf00a8ab9bc3d18701271a5aa5222a4da34373505dc1080ae32fff640d77cb8ed1d177c65c4e35fbf8260b70a483964125f96b7a34b3f7ffb89338ae2c4eca3c252ed12a65a8126bf3cbe347ad302324478cbb30cc49c75379d66ee817ad376df77652f543bc8118124a28a24bceacf8eba2c46837baf7f3ef21f397f0029a231ebf6a43504825bbcf32319d51935d4a13270275f38af8f8dd51c9657610aa70a1df049154af8c51e71f7d40f1cf260c9fe64110cdeb8850d7de7b9a75b81274c7d8f0cb38cf015e19e30dd56ef9775cb5f0a775c8152d8e3970b81c773e3a1d35841ba20f24148e8af50e6793c0f4b5f774c2c320967b54e6219a8b85cb22f6739aafa3d7e1c4ea70708d7d27bf4caa8c6f45ee2b4ca5a9cd681968435f42105ce64a9052efd5091896fbf1c77d83ee83cb39fee3c1458ad8dad7a952c31547e2c884e6c4567cec34cbfed96cdd1e8a584fee0230e0fda42a31af1e6a4422b3fd087173502f93bee83b49a1763eec255c9774fffd9da8faf55801f823a512b6d4582636b217d0fe5a62e0c56bd1f0684da9b9b98dfa9707af37c8b94c74be9b9a748ca9845cf63f8b615de30e5680bfd40a38e535109e1a2d7113156bb7e7a9a6ed91abd9dd903165419c35f0d4b15de9bf0b25d8d1fede8ef3b9d41f4fa241d470e671608d40e8e755285211b03b56fb6c6b9581ef091c04f9937fa77d7f1f0369b1b2002ac2f2088418977f24371cbda5450152808fcf988d00cfab3dabc6369bde9ab3cb2e82900c711dc49a00db75075f7c27259a8f15938eda22cd8626d0495c877792b2c9a56fef69edbb701beda1557c36c77b6f5fd1806bb531671f6146dfc709282e4c0adcde7aa00966d2995dbed95e9705a8005ae3734ee8e2edcb6edfec8da901dbde5a2c44fd809094cae6ca32d37346645c7f640b9cfab890d1c12f4aa8b2acb28fd56de7e7a66099e5e21551666a8ded1ac9cb14ec3913e0e0b363d26a979006b2e36d6e06c14b1d86ee5207085e9c39ac24d914c69408a6600d560afc4ee7768e80e5c54cc25be63309afb2ed7b1f3f219a86e7bf6c72a0ba19c7440b5f63b45d3541dcdab0c06f345472b2a497525fba41fc54849a5148ea0be20a2e80e487156a20fd10b939e6c887442ead3a010505ab1b32b54f115cc69e4befddd966ab2a9e00ab0bfef607484dc6cc211f1037c3b8a5fed3755e0a8eec4f2de01c38ed9eb3c2db85dda58b47fd4f1591515a6016d91b78c786ecfba43c37c1e62f83dcd7fde5885e1ca5d11b0f8c84a19926916c7a519ade628e2ef738a9afbf67416dd591c215482b7b5981c619ef20926d52d1a1f460f073b9b75ac8a59d1380a3142b84df069e884b37b4a7a2dba5c391040ff2ec6c2254e16ac67707483894fed9c2051bd3e0be440e9622467e671df5c01d0f7c91c0fac6255458bb09004578a8519911528cc6ee1f528bcef61589048e7c4303a46498e3818f0c34726a8494e12e41c12b203122e25c6a41f0b81767c1b12cc601deb93358a803a3db487062b72b6ec5199d97e87b3b22e9ebe3dc870496c8d6f601057b3f54e3229983def0016df830d3b5bf1730825ccbe4a12c2c5b0573a15209b0ca317fffb4dd524db73610e4b2e95ccf56cf90471bbc62b2485301da8f77c81f730c8576a1ca3093ef19068f8657ad9ee9bfc8a1932a29b743680fef8ffa31948d4947d72fabacf423a201b53323dc31da2cad681e4bf4e3e98dd5ed197ec0792c539dc1119e0b28105e216789c962eb8996b5162b529c3f88d127ccfb27779da2d5c56777c358d3cf6e627c973efb2b9947ff5e6afd770df34e2d5db4b6d7b9a3cde9c154a565074d70943083b1950a7280cdfa52be39b085920b1f0ad46b5335db43d6f0c11e2dac76228dbe6be590b2014bcd2da19b92afed7d7c1e7190cb5800bf54248db5e6abdaf9efc12b5f246c79790b003a999f8f31a4512c145e61ad1c95fa1e1d7e7a570186edba65ac596cb20019274af08f0dcde2c53230349984c449fb409587c89875748e472c01edde0090bee4e6e645a33ca7ef2d29ae3b03f28731412f55814144fb140a2072536f2a9a8ab49cc7079ddc474cbd07250d3aa2d7eabe5b8bfb4936cf41d840e4890b7ef19a635dbb035b8bc47b2fbb2639d6f8c2abb498965c7703e706fbd28fb63ea1bf91083045e70406a1a13b30354fc043e6d3690d62b2109c3c5f002edbb3f212e094987851c2dc82d99cabfb08fba1760bd61e1dc36b12b775fca3b7b81b6a5b01de172464f4a2a260bd56b994c5e21e59a53a4ee69f9ab5e638fe756a0b1018a7a4a903610d9445058b5fd3d59033d0e90f4f37ceea14122b974a753ed2052db01dc632561e01bcfc3619c9585ceb0d70ea5777108ecfb741d4f706cab94fc6319d167fa50589ed40d513d2bb51e3f9b23fd8670a272018ae7c57e78920f5db8ca6b46902ac6d2be59648ffaaeae3ed1c761a7465974877bf0919f28ce3e276a78c8059aa61bbc79df05f27a68649d863be0bfeb2f502e6b9c67716e965377309f348b133eab412481f2a8f3ccf05a8521a0959475649b110907b1818b674195787ff3dd5747eb390ca47d36402b909ff5a1a21fd72a9a26c78457e08c93b8043222929dec3f698ae5c06d28930407237998eef3a6f4f6314d0483cfccfa68864248f0948da0ba87252da302899b3eb16d1480361302a3f456017d5e3f764a2dcdc525815608ca9953b1e9a93445733e9260f4e389ae11d3fc898a51fe2eb92bfef95d22edd6cd2e9cec9cea08b7a32808137b4d70e9d67ba0cc43df67c0d7a2adf37dc8d3c4b8633e25358aba9ce9783d9f12571e5861fccae11896f28f9f1c5c976361265e3e685cafe2a3c4201226a22cae00e8bc2f88acc1d5d0e6891d4989e3175d38418d353eed62cdabd63993d45043cd188e0e6d34949c5715d8e1d34adefdb3e82ea7d743400febd90a8351b80bb71fa0b34a01825811d870008b1ae6e9be71bcc7b46a0a8f4da532b0f23fa56c9437f9372577f7e4e9e1755743e606b0e11a094a548c62461fa922bf0abd45490437dffe7a3505346f4174928ba69b5aa9420df300027981f67847f248fb1d7a4fa1f93340bf65a97141a191e2d615eb20fc70e39bf25fdccf50c2dc7a1b6415eef0b6c082739472f709d117ffeaf0e4af334414aac68147cd0836ed2e7d19da52fcdb1526265c861310f50fefd793223e90a57f6f476cea6ce7d0fd548036f650e498168af5354c3f515a654387b5cdb49c3ef75a73d54c9ddba6ea7948b3324fa2e188b99d500be99fac16a61309e0154a937a352555a5cef991800342aee1b2f870531d46071243d75d58b5c58d7afc2015b000131796a22dfae447dc9c7734313aa8009295c4188632074edcbb752c80711dc6833e75d5e7f9c38edc941db2905cdb7db59d82f5c71b99bd38285c4a293ed9c78a8adc6757340dc0bdefd6ec2d3af3b4f737008dd45a582132ce8c755cddc507bcdd04cfb5a73555d56b675b9cbdbd57bd3b683ee1a50f679605bb8ae9c4b541eac2fd6d348802d2c4f2e473df0e1263c4db7bb67dd0b77c70ce7cd1dfe6dc98e1b1195fc5a505a7be03684678f5db44b18d163f35778d67d5c9f141d263b6d5f1f9f88ec97edb04019ba271018f465ef1ecf9fa6787e774c67e8bed5ddfde145710f6ddeaf10b99529df8e35b3b1972209c8d952cac51d20c0ef9852f61fdf1cd945a9f3f24cebc21180198a8f9e48bb83ce42a3b15ee48235d8fa3112abd061034dab0cf8873eaea5f5e87be4b83cf2ce29f8137a04d0103eaf7f891da67f348d5e4476b8d192203cedf6aacf8a151157a7343ed9a1daee09c8d4573b38d457c948ffafb2d604e9cc456039b855b17473fdd69a015580d38e6fa9081a11ec4f6cb779572d997a4cf3ef0248ab7561e93e34c4b405d3c292a072b985d25a4c93c47ad933e1f9a2ed59dd5a9c7f8303ed0d9e1ea8b1563577045165484ce462b8c14d5fd15d12f3402390370775beacd4178cc3b599265c27d697bdfd9001448d22193d78caaccf519bbd99db4cbb5da6a8cf20b46bf67e364e2cc044f8720e69d10865f04d8f825023e1aa369ffaf0290cc04a8868f0d8bad35612b16919358310aa7b260135fbfc4686600affa620b9456d86015814096b89cd89f5bb1bec266ff9974d3c3f8418b79dec56822e68f70c9cff6ea240df1539d1b5f55220742aa42171c39d3573a424c0fe826426c666a8b46826e4e53e843b071f5c87481ebfe398d1ccf1c05de04ee6815394d6698f00d1234803f3045a97d8c59f36304baf5715640ed2c6cb35a5f34703b3019e77fb7f777045789f471c45bae5bd44f782660daeefc6f3b2a1aaf06be95b0392f160c17dca6cb8b4dc4eac96b13f0a02306f8c2325b2eb209efd17940b9a13d7c3dceb1580df2d9c44d277362570b6d65a536cb41776b07b1ad1128f57822396f5669b537522d6283a4b1e286e74114ef8a9f313ce92f01e114166425152d1cfddc93383da9c7984d6f3ac73579e8431a155d6c22a42af4866c6ac97d955c7aebf2b1c4338324349430312a1e16934dfdff2dba2e195e7aad14c1f5cb6aa1eeb510d7655738a882e2a21a565d860fa0f0651224767a607de700104c95344e51bc960bca92759190b2ef575fce4a7560cc4b79e3be9442f2dee344909a8c35c73a2e470051592a251cdd6cd7a2448b98d6590dc0b60933a804233f4663b4d278da5841c70c6396a9b8df8e2ccf8e9a4ffc592ff1d848df59e9a40c5d709565edd4a41140d2106f0d44b5b5c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
