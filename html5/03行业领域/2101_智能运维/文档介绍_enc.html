<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c4703781c4a2ebebbf03d5534929d9d3bc16a08bfcdb6b9775c708a096df6dc9df9576be8f0a71d0480017f66b18f3468cad5cc7d75676de0dde3cbc8fcc99487ccc1f420418dbded6a69278a6becb0dae190d72d4fd12f068fe5bf800e89f831927c4d69dbd07fdd84819486bb3f0f9909d76d12cd1b818bed6b7dee62bcfb8892bb1e58ed650c9304c24397a6f86079c5d8cb30d6560accfb3e0302bff2a050174f3cb5a3f36e9ad7af14a4c6cd5f6dbdd8e7531fd675f73f53c0fc6a0b13a3fc5449eebefd9aa6e94089fea2912880100d5d8bcc117b66e278d8069b4e0aaed91acb23c6bfd4776df8bdb794cd4b2873d993031508304a2872f181a8b1cf815c802468864b00dc53cd26c6ae589622d3833fbff76477d7f1fdc5502283f7cd1d118bac8b0bb88cd97063c49381eafa7f461b72abd92afd9771ae816f991f3c98f8ac4469192a6c4bb834279042f69346e7c575017969365dbd539d9d7ae80d0b5e5fe3ffb8832e90a211c9804e2cd2a7bb26af90a8b0cf25af50deabc99e3e0cf2b695bff6e21b1ffb69688e505044d8e4bd080908747ac5912939e002ac6161c5a9b58df712c3062c9e7122c62b2631e89b09b20e8107f6797ed4a92cc729faa9e88ed7a3a93cc42297880950271ba9569c7f1b3bbbf41ac9d3086423ea50a6adc139d2d2bf956260befb0521c7ad385dbec8305d4584a3e5a89e3e061c70f29b55386c51eda67ff08c40d4f066407e7a3c0904d4bdfc9114ab44c6e007dde14da627eddd6c938ccd5c35590faf844fb939d4fb68025e811fc034feea8f799548577fe26d659f563f8f29efb3f6d35df7a7bceaf9e43bb7b4e46855e253381040061433c858ef90b5918060ea468b1798b28780336b5dc76101172e40209847cda9ed087d2f68397892a4b74d9b3a78e08b619e5d14bbc9f493519054631f65d086d4c63fac7e670b16d1537775769465cf26b095ae3e6a35106430d581ebdb2fc48e735094ac1246b6096ae8ebb5708ea436359229545663cd089b35b1040ab09473e8eb0370a054ceb97de8fd4d50fef787871dd4cfd3b3a2aecf4d6ed25ff0977b2b4ea07346d25fd458b06d20fa2f03c364e75ca9e667a208c59b52306acb03e96ee24c00d46a092fed0a8b8545f1a2e29b0bdac4a9f059b1150179d124149ffcbd5e32fc90e7298ce988ff1f510866d2cd30e222b97d15eb67f815c03c9890c9cdcedacdca22abfb5e3241fccc92145ad87f894afe7730229201ac8fcb53c8d569e953dbe7771d428581d1ec03d325373bbde3972a8fa05f18fe37aa7e19801e7501844e0e575f9e50bcba1fb5099699e185b7293de7a5201897c41518bdfe077637badfd3b21e32444093595a190a32551dc13c4c301945340b68e477428d88d2e9903911ea9b279f057ec29178d7c4369733cc59bee0c1418494925d1a01a865d69e849f9f0814e49b4f97e43e21f36e053132e2facd4d3a8756fcde6b7b28c25e862d403274a90350f64e70940478216bbeee37c89da493a1d775bffe0c56d6d83488d85fa0f4be2c3ad354d397e613ee6989d6cf6a715da38a7566f5683373a5b7460e30079782b5a9ced2d27b4fc7bf67c31fcfc07a7dad40c7d4b6b47d82cb13e388184add89aece6b8d6c757a4903ae6b29e9c1b38760267e8e5fe27727738d3aeda35bc91c414022dc6bbb2179e057231ef6f4f5be9374b86a73dd905f542ba3dca2d9f30bac9776ab390008c02ea535e4a9280c78e81b0d05d1db0654cbced8c06d37d95acea48dc7a031781c2299190062337d90b896716f68ae5f569f6728b2135012cccd33c9d809628bdd633c119489e030fe1fe6e581b35d1a63b0f22805be4e48b24841ba56241645334703f6dcb12d1b907c8356de26ff1d263a38d83fc5717ae6ac42ff85c13789897386cbe87003eb824df13af273013d495f5746ed6c595443645e59ef560ab55db7f3335fadd8a83617b3d287e0432e2390274289e99b15fb57f934200f15037f925afc7e7f59c255bec516ee62dba4fcbf025c1e8bf833a2d31050378d38862dad2a2a3af838ff07c8d0945c5a72f77f45e0db562bdfbc1114d88131be9c7a1d8953fa400bf5acbcf7252ff5c0ae34d92e3028f74183f8dda32f68e415f4a9700b66c408c5dd5221219acee2c3ab34dcda196ca59f328ae143b63108151fdd9191460421963b5dbeb718174ad736912c03b877dcbd2a752fa751b0cd654b4678aadddca36215670fe7ff5562b78a93be36cf251946108ce3942b4a74773cb8e9cecb95de3cfabff3f0d7c316605ad68d4bc946c9c2e736200f4f6cff799fc86fd2ae4c8a11f72ed93b7f15aeeb9d78158ad24a70b3fcdff8f43ddcd3ec6ec1292b1fcf3a0e25f017902c66fc8ad970a219896786c2227203d9d2a5865fc96b3a30162bf78715fbab4131112c50ba6ecd549b85ab1cf0ca98afc075ca39c8ed5f8ed55e9b183401875295b74d831707e987523515df1997e76ce1e911fff3e3705f1a563d1e1cbebc8fd9f67ec8f86b4605c18e11bbbd29356fb1fd9b1af27ad45a074c451477a90f444391910382b90ed181179b3643673d28c90064221ec40b533f76dce04e90248ae68f5e09ec2cec9842ddf7572cb94e74573debd221379cd27bafba1ede3f4df48c8c2f3833e6752b4d809c08a122d23f8b0ebceea527e6a76c641e00fa9f547bf4039c155efb30404327dd24bac4f429949cea56c7bde74840eadd29916d28ff920be69d01058a200998712351d844341c2c6016ba6b6144e952974c31539f1a659abbb04bb5ea68b7757b7811f1f6aa5e7a12ec8d5e974f280ad255442398f640db1c808ab9924980f2138c2eb5e5b813b6f96afa0db157b3a33e87439022ad8a83a9677fe19bb81eb7c3c793e446ef5d68d51b0a06f0c8bf98fe6928bf4a38e6f43eb9c1a7fdc9528a9e067db5a7ed75c88b888f2b161f2d76c16f7b5409db79bce2225ee9e1524d82664c55457c871761a85fd05d0538305a0363d109804f131b5c173adad58eb08b84d567a1586294d4737c6ee21c862311fcb357d782d09d7caf5907406db012e5f21f368ca2dc735488433e3f1ca6743fffa857ed3be0d6779d97c13d2d0a14672d581cc513f414d4a695a2f3a6d0f88da12eddc88ea81fac752f34b38914c61f1b3ddbde85b615c75f64663093d250d40bcad8f937e7698a0fed76099bec5544b6ff63d2dc62b1e12ceec3f73c5fa1d238123a26d4d531c70b02e27515bf26ac20b13ac32d9bcd4198f2f436f7e40820ce1021b3c5bcfd00e3360e053d8cfc75bb81135e7da7a77b02668e4ce1017646d205dec978cd56390539acc67804e68136df46f340af840c89d55b350825c0337ecc592a3a752b97d6bbb524d2ba235a21eda662e7b9fef862b10274817b97ea093e82695530f6ab3e6ce7979f661f8f1d735850f83ce7e58d725c6b577d6477dff007e81b979f027f98b619a09a4e59ea10e9bdbfd77cd893306e83b57c14cefb042bc3abb2818b50a13c393c6e5c6880c14c7a070e711d768e5821f32c34495b6e7deb5f73922cc24da609b7416ed5f358795fa2aeb09c28b11449fabae523d1dd40fb7795cfac3c3e6065845e47c05a32ff3079ca09e3154d115ebd7617ad87eee3c12419264f3dfc4c422443a7da494c8b9f0b8c00b7c80ca381195a39eca88779f9732638c5da97a4f6f9d45e34bbe755a70b0c31e3b1a6d3d943d6471657c0a8dd3e1434cac9c778f09ffe892773d99ef88e8c9998b491ec2ac8698a927875e7bc3dfd6f62ad7abb996ab0a72d60109406ea82407171dc389a2102aaab73464f49638ceac467fe13361eef15f22a914fcb8308f5fab32cc2a264f18af8d9705ce30baa36b7ff2aa42ef3eeb982449a88acb0baa1cfbc2e3134d821816e815631f7f472a6a1f52528c0898ceee1c6013e2e90ceee28c30fc14b18a598730e4ad8e7293a8b37a0af168a2dd62f73ee02a7824a692c415f9f16875ed77538cbed6b2849d5b9e07aaf29671439c1e98f34f9e7bef8b9dc08f08b46aef54c70631b2b6ebc4c6a033857833e08d9e923ff12d4e21965334ffbbce887371ca1f45dde01f81d140b4262ce9c0bce1943a0134869fdc7ab39d3eed106693e00e4ae185a474e072ec32527fd70698d598f73211f4c03cbebf9b05ef81b599e8f4cf532184c4c57d28079774055f7533488545f2233e9c07baec7a9051b66c0ede169c4176e3060f9c9b08de3d50ceef58e249f4b6404a129fd4e746effe29e04dcc4301475bec0eaa57cd3f7e8297dc373748e1514db7060af61a4062a8941e8610eca6402f56eaa8e5c7f29afde825309d40baaa73cacc4f23b4b1fc8cc6251e0ae6ae32407e7d311a72a6e621f31d82d67c621dd9a3514046d6e24871dc0d19a7db592fbbdd7117bd28b8f9d0627101a2654edcfc6b2551ecf248b19d164ada63130dd244d0299635bb118ab39db30a6db6f0a39e637443926b23f3cafaa2c5733fc9361e62d9edf317eabd9cf976dd2417dcc9629e612fc15865717b0bafaa9cdd13665019ed3a9f0fe019b655d5d003ff9c5fb004e73742e484c1342410407d282c72f5f903284d2d78becd56de4f708e97c32bbed8033fe66984b80abbbf481f100f58231790562ff00b1378ce2423706586d8db639a963fdae094169508caca00906bd33f98c2c959825bd6ee953815730249040b742ebffdfd4897ad47694d422f87b525adb8d9c67006eacd858c2326a3b9d2b02a0487cf3239c9318859e598c081857a81fb415d21955b292eb10fb78c4aab9a70c8c16c5448a3b6df48180601c5c5fbe5a9c3e1d90e93b6e5c4b270cc142ec2269d19c4652131a350e7bf4e9e3da9c961303e3e0a7f76c2d5ad7e651178df67a22360803683d3e87a8fd1d0b800d9e7519bbc05b2200da90fcf40bb75250907325d4cc32b68bd7b9d0eb1753bcaa89ecd894271386e0e3dcb4ac8cb74192e528bc85849c4971aa8e03c37243d8c1ce00846c96fc1f174b2e5440a8fb1052f3d92f8146aaf5338ab4a84ec7bdbcb17deecff01c7ef8cf646e25728f94b4ee9d40fc527b46378d79f580d3eca2da3d0fee778ec2051a3a4e85cb522cd3219011387c8c8fc56356dc42ea5701b427eb6330c9a38a5f15261786312e490848ee55463a6674d0324c27c7cfc40d7baac7dd83c3a1e9553905ab87d08bef2809f697f3ba3e0e2bb6fec243e6025408a316dd26ecf9be489e650e1ded1f0cbe13072b6a9800a16ecc91c940b4c86b7925a8ea108792d78988a2dd9793134cce67e26793a4a71f2fb5300d74c3a6609c99379c5731f8173eaa0dbcdca331b841c59b39e0b364ba9061da93d03b21d71e7a6a737e8c1d6b622bb807bccdfb951f47c65a345a9fab8faa186ca128174538b1c7200e0f687fecc4701340bfd34a79feec7bc1cc628cbec05c80c5e348d195698f90b439b447791504150366edddde23e14e4977f8ae94e2032c56ae79cc59e2a60c2c450f3834fc2eea2a0949b3f190c6fa5c6caa78c51fdfcf46470b1c8ff28a87449957103815a776919dc350f6f1fd0ba004faa5886c7aa7eb7d55c982fdfd8bcab9ab97b63316d01880c0023854149a5afd974c9db384e041af8192a78ba5923403c3e18d558388d9dec4d2b578f2a21ec24530a14ed8c48badef869454523471f59baefc5dd11e1095c8521544cab1790aa366c9a2ad6100e43958257a064f0441f65459b32a7bd2a09d28989d0c028a57eff0a0487c1d3d56b6f08d77caebdccf75cc5093235f8b4c1fed00ec7bad93ca7cb682767eb39f66865441867a2382cda613e378d0bd83353c767f60ffa8c1c67cee28dd9592eff478e5efc89093c26eced6c874b652d9aafcf8db597806a1a63c5ce37dd53b0fa99f07d9016d8d3c04ae7f591e3c451ea771c06fd2b8fa32f3fbb531744316bbeef9212c8aede71d47838b23b4f597d714f358a1be820d4d68f92a4be7d3f9b131cdedbc359504967758477ae2e73e797af48e024d4e4300d3f39da343af3137c19f61e0e562169ef49243130fb5f76e4f2e23edd54d2c1cd2590069cdd31e20e54e7d0c6fd6c8814ee97a3845ef6b87de24a09946c754017839cdbd397f7fc563aae345eca6e36353c9e16dc8c2511282e21fd470f2012004a24a4996432853170396752edcf9d82f993fe6c0f345d203b7b6017026bd3a044ffe67080fdac9d7f352e2809e01dd8b6963220be3cb1b54923898fd3b2e63050eb6e5d564f2ef36112c662abfb9a524b85ed163942a11ca41d11fcd0efea636671a2833525c82b232b8c27d717370680a31d7fa467862bea65a217b8603b0eb872c42e7e4c0f8ae4f567689af40afb682ad9a860e976aba9c78a5ba6b2c8127f9aa2f2077d7c1913180840022e108df89f6c6549452462e16ce5215ce5740b0550ce6105e36d25386365ac53dc0541e0af80e3d3ede35cb8e14951619c6e19efbb273ac3ccc32303526f47451569df866933bc875e1295f6f4e5aa9a195c543d3eac35c749845dae28799b939d931222b310f562c2d465b8870dc2de879b138957468b99f3bee5f8149b6a790b75360c219c07d213eb15e73b8f519c90222328fa824486ae854d6288c0fdc55a01589455487035f034f593b9594a0019939965a085688881bd5b5e7303818f3f979e8a0e95d77194699e44732edf5c2d213e279a200dffd32436d213d11a1834b5dc507ab8d7be20217fd5c2e276f09670bc398390ec8f8ae486ce17bfb663f2ebc750df6897a4a74f9c49697080714865359542e69b24152daf43ed48cec440af9c5428d983b45d55ff35de30893e293fbd274725cdb1252a6c2e641529b3c3e730c3e8721ba9171c86dce7c6f9ab5a97de55cdf5fe807864c8fb5ee51e488f462bc740637726f4db7f97ac0030c8a2f1677d0f394d2505244d063090e31331a048bdfb1657bfabee1b502618b3b07dc183feda91a3a7e5dc452981bcc49cbca38a3bed3c08327b4b06442d8119c38e87474ee608b36b68339c62d89190da7b681c38b1f230ea13bc857d0f966753eddee012158e4ebc3b79fe827f6a43ce108275c57980f542414e0fe58c79657f1dc9f420c69a5ca49604ca737eccaf6a6c979169b0f52025384a90055b758384672c7c54a49aa28ffea9ccc8944cc6935bfb74f54ed2d41e3f1d876b09366dccd434658ccbe9bde02922ae4350d3aa172583c7d17bc2ef9a588a04d1629c281dabbc2e92e7eb7ba2c75f9f70b3b3ad1289d464da464c9a51fe37c3bb31b1dfc724a43b3394f4b28be36bec0e2920cda9f40ab984606a1badfbbbdec8b9a291a522e3da1f95336cfb3f759bc3a197ae4b0a2275f0320083d6296915267d602a37cd3bb31e3f8e22b032651a19cb6e2e1e7800b87a828673da35f3f40d5353d7c336b5dca0bd1fe5f8f6e87b7d38b1548857ec8a077166a362cc32c351c110e750d4d2e0997432678e3ae1d98617ba0903e971b51670ea6d210aa7397c0469f362e46c20b1b37578e8368d363001fc3e9c5b7dccfa8940d1b97077725f2828238cb17f1467aa0922a8412bd9020bda6e213ad6d8842b6d397ff32d85e7ec2fc8ddff93e6ef2f534275a8789c9fa95df474f3536efcd04d7a57f421c96b41d67e7eac25228e1e6e3e41100df2e2d75b9aa37337ad60d4e368133ea1236d81c91b0ad727863c395d46b26f8e14e3109f6c983db66fa40c6764e339815993aa9f88d1c1a7ee855b20127297772748a804aec602a6006cd1fff408cb5d6c45c051ffff4c7fee498e771e49580df4c6382abd722ea7a4f90d1e43c5778933a494aa413d684c95c2c0a2b92419619bee742b1ffd6622145856a03a0fc7b7b17c7fb6273d4e8ce386e0771974c06800e13a4931f908eb7f7350de789aff542dfbcf69cd4eb8b8219b800e7dc83bfe43c4948c29f36b687e8a746d7f1dafa70662c9fb15745a8a58e09bc4f5e6885609ffeaa0c3734d298dce24493505ead82b8e369d578cdff35f1cacfad2e8674c218d47610ede752997f632ea40263b896c4c6d5aefc77231a303eb95151f0595cd68ad5f28a22ef5fbe6b14c6189281dad2f6f2740d082e0420","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
