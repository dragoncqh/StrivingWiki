<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2240bbcf79004d61528f66af859a13b09eb5296b15b8d9a33583bd94a8f2633c6be11c4c60430d57e288044b668305ee81a5fea7c2362361271ad53dd8494761b562c51ab7a364aa9ab82175f03fd09a81e8d1139c33862bcb0453f236ced37b74d6225af65521ce984afbe12f655052323e10e0d5093f9530ee6f08c2e3a51c725ce9e4f43b509aadf02c13c1f0440c09fca238ec85e62afe9d0ab25012abaa1f594d4ac8f4767268576e864140d54f892fc8b3b9829a35965a319414737cf4561acacc1c4bbb03bb473dd5526e85480c5733bbce7a74311dc2149c61b73cd42bf50f2c0aec9ee00f74b4af5211ef5da868f4bd037e7b9eaed75f56050931e7123910fe4a90b436cacae490f22bbd7bbbd6742656dd655f0f8d87ed22cb2ed5c7d25b93069b64a0bbb852f5caddb6740395bf3b977bc5c9de52de49e1f6651d388e797e5941d14a281030fbcd5043e2419b778cb05449e4cc9be73454ea381712a4660074d4d56c259a09c96e8f0e8b127bf44aaaf3559ae5ecdb5350fcd99872285105a8f9d036712356d4f3e60a1766a478083b33599dae2a4023692d90a2dcfce4083a098f211ff823c17fa5da404562c0658d5b895ddd40f9fdb3318989d229ba7360b1d9d73571ba5236d131e1af2de7dc08645fade2862b875a3831acc16d1e1eae3f0a617a5b39395bdf68b34777a0e3d300527df8573ba2b81d297a2a8ca8d2189df2040f55ec3e5e24d508eba9d83748b0b4acf8be1d932b279b64a07187fc704c8b296fcb87e31af7dd7f8bee82eecd419dbc843476caa6c7043b8544a62f8838069d6794d041637655783b6fb7e2f1ad85fc93f5301715d5270ec1890217721b7c3a03c96cc401881844b3b8bb9b24054889c28f9c909b8298c603eaa43ce881f8989d0dbbb23843566f3c737166e8d46a23f768b5a228333274fafc4f939127db48ecff5ba99d6907ab0b7a2160f76f075d42559d99a99022eaaaf2b85fdc4ba8aa5e1b8c6b979e05b9409a8970d440cd400d6d687f7c26e434b0ea5a6d63257a90a5b1314aad1fc7761c3b195346b6e366c7a162e0d1f8ec19b26b6eeda634821f5fa59b4e5738d3774606b14433f59a39a9ce4af6c265b4964623c61d52a9771e409850751585cc7b13ece182782eb1f9cd88ced1cf121bb2f8eaed9f9f863f9a82b4c1f46806039f40a6e70b912ed6acc1bafead4385708b380f733eea6267a925fe2a0b6a344c2103f1fc3ee94f87a94da1de25439594a9555f5b3cae92cd4978ad4ea51691707efa89182c422b502b18c9df33c7ee027a7aca7a6532ee092d4fe885ec462b83dcebb73b41f43c58ed9bf357dfa53a1f868bdc043014450846df912089ba347b7f2d4042bed2a5b569b4d675bd3dbd67d75a47f67c717917b2955e374bf44a8c96d6951d09ebc9a61842371af73fa29146094c501f31783bd3e1bb48b034111731547101cf504624eeff57ac244fa4c67c538af334a27a98c0e8a3d1dce457323f0aabd35ac892231b94e15d5e07cbad72035e796e7204e985aa415196211fdbb2892396bd04d8d032b979809fa3349ddf650d3a83a01c83cc81bc6e57a0f64eaa86caaf91a477cf751dd9aa58f5f8fef69591ed9057358d5abd5ff0a3d41e9123f90aac75def81dccf20425333d25feb5c11aad4f5eb4f8c2fd7f199419b67e83270bdad53bdd181a6c7cf2abea698c3467d2bd77a2e0fb9b9aa0350802ea32e97a43c6bdcf477ddbdda318df8cfcdc0040ba6ed11354e0728d5a1a56663667aafd068b2c51e10aa54dd75225bede21b9c65de00df477748667af776cdfef9b041b30b012500419352914261e741f558e42c9ff2d3749f304d6a9edb0c78dc69def75f6bc5e24021b9afd2277f89d5d4306b4e1c05104968ea6c5cfcfc0eaad8923e49de71b4f986fb93f6a0fe75a194e428ba783e861e08f3a7da56221b21349e087cfa7c85d63c4d4b4c80b2178f758a1ee8353427e18d952c08bc4dff39700bb4f0c4f27127caf9beb301df514eb37c7795be9e4eaeb04ee987aaf845d1775912e0ed6e767abeab60d166badc00c2bb1fcb0c850c4386630fd04be92e3eba117eb5dce7d53e1ea32dea9f3dbfc111714606b576f8ddeeb77e5321df745785dd13fdd7df21f707bc00be5095f5b960b33cd45c0b5d195ed5df6d09d25383ffe547612be216b4a60bfb305713be6f38894f5e7b243d12add7914b2089a09de35ce6d77d8e071928d4be2e6d38bbb802cf81a4121ea22a132c10662769545dfd4cacfa9e5781e8b8a5df2b60007da380e8968fc3f3a98dbc27d8f26844d553d55126fe12ab17275f6702d7a323338bcdc3873fc1c6ea45e882a3e8d3cb14831beff652b760053243132eb54b3fec4765ca68c70f2bab890bd21c06caa3eac08be936de0dd89c058f195e05b2224a8cd2eacbed9facab1b70b1b1085a32ec766f858782f59ac3a54dae33201d7fcfbf9cd0f1920adf2a0117a7ff9d621f9ca84652cf7fc10862f8941c1edffdb684cb15130884444c5ec16fbc55f0477ba2eb0edccd037d3e7df1590ec8f3fa5a78185f1eab18ca80062151b87c300811875c9b04dd39529338817c0949fd8f0ed49a525e9cd6cde698f0654e1104a0fdb49dbf56d6157e88efa5114c0d70f968219bee77623df1f2499aac85398be8829217991b684e7d9a6c2faaaf10dc605dbbb1cce0a77bea1a8b8936b60d7135b83ac4ec1124743c0f0a09119cfd5f37b9503ec599962cc9ce679833463bbfc16d410235c6fe6384c25bb5a8c479f0e7e852dd2e6c64710db54a0e34a104dc59822ae4d98b5e5c58e7a80090367a4c46888834ecaca44cf1ca2dc7625937ebc8599aa6baf6bb25c8fe2d585390f995239554e301bee56787a75d2a8285f5975d7231c1728cc724433ea85901310cee54381b8f3b42e69ea09e6125f99cb321c7c3c7e2611027b106697035df7340941615962ac5557334ee10cebbf1562c55b55af6ec959164f09c09cc8e7bc935f246fe7940ecf3f59a26c18dd220738cb45a7fb15064a7d8d3581fda807985e86cf2cbb32b943f13a305d57db23d15793b32fcff17a841fdde4de6c892c1cfd4dea5f0e1717bdb46e96885c6fde4ddbf51112578d530f3feaa3ff05aa3baeac5cb31ba6824411c3937c72e1956b5f2c25caa9d9ec665a975787ac1b28228d2dfc614df8b2eced1df03ad5501337e8457306779981648b27222701b572ddc2311bc355714c0c130e09a8f575e63c65110cd43babb2aefcc42a26da07f2007346c7174b01b8d40c29b716da6f869385eece96d70888fbda33799898bcc81c5fadf01785e52e8fb03da8a863a2cd3bf44c3497ecad1b6cfd35521c79d5fb67efeb4f52155b51d8c32249b1d803507a7bbf28bb273ff675cd7f54e0f5703e6014de475996b510fab8b68417c02f7e5536de552277c3e5bb989346d122d8898f963b4c7ccc26ab1fc354940615016820ba92151eaaf7af538d43cda9d4f72f81139afee4e480e8ace92b3ec75ea0912368cb9f7e1f6cae360653ad89558be8bc185303c8dfae53e81adac80679228ead5eafddd20efde4011f135ec2a919c62ce25ae8b2603a3de3898241f32e9dbf34148d44f88fb439f0dc917ae705e46b1406c8a607137e88d787d57122f929ec06df6383d4e45081047f70de3ef6c1e3d16d69c99bd967ba547d9ab708655a6f8a22d1fc963641838a1327bcecafde7d4db2de2d6fba0d0037120f40c08c9fe631defeca6ffc7755e1c458bc466950b207756b0e9831e8cbfe5586f26ec5f538bc71c3067ff9af7cfddc68f8aa90e7444cb2ee240b780bc9b2db1053c4aa598a9a93b6ac02a65db262e054e324d6a7fa8ff13431b172a5a36807a203433a97d438e86ed97a42d7c699bcc307dbfb95e19b418157b9e7b968d06f74c40ca46078e97b707fed7427cb1756b778cbe6196768c7aa6bc48df53baa862513a2393a009598f694127051b5631dafedd283cc34c38623aaa510102e079ffbbd4d46af9f6263ba97e7bb510dd767696f3f191a49928a57640dfbaf79559c8934613e86588932b110797a5f0009edd61c060a909d2658104b06164b8d01533a4ecff93684733842fe8f969032c8150b4dafcd995bc5912417cf6a45642ed436bcae260203a9cc859aedda8b78074511ed69c1f46687ceaf10ee22ab08b1e0fac445ceda3ba10f190d41b601d5d44bd9a010e3605017127a2abfc3a280af426ac1b6c539472069e8b45df475e57c3c24aa3f6ddb9b4f35ca945880a5ee29af9ba8a9f1787a9d62b52e3100e248d796a02065fe709b41184ec02383ae38edab574f66372381cf72ea45feb86f0c0d3275e27e65f1d64dc24d71a7fde57e330ea2eeb064189db0207e12278031fe61ac6d85e71f959318d5393d51f67c92aa75f04652ea03ec70895ffc6e592e23355d575993b4992d945f5a46d7160e20e9688a2fb010a9e2acc0d8fcfa11d9a26bf054c565793edcb6a99e08a15e23ff833c25e45295fa53ed2d06daeb6b7392e2e8ebddfb58ecd23561693b0007271ffa81ced22f8113d25aef86358c1f2f1c2029092cb37de78669c3e65512e0254912b7942d5df2e6226056f2f6a9c2439a4efb2c3eaa5270b312bc7318ec9fed6366d8bc2e670e165baf38b59b7c8fac6819e366508f638c817ecb8708c893455ba787f63e831fac277e778cdb207f92c312276c48e55d2a426033e59cbf3214cf15bbf097aefe011f78cc6982a5c310a0fbdf7d3203e8a736ef0cd3bc29933535c0b937416311e66c4794faf5e0b512ad183de9ddadc96782287899d6c0a6063f0668c56e9e8df04c5cf9976f288ae4ea92f797c575aec3007f7fefb9b056b983e3390d0d82a6fc5b1adcf6e17e92b5d240b2eb17473e3fea29d8d1d28188afd244d0be54008dd4e653ac8cf74a8c11ac6279af06f480ca389eef4951587b25213f90c0e7c64d344a9c78a41b3c6c3bcdb99b49391171361973e2c0bfe1a5bbe830b3693dbb40722edd261a8f1a0a0b76f67ebbdfd6379f79741de9eed5d71aa1870f743a3d2ac00dc36aebc50de54ef7b4a4dc6be6065d7969500add062bb396fbf66d58898f6b464cd0a13b7b6b27d5c1843c184ec152ec755319b1f16acca4318f1e38581deafc5122f494c18efd4e6e1d899a3cb54304bb1500e3f375ce5de4e90004da6d374900c5f758b5a404d7952be9df0ac66f3244d3013683b9af530838d9b1b532fc7419115cb969bd7716dd3ca861d917bbdb0ed180d712dce5414ddd279bd6c20b599b874e5743b9b352e1d3144d8e758e6ed5f23f0fe7696acabd08d2706bf116fc1accc929202f30cddff75e6751d678f7952e98a4f468fcbcb51fcf58d3c48fed322cd3bb9d2cb19618affed9f88a3a4bee1190fe7e522cfb0f6433eca40325f8a017128ded92ecd3549c3e741a79f76e2f3ba28aeba4ea1bbe01a873c8b3e1b9e2849f3cf0c3b14c7bbadc26a7f2f970833082b173d37d925340acc9cb000776cc065c8a275f1a51e48a8f4af2f7e05ed43bef4e00406ea600a9583209955ed4707a6c2ace8112f94abf12aa899b88de9f2df3da15d0095b57ecd38b804598b1281ef243841c759a2e950879ed64f9b393dde16b3163fd1c8bd38a1f4a82b05754a63a1cea06e3ae61108c42e191d617ac7e9512d43b28783797df6f672c75810d6bec80782dc528725c1065950cd5964a7981cc981f6e46f31c92869cdd964fb9a870e68cd60ae0dc096e43b4fa69282559825591d15e95f44a596f2c0023a2bc006749453ce50335d087b8730e387f14db1a0d3db2524e3ca7c4f6c5ff07ea3044d22b2eefc1e96388da3d690bf2c645286f6476f60dcce98cd021b02050ff3b4e9024397cc156fcaf4d79e0e0db3062aa4aba3b482f0630209e9a4458fed5e2f9590bd6f07bbcbc6cd5cf4a16eba3dbb5ab208601d0ed2bc7f2f79db9237648be18948dc6cd45c1d84c22eb911aaff83aaa35564806dfaa19e7f918c2038cbe5513539c1b05f972e2d75a9352e6051ba986d67763c10bd73d915a087073b0b28bea51b529e1b6e5f893aa8221b49746cf3ad8fa307b6aa6cddb0606150ad9266c9274758ad2e0b784b5e6d3a5b9da26b0b23b2354af013a4a13d4f083a04887b9a070bb05835bd9d537a72d4100fb1d3c91c9076d077352fbe0af176582aa82bbc94cc658576931a85513097d7904ce711831f3a28df0b08d6bf678e4bd566535bbe0f93cf5929237614d8250f340817a934ebe4c053ad7f4ce3bac18bbe00fd284868455435c317d8ad9f805c78be072222b65fec168f616a1f74511f54b26b462b462af5296a74ba4905aa767032ebb7fb569a57985c60b715c3c835af9c95b8b4b08d7660f86ff8473347a8eea7d594a41fb32d31ade6a986bf71b4f040bd9793164a50190e404b31fd7436a6b645ca4b73678d84791aeb0a81e3dd0944e2daa28fd4382765e4624b524f68cedbc05ed2c2753c78fe8d8d560edfc040c25c15326177ae19455404bebfbc2cb9f2f10f7aa6663942f6bef8f4224aa5bd7cb567069e6ab50ec50e569cd56863228f2d369618f252821b5122955f437192499287b4bcdbf439d3a3308ab14d018dc1e276cc3cfa6bde4d5dc7860ce402a950c4b702dba056e636ed92854e72667a02625e12f59ed957483871c54fb652435b9e745192e59dbb0d6ff307cc25a7a742c56514c2f741f30b98187bb5bc1cd1928557c8b8df94ea207d1ec52961aff22ecd5b65400366bb1dcedfd671888f1bdf25eb2bfbd8e26b2c96d96959d804d0b1e029c1ebf8346f06f6d3395543cd5f8929a387f80ccadf157924c1a7c19eb55cf23b8eb307b45cf31b6a7aac7cbfc48ccc32b6ca26ac9e124645aaea8188cc3dcfa6fcf02795610e4b267389b0c0c2d41c6fea5f0f5db9567de12367d62ea750974a6114c19f765522beb2300e44fe2688670e847204d5cf3fb4b6426935e5d91b7bc89db8fa41f50181aaac6621a1ef72266dd3d3a0ea7bd19fda66a9c65118fecb5aa048aedbc8700b21e5f93edf7b1022625daff99dbf9f24adad6fd7c4b54a84a48af6ced1cb0f19165fe3b2eb94b4053cf452d440fff740f5896f96533dff1d866f1b0ed87e2a9d3702eab8107d1b8b89461ef60d0a90d62b3442302341c53c55d757c3bc36495593b96dae5c73b1cbaac6483339e4e393b54de5ab8e7e1b507a36520138f8534d9677284eed17cd2f07c046798a5048406dee383bd7a7bd0a7829cc3a70b8f4c5461a3fdf1c2234c2d3535a8d25d45c8780e57fef42bd95d2f38d8855cde903a86e47fafe64b8bbb2dfa1f6046b11de3e82315cc7d9b974f063a1dfba47e653a2def1a237089ca9b4d662707f7032081b4383f18862c408bc14e8acca239a9f883a2fc5cd459c7e15424c4b3c24cca1c29e1046f91d17fb747398a44ab9db316ec5410e3ee3d07aa22d5fc15103a75f37857bc64de7a4883a318a4dd84c4342887a67f0dcbb7ccc1e22697fa112474b1856102e2a8d58f8d535ad87a436501c685d4f5434e897af6c1c16f87b0e9dcbb561720082b1fbbc664742cda2f20cfdd22aeb444f4c1ba51f786dfd4c268bd8d0c2f088e86a7606db42d5c23e7fc9172525027d9d31a36d916084cef3d6835d7058fc943a94db15648de6762939cee8a7c9b2657483d8db02c3eb85ea0637e80ce0534469f52d98f5edc11c9559820d3ca579844bbca3fb26a734a9b08850b458b1992b6ba39b0c5de99d8fe0c3ed76ccb6d7fb2abbeecc20f3a1dac464f0314adb77e66282ecdfc9349680b04dafd5a92d14455a0aeb014375a2ba402b8eda74331b9ce75de39bc5b3babae7dd1dce30346cfe28f9f6c4e89f69d7b73e0f2d4d543ac702a822305aa56412b8afadb6ff1db6d6249c303e3bb8b90aa5952e0f77aca0105f38588d8bc6c5a01410fb88dc1ac8802e91005b0edab1432c1b6b34fb871d12f1133a98058dd292a573f16f1981dc2f5b64c1ca75bc23bcda8874bebe3c3c82625cf3e17b6d2e31c7a80629eaa62d5c5e61292047e55415971b3acc97fe460de1105612bfdbd13acedecfa45003105ade08a66dfcfc3ba75fb64518dec7fb683b3abf543cfda905197bf3dc8d50953114c773cb4d83c93f7eef99965d53b87cdf02a04c7ddc2fd28dc7172303600997e7073ce8b70637e217c2de911ffe25520109b5e7de3e7ad870a36b2f13543957b86e4f46d368e013aec61f8e92b26016eba32078650fb4c9b3079b7cd4ac60609898a56fe3287834e971cae5d3e9dafbc154d6136552b2d62da432b0643c7448263635b5fdde49ead1dc4fe516c4fb2a8cd0e88bd7a527e6c580704e87acb678d93042c5e117e49c3578f86f3b00fff09c02731a1a2e9d9f9cb5219baaa4dabbf38f543e8122b476397b47678fb3601c873aff8f471622fed0c816850883aafbfe4f5a29e8335aacfe6a7e017a796d902d61c3bbb6837e0987399994bea52b8f7b2c188548c1e149b613074b4cd218b8f964ff7187a4768cb735c6c439f494597ed24a89463e3e1a6a2473726380ffb2fc43d30b2c536c6304a731e5d48f7fd1902afc5c023ac71911fdf72df0a4ba45d2cb0ff2f8154e8e58b5eb1d45aeee002453e732401681b4c5a736a03e598275d96cda39cb47b5b71b41d531599b8937194f776b4109009a1a8b853b40ce5d4b69da75b122871d98308e08791e8ecfd75c5a384fd60cee5dc6031d34e548ba8fdb9f3adfe597dd56d0fd460507c9dc76d03ad62140bd12beb0aaabdefdfe5f476e2bda17c13919a6c024f45ba1c644f5903a99b33b6bb98e185620e2b77846e4ca03f153844914933dc442bc8d7521032a3895d6513218fe0737691e2c4bf79e32b6b4001ccc6ed51010ec0a2d675448f64a2cd0b00bd56333712de1eb0c66f1d2b3b24f87a25d90468ee970bd03ce47374e15b65015e0d73020c734ed2f87e8c99bc25f1374bd02b384f65ead69ce6ac4fdd06b759bdb8858731ec8451765436e13283c1eab0f2697009245d2f09999719effabc6a0cc0e9d0c310cf2d4ba03a2d26904a1f5d25c51f142468e6f7885fc464ec0d07d217a0a4e6ba0aa16b1ac378176642b83ae0b8785cc9f8f7eb5c9093dd9057e01bb68da407cfc42d36213694d1753a53a8ca2298b11413913f766ee6a6566011620ed60eea61e2c86c694e07482042640385216c853e5b389041024ddc417658906e7bca3b836d6fd6facc765363361e995182b691f05929ec44b62a3655cb87f59c1cde336da2717eae7df90ec4a403243a9bc8b89095c21621ddd36dce95eb0728dee00281f5a431ab8309ab34130de96f1bcfd7a75264c30cac76f891f1f8918c616d16618f7663bbf216fc697b4361bb7b2b62c3dfe335970a005b836ce75debe46d77fbc6d5629fc2939193900754dc98f7ae9d3232eea1602df47bad6d97d07048bcf97d756087cb3a1d111e80448a711a1a52510e769f0b99ddec948689724bcb65459ae537b7a3d73e9c85961d38ba0aba20d3c276e81c9ed69198312beabeae5ae934e120a137f709817f69e9a69f2aca0d51e29bb112327203412036c1341b0e9f1408a496c50d3137d6ec22cc1e40cdfa6ea1504aff19d421de27a72afbbd2e001786fff7cf726be4334638b226a5bd3bc954e3453fae4a757944b17278eb49caf8ed5ba3f397fe0fd61359b022d4ff1d982960081be7baa79a93d47caf47a80c8a017208910e2359d1918e90c6602164350b7d723469bdc674b07b1c9f1171e31661372e1c40ebfe6bf4da004bd6844b63459f01ba6577ea9e976d089e9fe4faa13137d19e5e1e67f9337bfc444571b798e0235ab3963e3993259cd0badb9a93ebecd6890ce36eb235db1d3face4208009a7679afded8a1ddbcd07da2e4631f5bd131081ae846ca03354fd61865b4493aed151368ae6f3cb601aa7fa2c0688116f05c84182d309dc6c7f2aa04a667d20c0559aa0fd0b382242b196f6e941615e53a1e6cf2c8f17f452a3a290102b854733c3784dc8e1cfc7fb6b5c56e852bd7e85e63d243165f9403455099fba274fd15919d94aa03062bfcafe5d692022a279fcebc65c9c9bbda29401fbf03ea8d6bf44bf8b4dd5a5a5635074f581ca58b0ae73f7ad4adfe5ff2ba7066394bc8f238c0baee9aa4f2dfe94e6276d65abb95fd3229aceb8fcc896676a45b2003fd6d7e028eb6653224bac76e6add218f36f3d71a3ceb95a3448abd73eea6db960a29b29f457275b0a57dc039f9e65d79e99f4c4593108433124f5c326c9ac222918aa3af8bbbad5644337deb1eccdafa960ab0cfbe3c9f51c74f92a25a9f61bcf9760cea459c9b85b12aae104ef76940c1281da7634bc53f8119519165059943de8a8967bda8ba08de66df2beef34dff78765f6949829d4875e709829f395c630c169afccff854731b927c698fa29ea4bd2ca9bc443a3c5d02093a8a351eb02cb6f3ebf586c021e56fb972bdbfa50787b235eb42e8f0ab59df74943d15433ccf88ba5aae052d16f9b93945c3ef51c129dec6e329f2cf2e45f579e669f68a642ea5bf3fc6e26cb8d75abcd2080140d6db5dfc6e6810d4cdd87eb4cee5dad6300decb35bbffc712b20b0b81f41b65de263b28e85a864a63d6adfe60a5f5a97d72d9de13baf65dbe40750fad95157a9ff51d1fce515a34c1d9f021e93d2475ed0bcdcc59973e858da9618f53f345c4dab37e3fa6f13a98e929ff7e2229214cee70a575db99c6d061736ba36a1b97c2e056c5382a883746a4c4a93bc76a893e913ce70ccd41313c0bf459571b1924032a4798ddb6902fce122eaed3a1a0c4ea16d4500011a9bc3ed5ae1a9dc51ab48f86e83e697e4c4dd2fd1b627bf088ec4d63dba5acef55b6e123a9cfaa702d3b0226a82ce0bf2a530ee5bd6f553610cb2212e4a5dbe8b8218acb867e1d03715f106b2a0a758d503c5690eb3e9c4bf3e7e917228c3e291488497479d08d0e729255d61e721a79382f5c7ef17fcc7799dc28e8a31088cf28df6c9349d625841c812481e42823a2dc6f8f74793c9b9b697800a1b2c6b0cbf3c3484ef7f53f0534a811573008de1c37f7ffd2f8afdd59d77fc2a42caea73c9b91f1f0c2e50f3d626e1b011ece9def08393c2f6c0a1c095a6f33c6ed1b995bccd5a2ec57a16c438709847321852e6f3e1bb800f3358c1ccc69019157f6254d55a6ff247920a33a0fa91e06cd346c9485b35fadfb34ddaef99c7b1ff1652482284b33088aa22c5cfeaf524b77f03fb7790f28a72a362ed8492449bd9703d1dcb6f1c5c057561fe1727bd08d812fa714d015e269b977f19e95c3113031c22f516fc8409b0e0f85abe29baaf5839b3c1bc6e3b4000c2b5d1b199614a8efa6cae6d1b8b37891aac2e2e65ce21967c0f31190434c2430010e44fe6dd49bfb21ec923df059eb9e9a7793363d6fa3d746303301c1fae676a10307f549bfb4e0d952fd3ed750b58c62d355350e65236750738936814608425e88c02a2bbd1dde0650a5363bf61dc33be56ee37f6044af04b5e2abc9cd9757f7ed6c238494fe30f742e1a595bb9ea4240a87af22f309250a05e5fdf234124356dd6675944e44c8c9420b0cdc21090d332becd8a82ed07cdc4b812092466f9435b5b2b574dfc25127406721676f9e5bbc3d79aad6099819280008a354aad6477d61a00ca1f21297a5313444238672f56d4b9291a365f27b76850e069632af593e2c06890336801e338a4507a6cca56d1d2e57b27a897440285449e7ba441acfecb1485980473a09ec34aa9a480ded63951d62d19edf4c01ce4549c2273ad7106d71666d8ac95d72cbf6e9ab50285cdb5f2dda6a7057294deeb8e0652f12673130a9ffb0b4052d1bef03fa2e554e02a54d5e03eefdc2964919eaf58d0a17e8c0745d3e23390a28a369390918f2dfa7dd32eb3b325e57c5012153ecc535e944551a0a2a6635d1582d76d723e1787a8edd9d7ffad69279bce1ce50188e51c62d2d97aba000abe08157fb95f365e5165ba66dc59d61bf7fe6f0e5bfddea5fb8d1c7e456e06fcde7e7bb9131e775d883bc9ab24be2c547ec81efdecda97d331612fcbae3d9a372c14cc871788ad78164747d48cb454921e88043c9f3f90344223654bfe68d07f20f957b37a415afac2f0e24575a1c259e1535fb735831b716a811d56e0a8cc19329d0722109a7f357fa36894f272fc0d9cfc5c22010bc1734a126cd4fdb05eb98bf3677fe09ed4d162403cc6d1850b5cbdbd11497b70ab3069216b74503fd2d3ae0a6596fba8ef2978d8c2825ce9dddc72edf3d13a0500f8bd2240fc20e65b55dfd9d428cf15293cfd48edbddc6d726e5c779b08a916a6fb0cbca542e1cab16ef1be374fc5d2e9f629d524108cc06e6a0f21e2d682a4321bec09f2ae47f6341f217ef7171b5018887b77ec5d93108be4481e961fd370a0c2077e36b6845b44a259764c841287fcbaeac00bf87c284685113faf63eef12eedcdc780bc8fb7101d4c26ddd2d087989f93a14660c53a92cc04cccd47de9f4103f88b784306cf1490a40684faa4f632541b9a7c62eea70be7da66b63005c272228b4222a2967dd54e18605d83344e55d02eeb7c0bca7f2f2ed65e4207e65f1c1d17ed6a6faa519eb5c2fe0c87b662a2e7c0c2e8151468ad82822280fb312a4f1214622a5f79f0278704a31b3c06f0596ce5dc67738131933ea7403085dab958a41b6542ddfa1f36cca4900088c7022b421396619deca2786935d592bbe3c3e58f2acecb571f8e3b22d63b0f2b0bcc48476e5fc5c78d62c239ef0ba08c8543b7aaa222f41ea9944796b612f1db7b2c8293e2e644f1cdcecf40f56e1fc6ff818a4b6c935bfc63c682fa6e9142a827faf93562ef29ef5cee1f3689b3e6f7bd7f2080e35b8c62855eca76e740c43a265351dbc0fab9fdb264a88b54c68af5e0730327a62b8838186a4ea9b59d045decee2e298767cf6c92b393b3c381eba12d969f82115045d0d8799982da86f802dc8c792a1420bb6ab902b28f0b748917c25495683a4e1930aa2e1eeb565a15ed798351514357228aaec6b805289883fcef09026b4e21bf3f89434aa08088b7745d2c8d7d1e3a9b14e040cdb09cd1279c3dd5f34a9c0bb4a9e4e2feee8b5102784c6465a92153c5795cf9a0e2a833c0fff91e271f0beffc48e70b07056ed01cc5efdb198de65fde3b381f16cba05f4e539792ec77a1979ad64e45a1887064c63a6f10248be04d3c3bf70b2cb7bd767b53242aac158811b26d4be9fd34ea0bb9a1768715bc1fc6cec1e9914bfd79971eb553f7580029762dac61da7a0b83a402cc7359b6d02ffdd32cb2b0aaa1e96b8afa2074087e43b5a2d529486d23c57b53e8c95ebf1afac1006b5ae1cc9d389245d9751e8691fe78bee0e4c4b245e1747c97eab7ee91b2cdfc51398bdd0702933ac77762ceae249da9555607204abf1d6d558dfa60e9dcd3fcc3fa65f8db5bb28ee4c447a596d6070b2ff830c26507a48eeb562d27aa9a9a038c1f174619492819c754d44daf32e37c602ccd2eef521f07c19a83d3bd78ca910b9a110facfceb4a09f9296e0d99b77ed79ecc183bd6684956ab2ca2ead3ceae81a6419fd67662e9b7eb44ee9ed9175ac9368a277bb2779542f5aa5a13635da6e17119c0f87be8623bbfb49a004b9626458c2fbbd50a11edd6b39234c08b7ba633b91ea0338d387cc62f524844a7e19eb83b3516d046d013dba6a6356a05122fafbbc67fcd0f96c0a77d1d7fe9c19eee51a51ec793736755ff4bcbf3e40e738fcbfe98fee34e62205bd620c4a14c324a01af94e8158117a185e14e1bb8776c879ce6f2e83188fb504d1add21ce10bff4c9a28f817bf9008c9a6f6b5a60f75b2d5a64353edda76ed09d0bdfa8f0efc8a9e1321988bd889e943bea1292dc93dda796f5f2207b28d1b3211bb155bc8c44a75cb7e9f153243c9c3f5479bf40cc17c41b88e37a322beb19f443997ba78d2f34f9b5285d7ca2f27d03472340e9ffe2dd09c73f5516d5b78fe66a8d0781676d1efcc700c8a1b21437225a56a365f183ce9d8c9ef8c590c8488bc5243e6f7d9a10ceb4473e2bb8fc8f260bd86e7724a9e1df575b07d2131aa9a6b319c2051ef727e57a2feed5ba01026cf7fb08eb4df61407971c18a2533af91a5c2a8cd7b04d2b6532fd1577e69af42e5a26c10614e4b0a5dfc84d2e5add5658a242ff641aa4f43534c10339f372707c12ff3df625198e0a06a61a2ad48ac39a01a76afe7b892177a42d192609df48c649f8ebf92c1274ec7d950ad7f2b064a09a9781ae37d478513fdf3798d0ef3214f3f7ad8dfa7532600089cd2cdfee5791f80b419f90a5805d07f0f9663582a25a41d9ca78dac2ae71ba2dcdcf455142bd3d458f64202e913700b417df1bff225095cb742a5b3fdf779b6afda7f277d751dbeeeda824d18d5867d6627323e98a738da026e5367c6a6faee278acab5e7cdf98d059b41a9bdcab1ed9c6430ce91d672e9c304ee426550d350f38b329ccee3a435516500f5f1ecc5ab1f2d0520875260d745c0aedb46dc6c70db498fd3789ceb7a8894533b31a922eea2d4d1cafc31a40e576ed4239d73acb05605f90e8c8835aa8cb822d027002b9e1b98e19a8732d39c922548ec0074984211db8752f7b9a81749e4f4dee51bca9a091e561dd33f1c15edae45bbd204aba444fd4ae0d406cbde9c8f985edc063df9d5b634c62c9a581e8ba2e7ed28225dc076a03eb38436e60706c1fff9bc8ac96281a4ec46bb2c0475584a561b8b2bdcdd334d6e5fe4e88da967e9a10acd440f430960ee0066fa748def5d63d28f94f9b7a3d92e65ec2a4752257e6e6cf93798f6812498a95ce929d7abf5fbbdc074c4550569a88b538076742db284f4888b74f6509d3eb897abd945d616614c97fcb9a664c5803af4e4923ea4e911ed93390d846cd9164b5a00b388315f1b69ca52cd3e00c92d7fad113e18f81de0533a5713c51e73ad24f42d15dd501bd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
