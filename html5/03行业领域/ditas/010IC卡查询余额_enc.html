<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db4d4c18b415718af9002707991d57f4eea52f4e2888cff0a9d355882b98c4ad1845ca658e9debde4631e0557166621b631e19be0628138e7519e5476d0a0f4b41a69e06e501ba1a031987039f8cc4f86c000073aa33216aeaf4932bf52503c3ab1ccb63bd63f8cabdf61ae797c7e17f69cdd0710a6d377eb369b1bf2ce4ded4206330386e965d172cfc8d18251163bf368e01be3375f941d1a155ce1f2efd64e52e52434135d3eee3a9e8bd7887709bf49f85edeaa48c866a61dea2a3f8b3f6cb7cdb1078ef1befb422744d47323cbf30a3e085a7636758c72e5c1b85a4e377aa1192e5aa4bd270fc51ea759155cb6f640717662c95d9318a70b3cf0ce3c5d17a03c2f9d24bd1447d6fbd79cc232600d667a10154b70117c04f9c0b3fc2d2401146a421f7143c9cf06c5c162e069fa67579422371febcaf71e6809cda736acd1681aedf2859bfd1774d79fde7d24c9b25787e78253be99c5bbc36d8353af3677cc07ae7fd22a53b6203c86aed97a24d40255673ce05b2e7927329100f969a1b0dd08ecdd3a57980862d789dfbba3e79194f6e3eb2938198761e85d457142507a5be0c307bd08aa2580819c6b8b7172c8e04c63d5afcdce33ad1845a265b218c0b5d9640a68c4d15ff06fb5e3bc6b93ae902a53c20cc5de4a10af30e697faffc8fefd501244f05c7046ad43b0cafe2477cf36344048cc7ce8e7b783b11a66ed201ff9e5e667dc39c5e1e3ffbb44d2cbbb19490f4952b659bdb2d4a9148d55ded990cc348b31fee9915c79da90701a60c6033567fe13038c3a2072fe2edf9bf310daef6b34b55e6347c727bd2526083879bf3fb6edcc8c0be85f2231a6d83640dd68def77aeed1660bdd4cff10c4b2f76648e0e8e4d9bfaf33ba005fb4cd89e28e99bb77daba8944734610c43254688314ef80db3521a1f5952611690ec971ad274014192f7b0c0f68aabecd262eacdb18c5586a1df32ed493fed12e64ecfde6452bc360671aabd1a2dfdd1fb72633c133dad7bae709528d365ee35f9f1dd1ecf9e329ac9b00834f911b0665c502576e67ac61cd6f9bcf45744015678217dce44ecc2c3ec751409ddcb101423e1d03c0f4a0f1ea43ec1b2982ec57996b971449bd8deec9d706862ae6069e957de67fe57c967e8119646cbad3154b6f118a4adb8ef142869c25877ff05629ac565717bc71ba87d68fea0340e14a44481f8931e7a6a07bd7a01ab55e08ad4acb682a8fe66ad9d6a1e96181f66e21cc003bac4af38468df9882ab90a070e0b072b641c6c5777867119d87a535de30024b43c04fa3b81e8c6404e45cbb85bd2f3a36c1a6d696e111b12f4e7b0c89c0729469f5c4000010272cc33e6dcd3ef9bb2761331cbf51480a61f1c369dc6cb6eeb5d8b442f0fe5bf3170ead5940fcde9315e3c80d73970df31bb808f375aba620da197c89cdda8aef81f3c769ede7fc3da4c10a90be8a0eebb65f04f3dec94710aa86032f6531aa664a633d451be1ec97359b8036791516a9f78418a7bf8dc5c1772f4991ed1984507befe66db65e751618a1e2fce8cde2829da49e749bf61636b24b412106418a380054e44f0126fee2a0dfb681383327f395e931afa6f270f78af2339202bb202b20b518d811a118c528e6d545397317649d0813a47eee39881b6c5af79e6ba1bcaa960ed32bed7933b6d48cbf291b346a04a1abfa5c4995876bec3157852df5b7a41813dc865b12e7dd127c23d105327b32a1a1cdf2ed94dee8c3898200ddcc5043280abb1aafe3c1844ae4dc248ed796907a698712731ac4d4d9971846031d2adff02ac93d7d7706509c4ff9bd6ffe9d378747aa1ddf4cac225c7f690c78029ccb49a0abf6d2d57200c2ea3db7f276c607bd4a271a7503d9f33776c6c487a1cc1e5cd22b0d9fc638be365aaf200f514bb3ed8b3df559bf89c525acb269faeea844be3d69950701615952b9fb5595b6dc3d59a27b4fa9af2c84e4f79945cb6be281db768cd126749a775b8801575296110aad4e38aa274636be2efe10d60b49954f6d87518a71682959af486f2d426bba1bc10c31e0fc4a07b9fba7af9dda1a9d67d73ccfd4b36d0fe12cb7eed6a75eb18a66971bb0c4db92084038bc9f4de68ce11e0ce01ec53fdd0477052a79eab1d53487c6ce63febc314cd5bf060639974ec70a638525a445e31bafd296dc8b61c370cbe37745dbd3e494328f7885cd5848b9819e0040dc8eb30cd1c159cc146390b0e2dd3bbe66b8e7ea7495cf0dc3b33673cb9fc5b6911d9475f5935b59b66196425ef1cba6fc5f23ae30f62fab559a5c9d498c8a2a7210ae526d7a6ec60d0f1b8004846a1459b43b2eda0d449ca47deaf5bc6955cc84ebdc6abfae1ec5375cbda57c29404df90fc4e1a37a4d9d365d22c3c3a22af0763f0f8ba7d415c6703f16b438aeaa1b517312535b0e3235bd8c995490869df28c078f0b082c68122bc2c8934328a0a7bb8d6b091fc8c8ee2e93ff00e95226fb391d0d36308c077d04e5c8822fd2f55b543a49b1f9a958855d9b3f308b92876f84583c00f7577a77191855df1d932c68ca60a3debd9ed709cd96cb1033d1d9a62de06f1b2dcc1e1659a62ae716af8b5b12c6b9ad4e79c8bcbabf75895ba10545c75ec139b4dddbf80c279bff1043ab97659a60acb95f1c0fab8db3024c3ae22851c0b5471754e8db4ebe8bc9109748378394e267b4c5a7d4fa7b4fa50cb376c3b1ecabece18ea20beadd0dd08d37c47d03d781e2e8a5bd900a0e64effce38e9610eb7a5462001520af45337ed078d2b4620b0b5ace942e971cf364771612163b650d5ef3ba35e13102eb041742a4e1c5a49a64787cb283ddbd63d09aafcdceacf691f13d8760f3aad2c2caff3ac0cbe9701eff054700725a8d8f24a69db8eaaf41de04a91b05e584b2c3cac2a4ea50fe90c87f94f56fc8b30bbd05d1aa36c9b854fe3a01e0b668fa7e79dedeb5e7f1759a7da152c2f6140ed7b5c106f5416e9949c9df743539cd20829c2a1d627c0144947919e35e162b377e4c773d39d53e80f1a647673d1dec40f481c3d343a140ebc18f686c158b79cbfd32f03c5f105c9892ef635e45e3c9a0c14505ace0712637ab24c25d396859d0a81d63da356eca75f3190e88435832bf12ae668dd3c59f21df7cb860840c3a12d14a3ccfe77bd66e25c602c8704f0f03df17815b1f070d23b89a48f695a9235be49135315fe4d7a23c31a913bb94078f793f83ca1ffa9a3ff69efb375aa62e58c74f9705790a38200acbdd3d97f9412f97d6e47c2b0d5eac1c981f6189193bce93f88cfaadf6d1600b1a5ddab7932a1c328ae5c5928752015448f056cb690bdfd5a25b3e2f2ef1c3422160cbd60de17834859fd9e6fce8dad641b9478334048175dc46c8827c04bff3882e57bbc0bf95537e872ec9eaa6e6e16aa51a6dad17df6029ad538ac79b648c43d7a5621702e60e9a378528ec9f8c6d05abd454c1bdd36442b42368f73c634177ca5e659aa21603beb91d85498be34f5ed5169dd90918dd9afcd63181c4eeeb24cad43737de08fb04472bf54ea20c8a705e0f5168cae0e12d7e1f8bd0917e474e5824762bdbf78094a3450b0a63da801993e7a6595b12dc3c723412e463ff4d5ba6e8427493de1a44cf2a62c74d1819c8c49d89726d3a06f456741a3e5d60052b065f387389f8772741d81e619cbe7d74b10b4f28cbcf5c30b916e4453b8353054a45ef06e9760dccdeb8c57247352600d8fcda64ef1f9d0557e932930461426f8a00b7c2b886c05698ce8c36436c7f52c1163e369681395e74a94cb5a147435391d34ee87dcf990f21cffeba51c7aab1e48c734531de464c6b96a034eaff04ecc7d476cfd5a3b4bcd48de3ef75a64369c4b30a81707fe28f47f44e0ae38f200d3f7c42be0bb39899a44243638b7599c8ecbe5a13996c836ddc4ea27df4f7c6e21ae52ea77aee24dcc23a00476b46c034213e0938c64fc3feef601f2bfcaa42dcabb0130f4ff1d7a53602fe4049aa18c79e5a15327597be6d8253878f0980b0fbe3b5cfb5072164c02154bc101ff6796f49bb9931c4d113462d35a2955296f55bb5cbb3bbd71275dc9286a1fad14ef3691711831226bd7e92b7a8cd1b8fadec7b16e621812127b01a6254e0a916f968f4d22b671f3da27db80632af9e8710779ac0852b2117bec71ec8835ddcbe7a67c6ab65d484f9de0d975b70d86c6ae888c058d3b5f2c76d275030d40ba059092f7cce5fdbf7cd717f7846606c9caededa9d9d85f574e80ff74fd99a17fed48ac1059cd16c5e876e55f8a4d7ab1da707f6c7ddc8b091fc9c6d7b0ba7fd2da2f5c01ca8166332e1adae3e581504fe250aead957cd556b8614b41c7c9f54c92fde89ae4fb3f5ee94645a4f28455d11da53ae1761913628a964c636c5b36015a93d65386760f1fb24c54a436cf6e3529321fd624529b14816ef8b129fda14164350bb69b93553a7cd1359fb777fc98944dcc14749bc64097b39f89a2893c9cbaf14ecdd58691a32755f604c81018cbfd6a87f64e3cb678a5cf1d16352ab376e0243ab745b98e353729b288aabce663f1a3fd35b5dfb3e75199e610be04c764831237da839955ab8d637e580360219f3b421820df9d2b7f413e622a8656dcb6fbed6ff7d2a22046f674fae494a3eb39e0cda9344d836e60b55bcb9b9eb6518547ebada651bdc9f5234094eacfa1e1dfa78eed4254a6b422a5f1eec9b57d7a7795a68d17eef249249da19699498917d21cc569943d12ea2921aa97d3ab805201510270331447987fa9924aaa259f02d22cb65c6bd9d9aab77c929bf002b387d41b155dd5b37be33605b8912253565bcf943f855338c988ca2f07dcd0d1376c91fc572cb7a2125e7b4066a1085792973b5b79182d0c4cce7594a7512c0309b8e81fe6a7b94a6397a35323c760aebd7b676d06992c2ba883374ff026786a3573e544f9b33ff1940aaa7fba74dff7f5d8d28b107050fc89414d73e7ae45e958a8db3f90998c462d38b0a8d10f611c8b4079a5f4577dbe3ac012d7c0755c7f46ffc55190c9d2d97ce44aef258788a9aa221b60f9badc665783cdeaab1b9a8ddf85b315854a565c07b96006ba7940dfa8ab2f207eafa7c1fc2bb3235acbaf7258b03eddc4d2906ead51b72faed4dcf2c9417b9a338c13f94cf085ac3fd42fddbe3e5641cbcf1f0f44fb111bc4aae4c518125bcb37a05e9a7286779b3f0a2e6753491ff41b61767958c520395d827856408de9edee27e662ee4b57eee847c66466e833e1cbe39e501ff467fa00e1e36d6394d328e220abbe14a0cb812ea33812f31860f6c697b6c4af6049f341382aa1c5eff7536e8abd2aee20d2614e83e5ceb9a81ca1957103dc5948cc4b8bdac9807af249710f54d47f1dad020f4ab0e2a43e7d18dff549eca4c14dd85bc351aaacafd9e497f59df0b600c0cfa3897465969609c539976549feb7843412b529a56527af37294e0bc2fd211ae9c2849ad8eda7b87374f03ec48233e3cc40852400f45bfc73fe985c5f9868d872b6828b550e1ae8e79c86e4dded9d4148dea5e967779e85d682b9420408a0b8eb3183411081d4a13562bd3e151a7670299f56158669b5a879427e2bbe143b7c43d24adf9ba15be0261f5ad678e3e46759b4e74b1212d290b62c6d737797b6783c74e258966b4cf2d48513cdc7389fa7c2e7a7bfa82a5813e24bd175ee86f7578e66e389fa5714cfbe3f875c8ce46bf864c76c95d9c0f9dd6e3e5a31b34f734b3340a2ae4094db3e574d0917ff94f55dd53c08cc10bdbb1d8025803c3572117c5e08b74d6596e99ec754f0072c6799c638436ee94c5f010edef21bf3996dccd215e24f8539aa753178b9b1f9abb2ca478d6ec389a7cf1afcbe4c441c81abcee6c26559cf1d525e8fb26577f9c509321ccecd228921c50bf193f352173b8b14da36286eab46988242d67d3e4d57d85f04dd9b2a4950233e0f39496136a155baa1cbee30d8ba65e43927550d01ab619de588991efe53c12a7ebceaf1e6a6b596ce03592b416f97ea3620471f544f5b2e3377093e39e59c71161bb795c6086df29c9cd683a6fabb278b60e1ef9647ad080d1cf44a0d5d0e0b3af3167269e576b2fe0adbbb28aec586e7f5b213a5325c145635984d677d229f6dcf70f5ed521b44577dfc735d3694c69ef10e29b0d7ebcebb03525bba927f2951aa8d49eef4372d103444bd1a8fe358a7fabb9b2a2405de164dbd0a2c02a8a7b9ecc994eeb22fddbbc0a8c449590d2bb40b074d02f2251bf65f5f32489cd66856e501763ef595bbf4298d781cbafbc5ef5e49fe06b46c3aabe085d62c51d5fe6c7cd841bf58edbcf8a251dd5608a07dd7d67caf4372bee00a0f780226803b1caa3abc139f84b8b666c47982b0b94ba6e281390dd8d36dd91af7ce80f08a54fdf5b5f6699c5f26811703160cf5800b9d5547b3876a8f1a16c5d221c889a319d7f2fe3a85d50f789857425a425c5aff701abfa0c634470115aa0bc8a909ebeccab7c46ec83c03aaa890d68959b36497adb1cf8f4eb794f6ddeb71309f738f13b6f8b3005d5841c033a6f68533ca3c20611cd1d3364a8d209639a58dd8bcc632251ce05a4628a3edc1067a4f171a621df6a4c1ba8a28ed0d84e56ae4a652021eb65075a68d3c6bbb97b9bb60c5316b8bd305e8a9fb9fbf3a2b82cd8be062d4c8511dfe87333a60bbe0c568cae02932323a0a5edf93c29f7d08c5c91dfdce366329836611ad4744a2ae60e3750832b4e8dc4cf821ae7a376bbd05d57634e5b65e64092fbe141e9deac80d5fecc42d7ece9b921b88636f72a83bbe1311eba73615a39aee70611cc02fc0bf08194ff026ace1161121221fee49da91cc95bc34c8b46bdb92a637e31d378687295d1da71d6694a4e22093b5b4ea3435438a83511b59d97c777bb4344f17aa2f2c48bf850e1d5cd1fb830eca38fd6b68177d4a00aa3fa1b69128e93f29cfa9a6c34a10de76a9df77219ca42e260106b671752e2260e9c6fb52871930af5dfd12bf77742279263cb4bb2790c1131a596f0ed4ce2929daf16a1b1f48174794f20831c7b14f33f120fdb5d781d511c6d12ad4bee5e8427b4ffc30fe3e2e4e6cfcf921622779f432341e23b5e28ab8dceb5760c777b2ea12e771811efa00d2878b86bccb104a5f1bc3c4f608303875f5d157572ca2b70ea5a9c8cbbdbd9a0393fcde7fe60382eb92226847318d41bf5e1bb346e9ff1678c4ad2db7a10d974ef1efd812f114e997158bab2b4e72da7c990000fb1edcec9cb3d671c5aa4bd22d783cd086bb37ce2ae10b63ba97e59c95267ca9c4a4ac6c7285d655c1cf532e1ed3bfd38303cff69a942c88fa94be2d75645af5f5e62306260fad05deef687e28168709198c905710d78ffba15f6ad85c81b8d6a94414a8d5a492fe489f72e9b38f65f8c6ce0d0f4069fbb77dba7ab773babf9e85a07a41170fcc5eb77394b0342264ef565d654d69aec85ff45b1920e5a3a96fddafe0b196d1cd74fb69a596cf528dc50961698b96e3155107a66495f6cc64af898f180362fc241fd75d50a2f912534422ff6cdad762082eea97ad47e2c6aa8c696ad11086185e66a4dd1055df84ccc1d539c741eeb48f18c1d152c2717862d05adcb3b71a54c89a4982706615476d32b49ad80851f922880a011a4fe3d768387ec187259993a6462f2b30ee8e3d82e26e64c640f6b6f551eb148db8b9bfded3a4911cb165d521738422283b79be78c8e7e2bf02119380b979e601b5dd810748a117594f303da55c10a4a658e53cbb68a5cb7d7321931f5b0f066d32b40428d5443ebc005f33381d22b01c96e5ddb2776442fd03459e76c07ad180473f06bbf55ea28e92f96eb65a84bbcb407be7db18053411e18b9d785e7734821fdfbbd4645b734d3d4378accf51e3cc06d32bc6ea34d076704a0a88ca29cadbf21c48650ac32ce001d3de0ec8348e269c4cecd345cc19f8de8e7be6e7e7ba67992c07b26d801b57d33068edb4c958fc8774b0a89440326437b73777d7eca2906c20ca38f5d16c6ad5f1e34aabed72a8e65c89c0f1f1ab79b46ead8488a87abbad3f8106bb2cddf1b23ca2b43580fb180b5330e5b90d8f469276f56a2d4d773dd55cc58a5869d368e70e1b44fabecf88e665bb34a9844eb2dd616deae07421b6f3e6348cb095c8b9066f66abbdfb43d6a1928592b5fdf88ce36bb686413eee2dcba81e668f5a182054f1846fe0e5288bba9c654b6e3c311c6a25692f0456b439f6a1e6330d3bdcbd10eb63d4d9c540d9fc21c5c7e1c64da0043acb823f637250106cdd1ebca11af3ce95a6e10ddc72940f2feae83204a8911e07d581b1fe3639064b4cc9649371ef83929fe95a57a23a510ab03835e9289c66b80eaab153f9d57c1a5d157ee985af926f81b8df05ca0f9afe129ed2e95916056aaa5db5c44f8ec2f7abdd99a309ad192a2eb8a124ab8383ac5e43b4318d731ed8beda1ab224abf7b2866ddf8adbb5b663d8da814c9830c13451546b98b3e2335c42638f6dbcf3a214ad2bbdd27ea25f45410122ef92a0effbdce39dec206bd38a5807651a09293e940c5db5c7b9357bf2dfc02211143df442f8f13cf825751b15a90484430c3ecaa60fa69dab4e34e3c7f9075879caee8b0d05315919b533c7e91353fca5070d000df2b30735de993719c3269623a512891b7a0d5b85ab2196b863bb0c5ecbf7af3b4788fa0fd6e98cf07dd2a40b41d407d1d176f1e9dcf6e137ee01064fb2930a36de45caf246654bb1a8296d3372d084fbf76a0e72d57220d1305e1bea9c720989adc140732d240010e488c0371d22132c5edeae30c359b1120f78c03a91fb43dd3911db59b0080035518a68589653b0f5970b4c023df00d93f6afd7102fb69b9c407560708faf022082cc5d18fd0df74ce2360358acdce15d7ba0a836ef59259e1c8a110d410dbda5e58b06f5352a9fb8b5261fdf54b29184781391ac8e3f2b458886a63bf4edc3b40f691aca04ad97a4e625664d6c6ae779914743a534d63083ee8a98393caaa6baaca5607284e00f0d802da2bbbe01771458b3307c0a921b63eeb546d731b5704a9f39a5da6433dc71b62fc0382e880338f3527796a103cb5baee62dc9b64c888caf3706253a77efd4310345e7af39e93fb67f5b8c9a45c5be59a16f5f76f8ca6cf1247d0ae8a590d3a8f543cbabb2dc14fbd99ee6090bfaded0893fff0aaf35864792fb199dd70d6e9f4add69d24fd95dc70671a068e9e975d1fd6574bdd74c0bf97914006988e84a5e1b9adfb4a4fbc85300676d1cd76ff551aa222490b61dd771edc1370f4a9bd6be6724a3cc2ffa9aeb21094643b6c0faed443fc0c9a77deb0bd9b4f74dd55d63012395c3eca94fa3bb008b94dd22f09d45c37a10a23fb8d3728c710d05332d5103005107e25573ba2f25ed34d5cd06cd01a6c501d59030c68c62f1a97ba162055a235bb4b09b014ba713311d01cce88f8900256655913d807bd3b5a09c68b9ac08a8f9fa3122073ae8729044fadee783e8e1061a8d6aca80d47f5b7b8411700d00f7ac7b0065a190af384ae1a35ef79d7b0c94f1bd01180ee19421563b582c94942f4db19ed1ccd14efc9f38cd478f74761412900c9e41688ca1c7d08fe02aa354c747bb4b78a40e7c96dc7f595401a2c35791055a9176b9ddceabe4c8e8b5f0da3347f98ff31c1272cf9b6a9070a4d7261059ee0ae6dc456dca19619bb48f77ea112d998d62f1658a3b88c2011170ebc527c6cd4457ef1739f9efe6f7f66b224dc9d30f63b361e70ff37ac06e8e34140649c3a242446a21279e1cedbd984a554e4463fe772a6fc7a415fe159f250f18a8f4ca37d71fbe9d30dfb14a1c6cb40ae9994268d73c9fa1d0f9b9b49001159977603fde3c3dcc346ae287c9f1203ea9c48ab9217dcc7d3fdd8f7863feda274112c5ba18c79f3b2e32f56f423176102f6d3cfb5ef59bc96c3468a96c899143dd5339105faaf96e228a16a93a7815050bfc49588e3b94f619debe8bca6fa37afb2f0b58b4e021dd037152bb15c5efd03a5dde79ae2eb4401ced3fe85cf299d6c2e2cda68a645ef238704335401ad5c6265e94db66fae4ae5981b35105f9246bb171bb29d918820d1b6973e5dc4f1e81298479877cb8ce610725c24df1666a014e79dd82f8633f6be7b7d8333128f1bbd5bb90ae22e8b5812e637d76c4dc549a62833aefdb1eb8d6bc2049a593249c286f208ac209a2a318213a7cae628e4fd58bcaee8f5e0900f865ae6bfb484d79829f740c8852d53e16b5de1d771ef13995cc653ac2e8d56a6f08783529ec7ea2580944454a433889920396402b665ff46902a6aaf70ec6b399ce7b05399f3467e42bf5c9e7733ef84ffd0ada7a488f6748aca76022237d1a535cf206a39236ec0417cf872dd19fdddbc0df7c743aa41fde7ba295c5752c0e15da926bcdebcc47ff0cb281e378f98bfdc975b926ff955f27cf06fbbdbed890dc6993022a99a0f77c4f2e748f21cccca366968eaa0a03bc9fb493c7ea622cb051f89ead05e700934395d1cf196361ce0b7919e8060e21c0e3f58435bee2e3a12ac64f43e340e8017e76636601e1f3ba90f96b8aea1e850c7a478858dcbe1e1a095af1ea3e902f10cd6df3f441a76505858fd5a169d6162090ac480dab658e4b402233d2a41ca10169d9211bb6c8315e5f551a6fdbd16935d474ec1fb57a7164757f2ec436b9beee9dee5d56eb2f1f9e2a07d38e2007999487046929371812af3b73f5a582d391805afc7f229ede40b058e2f7343c486188ba28d6d4e2b06210c1d22f2b72ee6d0fffe51a83263a21a75ee5f1eb4ebc55df43d6fc934a268676d168fb01afd7b5f6bb3ceba1fb68e55e49061227a482074c7bd09afd1fae16382e91ea92a94079690b309a41e796b70b4c1ec03ca5be91b05bb726c27d8ff5ec118222dae874bd10f35e0ddc124e7d958d0652c55130f49654611d737b8ce0cc088835fb25b1cf1f66af4905f8320ae8d4a18a23cdd2d8d9b1368012e3664cc945bfafc81ec2bf7922cc54a81af798bdd6ca3c8d5bc81f0a4666b49f2c2cdcb40bdc1d520badb14dc5a6c30c1e6f5f58a4e65358b255799b1faca68f5a518b87cb5e6c86d5c2a49a03ca6c2461ef0f17493495c833eecf05a29bf1cf5f136ae5d074d8c609f71c86c930743ab3698cb896afc4d30fdcc75e39516b0a6a2b1c9330e5b146765393ade3d477cc52c545475b6204ba814a1e4fd4ecaae6a8381d8025276af20c0d98ad41f92389bf71288dbee05e2991a053476dc719699faa9d841fa271a33bded8775754009bf553b55c1f127f71d16c985dd598aeac7c851f58471f2cf02e0d2743a4cbcd1b8e53f309118eef762b6b7234d0a64362611b597411b1b4a706a77fd4cbe4811218b2af1b47aa4b1bbf26697b4d8d0ff3e8e797a9f84ccbb31d4df6c19ea6c33d8610704117f81da241d48850f6a392b43fb7ed8de77fbf17c7daa8a3e7ce387a6f4c9cb2f8076a9262491d7bf100a5c8d149b815574f5d1ecb9f65f4eb8d8782f4a63ac67dfffbea1a6bf8e7479346a61d884e7626a4ae1b6a44fe247c47aeeceacbb87e550195f952b6ff8f3b3158a0d53a54ddf8de97af1e79d94fae689fc09d853f10d9308f1efaed99bb51abb248d7eab63cbeff830fa6d167f8d7152f9ce54fb45ac4df02cdfd19ea87ad6a5afb6ede68e14e37bdf1cfa89c91ae880fe3daca2409a644cd1ae76ca73eb2e6d15efb63cc556ab647e24dc6a5f5d11f7ea9bb18a8f1cabe4049b5a21e0b565cb104e2b3a65ed89b20ffc0ca54f8ed77d912a1962a5255b0173a7fcf4a8265636757f76819293702e6fa2afb9dfb35314db85447033b166f53bb295643173d87ac24d1208d9a9b8c284585f15750dc483051786a74e4e1f4567173d41c554b962c1733e8400c1fc769e0d9be6e2a7c61a48158400629b7e15c188edfe52856821e48dd030ea78a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
