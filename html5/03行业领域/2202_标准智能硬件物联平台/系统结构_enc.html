<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98ad29a38d0382f8a7b826f7d44104a00cb287ff1cf1b3d776b6bd0090e65593a9fed0ab316803c54cfcfdeb6a3c68df9d984eba11fcf65621a11184a5455a27f3b39599752b021d883ceffc170920637c0fada7f1d83a7fd43d431f9b5fcbdabc3ec186e46d0698ca6d246c4431bdfd92cdcb751104a6fe23acddbe5aad62576b09e63587666dd57b0a19821fc9c010db11f0d954248244dab3b3702eb9f6ffc7635982e777715bb320841b7c675a399defda791928a2692b99e1d622891d30abcdd39892494480a48869d78a0942454c0f38c185de42df1cc0d0fcfc2e40d0d5fce8aeedd416a8017fd6891afb523b1ea66e15326440761ff32b855069ae874701b95b4ba68db7639c9d42cba3c82d7f5c595c5b1c80b61c9497411624b59d0087e4eade7c37e326dc0cd012a4dcd9eab9d3645616fff5d910a3cbc0b443b49ff3fa1c9b4e08e2a6c8bef09285cc92b39de48efcd58fd5d1b79fdcc8e93179f13bf16c641beaef2118db8a61bf739789aa4aeebfa36fe0d09eab98e675cdb969e8c9c8fb457a690a6bf4f4996979dfcd0212175158c6077ce321bff624c1e335c5cdad3e4a7ec135ab6e10a6f48a1965cc4792e1c626c9d535727ba4065c1f944c76360d922b2c09141ebe196eca526ad4cfabb367a03d4f1ed810bf8cb2579fe7cfbdb5fb631f29a6d9410149ccb6e1aba763fe65334969899f64375d3e31aab0e3f0ede34c6ac2bd67fb053f764ce49f8f9b883c334f527c591beeb83c1608e0ad4fac4eefeaa14192940b8b990e6d2167bccfcc3e4178d1a42a72bde9b4fa2d5262496b3b30a61171b497728881f2dab7aa7f90fc222f1b3f1cd60ef3f96a75d894f798aaf644e318f5d07afb07b875cc9785c8553ffe829b344665ace45c4cd413216e2f9d561a3f857b0de3946ab13b6879edc2778fdb9e62bad629b67a0b330925862bae90c09bc53abd2742167b3212063719ab11a2b67485bfd35a2a62799edfbb42fad1bcc38b85bb77f9230e43b4fab9c42dba66ef6042359d2d8de728aa630ef1487f9a9c0eb816543c7319c43fcc0b68d48248768be9044fb672cc9ce70bde02fa46a007d4c31c8389d3f56ab839f0938a7905dd1a377d82b0170516dbc0cc3339c9e30154c1362c7eb3b4005563ffdb3a11997e4d5f8c4d704b713eb7bc0aadf86ec103d518a92fe486e980ea710cf631654f49be5d1bdefe22bf985346b3c65239febc91e60dcfaa2bc293143570fa853a37707580dfc32459bbff1d80df0477bb011c49b8d4e80aca3617acbc3e757fe847133500a017a42dd1b3506c9ea6e05a1defc3aa7068beaff350e3d8cb1640062355681268d624c724e279ae8410c2ce8c8be0dc663539b7941ee99f22e82c2c22eed14052b614e7769f7f832b59269f5c1bb64c440f89ec2df69ae3175c641c0ef77fa2a51fc577f43b2aef97841b479ddcb0803e14b1726ad40b8f0323ec71b633802aa4495be3b93c6b11d97b1d6e110152c5fc23fe26542d14b6b5deb9c90293cb378de1cb314606867217c45a0424539a7cbe1bda8530d114b747dd28ece72619c1cb9bc07843bc249228dcfbebd2180041946458e21c0b5bf247f93d01d13f39a6f30475921680ec1f1af9e614630739a882ee9524d4bfe249ee01b92abcbdd19d606eca51c70ec77789b5aee8777a60e020093224e565ab2c8fc88478c5fdb2a244580f21b41b2e53daa04b0bd9d86c6a74e8ffdcc31f468349953bc7090d5394f4586f0287329d8be93f56c3567e4c0cdccdc0294cce0b7e343eeeb74b958d331f39cab82045cb7debf95a0c09bf8d12771a592499a10d03d60c39046e541b2a68e814a034d5202ea868c7d0d9c81f042f5f47993392ec39b5a286b7a48e622a137889de116ea1bc58563540e776db52e90e52e460e281acc59cbdefe8c0ee7863df3af7f68057830854b84b226ecd2da56484ae86e170eee92916fea283499184755cb0634192d9499c65ef0a411a16665b98a3ded2f00eadb37aacceda34f0bbc7aeeacb3bde792256fb09d700810616caf368687e98cc5f9ecbb70e47ad6b383b568b278ae6145bdc888e265be577576084becd97fa5fab499deab6e52792a018612f4d8f46fb62f9221ed2b46dec8d78793c2041925e86332a126ec5e03dfb4f0c7c907ba54a14557c0123895a8ab985be2228adc3daa6910da0d3e0276c28a6dcf68995562e7a32449bf77303094cdcf4d6201d1e5c67ecceb3700a7ccdfda63085976d01d5bc564c18f971a27a909eb6ec51fdbce1cfbc61c6f50c1a8511c54b1612268dd3ec7fba038302b5158c0ac038b9f40d03040cc64bed11a17fc1d290d3a6ce60965f5c0153bd5cd0ab0d2a78a4b4e9fca2902a45fbc6ad2ffa1bcfc23e36d76e5775f390421da9dbe298460508bfce546190e2bdc4569b8864b24f10dc1d4f1eab84cbc5c5f752975f40495b518fad37140cb7e53d8d73449485c14ba34051d3a5ed0665d6d653b6594f107c542cf65a52a3f4cbbf0b7f7a284b51cf6b44723f0f87281c3c85a3ca2bb86ed10b97457101aeccd3a075b95c78dbb85f57b8dd340d3ddfa2dbf08db3bc07e7a02193d02c1e64d7267d312be7d5478f596029e066257c9f1db41aa9c23f9a52774e88caf55167bded59181c04d09acfe5a3e73d3f84b66d5e0dae3e6508df9303788168cffea72e24bb45ad6379e63f942748684de9f76236176bbdf13a6dc346910b54232ed9a4d7558d9ecc78895cc663d24887e7dea130a293dd0eaa0f4b831014158a463e34b3ca8d14058244bd62faa81b4914994381195611c569a08dd63792648240a8c77abdb06c33ec67dcdb50961658771ac97baab49ac1f3888352946334ccae9ec3fcaf37f4ef0795f0fa0a29461548d3e15b765b48041d42728cb897c7c53022c0c23c325a2dfcd671085ad4c5dc58e1a5ec9e9323f2d81333f0b451b61c622840ceb24bcfc1625d97e5d14b6b3e1885fadfe28db7a26f024b4e23f98899c01e82ff5f2fac4d42a3e48fbb6f02fea0b4d1121e8184074fe138ffd93365604d7de60900e649db2513bbf0bbec2b7b6d2105800af04d85cb649c21a6a53c4ad058609bf162526e05255bb797201d87837633277b57d984881c61385f27a8d432a6ae7790528cb2a5fa1737d9749592d96697336fe9aab29d36f9b6227893b35e19f8f7d32f82399b6576921ac643957ca4765304f5b6cdd46b9804102fef542754d58dc4d26f77f6acc6e449a173851a90680cb1b5722246c146f6f485ef89612eceae93b3c0efab032616a91d6b684f1b318f78442cd6ab12a0f4b29d7f6e00de1d203d2f34f72d999fbac94c1dd4859b57669e6f4ee6954e2349d8427367ee38f2e60020ad93a85aa6b6ca5e7598efd4d94e7a8f6392eb7d524094e87daeb566f01d7bb98ec7ae13a82f8426d61ab784f854731e91698d7404c2c6f36db9a9d7db0ff6e949ce298d220251445b5ced03d06885d12c272affd2c924ce29711ee443c40505d4066377a44486fc05563e489e373470f5731423e9f5ebace88b9ad3affddf147cb8d901db7ee07e772df58a2487d7667537dc0e3ffb9e1dc032a6bdc2c79b4d906d64fffac66dd1d07b79cd1d5555bd9ced299501d1c1458b6b1205e53cc8b1d120d1308b27d6a713b8839f01af8bf0fc9e57b477c00c96e30156b8b8208be60e005a5f8aff85da40c2cc2db50f6b33edf71cfc5c56f98e4db446683e6447d44b48392c0bfb6282549f467bf1c9b32a508ef0bf32fe3abe9bed6f540878a02872d1cd7977ba45b668c1902faace5557fd84cda13ac9b271fda623c744950333da0de7dd932e7f3896a56f13432e52e128c231e249780e729d9db872e25544f61f5bfdf2fae8acc64eda18f8ce5ebf4bbcc3735f77b8e6f4df614fb7c035344fae902d9b2d1750d197e34e53b155b5ec4411696d7d0d64d0143004276ed7858bb85d2c92c43bfd51d34bc0612ea60c06ed68705f19576df5635dc7e346150054163078a0dd66d6b7e443272543f20317a35041efe707cf5244273f6192a668008ca851d9f68cc92e16dcb87f9de6c8f74efc0f83729f013885402fea36f180620f0c8d515928b1d95f8bf0d4e915d73df1417859d01bf68a48331848f4e6df27d9a51d218ef17a2bf7340181ba66205d9f4e2363a0cd512c46e820285fc5244477cbe87516a0a264e77a00d3f035f594ac0acae23766e1e4aea9735a0d683d182715ea291b79315d517996c9efce20163f9f375d01c2a736cd70ff70a5ce6542d1c0bb2b7eece3b76d681102f8ba74a7497e20701e67e4e20a91fc9583222d7116f020d993ffb92197927278c81d2d411d69c3cc6d40cc4fff8fa26384114f5234244465245eedee9e36624c588c6505c811f9f146fb2c4bba7ce3f09c5dc31bced3d6411fa57e3465c7a3a305b3cac2b5205e49b9e35cdad8db819112a94b4bc4863d5300b9ba3fa97c99c3518e77fed4107fede9b8a43818d114dd8d11f75586aac6560832d6d0af383a0526b49c0203a3e64fa329d58935a793bb2a438eb32b1adf1de3050a930432bae93d46454f404af66b57d223664af9262a863971ce749cbdb42eeb2b196072ccf64200db48a4a57904612028d379a588c87c5e4f56ec3634e1dd245d08924ce5f87ae21511b39957c077e859c8057c87ab49318ea6e7f2ec7ee57c1c3d396962086809a7fef7a3ccda4f73cfaac07525fc5e55dc790cd4cd914a1155fa59f133beab57eacec2ed7182d88e3d57c75efdd740816ca318b24d081781264b75626b530928f65020540036b47b7358402c234e833f58b73222fd185cc371a05e7944b8e03178432ace06ee43dca6200aad38f45b6b53daa1e229a9300a13b0c40d89f827c1a010bbb80a32b93e7a39346bb4575a6a9f66b2c820442be60157f2c36b2056acd89365851ad0f36fb2e4cbebf4caeb0adaa6c880ca7488aeda9ce94429a40438b04203f6a01979a6833856bdbcdd3eae885ee3a9866e645c92528ad4e47f005f43666f64a39cc73fa177aef4f73afda52a099b277b4fbc99bef139776ce2ea80ec931d08e17da4b7e835dcafdde7059ef9d1b82a7de9159d4ee917faa9133d33965170208204b9eec7b4c2e4802db5ebdac2424a4ffcf9e3e845bc08dacccbe8987343e3c58b44a56c0f8a4b816042f00f2ec61caac4e7fb135c692efd1894cf8fca0bdf7fd06f8951542a6a8933829421af51802fc4ecdabf51badd46345dd8bc0945c1628686c54a04466d4ac5f10b77380749cd3534e10fce9155abb8d334a9afaaf5fd9428dfb3edc3f1ba613eb095a8eba0603aeabbe0e83ffd9fb28fdfdc923d8b02d1439bdaf55009474d787bf22e81b3e07007d2b6769efab6206e69e1a758cb20e98a3242ceba49489b3f37e7bfdde2a735ed6a2c31c9e0b9a82ee79f4908c22e733770623e2502ffbc35dc5244565898a7c876a07a65e0fa8481504a880b29a63a07739564f4ac848ac3c3d4266881375c53686cd903eeae3f370151162d9bf6012c9bd1d3a9e34600b2dd70bca6b95d1f166a49abc7887ae3020036c5265386afbf26a6396786cf51cb11565096839f738290dd7844f4d9edced35683df01c02b49c80b0934c0b59c9fa8e9771d2dddfe93654433f941b03565e1850ecf1ddd1aaea655d0cec5981ca2446b4148c4f165ab7aac0e3fee8771efed895a281e7755366622cdedf056298a25ee48ab923d8d26a38b57018bab45e709fd1afdf4f1fb7c91eb0d0793b1b10ee641bdf9fb1ba5fab748f5949df8a2a5e6e8dea2a445e10aa2cc9308a3088853b18840fdb7509d736c0024fd322597ee7a5475f5546d76ec20bf22472cce19bce5a4822b623e3cf1a2a26c38dfd4e7f9ea8bc99d22269bb00b45207ae6b9951449cb26986a70ae4e61e70f50ff8a10d149fd1c3302f370bfcfb058a637439210e050a33942da184a68e92397c188c9fcdf6fe45908dfcdbc23d199b53b241c6a53d6a289689ae23d2abe542c7f0bb4364d8b9e2e8f9e2c649b0a766ba4491efd36ff27dfb7d225b58cd46cbe20bdc7af9ae33275a80599457c67f03e002ca3992a198abe4dcb4c5f1d296f3d08cbaf2f9a1305a2b8fd3292b8b0030aae4f2ac6bd4d34bab8d7478d774cb608d898dbb6aeb9355116dc77e6875f4d124733e384ef26783043362ab3efd57a9f082737ce6000e708ffdcc972586800b1b0455b604e25cf3f85fb749c99e63f38aaf7b482b84d13a3091ff975526810b605f94a1a4a4570447ce47cddcb622cf78f5484dc19e55462b5a5e7ffb2b9ff763bd361839a631fcde4d56d5f588f357d75ca715783d6c86efafad0e54d4b9ac28087c2e505bfd51052b8f5f5aba00098bc56bac90c8e5e6c8b740c6ffe888cef02506dd6915202cec1b0be30ff226aa0f6eba67f0952344d05b737b3d0e1cebdb5d92fc33427040201b81f80d3c3212daf5093751ec8c953a9c6f8b1805ef7e016ca386d7fae81f2d60896d60c5819547160dc04f104ee83a4456afb5de92c4eaca03e107bcdb32e9d68dee64f69e1d49c0c6a1c75af29a73d77e55a46ea2f667847882049292009978c2d807340e27e6c135d8dfcff9dbb50b19703961057201e4bb3ffa710ed313302e404d2524e9d3ba54d0ee29f6eae596c18882cedb25afe155a6ed526ad06c5980edd447096d6a079ec69b246e43ca87268f2c8eacb60b29524b189ff1e9076e87b4283f32a0e96aa461815bd3816249599c10faee2114f45e34c68568b10606aa514a8e0196c39ad35f48e25e766f9a9f61c76b681d90d6d53fe1b1b536ac2030b763f5d2ee4314fdaa0ae90f04644037743bf1b499dcdde73e414258a4f4d72b7df7dfe2887d63476e51c8852941a4e48293cbff3cd78abc746be78bcb25b2f5c7358557d0c57498f1e6738ac01610552464d84a59baa38e24bc36ca19fdea4953973cfd765454b08878d72e3b92fdd8d9009f3ac9cf53b0ab9ab1fafb48ffe72c2f39088cea29ab60c47d8ebb6d78d94f7c8e28f5c90986c20bc412df0c1eb4810cfb78c5f241035a0e1e696fe96e42b60645e7ccb1ab620ad805071c9131bf64437d87977dfde1a2ef777759e4559c06776486194fd86755008f8f240c6cce7dd5108cadb849d704a7ec3467b2cd96adbaf4f8e7475d49af4d5f0bfa182e546efa101792b25c4ae3b955612bb68f7d436d30d18dd3152bfd3326e9feb1f84ab893a93b715750db567049b67cde2e7dbc6f0192099eea15e17aff8c7e0087ece3ce9b20b4e20ce61159aca6c0fbc216dacf150504ea4b47adb9bde1506a911e647fd7af5c0c518d8a134b354254540d260187e0d61b724cc3190cfa6304a98879e7610497eed454d8c6f333295951479812fea8981295a7e4dca4f6b8dfa32b023954e09319ba2c3104bec85614d40950533403c530a083a05b047d47d2347ddc36e6bbbdfd7c77cd15fec09d8549974e2099d159ab3e110707a63a3e4f142e1d07f90ae4ce13d77d212e80ddf0c95543b7cf9c8f90df77cfc6be93eb321a145cbdeb8945ea1e77ba439b5c7583288071a8bb59bfd06a11ee25be4f95436a6ce740c9d3fcd85d841ac59b94001984305bdb056608c86504df3d2cd986173cf54af7662f7526449016dca2f25560f9522a2ff2c3ec264719d46fa6e855a0039bdf2f2090236eda7364f98972877a1ff65cd28479f166b6e10c41a699695b414e1e0b375126238a811eb7a9eaf628be345695e4fcdf914ef8c1a60e1ff221ee954fe25f7789619d60b4e1ae8a22c62f77b271dc6f280b793260e9555e0deb1078726fd99890b4ae71e5810e3e577c5ff5606e0b2418ac9046df9a4cf6701063ea985c390d2e111cf77c6ce211a4be4ecb8eb59ca95fdf37e13cd50830d910154dbdd3d326aec8580b3268dc9c119dd2b6e064c870866552846b8b15b84133a052feba746903b464ddf79aa22b0d2ad84286c7f44ad4479476868689fe12ae2502c30cefdb7b4b0f4b753cc97f299126e82159e3fe7a58bbb0b72da104923980784d234e7cc30c46e115f80c315170deff3daf72f87407857c5b5ea50fd37fc3ff79b7a231fbfbe8705c3eae0a0a4f37302543be2a677509bd651589c1edd4143ea19ab8896ff2f06c069a74ef7b94db9fac909e2a78f0e07b733ced67d0f32967cfbaccdfd6ad0a1a2f5ce181bc29b546397bc9b540a5e706268c43e9aa94377887b26248d6677bd35a1ab4df8ca7ac9004a6dd39a50289b482baf429bab13a944543022cc640c544808e330db14ee35a2207bd678afebb212f5ea98c26b36ac5251cc48c416dee826f177328fbade828ad4d84252a3377b8c94354757121be86bd2fa4edd1a611bf085e772b258ad47a942b2786a36f7bf78991a87fb74cca28e36bfc2e2d1a892fc8a9212264382323096cab934ef25fbf1475cb89a3cc0dad82c495390d34374fefb90456d895bdb8e104fb7775b740f9f7046374f7695a84a4f6a07bc8f4fe7244ea30894fa6bc1257f06f75f39e5f8aee3875655d66f0a49756750e5c379990a0e74b4454b22bec735f540f033b0b78efd67ba75e6393fbdba0e7b22147aef39c9f8a8106fad407b48578087fb3be7f34b3a35643b85bfafed17553d00b6f2955c5a06d4b763fa8e6f4a18cd40b6f5315fd9f1255d1fa3dad418726f3c80ce8b08fbb9387bcfaaad3617d37f55140899f5d8a7f5c7548899ecac9e0be529ff5c2f5f362774a5d1c73db43fe2c9a482321a679a90f91918b2d5bc71cdf4671ec94217ff17fa705ae75e1f72dc17b5d057c5bf5390ca9365b573f62830a55014c810cd937fb173ac30448695b95dda5025e9521a325dfd58f2148d55b20d5c2af8052ad85e9bd4e57070ddd5a04441fbcdd2ce06aa730abe9244760f83e6b23edcb5008f333d2d689e21633dc4201bb442bea7a172347a97635f727506f174aac6a9332890d90b685e76114a769e3e1d1a96158264e88a8d7fe913053d60e469ed7bab4b327cebbc30acdbaa6d23585c2be5049e340bbf897c6a1cbca5eb67734662278abab8e0081a5d692c1850fa12084ad7b5bae3c7cc4adfd48e8d0e85b88fb31bdfb40bfb53fdf6f25f6f92885cef8b7fb3659e51c0bca1cc83d65e7c196ce81685504307c5faae40ef333d3e3768d4616674bcc6a559eaed8b53b96865ba9e4a724bb6a3e86ebd7a9faa0d199ddc5041ea0906e285f2993822d597b7fe0d11a8632f2d1cab53e8685b9fbe1e451e3d9c4f9495aa5d0aa24b7edd645b638b13111880a59f188a8b6987e36b4a3f1f03b3a394d62e569a54a9e860c9f472616abf8bdbdb6e4227a3182afb8d90a74f6a17c885dfbed9a2a6e747ef003c2e3e2354c46ed7f8d367b5504ad6d235262dfaa7012a039dd5a66a83dbc2c767ffbac88c5a764c2e04b8f491fa5b2970a72d8d860021185dfef901fea1eba263aca69e506bf97fb026d8693f07a8c12f7acd1bfb351a8e39ecb66a23865a50d6c20aefae96bd2b6e1cf91db4804f98b94379dfc141db9a964ee1580e31cdeeec93607fa2ef4b04d80371c6c34e2300dc0020cc4327ccf2b62b59ee088bcfccf9729476f0e0f6869b3f81e5fd23af95fbc5b853923653e5b3d535cf107aaf5cf5fbbafaec76a9b5ca03c62aa73bde1942205835b88cf83c16ce984223f5099c11b2f7a9bfd0152b33465723c9220d270b5867fac4c56898e385daf3b194b1c98ce3eb9724b0fb0d35b05ab71989aafc0f7b1bc980a58467f7572bd3467fdcc75a807a3c1fae810ae80625c8d668900cc3781a3715ef99d09c21a71f1c42e3d475b1806177b13bb92a23ba10c0f59f1ea09e9fd5c0ec78b8267f52704de36c4bc1f142ac5b2512c5033fcc0368e26fea3dba28dbc439e823302cdd99336ea84875cecb41e09b4816d8233ed656f19856148b0bcab1c4e426b447318fd780ccbcade9284c2095c18f6a33a296f1efd97cdae7af2cf2917135db8e27244471ce9d1e23fd17cacb18ceb190217d4af53d70246fb3184829ebefdc4bcaca80bf0f019fb28b27b148e100bc8aa49f6d74a48013f5f3bd860be25dcbc0a708b47b55270c76ae686a74296690d650c752bec9febbb25a9abe6129d5290b72027775284e68a321df7589f7d44d263d57ab77a045682e202f2629899ce9e359f643f5cbd4c69c103aefe749e202f1a6010e79d63cf3b2068e1679f1235dd48ba43c21d40d2be1f28f506cffe80c01efb1ac9a1da209462b052f6d684190e71c8b419704921c880784078e97dc5a6a58bbbb40fce3d0b085ec900c7654e7d188001ea90c203f082677d79755ebc4b8128cdf83d4b3ef40ecf2329ed54e462312174a8277df783c8d7ea226897bd48a974f9e513b74a500ef3f64227bd87d3bae4cfbbd57542ca87e4f512ef2cab436cf5e471dae644f86fa449f86a92a19e843fd38fae69dc90312a1e24d56a9812e3a6dee4603d0f566fca8622422f2f63ee513c4654077ec7f2efb20c67c82d5a576688592f7ddb676cbcc2d9fed14eb81bfd0bb2c4cdb737434ad5f623753b7dce81edbb0f4bebaa054c9dd68c12906c9ca62ca91e24cbc58645cf59bbbd994b76613ccd59882eb62e8fc33221720d92553ef94a97ec2fdd0749ff8bf486c1fb975c901f399ac74da1db82c900f6a7d49841a4d6b37c84ff1d56126dd70f7efd40207b209f4ac2558605bdbd7aaba2de757ee63961038ae9823d18950eb23d08495817389d372d025d42ed4b8913b1c817374ea907e00e89cd12d01597144e93695047ac2745c98606ba9990e2f40147bdb6330cc6e620af9b48d8d9c6d6274d17199acc704fd88effd4a4d73c076a603cd12c192f8ca271d49dfe6a8b53ee480253aa60fcde47ac3f7ed3cfd27063199194218e3e42676f3471eb88fc189d741963e88584a4980be4d2eaf2415f11eabbd1d52ad1176bfe61a955ca9c328c9e8f726135b70b649b25e29c1172b35a262775a732831aa6d321f486dd3da0f9618d7f7c41b135ef6a3ea42e110366510bbb6178335a99e367b13859dcf99f807b4736c1fb87b94c4f28a0c10afebab9d8a73025c44a94c95b21ad00e4657fee0e0cba548e6c0883e81b1938d646aa994d20b53a8013d1cc14487b20b6603264f726c363faaaaf009f65367b1355ec45f91ca2511975cbb2b8144d58f25af255adef6c1a9787830475d47ef762829411ef8ba46f47ac13da1a8b74acb2c2aba148406745e7e4af88766af9ff95a102b3c4b3a8c5696e2c112b97c49f41461a348ca49ac721029c9b2826fbce2bd5624651d0931f54a5baf61a3808e1299f67f6bc576d2219fe3bc5bc8b694a28fd7be952634eb3a3b91c09bde18e41dec9ea926fefba5de8e5ee005f5696a177f5d25e7efff8e8d2e90c9b999e27419d2dfc3d6168a229d7ac91559f0000cf14772407e6eba52fb5c28f4c41a0096310efe73f397bd7d2424b2a9b99ea039281a8eb5ad1f23c7ede387576c0a1bf2e618057c049da46375ffc6b2c84666febc282125bf7d32dee28248c04c4aff25fad8fc80aca45994eb50a4f8d34206d0888fc613d014ee2db0f16867b4f934224e596010e54753fde31a7b64ad60029b0a6e04c844092d04b080d758754187f1a48c20b334efffe8c5f2d90ae4b6bc82adef3fb0d842dadcf781a51395b53a907a1eb9eaa2e375538170985189bc48e3c07c26309de968177ba50054f0fcf65168c13ea28065223f34a442da977557e9c2d9a4c96de905bae05f4771e47e0a8c64e8ee119be6f6e482cfad136dc7c3fc04bd8ffabc676904ccdc51e4de438cec43d6e9c07b854bca9faa7b0cd7ccad067ab0029842ed41358a443afacf775a0f426cf0df93ec5f8ea7c934a25d3dc03c65e64d99ab8eec1d6425c110208fcec0adab81223421a0e3388f9536b5d8e9211559efc0e266114bf51eb95fdcefd299e43cd942757db6a56c7235cfee01681bd40ccf706a5d342b37ff91c18656c2129294c9df2d6deccc6fe235630c299a7006ded4cddb94b8e76ebf6e1fe19a3602f102ed1482ebf0a63a01cc6f0c9f5a099d9d789299bcc24514374f2f3719993349a57233c1587e3dddba68f20d189daa524e8957186e1aa2be53989d2a2049770370ecd40d852e897418565477b3045114cff590b1c41f8a1b78a70ef2c24f2dac77840cfcba241226e3d10663549dec3e576c5daf6b4811c58cf533553ab2c83593731ff6100525fa6ea9d842d7a40d096ff1caac2d40272db22557d48ea05c3d1ec5206b63d33e62ba685a388dd5be49f8b8e45ed12205be3447d2c74d22cef798496d8acb4f8ff0fa0334521b60ee0d8b3973d4c79be20fa7a2d11d68329f1c5c8ad6859861f1ce0c38869eb49a5e0f9d8e76398848a3e71eb43e68359fce01397a062eebaacf9c2837e86111d391dd9088bf1e14146139c7ea23e4004ddbe9d3ad1b9b77e84a135c6bb31d9177b90181599e0b75796d1dc862449d9572d45c8bc83996a96889a94de5cc3f147644c9bbd0875137c06b17517b1cf50b78f84229e736a5745b6617db2b1598435e2a36e557d0c9af8d1db583641cc7a9257494048d9e4f958d1d7305696463c25f1dfbb67f5ed8cc7e142513dbb4dde0aa8648747c767a82bb590eaaf8d8d7f06111f7e59c1021d69d9f3500f78ec4d4b88be5eed6ecc886c6739a2e7d18670fa99d2af0dd2d65952ee809a9da5745c721230621862773c5cc7a5cb8e1bb28389d4220bfd73c65ea0ee9bde504faef0c7ff4d513cf108f5ea9612ec47b18b582cefb6c647ba05613943317c3589fef5f51ee25012e8d6e3bdbbbd7a40ceda9e1afe85b9886e7c0b16d00e8aab8892e1db8853d362c064d955d5672dae26343a7e8743aa9234e03682ff089a91598db3506e1f69105a2a6ef5939eb485973634e8a0d4bfc6f58ecd9c7981e4d45da1fa070cb37387d223dd3c8020d543ab5c98832a640431ef5e18cffd40484bbdd19b3629cf69f4504b896a2a21ef549bdbb976ac49278278c3b3472a185cc6357fc0366f7fb4caca43b7ef807c69d26abcc42108fcc35512e14ab9e994d5e264afef5b15f160cac8dafe511698e6cbb1099c173066a3c06e0737d255adab035802960e6bef2e81f4dee482b00548cbfa6389cb1ff71ad01d8cd5496622366c63b601732dce1173abe4274d05b15127a84fd660bc72cf501dffdfd2c2bf9d951900257fb5810da022eb79d2a6dfa44aecb51ceec2290d30b9cf8b7696d16da6db28af141a1d035925bd0fefecc85de06e8197c6b19343ee7a3f1490fd55d4dfdbb31b1f82dccafe4febd4ae24b22997c2e626cb7ffe768dfd9515498a42ab76c19a00c3e8621a037c1c2b9613c73b472d44e405031e54b07927a692a91c5e9d5ab483985ceb58b1310d356da5e057445826272751cd7f7d06333c940fd2ad0ae930df7d57a5d51e1636b495cf0af440f18458af37be0a85270de437f0030925cf0309575888b9604e1055c830f8243a911b6af4bdc53e6246253563299f40798b0679da74b1aa11466f0b97052c29c1750a0b03871d1348e697926b4a82b2194218b801bdde72ec31d38ba1d70cbc51bbf6fbc1cd387ede58fe1bc23cdcbd6933249da4987b6d5ffc2e6baa07ac370f5e89fd525677b9019a8443f24c758470e1957e1d3477b521a48ad325fc84ee2e7c48a69ed5a35b12d0f7f8afe9849b5e342693aa3c5f5e62ff8b9a3ef17abac43e57a7f39e8e6c40f08792984340040a71059a809a811ea966d64710a14bdcc850c5fd504fff9bac4b8560e70f4a5c6595b5c8bf99d1cdaa6750563dedf75ea3de802d179637b8d528fe979a40c1e02e3e53da0abfc73c6f14a1f7076140d8f653967d7b475bc965254ec35177384e79e4c6fe3d7b08090cce16b8083b4c734da95964908bd08df73acf9d3d27c7de01aab6a04edf94770c5e0e18f619e7cbe54c91246a4bb2982a9c8f3cd77bcb944c3e58bdf816ef367711f484c117b8e6e4a48a430d6dc5646a91fc99cd4071f0940b5ca4768dda6f9297da01a02b2ea9116b38b020f4ec9986753543fed3d2daf32956adfdcf41856e6743f5d86ff866a38e39021ddcd4009442aede56fdbc196828666a3244c41506518239728cf89866d939bef3f8b2f85206fcbc60b5716610bfc224bb174f53599cc51d06b3154b55d963644af6f71a2b5970d4028ddea145cd91305c9139e8f31780a8a0d6068d81cda348fc5c82dbddd56fa0c3ed3cbb8956f448416cc01a67783bb8a38416dc2f8a7622c49bfface701eda2beee7e75d66da722bec2921c4e8f96141609f570dbe491cd3fcef29d150f8833685c0acc77835cef985a8a15e455e0d798c87ac96d325361507aa74f3369058802c5062c6746ba889fcb51690a3e2b57e8c3f363b1217db52de198ca97ac1a4558802b5f56dbf6c67a58a5d6c9f0a1c3b9af9464103ac79b719c2e5515f6a150473090f3d07b9975adb540673bece97f01ebc18e440b5aebebfaf80682688138377f57139f9787b6cb6b4f3fc6e39cc69fc2dea7204b2c8ba82345347aa9218fb53b0b895db818428e7a1c722ca9d12c3a67ac83b247e0269e39d00fda9015c6bd4e9e3a33fbd03e62e082f2ff7269dbf8bf93087b8902cf535f17c65c3d1acc7677503bd19758272bed5c052bb1c8e982204866fbc9537032871d0c68d8c4857552db313295f89124db152fb76414b033d76b8a0c86d8e75789f799236ad4af44f0e45748e5904659a3dd41584918351d4703fe69dc9b191dab5ea0f67d110c923a45f20a055711b07d687ce06f9077ad6ca54b671b67f927f604ffdcbe2713f99ba8b94169a5f311bd7d7f17e0b55264eacc15888c6dac0f513c264d252f22dca327a03c501e8880f05ae7e5512c9a4d98b45e47998a3890b3e6c41afc7b795eccc6697ddfaa12b59d6629160022330e093160183c2606d76d2295cd299ba96d7c9a7008a5a1d25adfdfe06c3d7c0050fe4b5b4a9627012d304725af1edb10bfbf57a804d89b5841cb49d5ad40a4e9cffe6420359e97aa812beb3254f2ef29833bd01f6ec0e5510d85314736f54fa5525fbc80e8c3f4c4c6a3f868a932b0e8d1fd78b75b46c6379568672d7721ccc570c90e428bd5b658bd1cdac6b3d1724c46b5225750298a3172eea9f9f50963b3e896934d8ceae35d867a052a7e6f56e2fc39ffd9b78de6520be714502f99971f75b200276a2a33d801b19d1cdff1afcff38ca1e395e86155d1db57a1e18249133e3f4d931b78f1be7696388d6aacfab29e93df7db68213bab72b85863febb3f83aa9444e92d97a58ee0a6fc03b8106c72c5168c1b4b1b79b163d07c4c6d2107c63182b797629001e6c499fdfe63d1ffcc27d62b0c65f139177a3de8fa5d743e8d0833ff0b28bb3675ea54df646cbc4b0b84be76c3b94338c7981ac6b8c608a1edade6988c261d26b792954e6b06ffa07f5cba90f0f4d4fae6610d707794cb4999341cb3041cc32be3302233f5a153bdd9410a2b8f52f229852ac5374c1d426b5df7e1af1bc2b56d97ad0c599cf6cc5600d26a9e1f84d2ccf4b6d69d22c5bba4f499bad901714464afd2db4362d833a9a584f35cd7d65287d2c4975ea45a797b61c7f070ac96be8ae5a3b96ca7048db2767ad5dd2863cc01c307b8affed6f9fed7ae7f3084984ea9551455a43adabb4594e76772dd264d9797f1a98e09953dedbbc46493bf5ff493ebaa9018784ba682f566d8777eda72cd3329dcff396a2fe8915cd6947e10abb5d264afe3293f8925e0b8b78973e65d43359b8e40bc7ea1bc55d29bcc856d809890a419709b0c9a218e86d23b4835262ae726ea940100a8f25770a4fbe7059da3c572c3cabd355a32ae019f4070826693226b51b2ec1841412b0bfff0cc50d9229292b5ff20a6867704b33c741057ffe250a4451ea580731cc9f10315f063cbc7b96c09cd948de2b3928537296bdb73e01eb30ca10cb36191d4c17b9bb0f991cce15784f437c4b22008a61d06ff1eab885059d40412fccace0caa8f4d3b9754dd0df302c46782c4270965e661b7c4e84a1228517b58b54ef1183bca6527ade52b88be26e84254afdc6fb2bacc464e6f3673f785bf2ab7d533afc98f2c73a6786b2241c8a54a4b8dc1563d49563682de7ee035aea30e1d015a550e38721f697a30f61d4daeb8814c19a3f3816ac359a9e246eb703ca37f41b8dcb30f2f9a38df6cd8ddf9301a9d6755b9801e8de32c036cd3f518acd9266ea40a820cd447817834cd4f4be3df206aa392a20f5a22255f6ed3ff729ab2a63a5bfce82c02f2cc27e87d9f8d18ed61144b7213367b43a6a8e4d2af2b91c2de3951c33e39fe8e43800032190470dfb910c231087173766e658eecbb5a99278734649d2c7b915c107ce44b1732a350f773b0493f50adb3748e2c70b6692037fff31751f2f8161aa00939abee772416a5d05da8013ffc8fcd02975625c975cb9cd60269ae99916ad214ed19c61a11fa0e89cf4686d9e4eefc9e887ac5323a0b3a851dbcc187e930aff76fd955724ff6085abf2c83ba28cd3c50b150d6e7f3c4819a9c28d3fe9ff34bb6912dd00ab705228670a5da6e9479c0393dcf0016467b2c23eac4366e1aac164faf4792b69d314a9a26a4a8ed58afda3cc3b2fc9b17aa59c0c836feeaf98e59d2a7933e0d1b85f3b3d4cff99025717b66b0c11dc922b63e4a9aadbf28ff802d9c7817418f4b0e466e7addc14aa5dc0a52acacb363a9e252e48cf2fdc2ef401c574065b9fd7414a3fdec220e2f990f0f5c5e4f12e157f212d2826513f51f9851b8c0aca8de6eb5a2e104177bd5c5a8202ba21e3799332ab5dba52058129aee3b7d204758cd85cb9204c7b07292b53e8456fb7bcc592fde885495c36c85f6941a1370b322a78f914e9cbd674bc9362971486d5e34f32fde3bf21cc258301257ba2bfe0d3e26146cc5864caaf3e846caa68524996fdb18cfd2ee238b48be8b2e798da4310ee2fc6bb062a3c10c2524f93a4fd8e4d610951374852560223e0c9f6f0d168654f254990fff258dcb2b32d2d4d685558d20081634b8a9434c24713938ff6c804daf3a1f218f63faecfcc1759f24358581eaf9b1933ca79f951cd581183557ef4cd3d1202d89cd03f3241f4639d08948cd0143e5cd95189f523b9a02421492648b3e9d7f29bb9b41a864b64a47cedcffa83316898bbb156c56d9049462ba971709902abf58eb27a73c22984c857bca49a33835f04f6d6866e5b2d0dff57c59296f3512fbb8340365d21267584bed3e827ee45f884bcdd8cdaae74401d5426e3e942e55351b1238ccdb0278d2e331e64803785ab0eba591b01c5bfaa86a47f60618727d025d9d78cd9088ba5c0735702c18995794e51731976c9df5963531db5514e68bf3a77b233e3ad035225cb151d4f920b29ff53917ee22e7a7a65551e0fda0c3ea61ad91af39e66640e6f53f1eb2b36c3169c552688ecea1be05663c996ad0b86c3da446a8e54ed5bacc0c216453ca6c091651b97e72f26a6a07088c937114cca3d733b97a684988e0ceb038114b85c03c86640dca43e105b137ca597279d6402a74ed48b28833d1285dff444cd27c5ab3f30313ca033043672645e33efe62b4809af53ed3a9d68d8582d8751ed8f5c6c3ab4bdcf98b12ec9e249505b070516d667e45454c74594fc3f9b5b67d21b912b1e3f2bcf2c0ee3380af7736214b6217d98c8257edac4f5265b38dabd1fdacf2d0ea1b601a8bdf0f9722e13797aba281c669b9a33eb258622928c03bebcd9a9a3dcf619987d795e76fcc5024347b76e5be3322ce001d22df25b2af016d426464feb8c6179eef392416766c3e1b7a3550ab5099048b36c24b5a63e3ce1fb0a1be956755523ef810d02f1893e19f29ed7faf991f0bb82235d5d32ab65e5926262c34f0c1817acd76fecdf20279d9a84f110dd50c9be0f1162860a40b6c9205eed5df3646b22afd4177ae3d02fc2a0bf45e357240ff653bf2fd17f9b9f9d8379e94868c45f82c5e995696adc88e35782e0a4dd6bcfde5bea2fb1d41b20431e704fa7a7ac78f1e8ed27b838debf5a12be676f92c21d1ebc8880700beed5020b6c4e6ee551d04c898b291971e1c17f38550a9a988d91ebeda41f40638cf4b68acf19bde62c0d00c8e14a20ddccaca403b12e2cd4b5d458d3463ff770e42857de6dab7c5b77c5fbf32f5dc20809451ac9b00d7aa52f43d75202c8db4ea96a72a10a40838712e612047e16057ab6f3b0366abb28a719c3b96a0e98f634f652d3343f9ebfbb38bcb995ec5aebb7dd6733746c416a54c4f783fadbe606dd4e71f40340f568c24aee9107c1a8bead29e08c9df1fc802c1d2ef7b11e46479e56ece17dfdccc01df4f3668aee098c2cd32c4fa86a477bfd1ce75494ffa600f98040aab601a897f2db230f1cbc774f5388915776770e7448e3b10bb0738bc82db0d35d1e05e48fda9b5fc4596fd3bbfc195e142438448836ac256f28fdce09bc6c6e3f9907b63c6d16cb2f1dfed01b908d3a97942c9f00d94e088552feba7eb0835358ce2774102f8754563657918c0808924ec814978caecf1df122b58dba35974fdee0ec90e634f8fc16673f59ee122a98ef04ac4605aa7fb6e4c20feadbc22472cb6d62171eb9e4473530bd2b9e83fda8e822d6b5618b8a8b28ed344622de5133d4624bad6221157c2b94619e8774850a585d070f3748da35e6ddc85df40cefa46feae0d55074ab29a61f5720669b9bbbf77eda564ad87a504b6e789bb77179cf9c48c1e6a8f8d55fb3dd1e0c455bb76d57d10ea5ce567c3b550cc754056752bedb92b1fbd35e7738d06cf2a92c8429f7b75d18fca37c55330e89539749b2f323842609d87a66cd6cc83612b367e3ff88347c717d226e856158d29290a8e1ecd92a8376859b28aeb53ab352424125d97a615b0977309fa07b12daa2fa62246db0e8a8810010ef73c2950596d137b49f0924405f84833bd8976fa6b3acae8fcc131d825af9363cb72fa89105fb5b28656f3d91610d99017b45e8a8b571130f709f38e2c36e8fc2611d5cd1b3a07797ab59ea7915b4e3e17463917272ff3e213a13897869f30d024643c7800f9e0746e79bb91e65e2256ac6544096e5ad2461832dd17e1ea13cf78cb9df4c71abf9db10387483de943534c0f999b6efce4d86b97f34083a700d332ec523de604067e49355f0fb63c0fe00b9578b22a5f6ab87d7d0b5c9c55446859e5ccf83b2932cf6d6108f112925c468d57154a24b512ecb6adde740214e24a3c9e771a3f665a48b8705408865bdac3f22ad9150dcdb9a1fa26ffba68c7bdac041cae6f2a95f230402ca4855d4ec31e4b14e5b9afea85163020ac8dc12bcd05dff7e7da75c97176323a0ce7c48e49ca8266f01bfd46005764fdde8d125cc42a43965d0113889ad98a230e24a55cc47348a74ceb3eeb9c5415bc8859dcd7a2e6df756eec08df33e0d888f0fdd07f9f989c865d52910014fdc841713f68958ae351c094fa509ecce9cb525393d019e214662c3e640dea098aded8efd5a323ff0e818f708140ddb0e8cbba27f09f59cf4bdedf6968c3194d226737b523dc02d84ee03564c1ef726009b1f372cec2437fd91b387511595b2d2e4e5782d50bbcf538c103b25cd8df8ff0327c7f05beced4499f6691bbff85e7155f7bb333f1ddead5aa41017c42aaa2e5fc58a324677c15ac8f5790c83e45a8e579f491ebdb2fcc5070a6e5a8cfbda1740cd2b6f5f8c355985e273f904b20a18f6e70e1c057a967a065eb2fb082a5e105b56b854b5b645abf6a70d2040de020cb703d9c13531223fa31ba9f9051e03c1f681cf3093aeb493b103e05309b77174f23b272db40faca9f1e5a9e9eeb804a884c19682bf6299e3ccf14b9661efa2a7da35e06785656b560234069f14b1273a615ccaf8d0eb0212c4d7b9abee26dffed0c0df916dac9cdae4ddc5530c30e561df375ae8d1121cf42a85e0fe4482676d182232b86adec420212e60223c3d484328faf17c8e538d64bfa31983425a79ea48eb1ef41b4beb571cd2e35d69f18e28550281f4c7dce7da867badcca7b8e8aebd58ee1aef202257851b41e749f7f9eb6ed4a16e15074899708249757003cef32a21442d612738f4375c38ee069b0cce3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
