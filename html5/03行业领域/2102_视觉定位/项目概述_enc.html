<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7f1b136eafc64e3d850b398172199abd633e23fde42995348371ce14f10a083fafec440346db7470c1060f5a7e0a72a2661181ea0bec2dd52c804e8cf7a5f693e127fa3215f4f743035adb683944a4b3f785d437d55315db670b0b05621fe9c019c6ea39db4c8d1dff6c484fc12704f1e62506e9a394f0b623264808be0d5f7ee8396fef54cb9cf89bfce87956da97330632959c72843ca5750697dd4c98c9c2321fba938a9e8d5e94b8642beec414fa2148eced92ce21b44a339278107bf2701c33bcf32165d4bfb5131d2d545204e2a1db24c15c8303589f9983f70a230ee322c2743248ed9ad6193336f60f60c4afa018da8f2777f3b00ab2c047d4d4819b3c76c4ad417f960c2acf79f6b0cc8e1c7a5d93c2fab36d5234bd381d1f43be55ea62fc978985ebd829a758fe75c6e29b3d21aac5ff9a81ea2d4f4d3f0cdce261e56aacdef18dff631f36bb9cbd6552d80a6e096ace75d13945bc785d06d9571ddafb357bd1de2d9e06fca2991f0536999fce0f3230c392e31a5df05f1219b1cc9a6c4622704569bc56f4f8a99c34244ce8658ba2411d85cbef3edcf08de6c936e34e60d565fa7bdd8916597a826fb5fded2384525a9d928ea5f6772aa5173f728e212fa7f82223e3d6049758340e786d5ed00a4407257647dd0f3438d2f02974b31ead0db85290a0e01f64a527bc4f1d7536e45120fc19646787aa97a32c2ca93a4ca5dc7e81be56403b89830ad2d5f15015516c5ee8e8204f6e272cd24fb29f7efa0b78c3b4a5118d3aada653c69a76fb5f5a38a0353b1a940ac76dff42291d993072fc694d418a1bb4373c5810f2bfb0fa412a4c62c2a859d3b18415d0ee507d8d980d6ad01310dcc3ba39d7a8ee1c9f890c4e5b36d153097f7e25f25142d841eb254aa100e77adc23143c277659b76a7384141cc5cb037a66d5d7118c90401951a61c02b323a8890584ab545510f63c24c5a8e0788dfe5f00219d3de37b1e382daf3d8cc1876d467f370d4adaf3ff6ab10cfd31ee6ca9f0bd590fe89a573188bf96dada77ab98db18509c031e9e0fa38bd85ff71155ab3a0e9bcedde9a5dfa5e4b9df3dc54d16f947e988a8c7d18fe0f8d4127eafa586bb632d882a307182bcf1e640363b09140befbf4ddc02845d146dc41ae0f3a8d6ef24619324e3e8288a445a9e2eb2e917d32d90ae98475ef1c8dd08363b7a708d7be2177b11ecfdc0f9be116bd2419534cf7e426bd6b7009fdce01ec82d06a28bdbe297b7bf7625114c7538b2f769e79442d10654a8d31f8e0cb40fac9d4ec20733547928d1a2cbc5267d9552b2042882687e71692351fbe9361a90ed1c3b50a602d0ace0776032430d3014de661b1ca524ff4b653691d3311b170aff755a999cb8c28eba47209fae54455299df6b589a60ae6b1df17fb23673904bffd1efb84e02e2675f5f8264563777a66b3cab940410eb32f2ed6722271294c6e08644cc889b9a98ad5f286e518d7cf6c4fa25c0d4ec333fcc13934b4db1a7de98c322209c35c7f6bf2299ca6a9f81d686dca8ad6de24fb7ab6b6ddaa8f7551aa0b41bed8b0281b0527649020c984c774154a8bdc0f7d379c4d51d7a71c8a8984d1fb071ada72738726b588cac0cd9d7365d712ddb7d98201758c543cac1d537504e29fabe1d73d5753103c09d518b9dd5a488381ecb3210bfc396d1732932b3307ee19f8cd8ff3ac6a5f6bff6e91ea6b06d400d9c72f2b78040c2560c3fd638af40a5660f78ca8eb3645fe588842a0d3153c3e8e4a47c22ec01896bac4913fe3671ca2db4fc8790a37884be0401ba57eed4a04fdae03e061524ed30dcebd2f8238a30af911d244875087fc6c9fd28d3dd1e6e8a572c030af21d94312a39817de2907195c83d9ea996638029e0212c105b7751565a56b5965cea60f7d0bd961fd3418adf391ad56aba0bff91532ff8474ee0ba90641abc1321ce42470cdca428e7ab3ab855c8904aede137c7773e2faccebe78c20b1dd049c31cbce63222ff4500e9a779e834558e5ef6395078c13921ec86daf938d5a803919cf34a90fdefc0a6b3304958f65cd8d7c7b4d2a165a4df939a8eb16bb84f157c990eeb1b65c29829ba421dbe1330da0bebf090e06e0b7053e41d7e08d16a21f362d8693d3d1d32a81f20832ca146aa175d35e88b2261e28b7aca368ac00d41b2435951eb027d2d895c8fed91bfdb847cfbac9118baa5b0234c02e7d4a4779df1069d972ab7be2b3b99b3c3a480bdbd421abf6f460c756c99cd808c86ce6670d398001f8e95b0058432ba8e9ab4ea72c87651887b5f3c522adefef23ed956247e62cb649ae40ab3093c82487207654a44d5d5e1013fd6581cb28819b3d2eb0f98cbe778af16d46cc79f5a89ccde0731c9520693b1e1270d50f50e36b782cfe9db837217dec1b3d5ae3199eff669babf508fd43f0b80d2be428020a4f2328751eba093afa277b364b60f1845646070215c96e388826169fea4daa28b5b09649a4770aa78dfec358863b2df30c3f8ab862e15550c921f0dfa22f3d02f17dcf7d4611ed70a55f0fec002d879a276c0e9c4c3ed7378158a4d47687f6f34c504e8f44657e39021cf951089e249b5049c7a50cc95645857a113907a0abcc4c8253941c885cc55824d073838adc6c9724bdd22b204fb8603d98315a3f71b8ef1cab8046a116a732d29eef025394ab70b8bb0b27274f70a684415064493cac0781b1d8bcfc1d05faebab1b86f66084d35fcd335916943ff0d227c23543a5ed11cdf8beb3ff87cbafa87cbc73d63ad75d9a0883da811eb5b761f4800d518c4d1d50d116fb26b8f30d0ed8a16c3726517e82a75d4df4f04bc3a70abe912c62b5251700868d35fc2538edb560afc7be8d5e5d24395cd72f9c5328bc08f5ec9d95a55f3838b1de01d6ba8608c15c2075dafec23d6904b52f8979b8d6b49d5b2ad1a3b7149929b617457df75dac9c2eb8eadcc84c0d998b987f506bf034d903cca5a4adec0e2e87bee44496843dcf811f678348d9a19a6b353efe1c413afd12a2e9f593c6384697b54ac021d4bf412eef01de5b1315394783d76cc5c92826d780500fa22d9a5e6ef1f8a0f26e2411c349d3f3ac1a2350906d401978b3e718c01e5d16539ec275313b0b85331ca4041199f8a8864b567749d1309b5899a14e1dd59daaea315b618b0211fd98dce148ffd1fabff7701a11e6fbac20f3f68f19a8ac41c734d35a7d05f73195a52048cc6371bf4edc0ddf0e62603b5a7a8857a66421f3623fd97264f0dc5ba9072ab9862a23a0b5cfec4d162d03801c308c6cdba26e68a54b5568d0c6c8c654c7981ef5bcc4eae0e6a403d10e2851bc1d92d8bc6f5e9057edad8caf314515b0066ec70fed2dcefffc790c5202bf0c45a521759ffd1f7b91319285dd1ec211ec81f72b182be72bae9d92f7e73880b4f15c38d7e3c42dccbee17eda4d7ec17adba48d362fbd25ddbb711f696706fbabd7ac92bb2e2a020799fca6e842d32d3c0c16aa1405a08022944abb32fdb5bd92bfe7ac4d8997148946c34cf98e7d6b1f0c147d43c0ca46139a0048c3e4b03a03d6814f7d13b98bacd5144b6390fc25a28b0db52340ceff3144dc47c14334b474d40d151559c533b1fa339b05efa9fe732c84f57df72cad763c015e073b9fa4ab5c6fe3888a1e7d9079fe7cfbb267709ee3065c9148d81710049bfd0b5759ec4b19933e713dbc81e9fb17c6cc9c39bc96b7931c10eb450809ce278f38256f914e5f6964f1052eac24e38b0f0b21825043c9d5b4a2a753e340f802246039f59cb039c6d05ddf92b223f15779f7dc888279aef07587ca3286b599819aafbc0fe0ccb2f56422b1d62746bf9f80ed351800a6ed33c87da3346613a80c3a2d8db0d4ac4f9bc2228529701b7571cfb03c726f6beeab26e26c7fa69c6d1b60b13c688bebe790bd266217b8b6b9d1f65b2f846e8c5b35fedaf0417ec228ab9a605890668cb936641a54688a5dfbf6c469e2c02b74843b537c7b1e392445dc6758d071f7544b1287e1f3abd1c51cdac0b9772a52ef18cc8a2da9aad5ffc7de3592bd326ce5e52edd2366c8ccfffb18c6518ff7a729482f4f045d4a8393b86074ede1c2d7319573ec5af07ad9079908437f53b7ee35424cabd270d82ccd3b39ff091670c9c9055709b8d42deaffaca76fbc23e14e96e8e6301158b65789dc44cf9d793f47311b712d034918e9d3966b2df90d7ec9ed4a560451b37afbf9fa01f68a0877a5494ff3cec03141647402a466732c3af57ff080325230d7f5454d2448a174ab1f7afa7e5e622d678b1e7b43a72d2bce84f849c9c22dc276395743269f6c253d0618f4fa234d5372020c923c730233f922e3330f6aeaebd8d2ffdc2d49fdd462978f0be5bde1bed80692f74b88c69f8a78ca9186e744c9c7924bac80389c8d058f803d8bebe96eeab97203f70dd4cf136cbb56573ae2dccf8d4651b886beac8012d996542316bcd195e3ed6ed862f414faf0a5d1a28cfff1c585952493f60bf8459623833da1115dd205b09734fc4dfec7a6833ae51d80833a2076a3c8fce21c3089028660feb180edb5d655ef6956f1685cafdd1ecd64a6cda6a692dfdc003268586376d24cd47a8cb6e993678dfc213bbf254f2a1529ef8237794af0637a8630280d6d5f913564605d6d73bb488f7648e47f559cfabb532467e076a7e19d1dba167146ce3e6ad089337c592f14536691d02e7dac1ac814320492eae455b80b903c44476a3497a48a2f2bdc876ce8fef8268231dbec1b6aa5a9d854d301425942c3be71c8d612f49d10afe530041bf0871f230982ecd6f04c26dd5786f20ce741612e01e4b79dab73403d8ba1125d792305214b4e62264f2fb514d52759556891e46efcd1ca923b04f43dbd6ff9f80975222469fc1dd9c7ee5a13cb72f41e57e4c9457fa9d10e2ade0484376c19a01c312d4952df7830831fe2dd8cdeb25fa740075702caf119cc392d78ee2c36b034a6c7460571429e63f9419b10209f5c7f3eb64895e1a6e6d659d44d87ae567b8968a2cef2a2aab206af4f200d5f0274d382623de132e7774baa6563362db26be9f05027aa3c6e1e19a337d46449c41b1271a6b156ea288be64a172d1de5b3f3f0ad1babadf8545d89f0a4c876a69445d96b57c588f3026641eb132f6a8793ee54164c26517065d3948428e679a98b19aa575cc4fe325a8bf22463b492288f8e09aff5e253461f80ac78ff77576c27f3b5e44ac7ad43070428425dd444ca16ec21fdaadfd2217e1eeb5579e3d5e52225ad6afec697cf03b9f5f77195ee0892088ce7d5be4faf12bce24988d7c7d38a1e6b7b6b8f5ec267d73a9212f02d9ccebe1c26cee482e370017109d334ee191d9b4e2a7fe6f3b52c63a158b9fdfca51ca0946ab265ce1cf58b11502cf78510d8370fccf8de498d0fa91e1a4edbbe0c80af142b982ab332e0941f865a700814c5b20ef14a4c2f3a6e719376eaff854a457537b1715e649760bea930623f75a3acc60631a22f2801d3e8eb0450406a6d89af0d5496190d24eb20afb3099dfc47c09fa61da413f445c1447fde63bbaafaadd06d471fec8239ae3537b57a3fcc3e0627a7d3faa1f5f7ef82da14ea07139f6cfa4eb6e7b8628b44a44959b098470be4c37c692ee283f69d1336a93e16aa08b3c28babf44230027e6a77b4e8060a8fed37ef1dde38ce3f6a6d64112ec6b903f67fb0b7b8ef75b951612b72c52815465698cb2aa97296fa9c71948fe30e629eb8751b24c976c27da9de7c9e55c1f60cde12a5ad180e56e3d949969ea9677b47f32c7af437a43a427dd702887d11dd002d4ef7df13079043be0a97e4aa5743d93c075905d77d45353a36809194648e220b8d4ced23d0804d5febec83f77db254120310ec9674c6fbbaefc198c00aec33e24f9c3d3fb66c1f5cfdb5d937e976e90b5fe4449325326ff63b35a2c206e56ebd0d92f252a82f610adb6d3c287f4fa2d9103fb6c435042011e72dd3fe14ea4a5b761eb4b0bad7b6553d699cc09e2ecbce95e3950e53deaf2ad2827e8318ae7fe53af1e17305a9465b20c35576ff7333bcd013c66e9b3335ea7d6008a0a8d5b295b983f50b2dcde5b54543dc7a96fa83fa7189f3573fcf7290da5b4638fdbc49d846b4b8ef3a9c29f4190dc0c23db928d3a64e37632550c853018d38ce2da95fe8ff0995ffe72bbbd69bd2f8fe2c804c68658e55beb3b3196fa2d947cc429b7c46bacdd2f095cb224c74a6d8a9c7a3722d9166c1ce818518a1e6eae6a30e745da84b4b6386d8aa270669aad3476d728d810ec2c8a0633604c2846daebae6aaccfc647cf8762598948f923fde081fe173a8520651062fddb40185261177f1808f0883f98adc56024ebe9e9856c41a050146f107747b97275bb32d563c06b53b0e01c2b4b597d51c06609a295539149b0d696616d1ba5b9cc1ef78520fdb3d0f14f62e1e240ca807f2f08963b1c0c113c137987ffcb405c780640a76899a670bb8747e2d1c808eb04914652c242a658487a25041bebc8a1bcc9e0d11d5024d587cd3e3721225bb2dea53bd9b7552325b9e9dc45b90831be0ca110f39014c98e708c8eca832c5e0229f56c0cd7156c01630382e9decacb4e40685675fff85af47533989aa980ddaf79e7e0394eb4a5798b559e83638c25476d563be54a8eec19e75d300b5cd67956d2e13a451b768d2903e144d269d50c33b062678b3b0a6a71a271e9de5a8498b44522c2aa26e0f6cdcd0715a8db10ec8efd973f3eec7f4bd6a091e951cdb224f125a4b13cadc3d24661eb210463e2b2f6b906871328ffeeb506542a74cd33c9a8fa7643d05044e76cd9e2c1fcb07ecfe96a76af741ea3f2d9962dcda9fb17fec933e1c54cac71c4bde5f8259c987e32955d1f1632da2c95e7ae19560043962d06cee98f7b54062eff06055926f17ba0f15165f6eb153c10531759357c635e5a9ccb4ec51df6ebb54a1aa13181acf917181b21aab4cdbffcd6e0412f9e89ac089fc2e2adb308ff529f8d80070ac8d0b42ee34574ae3a928b0165aeb725e2d8ed6b9806cfdd64f7904e0d4a7e6f73a7f3f03b8a86a31b076b9f183bf2b6e4d84bd13b6517a2682416312aeefb4b75bb73cf34037af8226e8ba4b4f0f7fbbc1082f1781536444fe440ebb89ea6232e9345363b9581f86b08a3a4d62b6949378fb91d3bd85eab5b732189d0dbb9736b7600b51f66e10c09c5b1672d373a357f0c6fec411804859b4f141267bb00b0dc574dc4499f274ac938c6de6895972173125d945364ed401a74866e3f93146e1ef8ebaa22b8af232dc34ec695d348637cfba472900b2ce5ab03431323e5ffe852ef18172a621e11b3f9cc1da4ab7eea8a1211fa25e7695b638bf5e78f1e6a6b9b73636b36f8ad99c79a9f21948b2c8eee1d41283c46ada57a712f14d55ebbd0431105e32e6bafc6d89dbd654a9c08ff3869058a0f91da897ec9a6711553b9422a4539938988ff7a653b10773e5e59d7e2ab90aa9b3d2b57d798e633ea54fd02694bba32e9d86397611eb63cf2cd3bb7df921464377a3f3e8e783e373a54c578f1e1c5f6dd9aef3e737602ee3e1e0883417466544b3ae5ee629436f7456971fc6c671d877f8974d566494812e9ac417c7d836830301cabc921464d2d78f11c5cb9213e840715ba0a3afa9045c4d3f9e8fe5eff8cbc8b77fdc398c6f2715dc75ef9d0fb584f4cdaed56cfdf8a8ecbc9d4a734815b3d1176eac06389a82b6271837e3966adee9538ef50d95df47ce68d03dfbe7c58efe3c90671a8c408ea56dd6143cb4010543ad94c815c872eee43609c40cd450219806e90c5a6a3d8d801e5f1ce6536d619494fd948a60670c1bed41d745c723498e61856b1c1c07b8e6a0e7ae29c01be5dbf26ef4fd7facfaf5b97188b52e884d47edd566bf8c92723f6596021750866abda45ed2cf0a497e7dfa4bbee97d71c12a4197393ddd4fdbafc33ef15805a896d33ccb98abe3ba40e73881d2cefba0b8382fa01ef5bbf935d1b898b587eb3472c534499b7d3cbaec076bd43bcc07c029c5fadbc26e575ec2f269bbe30b42dae46a2888244d28f0c7d509760c0b83163d83ee61d97ba0ce57368c85816fe47c385bf3be99b75762898a4a8984bb5f091014dfb6efcc004045fb063ec12b20679d4a0ac88304840fe69d8c3b8689dd822c92014e2436476e5604693f029079da95cb8fec6e375049f9277450878d64fd3c1f693ba772c7e31f196d248f5fcd76f23a39d2667e388e7c8860d04e9e8f8b70aa23167db7d3ba9e5a538b9fe31cf684d9a6f06070315c490083a67772adc56dd3a46ca5014ac41e6579886584d4daf0c3723449b25ebcd684afa43d489c57ccccee0fa246332a87c4951514a12b36f7c17fe596db0fd1d78de0ff9416e4b27a1f72339d0700043f98c7f58f66a71125068984af648d84aeaa9a96f9f15d141c6286d9e953c5d0f64e16ea49d1c64923702fa2b11b013b9364e6894bee2374e9c5c4b8b356f8c30c93afc1984e6f8ea5347bec64c2824b0924e48f987583ac96ea9229d43d80f19f39c66766dcf05255123ad2d84dece9688ef5ade04b0861f9fdb0d998252ecccd22cd01550569f513c63a4a3c7ce9e16eca8b5664c4c82543d4460df5ec4aadecd062b5cff07e888d0bc026c978bfcfaa16ec152339236409117a0d8f64b36977d58c413f2ca48c26316a158bda73351ce50e21c68fbc21aa023970ddb79031dbab59507d278659c32cc7d2af9c6d5a16d7e65bfab984ea1a265027cf34c5d46680ea6966f1b5fb5f3dc38ee51cbe786484e4f356801aafbba79324e9988c62cafd8918a680611f99e033b104952f67c4344531570e55d8c14dc0a14a69e1011a30b16fdf0754ac12d313017a4fe169bac7e6322704866b1700ab1a21aa1f027f1f85db271a2bb9426bb82c4b7c3dafff4949bc533884b29eaef33481292e4fa42ca09584925d42fe68f1bf5b9ffe75e72d04111ab662164023da1a8baa64290022ecd883d29bc7af658cf3941b60bd43cce6e3bc5d0881b8d5484f824a1ea5e8b8512bbf78ae7d2994f0d16448a98778a473b81cc23621a49019c2fc29772ca70eb5dcaef2013368099eb9dfe1c4a92b44abe19a19cd27410b46549c6091ca452884a441535869f76887ebaa59ed8a175e0f955f53728d13b0d36db661612fcd1a974208e784b92d682b8cdc1ab0deb6535aa47e84f2e83314ceb5ceaa08dc2bb60824757017318e0e97d08cbcea1e48e8a5d6761f6206742ac3c4cdb830b3ac78a9c9ec24c08d6b748af76efc388f6abc0b9eb69d4c866c0060999fa996b71f416017bcc9f172154de592d35a76817b3d9a68ae5969ff2b4c8ed77e9fdbd3d673d2abbc12d95e1fcbf5461b13e3e3aed6eddbeebf7e011e90da39316fa62f4bb38c84ad8f7654b809b90130599866d0dae5863961ee1af93229dea2579d2f0ab34f131973a9496143f49adb25acac49b5981ba9e26a9e96da518494b2f26095258d32b742c33de451eabb005cb50d7c96e388512eccb93246f6e10cf7da36eac4a664c6752d1bf1dab0ffe057cede26038525e2426945d22480a23a38515fae3f63a14bf708960a3d6bd7cc925b34ca000d4f212f9385a1e96d4f56629914c34e6313ab08ab16020dd24f0c7cdd9e9bc83bc24888ad229a06f4a5ba72d9d7e141021be8a1ceb53bcd5b63fbd4e824b50b274618525c78552e1861fa3b73e4b9417d712c13e199529e3d73d5d4e70d2c7f8cadae12c589816663108935a990ae45176a5a06b3312455773b8fd942e9cbf984562875f833b4efe97a0f6b7cf319557afbaba1ed73ae436774b0e186130201c99cad6443780bc5d44e7c8d3e7740b2d01c0de3039d68091ffcd0302798221c94644850e666a6a2ee100cf86c1689af57926733f9be953505ccd3ba087502ed8ccb30951d2ae9740bf0c66007771fbaf120f92aa3287e78565c6abaeff41d6ecb104bbd86db6faaca19bdab61435340260df226176b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
