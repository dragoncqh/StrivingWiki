<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c66b657218d85670c1f6acb34f23d32ee42569d74dd16eb9ac21dc4474a5975df0b784890f2fdf0bc3a09faf6d934e7db6be751386ef1546a09a2552b7d8c9edb56511c258a67129e4f0606785a5e69dd704a6e38a0ab4a6d2e6c3d555376a1fee76bacef9fb7b48e022e8cb1108385f186fa7277e16fd1db8d2c4557431e27ae4e66b713f489843399e8f1a0a93fa9443e35adb8cbf3f654285db31128b57b3b54d92311369c77d50f178abab81947378dc45dc9ae54be84649a899e5fb1994bb56248d85458d6b94948640c1068fc1fd0f29428c87e423501a221710f74b0c1584ef1cb09da60eed96bbade4ce60f64877eba47d91bb394139cdd18add1b6bf06233f02b672686cb1ecf72acb8e9571a968ed8053e2bc27be881911ed5c67369dbc01c9947db1166fc951d6cb23b84501d8ecb6bbd0ac33b3d811a1e4819073f0a91b08f5615c920d84cd32c9a01bfc8ac8afd6394460588cfc6191254f6527cf1e133070ac46d48036f70ebbae2a351594b49a15fe090055e9a40667564e499aeab11dde9bf55d800fa3774848dfd6f11bf6eef6308337cd45156764c3cae4b36f5d551d9f5ae8f77d644f4a7bf261c36e8e8534c51f5ab8d57a5568f42f65a830d0c3e56b87d102102adf3a056841fec9675c1fffbe82c89a8d85f2645575b3de2b335138014f3a9dd895efeae2d8bd5fe8811ffc09ee5fcc811bbd564b95e2f62b259a5d7264d00ef82c3426a27963c00267ee217c8af23b13a260287d0824e426940b6f111de47baffcf30fcbe3aa5931f5403101d7388a03f87a2fc62855b256a3265982ff66c0c06fb4a612fe8a1f9976ab8e9b6cf1bdf94564d6fae5934a22f07964ef2a83b50241b4e67781d904b546369905aa8be598bb1ce3ee76b2c291e8beb7c56570ab4cd8a861f2440e5b4eb0d22403a203da6a52b753d9f95e974dda84d79ac9fadbc75d0f78544d07b94c5ce491a29f03026af65457befb1b697db1c836f54457e72a620183fe62acbab8b341cccac314a9f2516f92fc982e2befde483f691afe5f61f9fde6e4682a6df6215b083ea6c3c734d586dc7ce65688a5b42d571a17d10eab4598f4feee55393a0e5440a7722574bfd7a91ea8bc325bbef52c9e09eb1776b6b2d2957c42df222d60e83ba2119c3e8059a5a35e6609ccd7d8d01d3fcf3e8c1acd5e2b89c9aba6fbc0ff871027a9adc9620d14e07f80e8e6157694b36e23b8c2a1646e285df313450cb65fe65c890c11af20685ddb247c0e01c8db1dd5d5d637b2b3ca2c2d6ef95071cfedfb99eaf9d62fa70619b25a3b01524e47072818816e921dbcbf6f9eeda88e4f9d9f30ff98592260f8c31b86d4f6913547bb29b686a98c2980c58d41b85b88dab3863378878077ce9ab73a415a95d81ad04b416e86f739358e2dd7b9d01d932dd4de03f5601191029338dfb5f4dbe4396f283c960009fe4242880d90b817765ba606f2c58c66a7960d1ee9a775dcc8bf004f841719874a05e34dc80c38e24b9f57623cd9ac50c14212a4162b43d5915daf954b595d9404ad54c03a8b49543ae8bbd0d0a98c498198853df0d346caace7f694b48f1ef7d4eaaeea40867a7e9b849fa0c87fd3b0f68fde709ed0d35764df5dbc5648177ca11c2739debadcc2479e6c4ccea71db5cfad250ec89f4166bd3b7322df057f48c6bb0eacfa3ee07591fab85b2e0c1ae1452cb41314588867b72df7c468413370cc0b31e9412e0bcecbf6b6222348daefbd80b4b4a78eadbba208fe0ab16835a77ddc16be07e51f63335f365e60e896f10e9587af020f272b19126262b4807ab58c637bd462a3cb465e74bffa773cb0bfb918a3935766bafb033f62207021671bc83c6c8f088d2e5c220f5bad56f4b3992470a14f5275611a7bd0dfc7df564df82830e0e5640dcfff31cd8be5f9eec2fa737a7f65dec00238cb6606c4cf5a4356adb4febf1183f52bc92dbc8978a7788de7fd28edb505c19b3c66c49f65a1fecbea6dbab3ea436387f6fb99791e66c8f23561de2692eeb8d0c31d50dec74ff9135d0ba3513fa577bf8ecdc8f6b80586b8ad0e6b1e6b48bc7cfd8da0ae78347749db0650acffcee7f64669cf640a6c4da51beaef9fd68242d819c9c8c2df6fe37c54bbd33b65e2f0f1425f12cfdd12e77cbb546ce125fd9b0cbd4c6df45e08cba4d048609b7cfee333420c90a4f4d3ed61cf756febefe08f1dc789cd136914e6ca5916920e88483b5cfaf4fdf401cc2b476f1a87ce6d254a18d0aa44b5e8fbd41a00820afb6971f1182ee938bed865b649faa0d310983067d57c48f23476efdf5378482ec7efa910728a7021fe85ccdb5ef6b63f38f7e4aad59d3ed59c8c15647ffdcbccca9b237aabaea998e2bd2ff9c12e4e48be10334b6123cf59c4b8ea23db53d3c5e85bba035ca8ee373934f9209bb09816462d27d59ced4038486f974627fd4d1b9218e971592ddf3a5201ff264ed34c08093e78636f862a1f22c15acaaee4587d6251a34aa32e2bcd29e678c4be4f58bb5fec190a85d7f8c3e8bf37ac95778217711d7e966a8e23ab14be6acfeb6ce504bc11a7aa90f3c460dd5f7bd3c5483af28d112234c522295b46a86e81c5b0ff6762bb0d2d729d85efb224913cca00f301f08d577867e798f29c0390e0efcf52e4ee8846e08252a9b9c96584cd2bd473c83dda2ee077ae271c71ed8aea4afb0b74d63846e117c047646143cb66a17949be749a69024727d0ccc092ac1629b4ab4bc3c184e8a9b71fc1ebd063a15385658f2f1ffeb6d528b30312b8663ca60eb528d830533743b07219eaff2c682b7f0fccfdc446a8bc933b42239b68ba17bfd08e169014c9fe0fad4205ff802f6cc890b1f41dd440afd3bcb05346ce294f6f5147f3650ce6f2b6efe78b6a4b3c9e0f0f8c46ed50e265af6a5c26aa3516ac63790c3986de94b14e9fdddc9d556f2def6bf85affde540208eaabdb26c4b239bc30973bcf885a147e887c3e5d670515e094aebc32ab026fda2d12e04cdd5068d3963851d5870cb73011e17d5fc6cba66e149112b1d384648f21876b25b755da614d9cc6e87d33a0ddc67e555588295fa812058023e32f27f863779822031a415a67e2db2cf44374005299c7ffe39f3e2b57394e2a95e93891158c464b107e31bdb9c71f37557e044f2aae5b51baf7e3941c4afb19c3e3ee5b3b9f90aed9c9ff5e96d7a9f52c33b3b82990e544fa0c6c96f9322df00fa68b9c42fd72397d8acafae3834c53462b75037441c4be9bc9bb5353f2320711e851f5d2e786bc6a7c8dd5b8dac54fffb0a9530ae642ec72c739b7ead9f4bea9a8e37983cc7295dcf64550ec61e8c5edaaf42008eb5a189e88b1dc5cd96e8c88552c3862ef590560492156f20293b77c36faa90c68e44001803d97fe5b08db2cb708aebeefa4dd7a6049d991c4498d6f9ebd1f169b4f8d021bdb2cdf9110350a8ec2fb2d0ef72ed3d0f0246eb3ec0eed3ba5ac2fcb88b76ccf4b1a39f4d19f4aa641773a7fbc12d37ff0b87208132af6c2117c8ba154dc13a47b0080123a8fd8211430663cb0c86169b0add8af76f5be1ad87a45645d95c6f54bb9a294c3f3dd49b872970e8b4a8f339e4a8039a1f0b9f6e31d4abce004a0cd560edc12e1b69148ba37e48a43b17f4c1f1731422a95f4fe46633ef4cae4c8a49644de71a8fa76a6302d94f3c99d7931f8d01075e4ef70e6bd8a7e861ea283b904319be972703fd3b1c236685b4b05b0eff64c25246de036e770250fc47f20d6aeb6c137b79723cd60ab36308fd472154ed1c5a49675eb6e8f8ec41afa0ccfe4f39ee88ce124944a93baa5179bb5a7230e01a14c1104a40a73c2b67cfaa5255836bd0b89f118435b54c83c7ffcefc58e0eae2b5ab5d0e5530b19ccb03e9a631c77d147220bde9691abe71e40e073bd0eac506b9b41041542ef898cf18cc895bf9631c4d5140b1da89af6adf88a1b3568ab2c53902294d05c59c5e77ca681df22e7700aa766d084e426988e2e46f4c888ab7d734960d7e39c0fa7071ce924291230f02d550bf424bb4a26330aba97799b5bb1ea8fa857936c3e85a7a958a7990410e0fbcd01103bd960849089a7137ca59f16662500bbcecf3af955aad4127261ceafcd080257be0e2dd0dd046ef0f401d3ebe9e7a6f1522b63c598a498dc05da19f9c861c3e2c786e18fcf1110d85b8e35690f00f7c79e84583ab79321b9a1f33e11af4ea2bb5ed4b8f5879adf476080c2f081bd27ef5001989616cea71eb0a9628b0bfffd17d9b19dd1582df73b2e3374ab1b1185c96496562f66a0366046766642870a0f3b1443c2c9ceb8d8a098be61b1926ee6ba394d59c313ae22fdb2bae36f986be6518e7b705d77d87fff6bc20d07e850d5d3843ddeb769b6dd0b226ccf61049629a0704c2ece4b9985465fac4f86ce350bec6d251fbbaa2b3c29c46912561c65c815ed4460342237977a38652d831c3bd8502395ea275a3cb0d29afab8fc038133b2fe9cb3836f0e3d6d1a4c8205ff7a723199eb5173def98b8dfbfb56e9be36d61914900467dca92dac991dca75d1c2c8c2b21280f29695f133778a7465aebf0922de3f414e907c64b8260896deec2d65b20bf1351b1a46567483f0b22b118fff19de8f42b56da18fd5fe3d99662ddc188e07e26ab761e9304ba1fd7d87ce1d513938b2b8eb0938df24882dbced464dd72f23c39edd36eaa11b9ea90300de49e3a4d2702155754d4ca7f116ccf336427d9c4bc105173a37fcd99d2a6c12a7dd00f631749e8526f81177644ec8fc217ebbde8a93c5c2316894cc6f40f4cb14f4723ef1fe7aa306a9a4f2dcebc00e3158f0e64b9efffbeaf5f0d0552fffdb5008ca67e227f5fa4c34a0e16333f5d4d08c0f39c9bf374b4d05283057a37af3151dc60c1c430f32c7cc4164956bb14eb76197067e1ed9110a81f5033c5bd1e3ab11fb6d2378353226d5f3a750e04bb2f7e684b54f5ff2f21d8e8380e58d12056efcd494cb6a8438f413bc8cd216eb1f6a20a1a36c685f352d41b1203ce45aed4b2ed5fd7badec4a5107dfca746bb2b4e49faf0696b73588b0f4ae2ed1fe7a2d92ffe2838e709069c24e873f0135f49072a417fea01090e64d3ae0cbb17ce146471ed74663419044d68f0bedaf65a0124b8e0cf6be0801fd20fc1cf6a60efd04506c433bd6e46f44cd9c71e3c749065a101bc7d4393ad69015eb1c97955f0289c285d8b1fa4b8731c9663dad0572ce8dcccc6e8bb7bc007aa377bb56dd1035acf89a8e48c9f276a270af7ebc4fb94101acedd85224e50ff55c6b15a4bf839932ad12ac7098150dd3664f6fcd63dfd6babb30f19102b66f00d3e96335da908f942f202f256f0999c5433724b4c2976011b79cc0db3f724ab773b02e756886eb080dc66d8f998a8cf3e8a12b8d08573ca2195ba945e02df9bd198965943f93d5ab78bd2b892aad38958fb310a5a6174374d805280676db04692920c84a92c8b5f8fa965434839aec6e36da2947545686d0d53d917a8d9392ee9defb7ff50408b7262dd265a96d78376f9e5aca86c964cead5951e75de4da1f1bc8380c65028bbcdc5967021a455253fde88a42e46b382619afb5d1541422255295c4374546e03b8eeef5dd2429615222f455a6676705b635e829a8346f576e77852648297b94eaf0b251a82f4789a2d417a603423f92ce908a732ed0b8dbbb2afa286a9e5b60b6555653a9456a24c22225360fccf86864cd10db7c381800b2db989367649bb722379b5c01a3462d15b30f18ea3b402e9f9b487825dd05fcb662fc2b3a65e8a951f12dc04a82ba9bd43f434729beb1a131019c723bdd524fc6dcb024f411eeb6ebfa52491","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
