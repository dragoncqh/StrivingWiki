<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7004b86c536b8d0046cc9332f0e2b649cdf8e246948ff914095a6d2eefcbc4131293e2f8aafda3ae1c65ec6cef734772e7549583480c089d3394a22912a857a8cd64ea7bd35e01bbae9842f006a6377e2bce29ee22a4320c746506e2b1a40b9d6278c08511c8d41193fe02f9f507912e0fbcce6fda9d26f7308f754aa11ca24b8886a1c0e6b45b8b70b35f9cb2c1aa947d7dbbfc08f410d8c76111cede2f6d45f4aad94b12e42011303e3e9e8dbb616467038fd87b3d8ebdf9ad176233f538bd8b503e9d81ce1a3093406a24bf1befe696cbd9cfb72c3bb7a08e0df6a4b44d5c991d05f00f9651bd785119a9282d0b83b9a90219f3fdca5a8000026fef3fefb90218b29609d739678cc69bd63fec9a835fcec01a581218a83eaff60e650da55dbd8543b573d55226578f05c3052b0c761f6b37cc61b8981e0185f8037d7b93685132d36ec8af6746df863d0ba2d4f99da410410ba493d55ad88269f286a4d8f9afb99223e98314841822b7ace7c6fd4d6363e27bb90b9dc7933702f8ef06471c7ee588cfae2ec6d3871bdbe5777f41b5120a4d73dadddf55207ea15e4ed061c1dbd8f8f746a14bfd2f64768fcf4ef177863018221964918e6c7cd45125e53601464824bd9365d2a58a93b723ade17fee296c60657ce7730936bf83a0f7ae5842b2fb22bd33fcc8fb30b48dc849378d9bf5931146430942976534e835bb1520351173a0b0fa0932faeb8b2dcb86340f660629a2b6790b1386573adba44710fbbe42596019c97f2a7d26f2d7b0cb96489ade82285fee717b4d29f82c37ee59236c58e40de55fef820b67bfef109291d602a6169c1d4b0892f4356d0d2396ba644d5d20e8f18fcf76cf537495713509a1500c5eb3ef1d86d0c448e50538f614813dd55a97e6bd87dde5f5f3f13a84699ee43c825e15084b3befda63b433a5dc9a5a024deb64a2b4fedf77aa63956c5fc880c5087561b2b47df19d47ab35148975bc75531bb008eb1cd875c685e20b31392af989cef28e85c29e3a29f2251a47e6d526a8858896191e6ac2c5fe7a8a94bc28c55616751fc1f93be3ae7e2e490f91f50b3f08de498bec8d1d421b6c4c1d80850eeb1226d654b77f66b83a6eb59c5bfeb44926815f12a4099f03830d22b117a3a2486282c1b14fe45e5183295a9875de1a31aaf88ecf7fb5eab91679fb0d470724bdf8902af1db231eab19d79476b2521acba5c4ae44236c6f7fcef6337620a8f7469f17e24e1ce320237cdff4530f6a7c73a65db08ee7350a82533506b0759c5ac33e17239190413909e69217ca730bfb10cf84601089e5dae29eff4399ba58a59dd38e51b78aafd68be84b66beb5cbf70da6d0e8e64c10e3d1f82c5bd8533b438bbdff2285d502793a59bcc4bef49995357d4edce2e0494f67e0e2618e481d76c20b046095ea0425ab04423035c3520b811cbae92abde2656455c45afe7b8344dceab9b1c8fb174bc61f6f07f60c648d848b2200e03c8f1e5bc84e6f3ab1ed894dd82cbc115d80d8a5e16319c0c98c304286b68d6ff756cc749708b21b1441dd3be78647164b7dc2a613eddb3f784c585fe1b4b6263c703a27fa32c600573af5b8243277eff59bd1980cd42c6b964659993a3ada4d30a6aa35a57382289f0a8d8b12cea74d82b961c6ccf30d9ad8ba3f984bf8e67c6e51564e120a836dfba1a7e62dd5e1f59bdab6249f24f671a0cb49fa2a8d440b78da4ea8aba7b024effcfbe135502975ec127a182a0350f8ae40501ca62ca68b406f27e1ce5563f5de3a3bc8cd6679cd5ae20c09e0974fc19091ea68382c9d63c75b6859bc53ff0a45c821f23750015d23327b8bb2be31e1e60fb42824a95a7d1e20b8423259adc882d020b623eaa4900347d17beb4280865a729dbdd00d643a02389dab4792f94a75c8d993ad36756d7b34e12bead013c2bb4ee5e19846b77e529d51a30beac8b8f949969f9715857db757b68ee42b1fca53daddef6052c67308c5713b8861269388afc74c9c6e19fa0831b26c04f7a3dd965ae8924f0577ab2dbc270c7b37d846b4d4e9f517e81d54fe4a52484cae7a4e54280cb841f40094e0c65f8d93fe2a452b3a74e06421d1dd204513135fc1a5e979dad386034f2a70767e99f506442c815d4191d54be597b54e30680724ee4eee487c5eb328ccace29e10f8c70a0dc69946b3b7ffa8c565fd5c452c7fdb241c627c3957af4ab31cab9c9cf38121d09563125a46ab3130a7209daa75a0320d24732fcc797ebeedc7435624dbcdd540d9939123319a363bc4815fe23edf9d6b31310df7a78cf5e59390e884ec68e287d0e0c85298cf512eea6eeb2336f57db52c10b79bf65f7ed28a38a049041184d17356bda0b012f06d1b36d32683d4952487d1085131fea9691db17e06dff720f80b71ceaca43bed972cd3a33fb4bcf13255fb9a6281a3bba655003f6999f500a888ed51a9016aed26ff99e5e5a67e07c2a1117e2b0f9180b1b2449945b4252d2f3f6eccb45cc4fe1a3d307b2536c835b26da16714f6d66dbfbddd69fe70c6b90fd06b8b0885d5a480e63a0e670f04d5c41810999a63f5564cc82a2102220f96d30139c7a300a5af0a0a842f7450bc3e26fd057efedc1a9e037d560021945bba5611680f087950942f28203a4abe74fb313f059759bbeae4427f10fff3b0c6eb5efa7bb144566e0b5c486adfbe667caf1ef1bdb88239c4953153e75c6fbacafccc6b225b2d0149662d2a53f12e65f54ce033470444dbbd5e5619fa483b0802586250f4b573551d698edaee7e7943892e92519ca0c618d05851e376c59dc8d9e403442c0dd9d3a8034bd891c74f8198ad4c567373d40d5f9afb770a1e33d5e6a7cd829f74ce7a9af6474740ea4fc5b2bbbe5e836554ca2aa0229f22732a3f397e096861918ed27ce351f13b957bd5e6f8960dc82ca8d63f710e9c0e8724ddd62ae19b0d903a40d4dd6d32de1e06ce494f6ab6ee3366a57d96b922a70340b0e8bb23d052d8d788c5766b104ec234bee60b16ba38efc7b1d7cdb4a2c548388efe8bb688736d206ff5ee02834e5e5d0cccd7be7a3c9ee9d61f7a83934d6f84a653285f266e3baf45e0a8101e97bc58c6786775a9c54d04a26a5b4c3ad267d0d5a2013b075e900406a16074209ea9f59e6f80e9adbf7831f9f2681bb2a4114b9b19df5e46e59ef2282c176f4db0e09be95a5975773a55be9996aba1160d07d343ae7bffca397eef514d6fdc505781923be60181e6bd912043472285a8a48f3c2084a92f84bb668ac9fa245c9d8c022a030663b2e6f81c6c84a631366203a2eed0c5496573dc6115171c895da56d2ab022e83ea26b87c9ae27fd25a34f0ec1902dc7140256564db5aa7867d9d346f1121829316ffb27dce6714f6100fbe8afa1d15e5ba721976de5ed60ef26b6fe430d0d8b80408cd10d41c54e6dc0c31fb2a983ba03fd9945b76750cb9db07ee39f3edbb6f13162c1d055ca8db01f161c8d53fcb763fe2c3d513d90f28a41ede4ea022edfc8d7855f15bf7903421ea2e67e55250a91945c880397f3661e5b88583359aeabe2834a9235c3557879dab07e5db7653429c0965d0e77321bdfb36b6efddb9054663430ca07f48f38b71e99bffbc5dea2c592a08360b16fb95d8912164d7c91fc91be52f7197937dff5ec1335d1eb2156ee6426388e580e507641afe97d41b935319a2b49dc031552fc80f5513282a03878d83274dd8ab4c0cc30e9707be40d315719764252415480c7597db61f8a7f1b85f8b92a578f8a30303345caad8956a293db51b708f17410a0efa2e0a6fff9bcffbe3690b8cdd6e9d61b5cf586e06cc8e546b3350c2c455c0e6fc502c4a566ec257b393098c4f80a8e07f6113f741c53d5747172f01f2071f71a48795d24dd82b0677c40fa421bedc71b996ee913561cd515953577c34b2620f7427f4b2c2ffbf1e0f2729634b9ee099b115914532c79f0e5538fc01d210ef4b287b9900e4d016b86f4cc7f67f240282174eb394cf1c765794bb5666b6d02660c418fad056cf887efa52bdc85f78abf23ecaceae1634c9d3b7869ed5b79b7dc321e3784e07dfb411c3173fe36bdef8ee8fd900211061ce0fba13156a47d357cb6046a0f5a4ef244651f4e5fa26ef1686ba31830c3a5a2506dd1dc76f1a057cbd065e5b29627b11f38410c3cdea59084089b112605953823dfaae5cc3083e6c2c752e9770d6ce73df49aa5ca838061f732ab23f08c4fc66f736b530498caef2bbd8bb92fa0053c6d317544ff8bd1cd7d476c8ca277c5cec932ce5fc0928aa142a0fc1c9ae35d1f2fc2f5f9c1d9ef2bf123734bf36ffe0f2aedb8e6fc06303f89431c09ac62df12a2b1ccec76af094751b72fb9bc295e0d61493448d98f9d3b58d13a66781cc4aa8036cd32fc9b72f1c30e888f4cd11098afd0b424f52fbce2bdc7b550f49ad3d9163a747182fe479bb6ac23e8f6bf0a9790c8c2325bffe304ac413f696987855fb5ed18e2223be6b15717241a7f3c96d7e31df2261511c3eb9755916ee1eccfbc1eaa1d0dac5062a5bf857db9af7974fe409eeb0b3f8cff64ca17dd71d69be7e3beba83040ecd4bd2cd48ca792e623bffa4085ffcbdd75d95320965d7401fe6d625cf2e184f072ecb8f062e5c92a5c6e4cf58ca38364c591cbe4d56f575543b0f22b7b71f9f9522bec33e6d35a53629ed9274d18e20cfc77bbe98090913fd72da095b3d70cfff742528c6aad7264fd5f5b98d58b5b718fff6f1aefc79135ac8444765743b88c2587b2f345f8380bc16b12985125e529a39f033b2b6f12ca907a742746dbf24b329453310187b1ee81ce7842892633786262dad02093d67bbf8a34302c019b8d19d9c868f3163fc4930a65173f99c9ac70ba88510eb2e8347549fc7372d3cfa43eb37176af6c90abb7c5f54dd3fb83d4310d400e75e12df1c78d390f5b16000b79c6c0d7f617e5bf5e396e01e1ef847ea675b1826ce1a619a78fac98d986a78915a59ee9043f1fece2c65915d72f185947f526c53f8e11269f2f4f9414d4bac246a7c60243f86c6a533b2bc31cc85c44cdbb2bc1395cc94efba56846eea3879f660a210debd53064db77518f10a1175c55cd6350e510f0ec71213a23dccff34962daf1f8556c1e27b1dadd286296b6a4f72243b183f9f65bdceb561dd03c0ff5e4d2cac9c65b8cdd4b246eb2c3034639a8a925aa767a9a41c2bbccc6ac5c75ca5dcedfccdf982a934d18197f4fe5df576df65a380988a55e72c017299786aaedb449fd746ddda26fb362ff8f9e4f75b3cf8f32b0f8c6c7e0f6b7d446ea4b6638a526c3e2ddb5954698b6bf5d8f4050ce163052fec21836a47dde168871aa884a32b1c1d43a5dd2b8b3d48b22184d821348ec30aecac7a34d66f7d20c10f56d1a060e39f6b7c711f70cdc6f36fd57a4442ca6b4fe7b7c62d54d6cdf5a42b90ad5816ced9bf36e90485df352c59569ba01e13dbe9f19bdcbdffd2239005722b9b11907ad8c7fa2b3b6374f2a209bf64e256f550a57d539719d7ec652e313e7146cd5b8abb2f9c231008445e54f000218b7e9a689149d1e9ff56720bf6bfacac3f86875abb123a7ba292851e3fde92e5c2f6a4e7e56dddf57c48d4d4d0df7ce9af4ad92f728ec2ee18907f6ec183a97f9df0266eacaa7b42ffaf6d9beb51a6ec35bc3aff39aa3fd96102c49ced6b099843d3517dcc25447ee883a5ef591224a37d3635bb008c838742fa1c783b462094d069f6bd18570529048b763328cd464d4c566a7b77908592ebb704deab4b2306d4f8237ea5879de57c1e6378da6b34343e5c58cb67b8336359ebc3806c358541faead33dd99045d53d23e62f72806bbb967002fa4ad099f44e208a2f0e0f3f48898afe585dd21d9c8c65a5780c5452479549e44c054c5ad76cd9e6249d365e49b6c38cd4c45a4439818b715436f6bc644f89cfb2d55ae636767d4ca2134c00e80be44883e2fb6a92934d4ef124cda470144cd99ae86e6a118c3045cecc2c2adfa262cf980e5ab7a707588a594f65d805af870174e5acc459e4168f125a8d77fe4d54e8e998fe56d931c8dbded2c844303b9896baf541a68f39a28a3d5b4cc43ab421cbd38a459d315cc967fd1bf5b6341a6b7eed78f57496633cdb623e9fbbee8fbdd9bbb28ace0ec157eed0f84bce2a9a7ff373459d6dce9e9bbb82d0b175bc5fc2d284380e656b649f8d6ec74d493e4a75ed9e72583cd91f6cd3b140c3e8b1a3814140aa4db1f1f5199955ff1fd4644de24df246af15efb497b0813e082f04561c06250f12108567269a25ccc645fc46f6b9eec193cf030144ce68429a54a18ab8fc606450d11553de17924bab28b135d6114b379701efae8a2a912baeffa54e22efa93eb3d38b9c73f1ae75425a6358604cc3ffc11cf801620c8bb35237a7b60ea6c2736f9b32acb8487a2a6ebc2b666830d93d2a30622ce575cd598b924c9f6a61612185773586a6a45f36dcada5ae4ac98072d7bf595e9d1e2b72b1ea49a4556da3acb29fb776555492e0679c8c6a8cec3bfd836634cd8da14f1e7a4130d5febb2c6d90c5774ea0a8990b1ef3b36be54057a10c9cb36911f601780fe550526de12ad37b0c6025e10fc0d380dd0457b873a1d792f40f9c01f2bb3a9c983978774f3a1e5be66ba6fa3030ebc793fbe52c80e1cdf990261e5879a2b709989c9f2344507faf7ec129921b8fc2fb162008f84c76223ed1319f6e01046f91fb0c204743d0ba5e7cb3da2c8a3cf938e6b8ef3d88a9bd81e355c1f9646d55236c89ec547c16571d7925dc8e7532de21298aa65cdbd7d09feec2ab7503cd33667044e561fbb52ec5e297189d94b5e8b04fb7eef9688cc5fb772a2163ff74dcf8d64bb843b85dee86dc7deefae83fceb9bf697f7be4c07aa197c5e82f92b957f43f1c64d295ae4d954e95346bef1a1332302e45166ff23a761ad339f0a427818e8f6bc3f44db2c304f75f44a87fb69a12f7b7261ac4655e5214e2b2fe34216fb3602150093386559ea53cb78707027921d134d696066d24797477c75b80588f98d7f3b890f250600f6a5d5576da4842b74df78b55a6d8eba013a1081c5a7dc32740c54338de1bd76f941df74d1087bfb276a4250e0ff515d711da4127e5e3eb2d719a060d23a6279d44fb83521cfa7893374a5f757b12dac73975334b3d3808cd2b1c46b24ab47b2cf9de9b998579a5599c7a5058541a72223ec80862080f93a34957ed4e776da77bb849bfd628fd4c6c1f865d6fbecef88efefadfdbf29dea90473133b18ccc98eac96acb78d110d6a8eec8efc06845d965674333a7590567951cfa41b20d4b37f255fa6200297e1f8699b0fe704c4e13785fbeedce1f02beeff6624e868bc1f1d0363164d4e6ac8a1aaec170b47b3c49328164fb609f82ab1034fa102e171215b58d48060d81629fa8f0139e1c9caf237a7496acefe0cf623e71ebad01270f50ec5656af8581e2241aacbf42571efe3c216d2df1b21bfc6c63e0b87865fe8043876389e12360c4f181abcbe5d40c04eba5cc03109f188dcacc581b4995748fd959191138f8207878cd74c8386ac589002419c75b17ccfbb456efe90a266626e42f24af98ff2bacaa62ac8c42d0f8d3f97fea12d58658936847f28514cde1d36dfad2f5fd354f2f8cfa65e27bff26a43f624acfe328694c23fcda4f69f8ccfc3424315163767419c49503494167a4acb11fea4d6dba8ac408b4cf1486a6a41efcdccb1738f7c5af458aac581f645f7af7353aa9bf108501af0cf25559418bb4891df04efecfbfa6e55f950257b4315884f8662e6f555e059aa842150645dd1b804a3364c9500a57b16b0df3225dc4933128df4c8b96bec7d8e0ff3e025726ccd64397d3e5ca3f107aff14c11f28cec67eb146acaba84d39dc437800f6c93e4ba79df7b5b5516bbd6c8332454b1087db1c626d212d65ed93bf286acf5de54caf07fd74a8218b54f932d6bae46ea060be550897fce227155d8d2064084aef1bde651e710b4c06f86ab3c8d07282c1e52148959d76e829fd58172b97c49e803b25dc1e9617e3865066e437b66131be92745e0c2ed6882c69a739e097a68d58f8deb574f9095ccc2dc8f93373a4a3680aa3eb43da372d7c1273dafbb2d69581d58f9cb000bf7c185734883e4b1e611e8857e7d7a3a7c0d69d164ba508b6062a155ce59b16f7977799ebe6202ee77e82d18d21d8aac7b686cf143227d99fb1677622e7c7d19098cd916fc64dca8a640cc95c644f3e53ea1b883ac8aea67ea5332ce68d89fdf273131b98f5af5aed5e135a91852911b1094a020640ee50abab68778e0d0387724df39b3f2f1f81a623e5d0a2844d719bb8295d2574627a0ca1a333cd6a9d8cc9c8503b3fdce1c305fc5230dfdf092b0fbfa204c5b51a89124644f61e403577899c864a1bdd0e514b11981d08825c9ab34b8360f2d22837fc855f3727ce88af85addfff5ec9b5d2a831bc3cfa5113fca2702cfd9e5dc31fa4de823a7cdc7d43c1ecf2c18813bd08121493c65c893e5e72c0b05249e879872264effa6d34f5b16e868de780fb0af7fdcd90094bc1583e8295bce40c7b9d4b578c9210b82e277065084348c6bbe548d8cb4a5658484b8fb9bda9ee532a6241f6584b686b81b4155a8cf6f161d09854da70687a914eb2f47740c25b78ac600a97cf235a318158a2fa837d2af68dc8ef28994f7c62b97605a8228236ebd70c22cdd5553de3ccb0a83dc75871f9ba4088eac1873c8f12130ab073f66998c4aea50c1f2e41535fc527bb84cf62559d4c6b71b1c588d752db2b93f16eb2c32800b7f8f959ae3b011ee1a36d172971e347b3a16c442561b3a0b6cf7ec97efaf0fd7242fab42b77b57bbc4ca0f9af0b4845d849823dcf1c4bcef7679484750267970c230232de299acd7f253f5cd07c4b0c82c35a1a593e011130b95ceeebffff1486b8ace072a1edf8c5c096b8f46dd70f67c756c2026744fd9d9d16838a82113ea1c69c28611d2febcc61d499fd4147d8ded0d18875a0fdb2671e2a3d94daf6909727b93beb7799233dfb3d4b19ff33e04aee097a3aa64923c145b7b5eaa9f5f807b9c2342f62b3f374f6ca7464ee3e0636009065d3e1643ffb32a07e18af48e61b8e7cf1aeca6c8b4fb8ffe59db4a67efcd836c2d5a7385f55b5e35840f466dccf3884d588e871fdc90fbadd58dc8e3fed26b29214d690640d61bc986e1c125c2f450c0ccd77f6b2c40c8673387a975fdbf6a1aec5b02c5c9d99edae3be295c523522d0c8fcbb7346eae6eb1e7550707ac2ac60e2241860322e7cd4ff97c1649b58ce41a3847dd6f4ec1eba1354c151b7be3a5235b9964daa3ea586ba8cd998c69f43419701d604e5533755906a649473deaa069b54b6ff9bdc68075093a060530a464eea9ee084a5180b4e70840029e9e6e1441","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
