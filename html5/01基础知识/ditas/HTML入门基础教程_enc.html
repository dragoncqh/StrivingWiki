<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab4def819681cc71be0b3a25c486a2aa8576e945a18d9284ca61b4203625429f0360512b2a502d9327d2ab61866322ca9a4591db1c499f8fc4045b975fa037fe5f379448fa51e464257eedfd70bc82bf141ad5ac03fdc05a5645a106f2ff9800f22c6081f3c6a09a91f9d0f0e65d2e4b55a5183ea1ae9c547a824e09dad1ad11ceb3d53801e04794dcff42a801eaef04eac4966da9426a2b8a0a7c4f79dd99c0065225ef62e5a6b0160a3d4723b5e4905b2559ef16cf03d6d055b6eaa69b17cef049a516cc88887162e14e863698788323da5ac599860763391b045edbc80746053e6e09e1a85f346887878465b5d4939a4217bafc224df2362d5d57b44d4416bb6cd850f29159143fa52c2c93ed5ad16aa95c3f56f421b4efe6bbdfef8ee74b82951e2c45b814bfd5b42f36f85ed978b7ec6f10afde611364cb426274631df38ac537a504a42376fc71df9df2c146b8e20db3deb210b50640548b7d554f66de24b7c02f26441f20e10dfaeba7dec63d6008ba8fddb69bcf2247bdefb0b4246a282723d420eaa81def0909acca6558e85e518e2cf0e3476a9e9ce804f7140fbcdd669feb9fcd90fe40c8e88c5abf22389b31dd8abf83a323ff3dbf3336bd32b6d460fad0090e179366a042317367cb1b224b433063c879ff403552774e304c9f4072b53e4732754b7eb065eee4961f8b1edae6c697962933e29814371233a4d62e8b821d279c72cdf5d8c07ea39d0faf6fdee781def46ab6b8ec4f06d2978f21fab640d76ca7b5da04a292aaf46c6cb8ab80a36e7825098dcb26c7ffc3eca62ec6b2b1f656a4a46295a7a200f7429221c3d1e3db56cca0848d8f824317199539da701826b8d86cb5f49edc234aa8e753350951d59cf52a4a55247b73a2ef1ae080eb3005c5d62ce9ca583404bef6de20a336cf64454ac4a23761794e794e28f97c0c25faa5d76061412aac5865fdc926a9143595e99e92a146331131e9a58c1c62f40d823744727237f88f8c076837c9b560253b625f47c7366d042435c9aeb77beef52794a364319d67b9c8241109bbd9912f1f1c1e88848f074e3bc31ddb2c4a172659b0f41add3f6bb0176fa0fed8c598431b839a98343d94f802053db22edacf2a350c07d85878501c1aceddf73580d85062d1804ec15710eb4d419f0695ccc91a2c449c1087e8a6faa777247f96359b4799c93a525e2b0a28dbe20bc6822d157c728d62101438e0bd0e048eb818472c9f94df8286961df602a8cda23ce53cfee621e2410f799fd90734431eb0b01fcb6c48583ee884603c35c10c507a2556e9c82b1e50ab1a29c4d642256d4f9a4c93ae202a34d1dfed3652d0e8b55154f6da2725390fedd5a60c78685d6676c1b5647d641d47be666ea1a83c9eed7c517b4cdc39c526c4b42cfcfc4711bce16fb66aba14d3699a1824783352c7483c59152b7ed68f9b16c2126effc552eb58a8181c5e380863f6b0156a72a868bc37efb3c05cb8ecd5a59b2736ffa4d4144d3688fa505fdb0b1c5184b662706bd4b23d02c813ea15c0378bc69e17fca1c438d91967c75bd287f72732fdbf4cdf9fca13c0f4201b54e68e0faca19a0cbb9291441626cf6164264d15fbb9998cc66e5c5780fe5eebbdeee3af9cb217beb16f0458cb519fc9012446df0d06978ac3021c76689abfc0013cc2ef32dcbfe70e819e5ce08c6df0aa80b002029dec80f02d12c2525ec84d9e10eda254a99428ab63cdebbcce3e7f248112ac31293e8a0bcb26967b700586216aad8850610a08ef4b1199309bdafa10bf6118d203beddefd3ca373c03966cf5fdb63ebba19e5c6828b98540ccd5c75ed4a37f57d7a38489d66b645c11cab0aab703965fd3e2991f471f46b155ba34e429e78c9259a029cc5a524b20e6c3847765a833e6fa84a5b47449d7120cc7d5667274fd29540bd658a9292f7a809c17d095a41ca4a2f32cf9259f441092d582df8c2611ce616fc710ab6ec51b7dc98a1bb3b6ea98033025cbf2ec1b5f4f92aa1532bc05748958927a02d13d653fcf023b872042bda483c878dd6640bb4eca438f6fe0d83e4f7cf74506f2f4adc029723bd538008a423ca3d78c4932de461199ef44ae0d06963a96be05e178966ea874fe367eb62b6dfc2b2a8b52b384e9bbb30fcfa9e10cc41be2aca27110297815c0af5691632e1d0b452ba2748dcfb903adb9bda3543197d0408ad5644a9014bf8d754aee3760cedf126775b1c1927fda11cf82a42e629aebafa13a15b91565f16efb040efc42c0c1131b64143932f8b49b787d1eaa14047716c591cf7e40ae946b4059d63a468399dba6bbd81091d90df472659ad235595997e76f0c2fd7c0c9c01eb788249dc651f3dc841dbd82641cb1a047920d17a1554d7b1348590d687e9b5ce7b5e323a46932b0d2f1c433721b23bf13d3758e88407fe2917eff93d93d07f7b9cd4c4c9d642b028d50abbfff8a3dca02e2caf2b6a21eac57f59b0accbb0b27e235a1ad84e051c211c354c95619c4debf7994ce7822efea030c9e347a008849c6d017466194a79419f847606fd989a4683035817f7d186be68cd644ed220afb880c582f387426972bdaf0d7cfdccedc9621553db5e3ddeeae94cdea7d2bb25f9f0e9b5ec24e8ef5eeef2a450da4e189db84804ec8cd43ccca04c7aa02e9096d87d904802b099b54ecefd75bcf068a6dfdfc642cc373234596897d38a6f928f0d068b0131b2f345f39fbeb21f73313a18f541b60d523371df7d847d087c4b855ede999c0d073caa5aadd3c2a9f040d49cd1abc6c2d19e74e4e52b8ed4bc4aebd719f77715afc9ee2cf13fae3ad6c92af5055283ecff3fce53c464c721a5261205e362c675cdefad8aefe74489aa2d9de0c0e381e0b3bd59c2f5ea0c27134ea92f67ccec33c760ba38cc9c25fecc433037923c4efd44b2e6b25d41158d195c10eb86ac6128ffea71723baafabec42f6e66fa1777eb8c7f193f214ce012d15a1c07867af231fd6285c1b6990316f120e1410b3bef5a4779d8996db2678d947d99b7e163ba62437a2fadb50b3ddb6adea3d38f3380e57c0bf9965739d4bd038be9a51a5966604bb835a3cbc8faaebb7a9f2ebfc7f3ecfb88df7be64e220cbe9dc6ffa6774f973f20158b098ace5c057c09f94f959c61b70c4b4bc26f54e46b6cda2e8b291acc17534c9d4a2d910d7341661362a2344427cb7102f0aef4b73a2eef7ccb6b10f1ac9413fddea2161cbb95ec10d59500494edd872b6f0a6942dcc56fbe9b26f879eb5e500fdb488f380d6acb89871e65c2648a5e9b32cdc2074faae5413802aae2c0cb02684e5c2a0d88c3009c8df2014efda31023d9bcbad1f1b75a86127d9510cdb65b329b32fc72aa568e28117e07b86abcb6628ffc8bb1577570ec62466ee8ba888fe11c2240cb8e1cc98688b9712abd575ece0debe4c19c2ae245332e7712aa04353b2a6088445a398ac9fba0accd62d5d7c94a5be44504791c3fc143cfea536c462eaf6910d93360cd8bbda432691b42d61cb994d672ac7fa949c34b2a25928d0b32be5cc7f1ebe10e54962ef29b8bf15831dcaf4090972f1123edb2f59f2a41122b20e4f018e90b5fea3e1f21f07907b52c2e66a921b3282d1db6a74f17dcf73ab3d010f59c246bd1f71d6e93aad07f14559b746a00473b90b5c9acc76bdcf03902af5d46381c0b4cdd15a890fb163f3167ce50121085bb8868dfde5060057de3693d6c31ed249cc3e46a16ed85f6717aacef9b4a1409cfc665bd7d98a813fe29846c6d6fd4742532c55f7b0ec2cbf62298e7a8cb8b7669c549c41f951661a78e62159f590809f76a8a3fe96b775ffdfc7456851f11f2976d46a12abb131731a8f52987e317c486d9449ef895300daef7b07bc032424de06e4f9a546060e993383f59bd4ad12130a9d212ac4a5e5352136975aba7da01cbf17f62fe3b8e8ed35045894c3ce18e3b30a9f17a9b2a8ba4f3490d08ba60f0e89237dd30a2427b4de01c90b6efbc17d82ad35fdf2724a2a1a220a346147cce985206ad09aefe9bdb440a5f8657be0d0d30e81e0fdffe503785f4a1ef6bb5df6a1f5bbef969bfb8f9c4e3dd31568c69e29f753d1d231e71f128bf88748d834abd8c4efa78922c8b6a85f2a7fc0cc22eca2761151d862d28dc18650571ac42be08f95d6822a5423d6c368b6009cbbb52d7f155a99a0bea488193390f25b31cc727c3cd1ea119cad0441430500cda95cb8c295f4dce9058e4f6ed2c3a131341e26c61240b16c2fc268a6dbfc704c064913e849902f1a7a25028d865a61f7aa1b775b3ae107d0593be55cced720a8a6457a2e87666e7a0f97eddbecb89d0f515917627224fc1299c1f30c9667cc540f2140418c7f7393cd4c817bab62d0d2a87706bfb4fb7dd407e9bf24a0ba7eccf15a84f585593e6a8a236dd607e21424ab7d702fde1723283f4c5630b57a03daceb9eb83907f3af907ea9b2cd38357cc04de5f36faeec858bf152683013a3a079ed62ffcdaf5f886b32f1f446bb288a3b68c93d5d169fe40a821b8587f763993f03b0995d67b40ba981911ac7df6f763046d1fe6deefb719dfe9a3100d147b0fe8b36026cac74776e23d61b321f1e98fbead94acc31922fbd0f071134fc14278822fed6451186e9a96ee7f8a52d868914f3ca0be50c97494a25d6c9c2ccae0afcad6ded13898f4c94e232b577edf53b2708be5fcaee2f3f815b316f1b059ab5f4a210f9f046524568a45f70d8e4da969fbe41bba31b940611d7eb5d72e03911179924e76057fa879870c25bc7725a7b8cb3eea006f1ba7d3661ffbe284ec2640ae966b0ebb2033a8392b37e091d3d2dd543a269302a90a2470bab4a607c52583f307111d8493b1e6e8cc5fd0a9ba3a8e1ac53154181956384349b7aa78c01f7a4d6b03bd26f116057316f11d08f3f25ae8248fce3fc22f3aebdf4a6f801a35bcff7a79f2c4ca3c25089ee1fbc0512a31b0d28dc951ae87309b7daacb5d23d22ff4225a5ff000c3aee4ec0dd00d729f69c522cd338c04d90711226bab7e139726d47e538a818bf89e9b8ff58f6ec34de0f8920f9f90f3fc009db5ef963578f08341c149732e5ace7f802fde42111409b5e4ce596f8872d51baa9089bb836e2cbdc1c77706272e88eec16f37eeb366ba321311cfef8fffd398e0162b47915d9dde3e6fb4bcff88df9121d3cce93c2519c7c98795c1a7fd7498d0b767b3ca8b8d16a948705fb13e272ec8e6f2cafb91b1fc398fb30543aa251a51ca31ac8894bd2bd815c8e33593450dc4f6ed797bf2723019b5768ddf394d610d7638ac3a5d01ef39885a5bd8962fd8ef5bee71e6686b9f70ec978b9b0e22405f3d81d6d38c2449df2245e6b1184b4926cca4d99e897e7ef614171fb200d1b7dee84b3e3619901b98d670fe344e8a49650c66fdb85ddcba8ac749de63c8a5c119bb0a595d7726a002f19508c9cd1591d04e3db41f605bd8425d4a7e3c52c210d18a4ffe4a8629c1aa4eedb24612760fc8c1c928d41bd3a70d9977359f5c4729108cabdc67d114385fd543e371d5165ab2676233b262873a695dd098bc6e8006753612d7264726a8176a113cc9359b47cddffe85e055d93d75cedc91337ebf60df6a46280b8a0bd25a3078521199ee86e8b88b81b47592a96ebc08189f8f05bdac9be0f836dc504ba1b32a6cc1caec77d0acf1bf074b8520fb8c572801c5e8240773bd7fbb117d7e686f38875999968a0965a0842a8fc8df00a9213211c0149d33654d116e3be0de2b34fd675f725f1dd3ec114edcd753d77f97167e290b31cc27c5407e2b63dee2e4fee536353306f59051a1153661f23644fe55ad29352a0d3212f024a4f9f9128a9ff3bccc1ccf300ade2fd2915c47444535a0eefe2a7efbc2c8aeedb93da0765c99ee9ead99959aa6ae4b9bf5f2b2b115f9303b41bcf007ff7c4edac6a8514fce71cc8785e95e4ad6ad0a4909ffcf50c8adebd8f4cedab66b2498f0ab46211e316259641e283a8693aecac3431e67529193cfc00cefa3dcd085422ec7b035da2cabf03f5bc0a7563ce5c61d1a7261214fd820e43202886edacf29f1f50ed73a958f1f94a652aaf53c20eb3774d3953ea75c617d4f7e85b17dc410afaedcb2c447b28496c11de2258b69e1c92e87e1003135e6451c9bc651eee509e51189f6ffd6f4db7223304cdd37622b6753e8372419d9bf2f6a3806b60ad6cf508f70e5121ac7e6ddf95254d615947e8d215d0c3c8b288fb76d0b73768fd4b22329a85b76e75581768dc886cf9b2173b967f96ab104350997cee46e319ba7cb660e0d64046394b6792225c8db602f1a2db97758f0c2b6e904f490df5f2bbd941903e4262d976d9523b7cd009ae62977d77a84e2fd807bc3bad703665c32c2e4b06432968c65cf8225d53f2e8ab5a4e828e2c958ef91cb4c01a19d914861f8b7823b0c2fcb4a6d24490eaedc548d166126a7c28b108c045f933813766ae1d2fbbc4bd9b050cb1f38e620223e41a0435afccabbe1ffa65e984dc361cdc50c127694ab0b7de81b1342e30a08f8a69afe2f5fa099eec3c5563a0e05d4bd660f4708a2763c39e6ae420c9bc3bed3c113df7c3c9ea950f36fa90fdac7852b728eb02d02337518641d77aec860e7345741c8e956cde478a2457ba794e1df63e0d7f2fbc21244ceabb78bfb78dba18ac7a1fc54f57b78eb8260f67b7c10d26cdef4b2d4f077473100c42299ee097eed143f153ca4c8890cc8624dd30dbf1305d723273ef2bacef6fa20ca9dd9853910499ae16db14fec810bc1161b9002565303544e5e11142655fb56afc7e04edac87b9b957b3fb2bdfe29f04fbc36ae4d090652b30821432b35664e435ee942edcf9cef5027b78cb5a3ff24b02f319a53c5ded08b7053cecf18a1c428acde52bcc7e6180620cf939d09cfd829de4a9b4ac7ea53ba8882600256df46a5729ab7173c55ad24bf35a39fefa6e61929f7487fcae6c39d706ddb3c85d7eb84b93dde6ee6bde1b04317ad763622539bb8f4bb54225f4be64dadb471876db64381bc48aaa617e432c4a07ad50d24e0a64a0e84dae94d1e3781197df02d81cb1501ca2ea3d7a568d2fd922a8777476ce9a546c216884bbdab6088cf364892aedc2779b5cb603732557cba91740ee778619141e10c3be4b74322a13ce335cb4ec4de654a997a2c708ad7711339a2354d9ccb35ec13e63db6836b55fcccc33c968651ae3890a36fbad961096e68588ed0a8a9e3cab6cbd53f3ea28506acdeb77883fcc858c8c40d3cda741acbb01700180ec0dd26760b44f0bc0bd83e89b151df54cc32cc96b1759738ba6be84ebff2caa036e50ecc7c6564eaad26c1d009104ebe30ebb904506bcf96ec97a367fe31b6ab49a48f90e2c8dd8ab238ba21d74754650acd9ea258bb98e5742419e385a6ca44d91d0978904e3506940d2cf803e507f8f42ec3a2969f40b3cfacabc08121c40a1f0418f253828b12a2fc9a4b03d32a455c95fc3e4c368fb693c82deea29dc21e6090a00509408c86b5616dc14a110e617e76f1bb5026a6607d52c18d43b70a7029412634d099e6d4baa68b85ba9e560463aab7d37de4342ff9d60ea96252e6a03065c11ca9055f0fa9da803b4b5c715096d14e0b01335261d9d4b4a91a80c5248f6e5e7f470ab9ca5454de84ade83058981c18372e994a7b3bc5c7e56be91df252d68e5ce2562e74fc7a1bc0db3e61944089b54a648539c6c283be32951dbd534c595743d96c930a2a1b66f6131431c3c9511c5ed3c73f062069be485da5c95a11017b5e465c3dc26d1b72d35d9854c66bc02514d07939d4aaf9204f849f0a7f963db13c915f9560231078e23948e4e89de1701cb327dc507a9ba9e5725f24e92c1498fb974523116c6807d5bd5239eb3073860564243ba3b47d189a0b7644d5a91d2e93a4806dee9abf864544000da39edea09a66176b057b08efd89475f50bc51dc52bd62d9dfb2a5d6ee4a98f4ebb491b375d41e92350fc48da353fc3fba69c767648d35c0bb414db359fbcbc091c68b05abb612a5e5ed0316464eaf88422622ddcd8b4972cdcba8dbecb6389cc39112b1ff607778e337e3c9c2c716f7b15017304104a3254f9a155e50740c7ab90a3809d9461d2cf02a0a1f6c0182cfc49c5ad19e163b59187eabd0833bfa074b54b4da45bdf57f00aefdbc5377502d38ab15264765d28d5a10c48760b41d5b5caa55ec2f261f9eb3fa608ec55796e041c790bca3256d305d8b2c3469ab579289b7d3ae2effcfd1d23f2a2dcadbce47a9c7226a02605c8998a80eebad161b06a3bd23f5107be6e0e11b56612e44acb767dcf468e08978eafffc4abe39518c9323f470ca4f9f159f90ae94ebb1d2b83134eb268fb6ffe5ad2265c46cc94d79e8b3bcf244edf3788280e14799b629f483032a88eb1738b67fde099da7ed6658a41f7b2ad29ed013a160e3046efb77eb87918b6fcad04ef39370c60478f1886644344af89b2cdce382057b3c8398f6303c71bbfe56a1f4a77b48416d66acde40ccfb51ff6c8b52559822231721a03046e8d2da85e22230d07c7e9380962b38fb3ca1402a415c0d22f9f1aca330a66dc0e4d4edc80b49a81ef25cf1352ee0d227de3a8f269f9462f8fcde4da5a0fc49705247a2c199b2448e1f2dcd8d3dfb4e56e0e9502e769445e2740a461c28b1d774d6ca5bd3e92a95690d95fb5e2e73efa08250a0cdee977a253a443b3b983ca68d6e5badefb878f65dd0b905ecd52cfcf83cb5228f4264d605ac049efa622883b121e08cddef10a4726b8e1ee5be4f49539d63daf3944173aae5a097bc34f68f5694d5f32f914659c2b82463374614153ccd1e4f8c1a3bbe4fcebdc46e53cc0f20f86cbca6dd783662466b5021ef5b6becf988472846032d2d90a5b7b209dd91e35b59dc9ad19150c74e31138e6e94766b0fd4437668e83d0dc755b98103a1503a844b704b94cb7bc7fd3cc6b4e628ac0f1280e465788b159199911ee7ec7554d4bf11bd7de8806f2483dd6ccf70223b46a6767003c10686b69609dee6f92e28d4e50dd43f065dcf928e2d4c881da8c44939f7c5cea0d602377215572b167f8bf6fdb464b7a8b17d3b9fe1dbe590b5cb0b03ce2cd5d4e60ab5181de93164192842f063cd024c75385b47b2f342d2c88ab0138ab9301ea5abb500ed63a047403b3d25a96ae6129f43dd32b8913901e239dcb16dcafe0ee0889217e5845ba67b2b5eb2f1fa4f83c02a38298609739b3990cb537192bb0a4d7e89495ac498359fb9541bf4787f6025682353bcb3b36511c93864e342ef92c056e41b1e16a89209dbca7954c76d6fb50d1030dfada04d8bbb544f45f3362e14e3e6f3003811697223eb387da83034a6943540166834eea60cdf752a2391b779c2e9ccfa3081064199f3c089c1a040ac88ba452a67a207707362d2d45068ad5359ef6c1f5d1443be79203f1cc3b80fbe6ae55fb98c81bf7a402fff7236a6e01aec8ae5307c4dcef1bbc112ff5b973f538d909f41108cd698af5750bdca2a4c7e52ca6ecb7423078b7982f953a94502feef3cec5fc31dae7d0d9d7b6e88f9d520e24f282029518645304a537537baf418e01d020ac9a50e230c13ed5a72d4c042807c23a563ca124e30b6133028a0d1b1ec72d4d05419793bacbf9f3cfbf6f751114419bcc2dc3a1d993a32afc1ddc6f952e4836638f663dea4d912eae4990c125b1c02da98909d8e35077b39138ee37e31d3b5c027b562166207cd0c9db5380e5ac5ea7f333592a19ead80ccc576ad8a73c995722fe019784e43907a0f10e84d4bd2f855bacaa7b6078b06cbaca87a638bf3559144d1c2246f2abb597c674825c9a4f3e51ae0104b9fc9721b66079a1e170d9b28c88d2a1fe6d4034da655c760b82de6a74bd8d64b70a47cd8acc4b23bd8d244527140cabc326a3d60adb79ac6d685c2301e027367954a2faf4d10965f3afed1fbbbe3c4c74df1611130c3f4b4b205530aca9b0313ea4ee0ab2d33c84fb7eeb06af6b695529ecf84bc812fd121520e7d06cd4d3b1d24c95653cdfcf4a63d0ec2af487caddee6c34c43bff55885cc0cee3c79d4d57dab33843a3645e394d7612de83142bf0e61effa9924d07b2e22745cb13eff677062427eed9317080a2ab091fd9576b8e29dd0abd78a4b372e9b0071742af5faea816202669bc559eff3b96be9343f35d45cc832252b5b9f45cabcc1203d15ef082f2e71d62581281f9ed5d58234572a76c14ab1c2ae60cf223ce5e89f539f61cbf6df9a9dfa4337c2b585a96052e1c8e600cfd9d46020d242ee547646fd7103d4588cc3baa1aabb71f2bd8d34457fed1d685a39db00f25aa32d6c7472fb758d62700b3125849fe86d71eabda2a5c41fd40d8921a393930fb795c9ad8a46e18116d741ce8cde51dcc3e59c91166633e13b8c51dd72f48a6c224fe647f7b14473ca76fe438a437b9a3902735b30fe05721c420d1ed3d7e4b5057d81c3265ec6c693f884ebf86215b621876f7c6ffc8aeda94c1bca41c336b71a76ab5aa433c2fa31d1bed968cb55f0e518426132a8bd6335c243f9330d1a30a4a4edbeb36901a0c9a7757e4d553e1fbf122029cd12776387ef5e0d44594f765a9923b1fab1efbef9ec2610b15bb58c4189d285fe8fa4a2ecda98e2e01bf14d6d5e842fe66dbde7e1c5e787f7171e55bdb897dade52f09b99c3642c724b839ff202a8024ca6c7c48aa14644db06fe0a090cbe8a1ff3dd3e58a18c331b90aa89c32fa7aeb385b5b233175ff260c0c261dbffab76716304465db9599fc0422cd5f1e3a6bb9bd7435ee7c669d3fd857d10fd76951290e0af3c950d049ad5ef736c69f5f37d6eac919aff946660cf295008f2567a510a4acea132cb7b0b652919b8308acaf912d9f4460da2a2ccc8de3d82d44a5959811b53e45f90457095ea61b22ae041fe5a70ab36fcc93d3e2eec8c0ef7de0b9187d30f0658ac524a36b24a7da1d8d72265e3e3ec8b9e89daa3907609c8447483f9b8b30be2d1028f91506319300d73898100fdd85fd28d4aaa0a22db8e72c3ab63677e0631a6dbf3fc7e647fb93ad8638a20faa68f55d2dcf2e4cc338f8f02b3f841b327060c4f2e3563c321beaa16e5cf9d18ae57e979e962df6d9b365d4854a79cc5f3ca2954c0bad50c684749d8498703db7825f6eac2c74932ceee8b62e129b2e0fbba549353a13e187bc3c2bf1a0d79d542677bed4fcc8d07acab0f2f457d4a21c4fdf1318c55505fa2b8f76d7eb3de3f0512e76c40105e54c369e0ab1005e03835f762fef08d9b2cde3b7898604131b6e80d13262803e8987574c6c23f3ff99745a2c08c606ab1480e9870cc9cb1b5afaac365ffe386bd31e2b1fcfa2c7831be37b1c75874780651e205680ee94a8248f59a964c5835685f7c73db2a538e9a93e22d2db898194427c4edc5dd44d736616fa6c6b74202e783aec3e6d0a0d29b4718e51bf2aa6b439358ee710fffd12f1b14730b9740cbe8f9c3ae1e1bf40856c1fa9a49f36f14b4ec44388895939411337dab8b74570782c77129a186733382af79ceb8de3ae52c490a4f1cd115639eea0d13ef05a79a59302257bf2452cb540bb9d857563c53eab56913329710cd571a697206e40313d8eb51f85e5c7553d5c3ac206fc8cbca758c518359f7b60c0b4272b333df29bbe52d8c97a047776dee7ad84ee3afcde47129bbdbc9ebd70839631c547bede961e321861d3f32d32ad14004c73afd6b1f3bbbee6a5bcca662f855a3a6e9395ce85006fd4663336feeb0313375557e6a01cfec57a152c28ca103057bfa9a694b926e9a47da66a0b3d0477631fed3e8933425df860b51cf72a827f27ea33fa5a06091dbe0a7427664da74a8501e315ec7cc76a16dd8a545e9c24fb487fd94165","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
