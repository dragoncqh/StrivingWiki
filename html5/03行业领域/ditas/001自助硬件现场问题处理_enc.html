<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5dd4174c72735939cda5de766d1e19418b5b48d9facff6956f4f1ecf5dd5ba809bbbf4259826a9ac39025425ea574d2a96390293471e137cbde6ad466b3d09ab3d5dcb8ef97c968091da9a0933c0a6e2adff11a1cf93e60a928f574300c7561df7459d9d11f88a42a84a8c4da35413846ac7f378fd35d9d52748ba1cedcf6a2da9368af5535977ddd58e4cc319b93b9b3f856e4467fd9684f141196ec6d945c4b3f334b5632a16bbdf97bebb3a084b80c59e880a5e0a1d5ccd375aad80647e849234ad94b7f10d4d1ecb404c812106b477f13bcb341e09f933cb120c6bca4764c2183657ee1a659efe68106674be0849546fc890d36482e7b0ac08b15e854c16e7a55dc0978424589b9bcb5b86a1642cd88df5234a7f422517a2009ca93977d3dcbd432185b6db760bd25cc20e439773fe2fdaf1edb6158458e511e213c8f6689c6fb110ee753d1901859c9afcbb2162d7350d1491346cc5860bc8ade414574b30b3431106e7131d443e4f6f7bdad883c01929795698c9e5d2ce910b4570e4735578ed0cc7b90a239f108657840322e3d73a81f6869886684a458e8751c7ee1fe85eb81218c024af2c6736ab0d9b2e6537c1e0f5782d51f8cce54a027cb83e27919ddf43b1ccfdfccf4b4d80eea1ab5fb46e943b98808f59e0e38bf99ad6aae4d0056560691356918c4c91ce7f1993a2662546ff9884195f87727dac942423f07db4f20d043534b91cc145a663c51cebbb9f81e481bf6f5c64610c76f7d45f60a706ec10ca7f391f5567c4f9918ca6f043b4c99bfdf4c055ae556e85564b1059c128b9141db682a0ffd8284c1c896d7589d9f63c95278c41dcea5bb8fc36d4d403b8a27e24a5bb29a0f6985e3bcd8416161def1f7ba55a1b250246923d8d044a3cb3bb3e1a728d6273e2c61c8d1a012177ec031384a865a90165186999cd536eaa492842846f9b386430fa061cd5f9c1232e8d17be5836be6f4c93258cbd0406ae88cee56102a4c7678cb969e08c65a580b0776623125b074c5d6350b71595355e69505c8fdc7294356cb6ea9e6d70f88c557cc5b6dc9897f60e5ad2945be8b0d8aea84bddedebeabdc95e6efc26644955800d65c857f24b16ea0505811cd37ec5f90db384908f1a2cb72ac5700177b932a2fc2ad1f220974d70d63b52013a5d6bb10395fe0db3c5133bd6b29bddc8c68526d184bcae80890e8749af300c6be76d284572c6ea720816723e4254838d093d1aa70aac277f3bac114c2c04f5e4c1c42cae0bfe409ed28e91721dd8a1a0826803130256807e555ab0518b8bfc6d0a8394f0df8af1a21c17a78342643f566960e0a6e2da69d449934929dfa4d6d6e6b27e6e5c041e4e9f027214adc9ddcfb2ba3f0e61c8bfd10ee1ee0553a4868af7139e869cf79fbac236d3eb84952880b0f2815cd327f2c5b3be62ae1160795a29382dc45bc86ac4ad884e58f101be7f1e558558d88d5c73101d62c919d956f68d97f2e1cfc06bf120f76ba1cf3d893e4ba76a01c98fef2bf88fc8400f5d91bab38a4d8a40aab81df358a6e0743f12762f8223b919b21ff69583c10d234ef99a4b5e079b64388d1c587cc7e20121f5bf3786a759c92e5ba859e24a0d8b8abc3e2fb30f8b6a500a07fb8ca53e1491c9e3a94043ec896461bb699100c115a9c116599e81928fc7359f37f8bdb5b24bf842f5988581a3c1cc299de461104c29ba197c374bdcac5119ffcfe142dc161b04b6e8c746eb97fdb585ee02df3e37502861d576fa83941551cc773bb22d9ca73f77a8585fe0601fe2caabe3bcbb30264bf720b92ee1f866109adbff4b028d26ae11d32297d349ce10d248e25e21ea6638647e5ebef6ca1c7ddfdc2e7ee425552ee2bf3f63fb15669f3d6ab2d3df1f46e3ca786d8cf34aa3171add4b1c2994daa5474ae7a4f4a5c48aedae6be1c87f3ea93fc4c4ffae27bc4c8a82428be3f51f02d720d94e7f776e3deb18281e66ded9172b79f3f565e23ba090dc9df5ae4427e6a0a2358f1ccc87d0544ee39f1b3c6404332ee53877e26438a33781d6129cae2e13becc7dd436b29038342b6b9af233a6a8e229d05b9bc320814dbc512649c197fba539e9564a7f7066b22a893977d98240072c56807bf5e606877e8a76428ead52442e50efd8bcbc50075cca39eedd0eb6755c4db0a6ebad936d4692d3b0b04378ae8753ac4182521b133fd9a5af3c444ee4e9703a0fe8ed0fe4c0687fe13f2346f6986f9b27c8c77862f779f39d421de390d5ceb0570cf5c6a9e257a78a714247a9814f020f3032337da84908e8f709c0bd133ee4889db3a1dc0f19cbd039eda14ff0ce1e7b79b05e7ae4ad47444017653e67dbda1f9ec91036191370d4eaee2a7ff8458866f0b40f59a68e71600eaaa06002f94bb06fb4b57a670c6468ba84403989d5e707794ff35a20e4adf549afe668c27d36fb61da3f9aaf4885ba8973eb03407ebc402a961bb522fd5446069e75cfeace0b006e49df317ee888e8be66066c4c42a1e2313c5f17a07e9619f5d3252caadad36ce8e745a9acd474288856e274ce6e06aa2eda8d2ae57f9db88e722d97f1e151da2539faa1b16ae2ece8f5b4a0210973f3a18a12681f184d9f35ea3d687953b006b42049e881806f60a9af7e477a0e7e04447d619986d7678f7dfc30206a8d439669f1ce9e706b4ac17dbbecc3b8f0e59a45270a6676b0dfde9442660b8e95ebf626c8b85f2fcdda1e33a5fd6b2e62e6086c62b4ec945ba7d82abd036d5e12faa03fde29eb43fcc406f25808582c46a3d629067caf4fd87756bc3026fb50913ec8d916eaebe3354979fc09bca8a9c118c347535cbb9a7c4116738dfbf3e3b5d6fbcd36432524ff26b5d503adbca5a9aee0e486477ec720c4f26580bcb01adbdc4a9bc54b14337849f2f1ae75b5845f97ca939d3b654d6189c23e128ddcccc78db63d968a1048ea14e6c1dc10c3d8d070f59fb13fe770f2ba53f5cc79f280647f2fddf8a9626f19162223c11db39eaab53a622eb093bff72b3ac8f71ffb796602f6c11a2154329ee7231066b69bb05d163d1cb9b554b0df084edbc46021cc846245550e50dab396159d588324fc1e002fcb61214e22c065d8693331da1f17e82f6498c01efaf84625c168b15a6de423a827ee14549badb3b6aa8f4c0d9366624f1dba4ca032e2b39e2b5e7ed6b63af8a75e4e10f165f2dc82e3a9634a7c3789a35000ef95c22b9b80947c587c1b244b30787d95b1d13be6f7d615e2ef534a29ac4f4273a4f6526bc7805a7a48b951d55ae431e4186360fd77d35873329b5f68cf3b31043498a58d48b35bdd06d3810ad27e6617ee0c2bae17052f62665cef1c0c8dbe90f52dcc0af36fb8733806f1bab6aa206f3854c4038b5fa7ebe8269f750a360dc011b5ded6df951b137ebd97c26a58cdde6e77d57ce784f4075cf1688225d6e9fbb19e9528310a867cf5385e37dcee8b3accd8e23dad3199bdf8a85be5f645e8e706bba33461adb720265a09140f974a25f641cf09a3cfcf16b6e563695592355dc52df7aff7a962b9c38d95a2ce850e83346206c44432241466c1a46af3e13c1764dbbe0dbd465da38330bf28b3e259dc6c90f2e847f3c893a8caa957202547d83fa04c8c82cb9d7a27f82db59646ecb3fed4bce64fa7fc81e8f90ac8c4f232344f0dfd8952a0e10fdf5a87eeea7b21740aee88f31df8001ef8f2eb0ae717097c754efb0409f227b27516d6a44396fb0fea5e11b0d444483b56b171048d8a580e8d45d328ed866e9a3dc8271f9bdd5644484292d4819cb07d4451846b68cc56ba41ca64dd49a7aa90d098e7d042615d6653448e145f4e17dc7b3ae426996a4c63ffdab239c53a23d5ce83f45ff96f5301b30aa2d858b82fdb79cb2e9d334f73e3318af8a236f9dcb7088c9abacb3352b60b124f821652709824c5454a145f0ce3aa7b14e7bca796072c297c113d907b158a61410ba8425705372c5c63f75a839ed601e55332aa59057fb3511141ec43233203c87f9154e81a1ba674db203742a975acd22431d4895da282dff9e9dcfc4d35289b908b3806056b72da285619b754acdf2ad5b92b5aa402920356fdceb546f988e99292066083de362c7778fc93fb6e58fdc5eb67a8c20f5a3a6d7b2a867f763db5d4b6193674a2787c031050aed19ebdacedee61456aafcd01de3cea871574c5b9593d5cbf546573d040d7d6802fd758a24c475ad1b2053072182b9d4d4df52c81e0d682c24e6f47cc89752caba35ae9fdba67d9789a68cd6c88e8027a87bf9729d3e28cb01994a26369d942bab2110c05a52c18e7a429d2d2177a4b8cd11e8986d7089c04d8f7b0425b6a535760aa165a9c3141a57304c8a07f74a63d9bb845c8d88c75908728114e616f15eeba5971e23f0bc43be3fdab4de67d4c49d7d39261a9f0d821e8ee7f25e9e80650a85de3516c89029f6afaf37fbc4a0136a15f89748f6e3f726454d75baa14cb6d043bed8f04b25c6d2453e7a9de4dd97422117fe874e51874c6e197051f3357ab2788f8d9886ac773a36d75ecb09018b94cc39a4044bca1f583e9882b9b8fb72a224b63359774b012cdb5cafa5fe84ed63447cc37082dfa1780b42aa3475e8285d7d1043ad671bfd06721ef78803d176c3863b20cd7c7051cfec67d301cc9c9dc33ce75aa6d1542eb409406ab755e4197ef9dd61e84d09fb8ae62ea913eded48c9d8503f6d6b1c2627e8be206d25974359183ff9f153de553947b67720878d3e1aa82623ccb74f0087530b8d489e54c3030314d094492102826ae4a2497fa64747de499a260c5c71664c334885a7d180ab0b76cdcb50bead4462ea8f85bcb2420ee4d399309fa272743f53fba8a6e4247d213c68eef51eaaa3b60a6dc8afe6e8c8df774266f462be3c431e6931665f268c99917a9d7c227515d2491ddcd79ea5a980f646cd6d46518c1c500270d8b0972e4734d2ee23ae37831df09f0ac5eac73aa748de84313ef00ffb66a0d4d58328d8dadb304ac10a477c32134ebbd95f034dcad8a1e1da5a403ddce34ba33add726f7ed2a567d33c48f37ded48f0eea8348788d92f3c5f3d39eed5029dcd66b4e7d08eba2eacfb6ea588882c5c86b918bf019004c6393b9a32367da0ee8dd06a549ffc844d33ba43ef32217a95ba3b81bb80cf0e0ac298fcc3b5630d21deb30b699a59814921d6a58ff592744fb4a5c99b537b83a1031a914eb806874fcd781b5b574b530c792f7738eefcfeac409f5aecd4435b17842b3b9c4298b49b6d21947b64aa4590aa5fe3b1b48947b500b1972714c383530081f3bfc05878c66f630bc52b65a985c186d882adb7b344ccc5973ed843c462a213033c3713b201947ad58b2e4fec45eddc070d83ce3da3b487644e9de1e5eded290362e22aeff0417a44f914b916025ce49c2757bea4c8040113f535be1ecadb91698fed9f060d947a1ade77c00870955649db24bfee8c1f361ad4e0f09acdc862398e7ea7b5315ef230d2a50c086e6a1324b09e5cdb9568323c2ca37ee8e44581f02067acb93b7d2781c30ffa714fe1c88da8ba8ddbd6ad277cca58f9a10b8cbb35e9b019550edc64bc105a4c92f33651542ee4c3a6edd6ba176e8c2cbc9b41c6c9dcaaba5afb493a12dde8fa9ab1da6757d608489e85a81ed5ce5cedd1512f9ef7be70970cd3f5529ab2cc32d45e311bb49918326a0be056ceff7eac1caf62680a4c562c88a57d89e57d2d1c9c3bfff53dd843fd9337ded1cd94c73f64c78e70fa6d584494a61efafb2317da3703620ee561bcbcdacd63e6b67eafb5dccb48156df9a8e4b8d81b8eeb673113bcc4616d64b1d03181dfc32937671d17cbea659ea2ca2e0189da57ac8011ccfd2b8e7256fc1313507ebc899fbc0136d64d1abb61e1b3c0a1479408eace212acb5a648a09bd449052dcb18f268cc256d7f13eb57e50e27ef174c57f73733b2c1e00b3a686c407daee8f51b58b4a06e300c8984d0eb65cd7ca9056f751a13e342023a68d849f9831f4a9d5c1ffea4fe6c21f4b1959e3ed070851074f75e5b133a5d1e4562ef840dfb220b41ae6ee6fcaa7a644fe75e334c7024f90f52dc38e80e711e8e8ba5c859519b647895050cf456fac07fdfacd6a10457eb80b6f2f280d4bb5bf0047a84a63ef180bb4d4c6607bc77e9d1a740baa6f72d2b421d408c9d7fa7feb974a0b174d786ce85620eaa42a20b2f64420e79f31ee7e80d87ba971ef8320e1d6a5561858b0a164810ba43c655f37b732aaf1ccbdc8d79207f3a72c2c4067e2029ff31e35c5b40ee25ca9accb6b2a9e245ba78e8f3b75243f5a0ce06bdd99920e3fbe77aa690f7145602621462dfaf09f5470b43c2bfcd167bea1700366d5ec13aac436dc782e0f0790377b8fbaf80ad7c7e48e0ce5cb25668be06f01dd1b2ca4ee89f0ebe6a3ec811f9cfce94aba75d32e2ed7bba67883e908222479a728afae08fe52b3a03732e3dc966850801694e2b4cbd3b08d56474e0227dfd8e9cd5e3a530a3bd1cf696","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
