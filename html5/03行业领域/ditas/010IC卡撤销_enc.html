<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d54a3657128813d5b6d13e18fcaa2135d64d14cc3c35d4ba136279e587f01c72217b00d3eb5c57fe328f52c1e687f785226d9e305105a4690398910387190b2bc4bf440d5da55413dee697035a07d8e869fd9faa1ba7870f147c808dece67a74f31cc2b411468a0682c80e9b998b15cff287da102cf0ceaf723b17ebdf64217270310ceb2734b40ddafc10a156a9fceac1d6ec9d0b30320ad41a980fda3d0cc8d360e9b7ab225be7d9a470c4ec4b24fe4b055cbed6db681c7c96cd7aad51bbb269390627e0b90ef38d071150b6b3803c340e1a4cdcd4ea529a55986e4db0fdc7283a8ce8d63b87191a134382ad4df7f5d29c6f0613fc467a0e9cf9eb3255bb43f9be452c823f09374e2276e616ffd43b771f0c4301aa03b4a83901952fe5667dc7cd4f63c4ba2122aca265a11b509166c33c219b8f2c370469bf70339c04f3c6a48fa3a7e521be61157d5ed3bd12281959972bee6034212b91181fe06dc3a95c234f246e64632d4c30b645b87ef0f10354adece8b73a0d5ac3843d62df21c3b243ec53688c5b6a6ff8abe90c7f0ecf592b0d4dd457ff86271b503f2a26d53d156583f0f5c20e536bc7fa717e893e85d5826036dfcff22951db91f0958b3915f0a2de8ebca891bcef712c8c201f34a68918f73de8539f2b614f0bed200b1a5bcec1e0a83eda94477ce9c61d17fae17495eb5e9e07e69c906c27d9749f78e5cb65a02dc3c8535ad74de3617f09ae14f191ab42f65f81bb33bf12f63e11f2b54a8ad15e1604176677925a73e0a236ad0210b2b8e61f4662545316ea30299a4962a4ef39476dda21a58a094406b1656021e52a2ee8c8f4571cbbb1c8878edebf5ad407ea4947ca9451236fa34bd669d267c5a6035a7215507c75f6a37505d784f43104ba90da817fb2708606b7657023a0928df7fcf76b91fd940d99f0ef44d202af05fbc3d9530109d0d2e3eefc38f26406561872a235c9db0f99ccff973cfb7b20a1cd6238301713ae109a9b7e0acfebb1390d777ab48b1d138e4fde119c1ee992f9951af46b270e43946cc49dd7b2e6cdd5d0f765e634462cc77ac254a146e42d1a953676bcbeb03e722818f334ec6960736030e536318a17859a14a17c58632f21e395e2c29331d6c4d766b52304ed967c4fe15f3e49ca392380f2afe7ef2b43e627a8cd119720ed74297de51dae6ff3ad24d7d264546c1bdd4ce6add81436ee34dd293d80366bb3b603d352033786ffd74b60f1708856ca6cd1f8a4881a9262d365458c423b27fa1a9210aaf56969ba0bd7441c6f7d2991ce1d056463a2b50530df876890a9a5f83dd425e1a7dbceb4114a51b8a9981c3079845865196855937837883e62bce04ec8a5b9ba35acdc6bac639230194adbd3cce0b6af9a413556383f1ffcbace5cb463392fba958553e8e4b402c478feea2a3d851553208c92d1476b803779507d12a096b8ef85f689561a29e8188cabe4bc80916637eba2d98845acf5af0e4129a05777765250b93f840dc8589181168b4737f5d7ea456179d67570d973e3edde90114d15b524cfb088fade566ddf858fd0fef856b2cd627b5f0093cad8fc8e8583fb417d6baff6a13dad4687dc6887cdd666bf9fb61b272c391df71aebbc7262281f4eb797995338f85f1f3f4edc302f917b1c93134a78049a8cb93e6f719af7d573ee6b3f62354e91281f014edc358c33853c28b1f2a3870d1517c7133d5b3882f287f368d0183ff79c2f760c7f2b932953ed70ebe939759eedec2a6d620587f03a10f27be0cddad6076c83bd9b522c16c872ccab3f1fb0367a98901eb30aa1b06c30e5a89624bceac42bf395f380b45d1eb763e1310ab45b518ba55cb842d1ef5c62dc620751d513790f0de5b1996eea7a74696036aa0d41008cbdb9f476f850eb75028d871ad496799008d58d904194f8ea52aaa06d3d8c4414cb598ec3c348ecfffff0abda86ad314d1cee44c37342b5f8b517f5763b18f97f99afae8feffbf37405dcbf7ae031b3fb8c0c0da0cd90408e1ab1de8e1327b44518fd829fc7721837a532ede1d92caa9bf3c09d9f11b822066ba913161ad904dac7284c2ddc26ce910d8b1506a5f394572e44966e9d6fa3f37a5b6edda530ca272377b02fb2ce956988e8f3450962dbaddf991186f29241173caed5d6790af8e15f725ee543eedcc8ea730357c1e1bd68016858f9b788c6fdbabc558358c7287a4323840bf5403921167b2f52b511e2ab3a8e756e63d7cea6f9a77a7b6d31b23d18870eb39fefae7214b22b17b933e2b524ce9bf0ed0e8805ed984e6ee4bd70ef9c27708ca8c5befea0bddb1da9e0d8025eddaa8455d6b09be4749ae2a9fbfb77eead4f7d8b8a3e025ab673a5f0791da24f310462098802e1d9d48bc858b86df44e0ef2bf9c8d4095337653112a8b2a777fda38cc33c38eb23647a74bd3cbd8b2799f6e49c3a985489736e9ce32da9456ce84c675566d1d1e51142b010872f3136a5eeffea00c465f4385b54133c458d4eb707f9314d6595e8c345cc267e89b61527a490f53032fc4ffb1b09f02ab9b48b3b9ec5544b6eafc12c20e23670319d6222ba69b9c3f515b6de5acb2da6ed7f9bd7a72238ade8c873fea30e4328612daad865788413b13d31ce8dfb37b6a47b94113a21eb7f8408bf4698239447bf819b26cbe5692ab053e33271277f2d8f405b4e6b9b6c96142f1724a4207cad91190efba4c4114a7681c59b24f2826461c2b1dac53797ea56878b71473f20c432f5472974882cf7d77961df66b959247d88063d8467e79f38ff47bdf1b91e853332bdf4c901df786a12d811e0f7deb5a93d9fecd0b4cfb322170b653cc2d85d6415d9e889237677d11482ac6d3f8e683f8f3b10f6d5ad48e5f5c2a4fb69f58e33e6e85314f3e4bbcad18f0e0b2b41542518a7b75ddff9f8f47394da8e1a58c44fc66046c99671d05975020a53eb0f99e4bc7155ae537647972a79b6c03b8d1014dbb54a8b27e8bd2c7dc43a2f1a7987630794a54a044c31b27b64d7c27c1da436e6fcbb0255f4aab3bea3a3ab3cd8cd758f0f798e742b521bfcb938ce73f2aabae02db0702606c9afe4a3eaa0e0574ed2e3ea5387b92cd5476761ecd143eff7f736473c5d888e295c72a2061054a69451c78944e2813594c386d912f48b7f227ab6ad3b6d1b31139f7315d942301aa954312289e9e236c5201311178ba3d5dfc43de8e50b43cb23a9b24618b5ee5b3dc934e1f3d16059c3e99fd5aa361cfa990936af50907bae72701236f18f357f3a23d690a3bcb3f31e7febff815c89ed960f6c0ca3300a3bc6863338a1a492fe0c2a77e70bffe3c7748cc1636be417ab41a39f12323857441b6754f968cbe5402518f1e06f9e7772f749e8173095604b40b987064a12f1dd53a17a014450a284a3f9b1165da0a3403c661ce5936e14e9a93a794f80a0cfaaade5f52a99621210c90f66b65bafbe59fcdb903cf7ad11763c1533c69515f8e902705cb6c1cd8f337582dc3662f9342aec4c3f50e5a224b0b37c22d865987a28b753e53d9b01cbdb88426a5aed474f26f2f7ad770c7393cd9f0f1596b138994608e3d08f7b4e93dd32f626af8ae96737527d56b7bd38876d8dcc4037477e3cb7c99714d4c33047e7a4aa82023b6f2bb343c088fb029d63ebc838d8d13c4c906dec7dd9c26547978c2c64a4d024ee025a900338ae0498629bc96c1f14e9c380eb424b26138963c019acd5ee96ffdb56d72a4de1e6c9f022ed6530f4cea3ebe3c0cfe4752eee41c883cefe51f5a740fafd9b2d202ce64037f0cbee7fc74d26ca557b2ff2257e3eb077962c5a2e113cc84084521e2a8fb43a8bfa0282e069ed7b08cc453f302edd6f70084909cf14402fa020f531eab94002af86bd6d3f6ef8720a1081f6261194bca229c9811bf64feb08813c15668b3cef9645f9332a65f49e6b03dfa9305460ed7e0fada1c58d875ede96a293d0a72fe06f86313743b4a8807d56da0fb94ea296b1238ca6250675cddbc439e6ac4809f8afcb2ccb5bb7319aa42181369340946d8a4fe45e20140f19bd427a424ae782ee09d7ee1c7b34125e5d60ff0140c936bdf72335dcc70ab4975f0271394b5419d02175e27d197dfd7f411168d7f140b3879368e0257db4fd0cbbfc542ae5c12fd8aad40d8e35fe4d2b9a4c73ff355a9e3e41813e165a90f2b7253342122014626c5ea5dbaf58cf6b3e5b0af38b9ef0adc8c38f30fa618002b77f712feae7c473bd972c915fc27e2e8a7fd5c4ae31ce8879a4d10f9e23fa494c5a7b926dff1ede3203a6732d34935340fd9e66131de56283612690b361955828bcea318dbf222a1a9acbc9006080158972149e42b152947df99d9223473d9548b1f84e73cea0831585f1ce2d53b53574cbcdfde033b4e2de4a424c3e5cdfd0102eac05d5d27cd03e1dfb69d8ca5124b1da6ca47869160534c95a6d40a6228c5b59dee8b82ddba2b531dc686bbd4fe357ec68b749352ed5a8e4247ffe8486da16e66af1f4be97ea10a96c72681bbca70f14cd317851d611ddd6b71a1020241553dd9f9b304d31be093d9db2e5631611a1d6cb5a459e1a6ddabb878fc7d7efff8af23de503557e8c136584787d8d5b908fa464355085865e746a0dd14e96ae335960b61e310044ccbcb276e1b43f54b71a6355d6b48dbab82e1c9b3a59e651f1c0590a461a93bb93bab330c4f039660b5a1595139481dfb4888cd45fe90e3f1c28ccf54b413a1f753a7d02b8c8dc2e944292ffeba6d17a8a71a34fb0672c1771face45a1745fd430adbfe9753ce2c8b568039819ea91955f032a679beb4e25da48c56600296b9c51ed3345b89a263822825f9dd621aa15cb92b08a994dd33b52a8edd4a67fd885e8b4ad980ee8d265afc109b0b46a2babbb931dd2ea711a64db0a5d3d186162481435a71f288e0ba62521806f1f8ac2b065bfd33aecf35e2b78a998e9819f6697e7395492f776cd1e0b84424286f0ac6e5688516c50b5dbd128ccdfa97d966ea2afa2bec52e8183efc3e28ce3f53183c2815c1d3ca2bde84dd617a3c56d0cc10a1f65158465cb8347a53d731149e1b44f6c083c4758a34878250d1f13dab9b0b51b945a69f46d8ff24bb773ce622e657eefecacbb45bedf4d1b72e1949ba1130184ee9a9f0c352f0edc48df3853a5f0942145fa682c3c8853abbf694d528f2680cc4bc847d7b708b33f031afdd2b2d0af827550bd0d500bab8236fb8428672c153a368e90dff995cfea03297267a33f729509958160a3c6e0bf89287d1a5cf58b4e4a1671cf871b226c87eac23b2b2ab189c2ffdbe38d198964be4e08fc1cd7cf25d42ecacd8c0af84e93502eb195fd85759d49c61fcdfd8213d8ddfaa341cb902294b22123fd55fe738636c92c2c0ac9b66ee21c4a59c5713c5e998af3390951c3316144951eba60a2fdfd79bb7ff2aee236ab12506fd9da779c39247119334365c10bbab8b75403df0974b5b337b872b12db36a3b5f25a170b15c8acd453e1bb0a2d140a8a5920dfcd26b9f804b12492172e293577ede4de50363cb8b1da5c16ac40ac34f501c6e1173d6e3afc1133d14960d39c05de7ffd461f7f4acfca761e141f7581c0fb0451fba3232da1904a16f4311ae3ed30102422a4bf06390ebe182eb2b06317fe6f0feb69590f10243b45331ebb06282d59ff994581e7d79e33d75838b5818252d50959e77c0d4db9db7e27b7cd3f61697cc4f75f8ec114f02199c999c5bd252c59a09e9a38bc722c154629ca325689fdbd988059d0c6867cc2fa418a89ed0dc6432867543d6dc5dbbf8c0f1271f19ed434ee5db352ea97b1d7a466bb5f86886ea467d2a4d35f6b9f695050f0b5a0f0fe43bfee6179e76e9b5e378f4ef6f5cac8d2a4445217952befaa4d9bfa49546969794512cb1c36d6b8df5a346feb2f7ccd8712e40ff9a4a943a03e9afcd0051dfbb71ddd417cb520ce2caa10b07d44d54501ab468742e5ee65657397db8e2b4def02605b066b2ebe27b5e4e398206183532444489cca845e76afb50f8f12f4a8d1fec27b221473daddcbadcc309b0ad45467029ae0bd24be52d14e983a78b5b2395b4c4f841055d246a616e7d2f0f42dfd5b722fe5403408de6cf1e8f94a65837ad4a53aae539e38d5651f34c12f250332f6778b5133389c3208d3812119b3f8de443254a73a58e25d827f6daac08eebd49696dcb395467de05ae8b0ff2f1bb0341993e0a81fd2dd9f8771fff3109857421a0161dfd5820ab7a28a821cea01c7b222cc4acbf7f738b38288f59182faf16e520eaa9dde2630ed9df58896484de20c1bbdc6160ad0a7e2914b34ff6e37cce5cbee285137b22341d26324f58b2cb06e2214e0cedb343d8a54b4a5847f164ce5c145a2072bcde482f9b0cd04a272daf5b2d2a5310432a037a3e3b2f5c479bbf8673b802e9792de11892e8e02d0949818f7454a41cc1b0a3efe6c76d70fbe4da357623147f05eb4ecdb96fafaeaad708855346f271da7e968cc37830c048a863cb0680a7a84df8f720df43a3adf48425b01f2b282c652f2f471d5eb9d2761c345ffdadb07535276ae6179ddb91027027d9ed07709abf552df39502bfb7be56a16621b363c5ef62c8af85e1193d8bd250e5cf931fbdf7930661db6f6fa6199c015886c0fa6ae828bc287c6927981646c7e669a05ebee4ae996c291e5dc2e1f657171bc9fa795900768fb88086783ea810205ba6712ad85c89bda146a3cd1b74b23da043cdf124e2520123d031f94cbc96d4fee60edd6135dedc3aa8738ba444fb96b659fc8c4f64fffe0da68f80cbe2efeaf2aecbe6114ea46ea9018b1061c5530b6f5915d1c37c01af58daf10b133b49ca680de4c3761ef85fb87f98e4a393411f4960efec0b6618b62733e12f27998c31d06763f31bb67ba9f84c970f5f6340c0fdabbf742af810895b7339fb6e0e95576f3fb658d1ac1bfedbbbdf4da2e716f8ca4153b0fab38f003455cbba7b9499faf3f54c1ff4dec369178041b24b658bc16c9b2910acbccbccd7f040642b996db4e73abba7843aabea28a4944be73915513f74eea21aec5ddddfab40447859eb23e7b21fcbfecda1887b0ebd93f5dac594ab38a0c0745f535eea0627f53c382f4c6359946079ae0902a218e0cf31c664f05e65a09c8c252e3ad172da0dd9a9e4e2b1edd8fd93d425e5321614ea29cf4528ce264e09eccb46119021d5f2902365bfe06a9e3f2efdc782d19452d3db03a8d336533235d4f2f1a40b9b2cb90343cf87e5d3176856da0ba414e548c77e0581e997b6eaf54800fb5039c218aec1baf7658c21fe7810fe701413a995759365ce2da607052d6cfb28c3fae4fd1e5217245ea5a38990861738320495952842c89582f89c7d5dd1586cb0f228b93ae4ae11069aee3e45c08d387e57d23651123df83c6770463951ec3d97d3c8f60a8bf48629d60216320abe25e1c39f2c6facb5ff0d2a2e5f99852aa23ad47dd98071768f0e46ce2e800f89ee6042073d478412367bff2048d8b6f60802f1cc21fe49006f3d744bdf00114d7c366483383fb5b1eb630b968451a13aebb5bd12512d514fa44a30030ee6f2550f44157cb09c6a04c482709be2f041f510e0571ce545fbef3ea3dca4d65e7efd319e92c358b3393f72a25a67a95fa79a6ce4c195f6c071cc0a217460f83a5ae33fadd018e9e3e2d1e898703e0a2ea404d48faa18e45f97c0c785598a0e1ddd96b15c0f52db57205f1aaa39f6f3703a1766e69c90cc59caab2b9889d351dbe6b685633a7f08d92fc2744da516e7e6dcbb9c9194b98ef535327fc0a3ef33e6cd17bd2e2053725babcceee576e94976b153934f0e5deb4c36a90eefa3de73733616b49ba9de4ecb717c2bcbb5a935b1e21f2ded0eacf86efc062ea7a9dce02fbbaf42794257851a353862c1287728a875a2c5dfd075fd7b975bc9ad9faddd08a0adfae84e10cbf71e43f74b0db19670cab68208829b3aa9c367bdbda20d1e01870f9ac9bc5e3d9c8445da38c53f8fd9c838f342c151c0059ab91df50733a1ccf46180fd38f6f7c14ab0fcbf192719f442179a1d56024f034c7113a5593a85f9783297cdf36b6466683faddcf7920411f34631f6e8d73d80455e9c02370691e29c7d3ea469d59cc374fed060ccc854318e1e0d625f4a177f764fc254728d22ae3465f529300a10967ad884a7b4489b257cfa2198f7f90deec1d154404489c49c8a646c4f3445d7a00c930714bb85dbfc25e83c5562831aca4e998074ba5bcb37539a2bd4d7c1d009e4057164ed908f24c3d2e43ce7b12ba1ed43a861c4a1b6f17a5d752fb0524a4957e76a1c416370e507c47a4357461207e30e85e7ffcc50166b0b2ce4dcec4dffa11f479772597aa36f1bdf31b193dc2c335737367203efd3a5c5a551d06fdec8eeffc999f74a69b6c9ee8e10a89f785e6b4ad8bb7ba58450a94e29358f33274f237567a8eadf501a8e96958ca917fb6abb7e9d67c442dd6d9bf330e9bae16e2d2846f762ba7147ef39b58cc8e06ea684161c514e8daaf45d55cff8559efb50137733bb938d1c6e090aae256623e7e91baea76da19b24352316e2a4e794c7fcedebe36ae8d2b18a60f2d78adb933518a23f9e063b6238bf00e0ed72f5f3692959368939b0051ccbbdc67150969f68035317613c2b5cb3092ce74002c98f12b943d21cece884d1f43bf83e9e155a81edbe9f2bbabeb5b67d01a56d61abdd264a241c1fa8f7358de066aaae36f28d9f8574867b0836bad928f14814c11fe8862b717c31d6e201b2872cbbeaa890df5e8748f652c64a2495e98d9b04a4448d92d030756a5328b0d04f02a0999879d071596598d69fe8795fe31aa70fcdf8404c8b905ca5724b1420529757f22b68138870edabcd69866a7354857f3b7eed677ad66fe91d6a3b94eaaabfd04e9d0f6ca9eacb66f4f435998a0e1b153f4a78edd070348358abee1dd146dc5e178f89a8009be2540c1ea052e6894c3d3cf19aafacc240ae39048eb17fac80ac906d055094a439965625b748f8b2954d886f329bc8d82f103ce7c2e129df29cb52aa4f388c8bea79c6133a43ac9708b7be9d9ff80d37c4e55a5b3f700292175f22b832032675200489659c91a26c362cf2c37dd0f74eeeec73828af442ac64d2548991a0200fec56b1d24f4f27a1ca4064d8af124101a79c76b4a7cc928dcde7c39a7db6f410c973719a28709eae47f6383c1dc3a0a5a78b8534f3ce6c77cb53073d9f3af46c3cd771c3109387af11250cf185ba66e4945a205b64f2b69f15a62c3241e43dc43e1be166d81d5904bcc97d3afd795e6f2a0fa4bfdc75230538bb577a4ee4cdca36ce812277aa33ed3465c54309edde22d413f2a717fee223285d7bed0b1e1f035473ee9ecb2e70ac4d3e3ffcc64094a24fc0fc2e64d2150d8e1ac3bed5481b1a592d578514d39c97bdd3ca6588a996f1236416e88d9d67298b15ccd096786c85f545455a70f91455704ca68ae4dea7dea21c824a8b790cfab17f200a627c05610b65bf72dcbfaec099911935d0b80eb4dad5da133c2204d623fd7470e6d8aa677c82dc559f96e5d3924869c8575ecdb1a9b402a8ed83afdf0eaa8818892eaf22b663838637553087a21ed4671c61987bce1c55f0eebc4a6c4fd718eb017e1a39656881999377151b070747e21aa5716d0217708e4982f750d26c4eb9c84f2f17c4d93e831302e34124a33175e11815bc35e489b39beb5eb5c0692855ca64be811809bf46bbe58a13f1a154dba76693c7f69aff24c6fec06f7d02b17d8421f4a99bbcf191134f059710d38acf1ee86f579377d5c26c6292922b3806de80c7c5da96f3e3e133904e8060edfedff9212bec968b1c5ce30ac3b651fd8489ea4cdf318fa5ad634c6867a97edcfa38ff5a2d2b173b8bdfd69ccdf2c092b392fad84130bd008734074cce5890a3f50da0cb8403d889995ff863d9c548e9ac1ef5561e2333a455df18a845e588d84f55aa196493bdb7fe8e38dba01f08437b1f0dba0a5302b49000d7e2d5f5f46007ef40dfb8b2449b551305720a73febc6243b62585cccdf594a5c3d29c969c13a290ca1e10d61508cbffee0252f68e27eed6933adccf71c89c9c980427f2e3b8270ee34385c89bc7e9763392248c78ce4b0ef9d7f4bec2db8a71bcd1640187eafbd7c08c7f4a8130bea1b5e6bcd7bdc61e70d8e3e2119f0d9a5d2237e30c380ace4aeae5ae593033abc60b323b3f430e119a703ee64c71803949df2fcc0956b2c07cf0e99dd8d5ce1cd17489b30f1587cdef3ed2830b5fa15aafe64b703e3f749987b838fcc1eb9465336ecfa6f85a44c5761f003149f82c4aa8a3891313ca83abc40be19be2d109096549fb55b3cae416decd2dfefeb79fb01318446564c767efb7df2807868e668c7f6612bb38bc9bcb1e04d3f75746dfdcdb32e87a135e731659ad6483538f6c03e2b6df2910a93cbe7d5bd342e2f86e4f0e7b646adcaf98d5a2d8fcda4146b60dccb292be6544dcef40d4d8e26506b8c26eea99119b3551568f7aaa0298008da02502c8e46f34a3437ccc58bb970c7d6b4b74be6543cc92687155febca2130dd0c1d2f89fa4e606288795be083a81c68b74d9e3d60b5615cd1a00620f19b319b9ecdff62dfbd5a4e36318abdc0ba8d8812fe16a611ebf49643a2b139d2aed01b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
