<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bbe7eda30a9b0669410c7575d2deef48f525b9af16c1feb1289bbaf5ceaa961d42c07fb6f2c9ae42eab7f8e18c9dc26a973379e3e58b02dd34bece5cc59a2c550b9a83656a6ed373fedfbb37b44c76223718604c696972f5195c5f15054770c06e6c6b9799edb7ea6b1c0f686f745eaf08f380fbf95e53e002e3bc86a579896434525ae0770c1c0cb401eaf0d91ed80a222c1c25930d4ca70837d14920160e09e0201b503e9960af8e5ecf4778ea4310655e6cd3dfb74ceb3769f98d57d3851d88546d75e9dd283c96e62944ba9e453e37324ea3231919b0a1f113be9627e1ab441c3ab82cd17b769254a11499bb7eac436f5d19671b1f0a6102e090624e0597c14bf566c26bfa04a9980fdea429f0742cb5fdbfd2cb0467e9a3f17372ef7ce9033aa08a3c6e8b31bcabb795cda9f84adc6c7eaa7dc792ceae68ccc373a9d0a287cde3c6dac7fa564a35c52a85c4d30c949e274566b697556a80c3a86dd595f238c67fdfda2d565b5215af46130278f83519007d02ea4af7a77e356ee8592aa03aedd8e6a6867d2dac3013a2b9e3f3b46ef7946de7b710a3f7604dfe2ac87b5dc7e994f235df35866582c27d03bcf53ff322bcad6ee701ffa66bc2212847290bb18bd460ed77e869ac85e032cbb01cf6d425064ca90701b48ede0aa9a4ec18188826d7523964b468dbe4d13582fe0f550fde7a4dd26b17fa6dc4620c4a5562a65e80e0dbc341a8ebb612f0883f0f88a560752b0a510d8666e6246a9bad911b9045c607979b47550f552390fc0d0ba620a0ca49b424efb0be2729865b8dd9b10851c68ccd60a1ef2f1d9fafe93ccb4e69f490987b5c7670dbd9bd2ec562f7485d4a2532fbb12c3469f32d96a9a442bf09bebb5028ef58c661917db60a02d8134a6bbaf72189662514f0be9d95d12b7969c0189281beb76e14a9af307bb4f8149b36bac1f82b3c7236c2eb95d94f7779c06f4e92c89d80ffeb5510dd69883c46c8efa4cd01f867a0a8f7a99d3d188b5e82ef9cf0363189bd4195bc7ce75cced23dcf7e73f87ea18083bb8f3307baecba6030708d0963007c87ddd184b0cce377254d6f30570a95a2b65e7afdf5aacfe5bbfb7a1ebd638a1f77985dcfe59ae93798b0d1c54c7fa11e67fa2a9de968bf18bfda3f6a7bca13d065ca36cddc5f2db387246c5a13ed1dfe38e1a7559ed8e44e1fb847ea24e8c801600408d534e6a972782d98915a10c9e1bfa376f2787e185936ca300109ab71d573b318d8549cd26b841773e588026605e0580349b9b74b0a4c81bfdbad06e54faaa1b58d3d4209e5c4b3d87208139d53c279b25366b93928af9250cec75eb902d5e5f31b065c7467a656f1d50e31c3cdc38b6be3822f217b283d1eb9413a98b215527ab3037a2e6e4130e05946457029fc2567b8099a6b0b0091b42dba17b4d2f3aa7563f3f2ab73c420c1a0734544f52b99788160312b20b1f36287b3361fd8c30ef8101c213b2b70d7dc4d0fb665506593fdcbf78280bd63c3b44753c6c9336d23c41bcd3c8c8f9741728e45ef7ce9554819c69c4f1a52bd2048df2606b3220de301b2f485a5e3b72c6e7de3fae74863d98187013f7012744e10bdbecf5acc7cb851fbe3f5120aee0021c76dcc00509e8e5e718763adda5d9e2957545c1aadd083351cefc4cda9d1d0b459c316579a1b08669412f5f87fe6be71a0dc18d6e40577c70998bdc5d66ae4a7be0b1bb79a3d5304cf656ce431da0c5a4368fed58682e2e145c8c453b798461adaabccf651e744b196f33346c96178cb119fce0296f712c8ec078f2ca13b8f499d5faf91a56d77e6ec2f36338b22f0736a902c8bbaf1141b1b700d09b727aba6156d29239d833b8173738b69d59ce35531f5a75ea660ee49cea12869e250c342f47a4bee805e2718421a38bf27e8ab5c6d4da358728e4121a8bd05a0109a77c17d15de96f0296a330e3fd6a56f73e1d3060f3e161065067e57491beb3d5a641a5bc30fa94fac5b7590c39c761b309b7ba5c3b96461d08502d7bc2a73594d4418964585d5070ae12159b62e2ccbec3b68886a28d48c22f67c04728b23b91101a19267ab05920deea0b117cb93a3cbb501c1e7b27464e599f5d05a5b1a28ff67cdd444f17554e6f45d29e60bfbb42342e19d7b6f8bdddbd87fd73e3100b13f9590be766552cc94ebe4c3dcbfdc2d928dbd54842eea9ac1a4d82da0ccd34aca7a63f9dc5b53ec54505555d64ab71bab967e9d6e8b581773973b402ccd931b7150fa49ff667a096f151c2dc202a581149c155830c5c4ee518c93659431c7bfe28e8b234f6107c8ccd32a89f5634be19c64d86363a0203c8b8a7e71c452e62c1e0a6c56cca414b05cab51835ffa19a265e694c08c0947e1b9a59878a338ef6a76d8ac43470e5ff7b1cd0f0d5d92a5e899d88fa70e07527dcb5aac81a4a190d0258258ae78a59bd230951d90cc4c3b56b3852a1c6566f45920f0792e43662a54e1f56b7e6ec687c82333da069749d45d5f30c3b39f399a450132d40be55155c4caafca85e2a45a543ae38615e6c672693230f09c74c341f5128633d2c8dc1d7e46f8b61009a63606e12732258e38343e2b46032646a120b01d5bae8e120b3ab0fc7c5e561cf774ab8688e68915dbcb2eecf72935f06026ffdcf14f0313cdc3c14d9b9544d8b7369d30af9175d2f674c2a53e97892e852c543fb4a8bbec7677d8fdb5bfa17d6db28d96c45201cb7e68d0ac604a635b1196dcf234e3622337ffa7b37e4ca13628d22a1c3485415ad2b1705e41b7045c2387704b8f6480bc9baddbd18973494240c195720d8bfdf40d543fe2127bba6ddccb451b4facbe34446afaad8bcfe3628320e98fdd91c84dd16aa6fad988f87394737f5fa753d9cfd8c35ad0c195a37567a3cb1fbdf2eee5c1d3b9c9c92e31ce9f2c56e82dd30a197f6f29fccd78158eda6b3109a2acb0113f248f2205ba8c303aa9605edf3dad0757cdc339c4a514c795aa13b09b20d77a7caf3cd57ea6b0e551f6d567f04eb8e467be6dff2c790b07391444929b9d6d8a54f9834df42f2cd4b55cc1a60843a39f77317007f5009221593217e9a2953f709a5ff0a326caa72afe8cfba2320917bda314d6ab280424b886a520e65cb1e842a85e6742a1feacf315f117a208bf16bc48d66abd6d81b345017b2c5ee1a34980747a21ee1de064cec35cd4f565aeb33296ae897b1b877ff33ed4eefbfba853444f7442a2c635e8995923645ee6afa53f870cf35f2de6e8678c3f010a3faf7ef8f971ef9491d75daf0904d5dabb51cf8017c94de304fdc2d59af03028e2eae7c2e4633e342241a29c0ceef3ece0e712bbc615a1ecc00bef0ab7f4abe0c6b9219ea488d5e187f50f58af88f05946e2c881dee2ed8e1a46565121cfd0fad79b10e3ce4479ff7981666bf8a7153fa8a8268d19dd5340fce1a08ac7ca4246d17645aae9680b443bc880a3949874f0ead01baf6890170a1c0b1146f45639ac43a09d0cdeb2019a71cc8714b78e279de4572aed505da1d002e23191c1ccde8ff2fd3f16b95b2a32bb6ee176071acac0ad28d6665b97db3c6ced05ee80427e53d6de4d67d3e2813dc4a636daa2bbce10533777bc6e52aa93c3f86a4794fb2b8715575a20129998c8b55e253c5d65d191348261737e6823cd46ecb6a94477fd88cb47c0aba96be28f47b0a6f4991ecd76df213c5351e27a7582609581988901f46705d4be0fc19259f4e391d7b178b1c4fc511c417a4d6afa08224be86776ba42dcd5138b2247f2e1bd0bb29522b0650a40cb69a27d758695274fa6fc4fbcf33893d2ce1b56c577c592f7747ad7f70f577c61cc72873ab03b8c29a93a77e4d270728f1875cbde96fc05cf6fdd18ef87bef7e8b5fba8e1f6f32e58291709958a23717c55b316c43b522adf9798032340779b7ad98f1097fdba23ea1c27446764b889a270f1808aaf6665664b517d5e697ae57a3df6a6dc88fad0dc3ae630a90b028c0c586d69714ae91afd540d6b31b9c690adbdd2db98cf783a07771db1947c84a95ea4710024f2693c0ff02a02d9672bad7360a959e0e0e42cbe9b5ea01fcd9a4b8555e2be654c2b835f56e6b1c27ce23b48c83402d469beaf166677eba183fd5257fd02ba5267f0d717cc3ac658b15fa79e10f9475aa81b090a55841f73a0cc3fdee946c0424024a9cec1478fcad250d3797779e293d5ffb8cc229b9918b79b55b04f5b477081fcd15e5e46c815bd80b51255f4aaec5a22a372119692f323aac30bd3128e14266e9da9ae41460182f42dbb912efe811a1b677f540c91466edeaac073c224a9432a401c46139db64cd1278700d6948f06d6df39cc656901fc48875fe331ce5a01f184e0fab7b333d80faae23562fca09c812ef790dc7fd10aa8a6be837c81a5558557ce4de62488f9a3068ce64f2e99ebdbbc82ead06f067945b6ad0bb96c40054c38731aa7b188eb1853bc6a280283c5d7de963b53200f03b3a3cc2827a68781fca1dce69ef443d2c709fc818b92c897d73a41e8524b496fb4927f3cacb7c709c04b4a5432c2624a3371ef510526a337a4b8628d25799217393ba1527352cb0cbebfad85e0cc165919d5fdd40dffdc9b9ce71ee70eb4676210ecb8d99883b986f9ceb3c098f6afb4b515bf96514f6f0ca07d662e6ffe4cd9a0cffe3e7fb6435d1be6192113b7a7d493e3d6b8aa01a9b9efba04636af467240b1c9c3863500165db10a25250314ff68f408fe57b4cbc77f10f381788089ace18885f2a62c84c5c0300cfe1294b24d2ae65cd9baf42deb485b75dbc739da718b74cb94f8efb737833c88ea81cf85ef778523349f43867643b0c9a29ec0367ae93d82b3c08418d96cc38d8365e83001c2438a4991a3320c5e837b92c8d3911c864d81451b342254c373a7b1a47c5af2d2ab23c9513c51bec1496ca954b8cd5d6ba814639c96eda2dc6a89d8ad5b204509cd087b914d36edcd30ab9e82276017a8fbd3e691394b0ff8437d4132b47daa568fe007e420ab2400bca2c164fbac9fc8708babcfbe9a1e70db3797f2ef0f2dbc881c6dbd5fe175fceed1fd3e927b82b5f79b4287a8157e965b6016b4f2e20b1b384d377d620643613be05d1d6d165e1c7b6d1873e07b612e3cbf3123b900133a3f8d49fce7c2634d1982a95b2764000c95f89360b2f840ab1cc65f605b90ed628c47cbff6cc04dae7e3a10203ef0af2efcdc4c855b9fef6b73d9e979deb43b28afceec85481149dead30a954c27d0a4f5e2bb679dc76d1a2ed72014e1d6a90aa94e9856c49919f8109e5b08537863ca15d0406d6f8efbafd2b7cbe024e6789ce562358f2ef7bb07cb2f4f14183995fc7765b2ba1c0b9ab6e931ad799b2d3d30e4474f60a48488ff67ebba6021baf8a2f5d1d96e15c5ce1d9904b018a38cbe0cb417243c539e50dca73cb4abc2cc1656432b5684f8c65a2f08008ad4f256990438c72887e693b7e328c3a742d4bd8deeb498f414c54afed03ebb40d05d93d2ee4d1ba77d87a1282986eb833825a30ba89a1dcdf947ea9ea662e4f4890656127ed7653aea70f5f0117e3b34b1fd36f87236c30105e9a625813238777c9939994812077e7d62ba2e8eaf673cda2b4b196902062719a92c06627119a1b2adb9de86a35c502743092f92e99620fcc5b45d781a7eb59b3fa6064030357ed1cca7ef4532ab6c3cecf2a9077af20bb2cf5a8bba59515b7aac77132229d8a1fa3bc6ef7fc9b4088871b55e5afb1af351e43176d9d84da22769d6f666a96bc3d22e2619b20a8a72923ffe2ff15a0db72a407f268311b771d3e99a3733cf143bcbfce6d524cd0febd9b1d02329964b4741f285d8bd08ede3e42a674a85c573ead0f185a9fa2bcbbdc6065452aa2e99a55fb50230fe74a65575dade2a8f8449baf223af1e13f042a8999670f0f13e19dd428d592bed6751918c7056da27dc1979e755002206d1fa2eb0ca632af28152ed7ab68398ac8e21f94558ccddaf5ee040bb2e6b67d2b3e766235ca5a223c27478dd694064a5335e0dc47df1d7faccdc3095aaaf73b0b48b46380f2f72e9422ad3e1311ed15b0968c60c11927e821d5aff30b01743376aa155b88d127adb439efd8987aad6ae6a8965b58d9f4e79559480adb277a90b4638cec874bdb52a14fb9d6437a6d3a58fae31e084f8a7fd5329b46b6c19291b33f339e2ee6a5c62ef2aa617ee036fa81b359f2bbea199752294efa4751d08081c5066f6c49a92e06c7df60829400094d51d86b88b7f62f49d45a84019c764b3cd01d9d2e00dfc14060e86fe9f23d7a3549efa49eb867487ed83efe16d20960800e2e5dfacb1a63c0bc065725aadf6bb26390bf6687c1f16928a99b447975f16c19e27d1891d763bc3d0d01112b9e9ecddb630a26e6837b2c6ea0c196d0c6a62965bae2fbf4d28f94760e1c27db87af7bac086f16c71cebf28df1d493d7eed57dcf2b5bbdbac4396257615c68227c2db48225971d3d203147dffd8164d9c51aff267628833a176d20668bc1e722b669b80ade37534cbb6687f2c475130be99baa840fb590174a18039d3395c53e9359cb910b34e237c22ea9206325d5b819f054da1c3e2c230636fd240b039114e60513b43b329819cf3206055c60046f457e7eec5b986463b2bce9f3e3584d95e6689ca1bf67accf7b3cb593408be826f3f98e862fddd060f0505d115690815d0a99819bfef7d6c3130fe3ce851e9cfcf5c658089ca78448ea55cbd95d72d0132fb0f47a44a55bad5f1c78afa38b6ef006dc3a9957ca676bf2c6a3a3f1500c3709c368687c6e1de2d41f7d639a851b901592bd4d219f6f984fc29fb71d46ab0b268e1b39831c9611b779a3f4c88befbc8290996456764b6b53c03bf0ff9690c11bf5eb379054d9f205d2fca2325ac6ce6f3bb17c99ae229a34474c90d8697c12ab15f044ebb3572b5a31bd9899d06961f6c224816828ef6492c257e5b6d501e6f3d63bfbac1a9298693e698ae0e447dbc1024064a30db0a5d4398e20c36bfe3c118a1b7a483daa874ebf9e1d2d61e0cd5a748f1766af9eef6d379e6c0b8ea25b93af423c23eaed94b74e71ab7f1c8fff81be7181e167c469d4065969e964b780c93b9c7a154f1b2ae8eb9534430be81841f78aa4e381a89e1dcf1e66b048c43d57394d33656df1e55b9bc41a3d550f37fcc6ac4e294170d7b2aecccf075481e83f68221f9a8befe9f311a8aadd4a4bf44980e83a41fa18fff5b5c0dc7bc7b9ce94bd0c03fcb1a5a60efb450b4bdb2c57c9dffa33e048cb6dfad6462106f70d6b15358860f32bcae6c33d00aa1f85c02bb9e29ba5c400bf3761fbb3a93f243f7a5893cadebbe5fae96bcb73686a9eebde951585c52d2e84e9442d3093a882352d780925a031659aa12d4a694cc207d2048d297b48dcdff924858c3109819a6a81aa574bf34670c9eef10cac1eb4c98bffcd57fefdc78a2712f429fb46976e713a8b229a189edfa24683d12e281bda5de7a357ab7bb13ac0d205d3540ab16d090ae14129c8798dc88360298ea0c44e3cd0427fcc181bc42755eff98bdb9165a1696621f0edbb6bc9e3f8df3a19130ba55048dbd7407daa34deb29a5e17e5b620a37615d869cc18f0f219335b62bfc6855871d5086d70632246beb13a7b12bf3b12652d9c800561b0c4b6b01488b23099e48b069e997b8f45949a7e74fdc971af8c418cf532fde99ac3dc7c154e5ecb45ea37a7f4bb501b5bc8fc3581008addb6c44076bf399454f42cbcecefb18f324961944f2ef8a8d2cc3032b18baa6cc8da3bd24787dcda846b9162e1d53f96d777d70930bfe26a1e98fcccbe5b7f600fc0de4acd9f7ddedd2b16fc30c88fc4b0f27e67884671dabc2efc8ad4a0855e486597a6d30b4e84bddf5f45c181608efe3d380b64ce874567f4fb830695712c8f10fe751ecdd9feb48163f60ca78b86879f8cf5475bf454f5d324668046b67947a03988ad1fa0ed18eb0b89caa1a315cbb8a440446964a1308ee98cad8cda730870acdc124c9a3930ee9b05d5a05836caf235942d2157910a10c2b728c0cce2db4fc831c9ec11d8d4850a41b8dea399499490cb3ac6bd8e7f681aeb3991dcf76a8832971cfb1c9c11b46311120af7d2f4943500df426d97cc77323578283651348a67cb73c33c9bdbcce39c1c3727bf9871dc6a488efc695471ad6da82b16746233c625ea9ddece9aa506a4105d95a493442bd704f489482ca18e7947ab2f30c89b8a44b99fa96b043eaef91ae435feaceb8e2db01544f0432a5fa5ed4d9fb450f1a7b94e01920cc3de5dd0c809c8a5ceda0333f855bef7039d6914b4be905de19da91c0c61aa8812bb81bc2535ff1379fead4fdfc3a6144d748bd6a1e6d43d0c777647865a3f9e0ec80e516588d8f11d236354b594d3165c463dc842db5fd0d335030a982b36e530c64081840c2a5fe6da9b44c9486247d62f7404c5740c7f780d3c03c8d347139e25072ac3a5e0e29dc1d278126d8a718c7472c3abeac23a3bbe85d8661e834dbee0ef808cbd267a9400c6dbc353e52e967f1bf44d227f6f2992632afcfa19b48773eecba4f70c1a6212ecce19de14653e9542473ab9a6b0ee02176e8cb1ff9f455a2f0a20c985b9bca5199b0aa96a8a95c4fac542c29b1a826c5999854e8a947773b72061ba928b4fc7fad11291addb43bb40852ae4332ee10d99a417ff56fc26ac55b690b982759a6b3def1bac4afd49a624cddf70bed8c6c9b11e49970df18633b96c2d95cada205ff46ae2724ddfed3de23c7636c81e4a27074f5a0ac4b585f287527826373e465e548ea7f0432c55b652213640c6df99ccd29aed1db537f9309fc14aaa11d56461823524981892d0ef65803f5c84beeb90ffe1f6bcc237c0be0a35f33c696f11dcb0346837bf01ba1e0d289096339ce0e70fce0f32c6ae6aa88c793fa3b47472b17d70dad2e81a0c2e4f0633129353abea6e0c32cbaa962a7e9bf452569c2bb37ebfa632d6947cbd7d05702df715012606f5e7b4dd7cf1d0fff4af566aef68e410da0df60c179437207ec63128ce9bec597bf5e1a7bfc3e5a8131616fb13a4b7143898489840a49bebf821af3433c92b29cc21ed21552201a6127203ef1cf79152c07489e7a0f791bc8291402c3f6adeab902f4d9ead2fdc75c45168a178da672f72e9e70a40e01e61d677882f7508803ba6072b4f164684df2a33cecb8153d5eaf42bd20b2dad37dcec564643","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
