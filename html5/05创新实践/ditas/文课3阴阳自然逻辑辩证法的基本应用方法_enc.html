<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccdb2284940d8809c27410f3da550e99a0e2cef61ad49c0176ab121a1368b8b46ac96a11f2b0309c307c4b73fe08fc2bdea0de011c710438f3c9bc869beb450b84b28e0b9a635ba291f9258e963adc18bfcbc459398ac3e2288d7c21641ece670b8e053afac4f1a0400f8f887c05b69a3581b3f08c1ff86c6af0928c6f6ef37f5e58049486d7ac02eaf067b3f53b26d8411257b5cb2fed1abfa37730052d2e6ae8fbac06cefb3fcb591765af5137af552f057b4346a33005aed277e1f303e944d566db8ff50a09c17eb9c359206efe064d4966f45e8fc150884b620387e88a6d7ef31e3fae3e5e15f53431face3a581591e370ef29965fbf29733ca62327962b7ed8550a0a81cc044aa1d79688935ab9ac410e8b5ac445168cf71d54c3b5cf4adfe755c303a6ef3312e5228f9cb94ca3bb8ac78ee42622d065ebb130a25993289613ad7cd2b717c8c2c3584582683652b9a522826c7ef0943d5786e4406285fe18249449ef29487fb0b3cf97d4f06562098129289cc0ca313bdebee4c1446c6d10ad53ebc4598f2579ad8dac9735fe7ab8928b5b658747a134caa9dcd94504e0fa1763cc50bc6bc946bd9c767896e354cb1ffa8719908654e4f6ec0edbcd45ef789c69cd150aff0c0d168666b4314b912c2c604c487e6e3f7d6fc5f70a9971474d09fda33c6d0e2adb1545f215f82f690830520ba76b3d73fc6f8c21b819d164cbfc17b7dbc5b68e9c61f1ecbe35c086e02d5a9cc062331c72b093779898b63e7b65e010fbf47ead56e0e489835b002e523a1daba9f1c7d513ff270cb5a70e6501fe7e92f01969dede5cca2d2a99bbcc08566408b76ed5f3a4735709c3f60dfad9458c32eb2e1191860538b70cf017cd2e6fd02a8f2b2781d521b0a61488d30b7a9199c9ac55f9eb1db615836f73eb9415cbc0558317fbb99fc232abcb3c9c08539d527eef3f8a1e690436ca18167c505369f892eb7907f0d673d423f8af3bba8156209f13435da228ac4d591eba03bdf77c1c25e36af7f6f2ef50566566acdb7d7b60ed548142bc61a1fcf89dc4ceec19059bd7a866b877396ce02908045e0e4ed7861311c20ae66705e9b0d66889ea36ddc63c2f409a079ea2b7fa98dfdb90903d5a7b9370abbd57ac5957cece0daf6f4fedb79cbaa41bbeb40c411b92317247dd71a412e5095a519e84607fdb5f657fba5bbab47c73d3ebdc983b401d6648d083ddcb40700ffdc503e78eb7f2116a02db082b25031efba5a813af83d80e76ff5879285f31b8bd5f3dc85641a76b12327296fdced192b94902a6391671a1f1acc35efc0232370b670d418d54a092d3193aad613f886393f6538e83901285fc73556005f0aa03153a3d77178b0b25a91d0c4dca2b53ce5731ecb08145ebbc76926edb0526dd9ab69c169d5e4195ab4ab0ef00a9138c44b0470fb7358a19e4d120652ae51872c6d8086637a3116ed1075c9b531037f0ab35ea06670ae51c3a9259ba2e40cc4e5feaca3b684a95332d3db9ea368f734179d88e405d800f0f474dc2d8e7b188ec83c428b5fec0759a4c7b30c2a062c559871ad8438c484a407572c7ad4e061961a0bada26ef321e5b4c576345e875d1af02f332096ad135708b6b9561e136494c01cdb809c800fc379d2dcabcdc07372f6ad4328f5c18c50a94a431094344601d90c7c7dba900c71d3102a39e899d88bb42f98109c5fad1e52aad29126b92170b4ec95b9ea0a829ead535d05a23094a7ad599ebacc9bd4fd0aacf8b5512205bf312e543023acfd07e8a330709171a9e0165d72d1879553f8b44bbd4c0c463759cf4793f2afbe5567f6ce14427c38b88b3316afddec2377f22beab63d0ff9625eaf7160d4b20c9492ae59532ea58b74d11c20de105e99079fb59240e6cd52bf7de7e9f3e59d6514f5aab90dfbf5bbe5e2e57b2f21170b7dab448df12be44479bab70d2bf82515dfce6377dd498ab9eaab874d7da75f822abf653daf9cbf2a84547139059176f8d5578e58026da12dfb1c9ed6a8bc1cc7b13f8f0117b0eba63d904e8ac0665abdde32dd71d7b20a2142e571247c546bd14eb9764c141ba54c932ff45cc02c305ec3a6e15597ff3463e2d8d4373146535fcaf4bc180c8dc6d89bca6ac0d56355ac22e40bfa9a0c24dde8d9f6244a80f885de47835c6ac461321b69e92e2c310020fd04f11f1b56c80ceef22d86fef2b0182d1ab5f3399a4449c96b02d2c778a54eb1260f43be1f5f4c881f363e9cc4ad7e520550febe955957244d3251ce6cbd9af7fda39cc736668114e46238370762a288324303c059fbadde0a062599ae04bb2ef90b941335ff6122415b05b37f6f824713f12e055762de8b0258a35f959d6c52750202badbf2207ac23caf524b68b60628bcddd7ad48f261c5b656e1bf4b5e3d062ea95b6d30961524e52bd93d2570599e800dee25717b8f2f07eb01afffb8ab6713881681d56eadeee2bb8472c873463875207033d57767ec25a8987256d8f3fc64a01d9b68f4323a933dfb6b8b7c49625e4e64ef93e953a0a70f868e4956eafb6cd34debb07d63f3653ac8f1b2daae1f1733bf18973e44f2a062294c296ed543214179a681fba3e49753c1e8a6a5d2445a48bc185fab32ee9d0b7c25a317dfedc228cfdae96abe0a96a5648b24a8b2b5cee4ad43e3733c64c612dc0ad6ba8a0bae5e539f3d560a9bf91ea27efd5c75bbfe131b4074b4d99efbbede6109d7fae5e17be0c8928a5edbffc9b39a74b68a276c61ef281e21a927b02785ef5f7456c3b0b4fecea6c24a803a78eff36182a261ec88d7bb4c4e6f1ba2a8f52e5fba930d93bfc391e385c3f4ccb322311642e243658af2aa4c4ecf2d0224751658dd7665960cb92d1f1280095adb690f81ddf9438b14d9310a51c143f9b439543f7a0242748b03b9ba166985515407cadaf607e317a4f0ccb3dbd085b88dd9dfced4a41ea514334851d6f211f9ed8e2d15c3f48b83625bafe2cb86085fbdb9792d84c77a2bdeee17782f2fe12da1edebafa96a6f64894544689a0ea9c6a2145cfcdcf30c82eee92c52b860e92c3ce89869f71f2696e80d66e9336d8c68031b004c39203e9502e74aaa4babacf4cf2c757f2c3cb9499b1be0763c7440cf08cb8c1c9258e6620c7802f19643e616e382066eeb2f69130d497ef3b051a1856e3f8151c55884671983c787d89099ff411471e06fdf8d9c0327a3535222b608248af6eec32ae232ac501bd0ac02fbe4b72e3d1974fc257e7c72f821983c598cad6567f34c474e1aca441c408655df6bd8089267d0538db769969b3ddbcd902610d788b9e3c1cabd3f57352b9147200482b78c87f63d2ae8f886a0f6c6d572a95dd441a8e76bd7ed3ce7a0c37a42df1aafcd4682b5da98cceff6f013c1b260da2daddbecdd278da230a2655e895b24cfc072d8b9ec2ab7963c1356a75fee727e8825c89f1fa1e43386fc9a0e5786307e6f93580ba7dd2e70241b19eb35445acc7fa9ca0dd640d933573427b92e22e65420d47a4814ee296de9589697fd181b9201938651b62f7107391a101e92e257d559a6e2aea3e076a2fe1d51ac77af27c2bbc9a42a80ebb95540639f9184ea4e2b44edd181a7acbb26960254b9eb12d454f73ee7c39681227d910676dc46c4e404b60c90cef499d1470a3f0cdf67648974e029d0c4148dddb9ecea2f61b1a9b8807cb32c32a4f1e14abb88c814d8d612655e1d495f91511e51538e949fdfa080c76311166f1476a633fda3455708384ef2c29d87e0fa3652539ab84ed69d088a06dba7031dc646949294e889b05b2604ff48123acb0c709d885eea8922317a3dc6a12eb103c8d10cb7057c880701b3d06b6588356032acaa8034f31185ba59a98dc61b8d2e75e0097af7a4efee46b9f6827889873ad6bb09c4b2d10c7dfc7e0dd09ab566be051115132ca67b460dc0f353c89a663f9ad7f1b8bc08d2cd81b3c258909a11871919399c46a574e377fbad41168b2fab3286b04b7be835b1a8e2e2d301542ec4f4db99485116f34937ae314733e062d7ff12420d678b427634231c1e44630a1109c82e7d2395f4c07f6b4a80059ae2ce53f0024ec27422e39a91aa1f5613ad6b892460efe55891a89cdc2d281ce6f59a3572f7610d82dae8c7d2f4e4d23a3c221740a8c622e464c85f0c3be7338cda5b2433e91fd71f4284b0999597d9677fd3feee2986731df3b8c87be9e2d203760c878aface91dacc70767395a5d04f4bc718874b35905c3d26a98a6235460306faedd44c6233eab669f8db0d8195d321ed726052e2ea8cfce3eaec5c71f88d91f24f637a2e6e90fe2f7b9258623c1f14cf4a7c82f79de8c711542419e07a41b2922f82a972bbf8067a8c03d7cc055475c42738336f7a1299dddffc500eb1611b50faed571dd5e860ec6488bf342ac1ad3dbdbd5fe52297f5280afae31d36eb96d3b4fb4f32482ce0535a9efb1eea0e53863a48b17c336e2c3d974e6dcdef62e7e761852fde8aacd2131404cd99e9e2fb625f658d621ad7219e163e5fd4abeb0df8325d40f6a174d9f742eaba1db32222b3579e77a76c01d35eae833d2961da95ef8bc75c0d872ae718c734bdfda75f4a904ba4a9c681fb01aa879358aa6c78d2bc81829c901d0a3ffe686b8649af63ac40f95c34a11f5cb74cf63873f93061bfa4d9c1202f0789042f4f359e90d843318c2a079c6d16d6bae09edc15aff22030205388aaba3385f45939ecd97355c309b545c4843ed6065050db0587991ca2768251088ceacfae675986d18f38d4081ee74caac0e980c0521db1434c2f4ec1380deaa58c721aaf953175da44bd4ed7903367dfe446df44c3aa81776899335e9ee759a7de20c8b05129c95cf501a0cb41976773f72d0c86cd8b7a237c91b87e7c5ff61d8770a54b7c5af4200f661ba68a15e789836058bb5df1f39004b130ea5f761871e4d0ce05730ed316f6edb694670063590c7be1370a58030f33e1125e5eb3a6b3e5209b45b400273d765a3ebcad13843dab98b3a998cc5da99243825b60d986570d3a3a91d5928980b5dedc327e7623023a6369a7fb566bfe60b639e4b7f6b3a91c3680ab9002f5ffaa0e2f6c7405f4334160b0778d978cda5764d93a34c3f5dc0b291eab5cba454428dcac5b4bee081402c2108b7a5b8517654beeae68baef58e3780b95496405e9f52568bea2837c2d1f5aca8e14caf0fd09dd112f3d60c3f19753b15bf57df9991b2464b53bd765bb5ec051a72b1a7f16b6fd7d1f1b6d9abb76732e65c4aa493e8675b5e9f475b70d70d3ee86628eab7e601b02dfca710eef658aaf72bd782078abd49d96f4f9e46ac0c763af77e1db329e496e51eee6d14184f9335a14a37c9905ff47d8dfa60072603aa802e7552e8fcde8cbe4fa598fe1413fa5dccf7545f8a8788ec6253adfe119bd57456c7f867a9bbc93f6e2eb0857cb381363b6de635701f84fb1d8d100a7c570e4edb03b26a73bbb48e50db8259b4810c2807dddf7b28f0d08ca480dbde78118a87ff0ad7121122fedd775a4e45c542324a7bf66c30d1271988238ea6af4e4d4de16e6678f4f8f2926f3804d359ac6b4653939b68688ef84a73caa0170003fcb73488960469d5ed1fa567e93021d484a83b1bb598be6f800b318872e9f4842359927e386559e2af41343d1ba6fac847fbbe30bc6b791a32b28d47e9e207e894df8d6fda1acad1e3d8668d52b9e34b91c829f3f18e91950cccd7aeeda94adc8d7d4eea12d688fcb8afeef7c3a6e50ee2b58ef470778da9776cc64538fbc97d80f252fa41f0d43d409346cf0a5d8aa211d2c3ad52ef7ee7f17a705b2bdf9c25cbb0f14e6853a521b3364bb7c3f790d3efe8aefc9b665402e9f7ea808cc1985a38bfc240f17fc3c6a28903165cb75d5d0f6f7ee73fb950f1653b57e4b8c127ac5687b734bb67112595f20db27edfef30991b1ba34840c73c6d467468c96814bf65a94430e72d5f6a3958435de43341d7e21ce59d48b3ad018e85047270a4dec7af73e0f44b262ea338d837161cc19a196562bb5e623624c4610ec2bb97eb6d013003278605143c20cae52ee8bf5cbaa43d98090b0e8e58a7b2ed6c7218c97133270fb709cfb97f181581f95378e2eb522ebf298ebc23c52ed5563bcde327c532c23def709ef7d436b9e4c68609035976bc7c7768951704b47994afbac914775bf3e3b619dfebae809150e1b8ddb63c92c0bcad2c4d7916ee76467c735a977ae8ec4cb75b2ecf68f8804e70dbae66023d6b144ec5cb7fad9f6f1d53ab362c10dcd74c235373dc46166b12d50b37016f0ba9455224a772ea6e312eecb136b08e5d17f6b67f9c5c51a2f7b475a72e95d7c3ba4bde4e22d5cfd0701f9f6b64d95d7808ee63f48d5a93078293cff40b613ca99c06296c445779f37aaa9f03f7ffe70ce63cd2ca72250aef548975df2fe5189566a22ee163189daba4616e3886976961806ed6395fba13560cfb43b780d53e25239c41dabf2e64caadb2fd00a8b3d98a99c7d65e1a14ccd81995aba80684bc938b92fc2bb4f53b8b7ff6625111f420eaa16501aabe7084d80a282c6a6b447f3949c6ad7e743a392d9cc59e4b11582f7fe80822e19f226b669b196946298e7ffe6ed8ee7b0355fb75df410f3836fd9109edf81022f0205837a08fb65aad90e9bd853358626a79da5b38aba9ccb81d13d1eefb8d7a0b29931cc7febdc30a75aceac4237601d74198e889ac26ea414ddb2d103344676c910a45431709c452c76570c72d86c7cc9e622ffd900b60ad080f97ab99c51ef041397b3442d70214adfd8c76bb6e78604b0acbe385c7c60efd687e863ba0d265aed066cf11e2751a17851d68f289332dba3251ddb51c60fe1a82643b2edb54ebbec302ff08dc790197342e134ca05a21bd36c0118a6b9d0fe0816dd378b0ee427acafcc5f5eac8fa714792c6c4a1f2162cc81672088afbe720519524d1a60e2b021a302b052337b5d1efc5736fdaff41d7ee3b1ab2c7a5d7c86109c3690ce479a457babf1ad96188dc2f503c8e966a0517589075a2a21086a309d3a322b115e42d417e0cfb26236f5275f696713475ed0b6de38a4e04cb6e38fc0098c75d1eee5b7c7b4f7a311550780ca02db81482111501a16faebb7797e9dbe61ddb10564c19ca058f2e50acb26944e57782149346bb9e19949416100d099b0280ad95d16339529cb69be88a8b172d9395db053677bfa9179335479f5e17df96c033fd67ad8afc4da8df4ddb571c7dafa28aed780c1ec141fe911ad69878318f27650271eec3cceb69f37d16c44926a587c942ac1fed8a952fbbb35f28e46aded8ad971188066f45ba2d3df5a6bebe5bf9d96e50d500068147acc13174ad63b4df57a70844fefa826018ce7b14ae9c7f12110361677c304d15f479af42c478002c4d414277a2c8c9324d20cd0e5a9f2800df25e333df703ce37f869228bb4b2f13695991ac04e9268ae0a95b0e32417181ff30e2651664ecb7418881d3acdbb37a58906300738f49776f22164bd54a1248bc137ba0780ae8fa5d79e8435105424b91e322aa9dcfb4ae8f8b35be1f4d021ba8168cee11d8c644cd1de3a42b061daea65966247dd1d2dcb6f581ed38c87eaddb9cca5215732bf2446b5d621ac18f1dcccd0bd8e82f8722eefecfb25fe25b62162a42ffd190a81187efd2db369ef35b351b9004b691f9c98ca041d53fddc0bf16d2e26fa27f205996316246ae9ee7d4641aa12285824ebbafd7091242d9cb36f43e928e691a5f75443eab3647514af1779b78843e15d8139580310bee6968e6f963df0092023de875b90305509308962d011082525ec5dbaf5bb028bc0fa08bb1698dd3375170685fa6291ca916d8fb1613035226ae410691c8a43b6ee9d388f6cf05d6551601cfe9d183b39fc60c6f4e50f1cce6cf5c92b08ac0726c32de818b57196df72aa3d30f2998dce0c0e0cdcd0258c927bee7e3c68a220d2fd88718dc148e02d03f4c43144c5b2a4ba26a12fb4d9e27bbb7673d1ff932e63740ec189b65ac96564a925f895e069750d8f482a64e03ef9d87084b9ce404c156f94bba04796ab8e4119c07c639486816e95a5d8155e36aa697d73655c4edf1be78cf8960c3f71367c31da2055afd4d3a20526a1e4aaf06b075507fd48cd4cba24b8cad8a2c55f13708b6f1a9ed96d920677391ca28c8e26eb635db27363edd61359d226a821b54bbfaac72f583563680dc88bd59ad65afeb683bca86ca7e696d5df0fbb0d60d716384fcc3e1e3edbdd8b5a306ec3d07de4242793482671d6262f73d0030186a7eb4c612320824451809b2c8d355b34d8dc6f5261f45d5c4fb9596ad1f88703f383c39b6a239a6321cb78dd5694c8a58eb930c74900c0454bec68ae5869b30aec7545f0533b054d75e68fe149d7371802bbb655cc0012716b39c9817e956ec6742ab5ab4634ae590408a1012a375bc3c77f4ea775bb58bca1e57055f90e9b1a5e2737c051ff3f4875a8cad0de5d3f19a7f7bd3221108b91e470f03a3dd5e018d4316e5a2ba1f66d2d4d70bfda34282d595f3164aea095e55aef623445a0c773dcb65e14b5f5ffa8122970b934747bd8671cf6f9565289583ea06051cd5b99581a7df2694500a988c15f6f7595c8b2341615417cd62451042d211e4e5e205e23b982d269089699064028de80a6a6aff73b526063a73ae28d9c77096b178e3e842c28b48c73d66dc4b31b1f95be355f04a1d436fa5828d6e65b00959a00a3a47fc9643848294be2251e27416d178aad553fb96fc417505c0c84cf56d4d066063b3461cbd565c844347220706a722212401dbe736eb3676f46e334668735954363dbe3372273b54dcb3b8e6b14a3efd3a9fca273314cabcdd28bfd1e06a51c56a72b72a33e0a056f0a6f039a8b48f73535a87cffbe911ef5c8d3fc425cc6db70ea8c8e9d57ccc4909902216cea8868c4fa22b2c93cdc651e8b1cdf762c2e5166b570fc2419429413f1577574cf69debbe00e75ec5a6ca4e46ed0d6b15251adb98ff9e8af82a5bad074a4b6dcc0e74c85ba1e9883924d8b1a14ce68bd52af94f7be5547d234b2da943e2e6a9c6785c6f09d266ec7d5359257bf83081c1c66de440a38142e435bc652ad03f34eb598e359e250e01d98afbe7e5401e2ee8cbe2fb5c3b327b1439d299691704ac7eb68964cece5948bf9f3a9d715dbf6d820ad0cffa24e8e521159f69fdffd4b364a620fe4ffcef9bfa94ac8b3a71d58330228a17ebb578155714c18afca3d279ad8c08288edcb3a1bfe0e7a7c387a625eab65a6a3fcba18f94bcf9532787ea36dffc0e1485f7f4d95623ee1da0f8ab44654d67afbf6d964bb810b787826846b142a6097137cc3b9ae0e3fc28b2e441c2881e33075c18ff8c28a4734c9a18aa89a2c1d54c48ce27c04046ba6e62b9035bba98ca81bafe6f235c59a207847930ec2d133196cd12915036ffcba9f69ee622af92cd70339bfa9ade9ebe80a79d03e3b5bb86d4e6acd77dfaf1a82fd74d86b1726dcc0fb87a64a57bb62b3b00a99b02990d758d8d193265e4bdd212d2ecba93437e2970f6a9cbe2e4bb66e2de7a0a452935e121460e16c1f4bf46caefce232b584fc0c44a3df122260a4f35e684350366ddd097069ca4c5cc868d28511a3d250ea28490b3ba269dfa2f9f34cfd7117f5d8d20e57f7abe5794397890b634b423fe11aff735029527252bb8390d5b2d5e62d7a534122e2ea85bcc6fdb61b4ac5183d413a21da4a568b5e39433ce3aa638382d00d148b2266cd86e7ed372f1ceef414fd057fd51b1ec866aab857ac6fb25119df4342e2040f0f08c4af149d52ef4106f0f3094d064c73a238cd853ce5bb89d2c18de33f1f00a28d9015c49d76d64204558906105489eee3fc8a9194844eb7c0ffe2c420ecc4ea02c582475fd970227062a3136e37ea7996d1cf7ab369a3fa36931929305403d6b3a1fbacd2fb11746cde37c6c8d03a08192043ca658dc7005d7bc3a2818dd4a301ee3fac855c9e9d2d01efd49b58903180ecbc6aac5a9dc151ca69e33de88c864727486b7e0bb55d93996f60447f3af3d70815aa5a3ca3e3b7a0d4fefeadb65c1e0165d27668a6a094ffa7f955ed64d7ed1d83a57ded79111900ea855b799ea36867fc8c8f42c2c3c2653700dcee22309ad43adaa95518b0c695657a4bdf2c17aea12e5783c2c66863f6602d140232a739f5fea9014db1f2cd26b4481b65e389f8d1a49a5fb4135cff3e829d793b52f66e0e81254e1ad7842011e7ef55edbd57c6e3078c4a899bb65d3e028a060a011cf356f32f7fb7a061f7739c393ec000defd821e52bb77b94b587dd9d349b7c365872aeaa4ce6f07a754c3cee549925954a7840e0d0cc0131ad18c0e590e6983f393d399e308ac7f4b929ce9deb90870389b25e1427e3f8e9ee096534341beef248d7454a776b4d668a1de61e21ac1a5d63d41959e0d5810becc479da66f805f892b2c6054ff890eb0528aaa94be455eabf21425f29728625702c8b29674599a49ea7b5e8267ba8dbbf39d55d2da1e0e4b03a4b289bd304853130d50c7c800ae79def28075b4875ba53b03e144aea1d40ac8a97c3d5b0209c12cf7a8b816658ebed0f9e260f5b1f6a352d236dfe8dbfc2f8098abbb1a6f496a130c067c2c0e04a6e220de6331ebdb329573895c6b09e8397154df7162690208fdbc57e9a15116083b4c3e52f662403eb9416b1953a29ddebd0f5d2fe6284219f7e571bcce7d753d59b425bc0959b625ccb1d1f2a7c64721f681d079c72eadd6b16d60d8f8adffaf16f6da9b3f0cda9834c807ce25f153982d8937bbf3f5fb57573ebe56f3c1da7b99f41622e92fed401c230533a7454c51f681681fd280bc7ab55f830a8583f56f62745a7487b82dcf45edf685612f3acdd97ed5fddb050b1ebbb9b3367a281a21f74274121897d664290d50c96f6b1f37731615450afd101843472a898641d7dcb17e2c8bbc5f9020b73c8694084b1532ca1987efcf6e4a7731d2eb12821eb2a35a07e0fd8fe58ade89bd3cedeb66ceb72534c71f59d51f543529c4b9f097bd0cd6f895ec3b3f46275578712bb4ccba0bb00d636883ee22a667c603a118cc10594b35569adc76ac74216e53498404c1e9f60845492f91e9f4290920fa19723409a33270adefe06eff21491773fa5fa9dff4d5a24a84affe9948c9fbcf775135a124f48507422caf41916f98f4125611b05427d7a347e79e801fa2f9c0e91df5fd02ef793cc91f4f0e08f5557c542f3be74ca647f3040842709e8d874263934278532c6d500911c55e3a4578ad13a609e1cdfa7e000fe9da70e0b1e35544a70915476a7b5b4ae0cd155da17423f4514eee764aa214985029a87af92978a5c00bbd263185a3ec581102c217e5aef75b6d6a10ac7049da8ffbb031d92561d7e4b4a45238fc76ead337aaba65a696d789bf0628de43c4d6aab131ef9bfa64fb767f1fa420522a66e48791d6d86b4184bb27a5b5a0ddc4e68e79794b5b8ab8a7563581ee13ed15184d58a1e9bbb6c952033d7722914583698a4bf6ae1d20378fd55d7c9e0a1ed21f11cc41c60492aa8673c907b2ae35909be5fa6810fa79e3846e25797e8a3dd1728e2c3752d1095d9af68b595fd029dc52e6e1e56e17846be1f6a0f70d8ec9bbd9a4fb67981fd83214a3111144c4903f1553fcba0063f3e8a551860f7a1e02efbda42bae1f18089008309816c49465186eb4751f97ceb3101018bf748b0cc56906fee59f2b6809f6e8659783f56b56af8124a4f50d81e82763aed609e07994bb3a2deb62e26689b3f822f138d4553088e6cebd15c4ce1124571116a2007d42fed35fae6ab0383620cff2a42163f2a93ce65a5ec4a5962c278c32c84541e3e926181bda8ba68f834544bc9e5492333276d5185648dd993fce7b9e71ed8420f7be4341617c811739c0695c8fedd5267eb6bc0123dc1668345a771b1f555305e5e9864f8517f550206eb24235f184999f6dc1639b06a209430cd07874c687839dbf2f0ee9de573363425c5f6510d626ff5724d040622fe575e022f496b3d47495a884981426c428f0273b70a0f09697897c2023bb23f72991e9601c59ca5dbff5dae622733b95480601932e442c2c043af8592e082d24d9edc2a48d4e7cdd5f7248f9c1352b47b6e8f5d6addd2d85326abde5d043429aec0cba6ec414eea33dd39de4c64eb21ca819fb472936704c253362ddcc20513eccb99e986d1f9189fde09c4615ed5b0ac658265a204a06438ffc9219eca04be462200b62088468c9815c0e2aaff12e12b3e6666c5db19059823332b9dd2a08bf03bdf2fae2720054736266a70e90eb92ae00c41e78665559a0af0f29ac7c2ce7aae7ec2bc3aac032bcde6a24aa1c94badc5cbd6dd2d95ec75cfcc29c14465d01a58b1f120413737c78a860a343414dc12a37e4f16d35f26013a012ed20718e0e0d057d002a8c1f95cceb8efb6b07f307031ade8bc72be9bb09441ee7adedd4183790a0b9b00ea8b91dafcf37177dd7905e21157a83e6e350644f344060707d96674da0541572b40409a793275f849d2ea7de578","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
