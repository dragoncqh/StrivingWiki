<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e73b2644edab26ec1038a073ab7b7ecbe72b960709b5ef9350ad16e7aef5968f076717850f5a856a81c0dab784427bad71b92b353faf21a34ecbb065d3c63c25894fc513759c4dc9cb057b8c7a67242db1fcfa0d956632f27a16d5b5b0d6745913aee203415c026990027f0dbb80da377b51b43a379447d642ccd8739ba6cba3ba4f21991120e21e04a2080676c0ba9eb4a750b90c3f686be5d5deef8817ac5c21b9f1c721793a163020027ac2673568095aa295ff4cec12b2b67c7e066d90c90865d4eab7ec1cf2f891a75610b4da16ebf5bb2751bec28d3ec9a125186774541ef51c9b4c1c7290173b232aded118949b147c08c4d529c504bab1e5e895f0c3a601dbf3d2b21e1a86f50e89f072412e47ad0eb9d7629e066a921c4b862e18573829e7fc466d8bed6fb9dd0fbab59720fe03cad239571874cb17adf6aa4aa9474670d45a3216d2d8b3f24c873cd1473e58e0bcf4a1c3392fc876b8f2f57dadf6be01b149d814ec501ee3581b8933cb61adb85c6729e8a403432810bb203e83a1314b54b4538bc815fc59b4ab6128169be3f1dd544664c550bc08c0418039ffb8c29cfe4644442841adc7efd98b7b8bc30979d1bc28bc52fea802441bad5a9cc6a392d76c06c9c7783d321f3cceba4c23772d8f0ea620d7bde27042bbcfdde418826fca6617dfebe480031b45a26cd368975682a253ef9f7af12845140cbe3bb76b94672fc31721fb191cbc461e4508cb05a5589cdf58d2bda42d57bdd5da3db0468c96f6f7407d2696eb40f50e7035598cea355ca02767f1053f4ddad5b75c2205e3f6737bc483d3a8f6aedba8936ed8a0b4a24b515a86f7ad91b659120d67f46bc946e732c0ffe8c8f4f3e94d8159189f5d68a552a2e7ecb7d4660b500acfaf10d82096bf089477cba12b11376b2424894929abcc329fac04a2b449d7eadd5bd9c1b3729e5addb4522a52fcd1b1a2ab476177826987dfae86d6651cd7076e017c9a2a737255d06a831798b104cce0158036b6f4563387dc1baca11535addc6e3ca500b21c143d01fec5e9622d139f99f7eb29103ed76745f2a66d8309fe90dc96bd85ef5370d1bd76ba7a86741ed187411529150c79bfbf7a741544977b2ece33b95661660a7fa806410d3a2d8a3245e2d6d7ce1f25edd0226bc29b29009472444d46e255d9dfcbb09e102f8bee7ac0a561d3efb5217d84ecc8f31a9afc4d4577ef0574da7d124088ab3039158784c9af939d07528bfb8f6970e7792271b9492d2e4fbf97785feb6700fb7adb7f70790d3a86fab39a7a4f2032602c35dd1300d6df7cf7a0f71434e0bc51cafaabee24dd5d2928aa4e18547f7c84f61ba348cf094455430c837a51cf92b434caf06cc56f4481f03b383cd814cbc11a1ef0c2ce0b94243626a044d2982f5e355c05527328005779e736221e1ab050d06f6bc7db62f0021bc9f2d923439d414a59b81b5c56172115dcace1c71b31507dd78c5653cdd3f765453d74ec0efd2b7e28d8b98e437af304c1da356a3b0af6c8ba86ccbaf32e99355f06de804654903151cbfe1677511de2015f28f6e7fce3f44128045dd40ed8e59c031113d763182b087b68243db142a75c854a37ff89e49df1224412ce779f74c5cdc89e9403da5fdb76b498ff18095656598caf27ed237f120f8ee187dd9f5563498e9f43a07afdad5cbfaaa9b01f32b39f04fc8d98a46da100ecb577cabc6e3850fbf95b1d989ed42f80becc0c399edcc171aeccb2daefd1576ec6d09591ab139f5bba87534b2a2f5620ce9beb778c8c12bbbb826c0426cc4ae41bf6ff56a73ddc0e051603e79f08f4ea3b80af59ba1e9ef396ac374239d370f5604d08b22b5656f10426639c5501f5ffb8fd61aa6b63d0cf13fa95b1e0951d2451ceee63192f33e45e64ea5b0950c6c2e7006e501274a0295838b7052a86d2f3f0b33d8ddd5bed351e53316daca3f6f5a638a2880b9eb3ad57a3eade9c85b4636f3fc8b2dba98f18e99f7789b250aaa3eb2f76e32fc06c5886a87d4e1e1ca3f7f8292fe0387790f9d83fda70f389ff370d29f3d402c1f907ebde6a97422006f928427de1502ff6fd32a326ca9285deb49faceaed4b7c66b75b63c08505c65229b613610c9e0c42ca02142ef448ba07302c0f93377e414d7b6189144427993eb84d9c18ff1c4ad6ffd9052400c9821124342f26cbf45ab88bb96d774afc50c97cf010d77ec6438bcb5bc233df65bfc9473341f959b4e88ada9378f4c9e83697dcd30e603981759ba1034c3903fb488508d420bc1439ece53fb7fee37da3f0aea1f176529c6611db57dbafbf9719432d8e92ae9a3b6b87631a921c54ab3e6e81a8514a693817cb773245a2df71903394ad5ccb5d43f3b5fa61d7705b86b8a344dfd65a9c9ff5e40e432aed0c55b3e9b7902a9df67021fb5fda7311abe88a61b3985d23883093f0eafaa34ea785becc5f8120d2e3720ce8f6a783e8f6c764424089a951e47f346869f2a1479692fe2c9737247edf7ade39a77e3ad2ea4dff9411b4a7fd79f6374e87baf88b1a4181afb948ab37de3f91bfc83a5813b81465e82736a8ae872f1f13c0e0c6ee5a5ff689ecf01f4040e7822a009aaa34a27d6f456138ecb1d55fa2316ea7ea745daca5c3309905aba2408296a03428432a9056fe450d302093c0143060d9ada77329f850888979e7872a324de833b2617e9540ad0a29c000de97625555800c05c7beb1f32fb2df8c1daecd4c8518aa2b11755d32fc24158492d45fba4ca317f3b9394fa426be6e5f76b6df725dd60cfce35ce972149ea6bc10d08f3ab5e1b832d3e7bf3103e70fc8057b9a176d025475f8884ab7d00e0b21fa653ce505a0381e49df67259a4b70873be78c8058572859acc4a7a776791089968f0f32cf0d150b61f8ec885a13cecd408527c3c50efbc9d3e5f61009242e878c86cef72390ba3f5322b489df3a187416750f0ab8b44b6936c9e92870efbb7a256b9c5cb8569d61012dcafdfb23036b678a501f77855ba5a959f06d10611d4efd802a2c15a82e92ed95cd8ad87ab823b0ad72c1f05514dc4a7d4602f510e42c5b5663f810cfc514fdea1ec1acc516cc748fc057b20fdaf2c0aece81f6264eefd8b362413e64c38b8c86dbcd7fec526d4b7454b4ff6f97c3fe0d93860a807a39c512515a3df9726f588632be773bd8cc4f47f5a5f79d7ce6759b86dd14d3d241880ef233cbc4d045e1249e977749bbfbab22bdcdcf7f894d4120220609c382c51512456152eddb5f9c8156a70e337dc885b119c4c5b0d82763ec14835f1c55a10772f3f18fc550b9272b3d162954d590aa2f08fc6e53275d271275c22bd966ab3246760cd229a158ce0b6a21fb7f8df4758afe27b8d0d86303a9830655b446e6425189eff647b161e9a2964b6d57d9660454e7a3247032da2b24468b8120b09deb599fe6079e057c1b7e702b7765772fed412fd8fe6c8ea9485d8da0bdf2ed741281c7c74979caaada2dfa16472781ddedf56af6591f593120d7ef7096127bdacfab803e538fd829674854f18dd001c4dc4bf262de08b6881f14727a6b765b691e33dcf2a5fe1cc18a7e2e9c07be24178a015268a62e2fce9e4d73906248e9d1848eaba69cf9174a18f530cff5f45643fd094e357c22630a0a7bd4160a2f5d227c51fff41d390af9af90a3605640c4ea63a092e0ded2758fbc7a96376d1e6dc8e1cc8197ecb98bfcab16646c26e58a22dfecc96e4bd97f6439b3642e42183405f4010006ce2d900844d64afb52f278ed139d136bccfb10cc65431649e26bfb147a378931b9fd77357abd407633c505ac89abfc85b9fa9226e6d2a1cd3a80ee8a66682b2027d449699be5e0b0f74f522fdad7702eee00e732b91f2c93f457a1450ef944bcd48200697dc105606f4804da585e260c9832ac3da6da095878ddd8fdc82ad9d9c772acd497fa13662b5faf2e73c9df9485d9c883706c25d08089326b65d18da6ff6ced81ff0c3eea8b1050c552ae0ab148511336a84110022642619c707c271447f03cf28154802cd2b9a2643e68fa663d4ab1d1a8ce7eda209535455796dfc14f0a4efafde3a84169ba9b43d951fe1faff799e7176b123ba0fc5704e566946f2ef4caf882fd76e1eb88cfc6cecd06861996cce8889c538cc02b0da3358c9a4cf34639b1c4be35e04b67d0eca4e73bae7502b7443210f5528c4c7c6f8ee2a21c12c848e03f578ca76d4e3ccf5488bd2274ebed7acef99e0fc0b55a89eeadfeabaaa2deee0551615e15de1ce74c6096ee167983a101c1972cb39eb1f3c6f6e97449e81387895ff2ebe9c23def17dc5ebfff921225be7247c082c4dedc4f768da4f6d92debec1380fadd3f4ce808b929759fc44ccabfa2ccb924a5ee24f9397a5cb145fb9743bbd697caf08be884902e284732e78589c9487b6bd1c9049e19e22d78cb1f1dc13f0a576b29a0d7444eef7498536ed81123bcbe3bd7c2bb6d5af86d5651822e031c98cadae2e40844df697ac1187546024400c70d107e78c759ba0461d649784740267fb16019a53f2ad0751072f78c57f44f4a8a305d601693fd8181ac691acd69b748fb0d3e8ea1608cd68592bad630274681cbab43ca9cb22d4bdca3c7d5240a36a5ecc18198d5db59de621261ed77feea9c34a6eafa7f83b22ec836fa39a40338a997e5b27ff5dbd6de5bc24a658697496b2cd9720d741235a646a026d5b59e8f95f05c67a4dcd6c7e62cdde9e3c2ffc42fb8247d59b30020183ba0e60a0a30fe8ef639ca9741cce80997b10c52f6ad8e17bd7a983952723cb6409ae520bf5330f081191f1477339da6743c0d7082c91a479ab4bafe82511704c96a673514927b820df4447c51e7265075dd5c8534495973ba8c404aa6d3ec3a2eec5804362ef4aaeed91b75039ff6b74e18e3944950f3cedabe4c685433b43da89e7af355f0e63109bfee7ad93a6216ffa31190b3ec0148e9f3d88ff7d8ac6667c36f670aaafe986a6e8ba31d46bfda75b29e6db4779f547f69be93954134e07ad28f33f4a46b536a2e535c7e1a200169ab0d88b9d354f1fc6b0cfe972b61849b33a29d31bb4226ade0721d46ca2c65310dc37d0dc35f4979128fceeb453f416daedd626b8cff629fac51784fe55ee3bc210168e996351ae66cd0014a1715f2a3264a46836dd89ffcf2dddfd91746c8ee86c6575c724b6ac7cc9ed71413ad4560479580eceb115ee6ac943a09ba8795c73c3a198f396701aa7675843a72869020d864c2e437ba09857b1a6fad9f71ac19d4f329f5746874c1db31b5e4083b46c692e98bc38ee73520af01df6c9cc253041e2430c174c90b7008ad6bfe482bc467b5098ad267db07d7437cb977858dc2b816d19fd93a9c4e52d3e346d846a094aaf8c620e4a514a23f88e8b2a96ca31ccb7e11325ebdecad4092c9825624d3add0e8eeea894fd7c0e97efe7de40eadadb8d2d2a3a1029058c2ab7e3acf9aff456d71c0e74f0adba4b084d076a47fcd9f3447e855b81c5036bb9727c8a05406032bb30f8199d4c296df50b6fcacb37dc5eeb36e834b289f14ba50ba1824d5406bc1888ae5d06979184f3dff333ef8538c2b7f3f09bdec63d6faa94a1995f39cfce6b039e0e59996340a0f440f0faa44458749e70c4c5456f9d10d3f50431c9e04a822a04bc781266a64930c11467374cccdf55a97bbdde2c82706ea9a5205afd8a48e0eb3feb4e2af7bcbb666a8d06611f41ae53174d73dbcd664450706482c8615051549dd0032fc9a0fd4c24c19c3dfd5bd845c9ce455e8e1728e9429a6bc8ad3446cb5b6a3e299e5a217cadd4a2cf8daa28e752770409d8fb7abd8c894d6c84e0dbfb28f3ae70b304e5e57a7973b7d025bc0b564ed2b97bbc0abb8150aa530b8ad845a8af01513642505dc7138fe00ff13fe9424965bfa902a42e85ab9ee326cc7d545465c316e524da33db851526d55d24e3394f2d50138cf1bd55be592aa04820bdc1606ef114b8eb42d93a806b90344ad30cd2e7dd16b80185f1e06d0fc1a62b0fd6022620be721a0fc1a79f4b09c295b78ff45adb128d7423d9e0bafb05c883f82f3f7019d174eecb6e91f533eba31235b82848eee4b9a7cc2a280dfbf85eb63814363cbce54ed868f0d9466bde563bfae2e25032a3d08f70135ebe7c1f8d3b8b8b72dc1d831f91959fc58f5f369a9f9944d343f7a689957d7873776812b890f41a1cc07d26dc3e63887a3e208c797870640dec142bf0efdb6e555c349b676f5662ffe1836ca85a5ebc760cf18bb07687225b90e1c94a3281f40cb50a549a13ed652efc1017d3b9a52b1e005bd4eddec5180673400e622bfb87a7a8417f2ce1d2828e4c5f1c8c34277843162ff16b35c51ee9e067ada506c70cd990b6f575d33ffe89989f05e6a11491a62759d1818664efd0d6cd9cbb0334ea42fc4bec1cf170c5a2e43206004d8bc2d88c322e0810b73104bb94fa454a8d2937cc3c7d06b83893480e6e4172f64160ded7a000ab1954afb3c80857009ce49229d6efc61c4553806fba207fee3a59f704ce6f4e2cf22230a4e04d7448ef68f04b911b844bfca9d985c77e236ce64e6709a39d999abd09bb717cea1ef872570c0dd1dffd0c45e8becdf3e4bfeb9f2e0f58ba556c503cdbb5a6a9ac916e6268a4f1d9447453d9deaa4c4f13748178b416343aaf137dbd65281c9e46475cca784142ddf50613a9317efddf9ab6c79c33eebed5ddef0032adf8944519baf1f336c4c72ba77d60d9fdabbe313c5fdc7abcf6319a242e7534a70188e603ba42f165748b5b4966c4c81b0468f34a62073f1da5e74d86a06ee242d606eb254bcd665c42711ce6c7fe7a34e599b06783608428776a9979860bc5d3a666ba5e88c6bb31ed514b7fdec64abc846184ef3ab083bc5e0981ff6577b4928be53766103b832e4cd6adce95c8da69b8bda9eb0b2ab33e7ca166c54b7ce54ec09c96d180a45988e47ec9f81ed860b8cf22a77aeb5b2d08c9c0fbf87da83f8c862757867359d229bd063762f4116a7ab781aa6a2ab29234767609668f13ef565c5353adc3573e1c7d7278d96ab5eba656bdc1f5de8b5bc381d48697d7d7fe381170074b5d21045cbc67cbc7ffcb85d43d7b7b7a355e13eba3fcee4edfc6ad533ee5f0be11e45eb3827b614b2db1a56bcb48467546b4c4c82859f52399b2e8bf0add176bdd1069a675f15d0add4481f2d4f4a6994ef1bbad1ac4e77f92bb9bb1dc47d79ed5baf82bb9b362187409997538bbfef3d8715f64e411fa4431bf60ffe6aaee97c6284a911caa9a87f804f629028ead1ad777c87d0c7e19453bca9e09d1953503f3eedd7297a4619ba5d87825256b4c5bc8b7b12779f9b3698fedf13ed5db44321fb221adcd827f4c1ee91301d0ee8da59eaf555eb0372930077d0f6bdb42f8c44c13d77093418457d305dc19fc9d84c419ae51ba27bbe02ddec7e6331e536c5a2ef59fc567dfd05c7c2351eed88a6a11d97796f78f0dcee00c3cbc243e7a056516a4ba48fceebbe9715111d65d43212ef341dd6bbe996e47b134db5ecc580c7a3e1feddf3f7b164c0b12a9e8cd4f351a8527b6170b6074513e8e9ad8074a49fe5167cce4bc62fb98aebb43a8927ac86a089e6f863fc05f6a240f48a984a3e2aa62f45f272a44e71265c9ae51ce32e1da0d3e586f98d5c799a911f599affd7873119baccc4cef097006140a5af4585d93b7679c7ec1f5b74abe514e6ced6bc821136ba248a1096b24802f73ce1a5a09da3f7f995147453f2dff3d055d0fdc746eff9e51c8fd32e3428ff85f971788828f8bb86fe1e37dc78499f12df010703c4935461ee369e19e7e61fb3d3a206342d5de24b659675a34a4dcf593428f0f5e2d9d941004ba2949bbe3eb05598a38dd79b8d3253f66df8fd96d6531f438a66c3839cbe9940b53f768367bfcb3d5a9132474d2347da99ed1d9641509bf4479f61c8e9b30d1a2f04cddd0638d930f174053d24a86b778fb4050f523190348b0a5ef1c65f116541d8be20e14824f02effa77564114613278ded2959f2a1633e0dd2a3bf671ab5948344bea5a6550c168ea8b00ed14d2e244bf78e1f9b3dff8d2df31361c5fded4523853ed46132a9411c0f9b9ab7fb04e023586b4b3593f6cb462ccf60e5ba30ecda2d2c70594cb5b36b05ac36918f6db72b4f54a2a3b0918f8653dd108afa48f12235b25409b55c62a1361f4ba8c327a092c0d148e3bb10e4e39fb982302971283ddb88563a2da79c9b7d3318de2d2b6907d1593118042223a156735e5c19ec6ac405ebf7b4977a948ae8ae1e6067e47bf6caa1f8a3431342881e74b2843ef6188dc454f09c253dddfd2d8d56acb3a56beefba3b09f925f67b7b4abf93117c413bed476bbb52afb870106f8d8894a125ca6be2fd35790f9a78d0785463f756eebd887cb4a56a41e8cd75908e83b3bb8df98c68ea3b1517dee33174050f0d1b908c43c4350d1dbb46f42ff545f8e63a9d52f570eedfcc49d3331eb1fbbc7d9da2d69ef6a20dd9a01f69dbdc8af96dd7d7e42eb49ccdee8b3a2679f7dd781fdc96a7dbaabbdadcdf01ef9b28a16dac50c237e12174ea02c868cf902b0994639728df7c88026cc03457cbb27828210b833996a6d95aa5471be9711509f4a8fb6c53ac9e8108d244edb60f7787781d933564f534bed7b5f619cd8ac7a44e7ba364f64aadfddce887bec20f62da5cc3f5381d6ce59cb5b58e8ec7aa93213c6178cc8ca7575df2acb4cdd37f41d41e690c31bbd69a403623d786eaf04434954ee4c3e7262d5211d7a4921743edd1897c6bd8efaa09afe5e0aebd37a434fa923b42703974b3c037995e6f6c71a509ecf7e2b0825048d0114dff74d52e965b71adf8dfbe953856df0e98f25049ac11ad0a9a024c559d953c120bf408c6d25e5fa7336160c95d0cc59d93a62be1aeff885bac452d5646a192da313a5e3eaa7702be400c75725268a5e7b6ad31c603b76c2b7cbeaa9b23697a39403efb4686214adc87df63059b113728ecba8a494c4669d6bceaa91e6bd274cc1d691dd518db82a2d99348d76e38b99054354aab72e6fd9d6a9f44a2c119c67ecbf3ee8741be160808612053bcb53eb16ddf2fc7ab4cee4ba1fd0df4a554aad0a92e6eac9c5841ec75e9472a3679187cbce5e2c27a06a1aec01a917c496c1370075a112f1576bd7ae12bfad03afa7d3d655b3ac4ffdc66b650c0a2b60445facebc47f77b5f984c17b457991f924df6e411fa5c56bccf6f4d83181dc9c631f897df621ec8831bb2b6f55bb9f34bd5a4b3beb5a4b205cacea166b694dc3eecdeb7c7e14618172fba469e1ea867631304f4e065047970c6e0ee29d11853d4ad941b4a59efa98aa22b8a3527d705c3e1394b8dac65f94e41e7c474ccdaa1f37d2d09709eb475ced99062fc51086f8372b97c4b9a8a51fe23235ec078e1e23b464576fd3862ba603b2bb5ef5dd053d1b3e980d46a4596f5b10b90ed159ecb084483ff57a0efd11919649a35947c887329a623e79f2054a7588cc788148f498fc56261d55984ffa1604d9193a8ce4660fedce117fe076496ed05809e247a6fa6a4e9cfc1eb2675eb819b220d570afd0205ee3ee6d30af0c5afbd7526dea3d0d5c5b6f95cfe36b3423ba8ee506f52ac29c2b9619e7e71b3c081de8441b526b7538cb8337ead3f34420cbb1023e02045b1861022eb1aa7336149ca7243683266c27aff63a95cd9a96d040d70128b5721a4be5635d35041e0792a63ed7f93cb82bb84ba171c4b0d58c908db68b7a62b2e03087a316edf8654482519fc1403ce7a00dce336d6270aaf8c12b73da3b3a8460518f3b8563fece52dd2207280315520480ef8c90f5d0ab3d4d46a2eeeafd46ba380a495b9f2fa62a6f5bf8161bd00e84f6762d527d73770cfa817e4623c5e00b31428dcdfd745cd7a29967a906831dda386b629cc7f30bcf1caee1f2d867305eca2b510990d819a9ca80416db1cbcfacedf834f20c613e8c72aa274352ff6aff8f85c08b1c3b49e8f3e9ebf3743b6e5945f1c1a19d956d6ac0e3d67baf50e9752c24bab33c1e5ca9e3a4510abedaf92a7f9a1b46be992d799d3a1aec500c3e45f6e04f13e067f03ba03e12614f4beaafa32d9c923ba268e05cdcb41aa8c85b2e5497eb43f48199a74b148c67d514430a60b3161f30f7c823643897e4a34a4561f4fd2c03124c2fac6c7f53c5659e969ccb9068942274fa3748fa6e6e9085edda9b5a0a75d9f02aea4d7a866dcde78a877b983ae94ccc8c2589495651751eb1f7f658037a9bb8c6e0da0b5621cfd01ed509005ccd38c8d0c68b7557eeb3b593eec298b9ef652c6793b3481531b1a1ec380ab637a52df1b07bac22cdf6185333bc5ee294f5afde628947e2cd7431f14ec3b7bd3f953ec007f3bb0a9d4e2967052ea4396ec0b0bc7af6b2f17bd2b73e8beecbf2ae6755a6d64d88507564b7c150c7b617c426ebe1526c7bbd83517250324f6c8275eb7e97a7e453655bbc199320f3081624b39e9d6d30a10f4f85e72e9f5f6fa2cb7c742ad19908465dfa0786d8edb460552e414a07a11b0c3aedc122d7f51486970bcc53b9fcca92e3588b4fc858c03f8bc0765e3c2db2d25f868cf941b4b6ca6d283b938d4f465b34cba1be7ad3a796abae056a57d337f3c0bf9384b10d70b66940672786bd376f4633dc51a4c0f9a255c27cb1e784d54a3a0a3fb297fc314aeb51c3bf974554adc4e33f740312d4eecb50d1421238274fb1bc0a6cb03c64bb323dcf2b6f5a672fd9ae5ff7ce6a2fea1872d094dbb7dfaf342478b40eb3e97d20c0adfc875eb60e5dcc13add10a85e2cc50ab2105be41099a53f779cabfae14b6c9076074780723e2af942b4db801fc9223e1333773ccce7e37e75d596469e46128fcb80eddb16152cd56f2fee559795c27b60b405ef0dc937e5e067971634f6a45e31a34d715aaccc9cb305d889e4e75fb8b295d2cb0b920d21f04b17c26f17d6087f9b031f69f2d813dba2b5d5f32705527a30569f8200500884abf8a0a8d00ece65ebbe346cc29800aebfd6ba2e153ae06ea6bb4369764110cb658befa58926a5da9aceb5ee4a73a7a4685c91d0ec1b3f5ce658cfcfbe237911b25fc08fc5678daa0e18e721eb16902a27d3751bf2888dcec6a2627d1124b3b3866eaa49f59f73fa6028d8dd279a344398b779149e07a83abc7632fb7601314bb626c0ced475101407bf49f17a7fd4858fe0345da75a799ee0331ad2fc7e78480ca5101f5c9347c9b7ea0784cc18224242b16fff6f750feaf65a133a7b1adbbb2b5d33785fb3ae8ea79ccbfcb9c38df057c9a06eb4230d8e6273f7ba3932c7f5d38af125379229711cfa2d0bd41da3a26d1e2d15298e621dfafe8745130ec2ea51aee808f58e60113455962833c85612e3360717a8c2b4dfbea48952afbde42df3ef695123a9ea605e72b8e579d503d20f35c9dc25e96355a0530e921aa8e77cc9e706b4435ee778934fda51bbc7f44323a9a3c9f46e70f313d8a49504967742fcef1680fc98660bfbcb4ae10c4f6cc9dd167ac3998825826618b85edf57b45c7cf94a46ef373c7081b340a9fd2052a1431ca8e25de2893b3cdac61492d543ba1e0b466d936b6a51bbdd3816fdce8731256bb286d7391785e41820fcf665ce57cf693c339ebbfd49223cb5b947db25db268d02ca80015041f2da413b383b06e24f4a64435ef4ca2274d1207aca545566671af2c9647dfcad9d4ef49473289bc9767ddac03a3de6218e7d14b6086e2b97eff4cce37deec8965f571e85073b8e62ee08d30ed86e2e2190a04901a46c67897dc87d499584488f7e1d49fae50690d318cd08eb1997f1983a676353d0d32020c3a85834d79f71256204380010dfdc5dd0fa8523cb819ef072516868ed6fbac3fcaf40ba609918041339d201b43db40217d50804de8d9a825df898eb101e45f7342709fc2aa09c9504323a0859e442f36b570a7e417ba6fbfcded1ab3947d2ea41cf81c55c764283f2157b675f0feaaaf12e454b7271299e3c657d6535ce8a2f986ad3eed7f4a7700f38fb49f1e0a1a8226b2b30ff0ba4ea8fc54b8d017825696f249f1258a23ec34a99b6a847837d84773945d1fd0337744efcce667ab1ce65722f02e5f175d352ac0572af6940f384be204e9919f2acc07a6e163f7cae0bb33ce1a0a38b12425495c6551c5f828f4153b2e09b14837d134cacc3801314152a0bf59dcb67e0f25f9603aedf348e9fd74904099db496f7dbcb3a2e0c4907e64d2015aca5360b07fc00f6c388ff76a147696fd96e5d4f523529b121dba66d9c41da062b7a3bbbb7788e8deb081cbaf22dcc277cddeea8a9f1f565f275eb1575ce9e5a5b57e8da3fce2f72ead10cf2fea9d9acb951ba60f8db57a9f177ddbcf19c812b24eb24bdae01dedfbde3d1ff85a7a25546f1401eeed9a3eb4ecbbf89bd9968344cb28c22f8379482ba80c4b8668e72dd6b7e43181cb3a8b1f172707749464e04317439b1a3bab8b13bcf9e416d129aa380e6a8c53081b2f7f41900864fef4aea289094871224822b8a8270be90d985ec6b639b1c56b6bea0e6793160b435e95a3b5f9c828632495b0facafe8b0eaa035b8476d6a3c163e0836c559f2a48fe67017e4197344e107aa82a0ccf0c340a4518bc24df28e12a521d75b1378fd52441ca1a37bcf86c6a0340a812e3857217b484243e14e21a2fbbd61e35071e07fcfce3e90d708e4840c385d674c0ac866b18d6645cb40fd9c60b0a63d429331cba723788a75d215fd87d134d57c9d3af269115f0d4b0e04363095140f1df11878b66bee54cd348d6c57f4ab5a512935bdd09086e52993268e0b6db080bf629aa98c1aa8d50c5c4a98d5a2fa97c3c3c37a5d19468ff03c032b6746966cfd3e58600b3248450b7007c6753ae969a72c6e3d182e2b6b8b1b9f2cf894c9ce4141b97d27935fc5d2b9bdf1cdb3e9d6d28d4bafb6e6bb7c780e8c66ef5a0424edfecc6490c4d01998465d210dff166ae96fbd45bad373339fe1a53f7d81987fd2f0cd20a4b2ad998f17acc92107341f0768d5cf3b1d6da24cc308cd480b0ac5579e527548421195a2275b4bbecaa44ff9ac3ff94691033b6368d59a8d347d428c536d13e16dec5114d439fe9b57ce5a1928e591638dbe6cbf98656a281b5c10f48d8ff28cd353b9645ac91afbc97ad3043495b990bb956c4498deb1ac00768ba29bd1157252118b74da3b681a500da5dca5b568fd3a6221662524dc444b7166556e3cdb64b45a13efb5e1533aa1fbdb8260f72039d95efa0a1da2748ec4f03cf3cd6df939e7d8bb573ffa3ad384fc7a6f1602b002526db6284b887fad1f7fda5a10c5704db5223876140c1bf4c3fe39eb5fd1eed6cf07f99d694f6e4ef1cbd537323a0f160ada0607476d9cf5b28b8547b4e262c4b0e6be85b13ee99528f6cf56d21fe116851d5bf04a9451a0af5d65fa0690de2d42f72950e3ce7d7ae33633aad6b705497f6a1d5369daad77a9cc99e95b237f0f49b59dbb3e82b1c8734ae61f335e726e795d303ca1c27befc4bedeb7a4000fc979c8cb2b1b135ceaf743bd9039568a90f6783045c625d89e11848e008eb3ba0ff0c2ac0761fea79f169211db7c3591c8a712d3d9a6986cc8588d4e3e2ccd65e1a011be801ccb713269f554440fda693e9f1efe2bb443c7b8ada6ec798bb17e43a97eb85d1622d8e202cc8a1bb18ecad4409c12124ec4fe77d2a2c8a9225b52b77225b674ddca974039ed94bc1d0a7f58d6b2ffef61945661c6224609cb6667d2ffc4832fb4b940f4153fd6fe11bf64c14afdbb31eefbaf43e0055835fd659baf71f27ac234a32942858edce41cb28575d6025f4baa5afd702fff66c8425b1d5f84d536abfc9ebc16a19c2db8c037551d3f7cfd9acfcf3fb9d349e251a4ff6856614cf9ac9be84e4862f51d9f7799235a929b01547631a93dac799002523a8502e137d9b5ce95a7b9902cae64284703ec224d88cf435fa7330f5819b77e4d0c9f76ec15d35ad7e488291ca8139ede6a0f7f4f6fc6536597ab61516730d3af2ec57d12962e9a000edfab248df84b77f208234011c0705ae4c94004e3b7e2e43d77c40e5dad2f863f84430fa599d9f62d0caf8a660eca08f58a516a029191b5a3f0b593345ef5b2b6251066d055a3176ccbfe74311c7f0c3ddd41ae01a16cb7daea3b2f1132503edda38354a585ed1cb7f356148fa9a9b3d373b8dce7244eaeadc8c63c45a8ddb5d6e93c48ba20750705790e4cbe82af8aa32339e5e74eba3e2ab4234a12530e18b5cbc74c3b770e1915cc20b24a0d0fc5a666bee5d47c3bb19111410b77eefc9c3197df469ac75ea356c885eaf81089c0a4434c2863d586f3b5902b144524f1ff2f8d2831689cf3c43c23974cdd57bc5ba9b2df6fa4eeeeea2a166f499fa5c1bdf09372ea81d883019991276053f15fff8eb27927423ef582f9be979ee9f2a754e2152df3f13e26e3d6be17e4f063c3334c2f26319466d6ea9d25d7c53eaef1dd0372bf64b92cd40c42355880855aa31e387fe9d2148a17bb437d60cc9dbbdbafec6cbdfd74502fb971fc1c763c56f60fc110813682c7ded20278886edbb0f03412434654e54d6dcdda0795bb12aca2be04666b715c01d5608f64979364fb7a03616b7a544ea4e6df4aa60aadf3cb568b695e1f29daf863e560956aee0d10b9205fb016e927076d099f5764ff3253c7294bb5c7e58f9f0a78d9fa9e69a512a27d670d4bb26313883a73c67389e927ded607fbf35fd68d7ef3879cf3ebe2c4f13c98bbb71a083d5619d884041cb33b2954c3d82a147cb941baf9328f32bec60b2c07d8a4cc9284919df6c0007705bf4e6e07a7a26c76811e7e619a48abcb8d2ec1720b90b05e5d25a1e326f2e00def52309a43e7a5e72b2e91b26429e22a9b22a73c236c061ee14b1cbf0f5663ef19559bbb95b877b13e76809f31b38c9b393e6b6f74188ecf3faff4a74d8740810d390d62c2a9b428b0b857b3767372ff5ff98c31f3ffab6125999229b5eaebd95471757b57fc94fe0eac1794a4883084b05d44c1c80d5d39b0e928b186cc8ff2349f4897f03aa40dce973c584b23185cb38192effe0204856925112598154a9201e301d61e3630afdb18874f331683c2b2640e2cb8f4f4ce76fae9cb9c6244b4592c8502f1f6737831d3adab01e1291217ff3e53eb20543b6bca98449497f2bd5d62e255558cdafda2ca64f60006d3120a00182a0d6eaf781075a8f1325ff672d04192d0aff4862d12449169c69b01e696222c76b4a0e6cf27c4282b536aa21d3f4d5241cfd98144e32329650a9091ce89c5ae0b792ce8f0cf970557d1320e529025d02e885c4158a9d8805f2bdf53256df7f8a58a194c71a9f3600561caf53e3bbbf32f7c0fa9821dfdabc1927203b8235f5b8763320c5a4445556486ead893ef9ad76cee0fab15fec29432bd4e017e73c37062c919c843580b790316e57f00987623db278a93633b498361f65aef12561bb5aa8b53cc46c92bc8f99320fcabc2d984322a5198d6603400ed8f592615326c525ebf22b706348d09fb870baa5b66fedf0745bba161db988a9292f3a706e54a978f8a026aa3b93ee5bc6efbf50ebb7bf5b1fdb1a455f3532735f351b0aff9949ceea1bdf7ca093d3fceecee0db5863819bade4f4526700faac5b95a75ac3c6e8f6461dfb573df6cf857d25822d35c3ba1c0038701c801521117517d81602af48b9648eb3d5b60231459b650c329efde2e7b8f440cc9307f872573e19677a3bcef395bbc694ff87a3fd18d9a09c6f3d1ca7f8f7e81937d722f026206fa7e1f2c000305a879151b7cf07b7f7b1ac451968085343abe731c8dd57373a5350190ebdb394d69db6bcccd73890042a2c237fae9c3ab4648ce31ab4accd1095199a7a0c2dac05a8de3e7646eaaeae164aa5683ba2df36c08a761169656ab44c8462350721c3533bd9e7d0ceb435a63ef2349d30811f293e37985e684c8ba9e3d58ec3bb4bf9aad9c3e8bfdb9ae99b85110842229e3f64dbb57d01770d772924ff13fcf536d966a59e051a4e832bf36d396104f739dc2e983b2a99875a82c935530b2b8cee247bc18a0bac2a87112c8786603da7004e1e6b5703a5d27acb9db929a469c0462eb3c765e4c30b91c1afb961f11cd25f4c8254c24b586c5dbb35f4dd71d638b6e79ebdeafd18c521255bef336147d7bda630d6dbe09301135db76b637fe15818040a9a119de3d8865b989eecb8071b9cbdf39f699050ac44814a76a3234dfe0acf630612e1cf7de2d8b9b8bb93cb6d0679b0d4038935fe1c995b20262a2303c79932ebfe8a63cff32a11e4c17e36c57767732ed9972fe14eac887a94659e62972da4410d1839340c34d4ab5f68e6dae3e99fff2af4f7c5eeedaa4bcb67c6e06d089ce682b5244b2a7179ce93001609c63fa5fc99e0cde7cbadaf613362ff060d7bcc821d44f3cc7f0aab954681628c687e3fb3957526793308fee29edf6bec777561c0c3e91991f155b0b5ed25e86b84571abec65339ed6958cf618c3e078f9e3e40f41b947993c0e853f85d8a76b4af79e5ac5f7bd70bc35c073fd5a16ec35f24e71ced8181d2ca9b23c07a0a669bb37e87811e247e2230","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
