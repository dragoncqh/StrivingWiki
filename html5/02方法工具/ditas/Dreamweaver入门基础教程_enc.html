<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3d1cf82a7a02939592f37228b1ad1367eff6769c4d06cd7eb620b0df511615e72aa2472824c04fc8394f354344ac554dd7ca14ae874ed94e9ccb8727ebb40471e3819e3075de611473d78329a3ec437be43472644e2e415c2091f52103bedeb4a4a456210962e999c867bc206fb08dfba6b9a892356da49458ef38f2f34dbace510ddf70c4d93d53b17bf0e4de165ef5f3e65bbd76e0c546139db63e5c6c6d628656ac9a9d25ca90ac92188c4b112cac1a4b674d50194da1ea6742ff6ac8aa379e6a1e9ca100cab0269f1c22918d8da2907d50d76509d8cfaa42d803930ea6633489492fc646b1f7c7816a5190333f6a130ac3402b0dbb8b46acc8027e5c28f0088390130a2efa50df1e5f24a4d257c4506636e79e8f930341395e28c1d459b221b45ba2f3cc43a6045da0cedb3045e85fdf204505f0063146b5e7e258bddb6c69789029ddbe2443cd5191ce6c23c2904731f2eb295123d55c6d417cc87b6a92bef57e15a4adebf1fc4350bae6c52266128388a845ea2be907422c89dc58220c7835426e876c061a8f9b12ac341664a43ff4cb87b0989cddc46010475c3adaf70dd3e75695715419d593d544d4be0c28680ec82401ebf633a71ff8b66c3ef8d8291ff366f99ceb67bdcf55119239844d2fb37f0ccf3216ee0348c44b463af33e26424fba4fefef0df8cd13d138a286671e7a835c364ec292c09de6999abf299fbef4d0da621371197f9e675a3fdb973115145afefc028b6896542b6ee3e8c57bb37d5c349b1c5eaced1f5efd59d40dd256755c14dde24d584ff29bbd302d384fca22672fb39a28c7206c48b1d50243837a8fc52566e93b06f496376121e5521425c3298f6060084a00291df0c44553f4e9079b8036818902a3e57a7fc895f96982ea8432e93e08a64dd70b1f8f74d801d038a8fd021b9d958230f4cc975d277d0f474dd46ba81b6d81b281938007d84ce7c43b6d5812a2d3668ec66dbb32e854250e22b312e01177b9a4c92b71e7b837829c3ff97c7bcc013259cf9bc944a3b3b86d5508700dd2546fc1b10568d5ffd52cca9979edb4a304325b3eaad77d7a038ef33f708663bff7df63883a652d2857f2d2a89695de1df9def234693e8d33cd1e29c6b2cbb23652380debe0e9d1d55c5ae5be534e7137d50a7b545d2ccec44770c5f73db01464e1c98e16750087241b6cfee693fafffe2bce171d689deb219b032a367a5cd165ef22ebd0bb4e06f34bf4bacfbe9dd070ff136540bee8563845a9cb4565414b666b0283da1eb0380b57659e7e8d56678aca923842915f6d0935c5e80681962e3c55bca750ffb36d3ff68704c01dd4ca177a6631a5bb10697349b5fc358aa8ac08aa6664fe87a4930566a9b343b588a58539449b31e3ab9a2a81e0dbdc5ab5b63cb3cb3ef465df7ed1fb45734ac08d942566845a4c3d10919820b01d342f98b275bc4de3010ce6b81162871f5c432e748aaa3b6444580bd22eb08e22266380c4e007feb8d44a4798ed5e353479ebcc389412a6b8c21392ebf2a97aa71cf300025a76d477bbfc707a48d4b2b0d35be3adf58d244b3a93a9f2dac42cdf5cc466b27c9f0018b1ac837f6326ead770ffa3b30f255e8c1ad9f772bdad0d0263f2f9fce42d96789b35cda21f8c281cd7772c570635be0eb7ec1b06ba3c0683293806389116c2fcb8ccc2993e8b9336294162ccf6a28a055fbc70c20c2f720d7350fe9cdddfd7a40f38c65f89d88389879dc0cbadbe1d6fbe076088206554a89f2812bcbef4f2698d0d4e3ac6f7fa93f7d641abde0aadcc258f9b052bbdac5125c776066f3496ccdefacfd526e37d4fc82d7eea89500b9b7cb8d6103cc4b7f02e5565fd018ee14958e11142e77527d58c7d56a2ff044d8430a654d47b251f2a06f05a46571a3c3dea05241733a1f8308778df2e504e381add3ba1421d8169b840bc20c73a53b71de1d979469e3a635248d1b413e5641b4e26facdc2434385286f2ee1c20303234acc3b2873e1ec5758a41dcbde10775ed80fbe328f80c7f9ebcae2491f68cfb5572e9edaa2785c21654ca7101cf2ad574e9a058ce49795600a1bad7e96c72019968af371c819ab3a63806c76ecc55764b7cf0609add9176843f1f5c6a4c863522be3f9c020bb6afe1d821376086ff01befe53d8fba6d2f3a130d5c18ecb73468fb68948e0a033ee89211c745f77eb36c6f92d9152f0893eab6512541bc3095fd34fe1c0b37a815a36c2af4cb9cb1a28ac53fc442af0abc195d2bffaf8114969bd89e1e1873ec083ebe0249236c835519ed10f6144f895ed81e79994cf1b1b60466670e37ffdfc80b522467793d7bd5939954dcd56757726fd460c2734b904e8cccbe03a63e87f55d3de110ff203d2e1f6ff5fba661d731ca74b83d6144ca477195082aa33a31bfbd8df41f1a45be35a8fd5a6e55bb5044a5f5578ad95f4dd32da40d156a59dfb680ed7d5455b12d34aadce15e3f9a50ac2bef42bf479b83174ae759a6085e536d3367c9ae4dc8360c17e927008fbe52928a5d9a0c5f7f742962c9b2ce7e62e91c608514ff1bc7eb77b2876aeab1bb95f6122cafa9f182268106c99636605a79eba8ea4d890592f991ab88c6d165657ac0b8ce78803be16d2e5f83beb2edf821226927d172e516c2d978110321620754f09e2c0f94cbb3cc7782064d2b311624d2fc326bc98c2e525cbfff42127d0f9f6a6720e46524cdfe6d4904a4745397d6b50612b46a092b10c8bf34f4ce7e001fc6b955f78575b425bb2a8d8233fa39859a95733d674e76a8adeba082ec344b6c680c8d6d8bf779f9f753f8df1eeb327e72ec0cabe1954ba77dd68cd0f9a00f4bfdba409c9e03f98140e182ed1f86ffb40a35e054981f7faa609f7c13a6349f1512c43f48590b94c351fe7f5a0074710d0d5c13fa136d02640bde8227fddc92e4a1016b1a0feabbbfa30e941c843d6a192524df8bda237aeb88ea6ce4444db2839c483d0b091be96e869eda959910ff100fbf1d810b3c9a787e3386a3652fa36dc265f751964f692a637d2b8946971a6c6de428187d51db22175bf6aad514eb7c03ac28a5e9b13c937dddce47fd9a16d03327a68361f2e2575f8c629b95f031d08993c5b4ef685e1e7e3814c9de71c83f5bb309a37b944d037ff17923279b0005e87781c37e9cf6787309b83d8cdfbd7ee3bef5354f76c27f950f2ffcbeb7fa6cf7e24028156e50521ecae9d2584882866ec5276e272ea2aed7f217cbc78291a82af043a497d6581fabf9838e5ec356c6645f45d109860ff0115cf2b27ab980d6f4271ea517a73a72d21a5dc1fd181573a823ecabf45be8cb107c108294738bcc0914f0b2def3ddb50a0e4e92414dcf4ee7ffecc81de05066605cb8e4f760959b058c0ffc433b6f61ba0de61dac42193460b13770fbcd36fe75a18135e8007c59a428444fb7b4ac7d053a88ca45fbaeb63c7b5f534e7427a8511b8311e35e1a744d3ebb4b26002fd8a01766bd70742a920cdf975fab7f7fe24aace4939452ae04a91b3ec7d821a5a3ca58548b0dea9a8ff111c7d55e0adf57d5a89591022e9913d065186452f09f083b9896731dc037c84907aa73d7f9e328450afdc9158498c50eea8434a800cbbd8a1450fd8f1c727989460a3bb3ab63b4d596057eca055163e339f366f24e9f1fcf04e5a3f2b037f48da115d4bd95ffd3d08a0fee109a6537b40902e677c56010b9ae6f3a58facbdc17dce0c807a3df180407614606b2271f609572a0107d7d9ef9fcd97622c12cb4e70261ecf70aee67ec9b7bc301f2f3ca1cb04b63a71e1270a867284cea3fdc5b1732d73a424c63d84ce577c15b0e8db3e843ea8456e2abd77ae9307fd616deaae98cc62860121c21c5c9244b119d2af7a08c3f063e1b08ac2d6dff188167d2d8d52e9d1de42960ab5a8e23ba3b8e86310063722299fdbe7a212188fb7370e225f7ced5786c1034ddffd873b404316005f2efaf3bec376e26a5d2092b24fbac4d17a94e4375d5750c5bb232725d535cd8e35a7bda82545f3a42f3b20707bb2b27cd04d330c767af4e08f65f1c552ab5ea8c63d32c6c149e568a88b4c282342a683c4b23dbd07d856927b4734e5604f177b402e07aec94217dbe01531b1a82d781e084c17fda3ea5b100bcc9a3b9cce3a5b2b01ef2e6a3cd9f441c6c08358fd3dcbfaa5fceb3e945a4bda2d118078c15f76d92166b696f811a8e4298d610424f0f33cfbf1c856b832f89248112c45594912be6394cc21351255a3f0e00851d54cd3a526334d4f634dfe2d521666abb236804f116ee15c3f385195003119ea6bb09b399109a660b827c88e381cd91d64e562a5abcc3bfd7b8ea04494e2bbd68c3c0ae0a45a9bd418bfaa987b47067959c48ddedfa3b54cc08823f8ade55c376ec53e418df2d2f001734d4b02e3a1b3d1cac3e2242a793180c19a31a514d1e3addf67eea9ca1d19db183d2d40cc21faad1c9df2f8db6a35c91f9219b7953adb5fc777efbcf1d1426959a44788a4895e3605d02c9c6d6b222f6bf13e76a9b9d33fad9c51a6a1755f37c4cc6862a7c3c592e233a1e4fa60a6ad5805290247af5be5adf61b79122ff27061f975da8706ff5e65848c916e957978f9450f57e5f2212b7a3ee645d15642cff6061417e79e0a0725d45fd9e3f7732bf78758e9ae2f490109b5137ec83ef7ef174506caf585b7646d284b1635ad598f156b22c208bfcd19c35922e7698999f5d8a26155333c53dfe6bb5fc84f7ec053278c6e53354a6a5e71badbf8cb2454733e1f48a15ce72c57583164ce25bc98ad60e4910a07c701b17338a66def3403d45dc56d94672590379e164ae2cdf08672f31aff9b42ea822f2a9453efae2b3073c8079a40cc816b140dfac1ae8b92552843efb9a29ed8a54e3a4dbcb7c624f45ba8da09708ec275e0954fb384ed2a637a1ae9699e80b3bb1ff63782db7ef81c573b0275428d673f89b3ce1bccf43e75edeb00d2667dea59eb7710dfd5fb2d81353fa6f4e2f3d6e17a8dc9543d82d2a4048ae3c7b3b206e4bf7b70a73089ffb62e2412e33d2bd787b3074a58976e527c852e3f5bd76cbfe4158ae9b776b8eebb66f14b3a964cab5f718403a43abe7b181700892dffb204975acc18246347c164aa339f9d51a973c916ce481210e28d7289bf1ef18ba262569088bc146c84794c5fdb2e15fed46c00ecb42ce53ea9abc736b62e7955ecce616097fc0aede23e3b48b3a2caa62ffb4622e20ce821c93157e8a1491834f8cc16dede37b3638cafad9dc99219cee9e4844439b95fee2bd1ecbfee47641d612442b980ab529d6e37c37f2034707f203d3469b58cddd2c667b002841c4537514ba95902492c02c8b06c390820d919d87fefaaa0861eca92191fe525925a9cd79793f2ff653f6af6be98102b54f854e27902c2b7db2344eb1b6a1c55ca2cf2929519be7e9cfed4313d41733a99edc958b6f3b1bcb65c7254bb4d2580732a84382acad9aa685e421688969c83cd0412b381deb718ac8de0659783f4b7f38afce71dbd311c46c13cb91218e0634edaccc3c3d9082072e2a4469288e43ae881f4bcb061b7cd859990253dfcd0227666331aba38fd5984cd3febee9b8df6f1fe2808505025c48f17bed77f495161c1522c5078977474dd7b33864a83a286af563f788d6c7cfcff98e8eb61228d3e1479237b76284d8fb5c4e806f6fd520fadd6bfe85d41b7c40dbead1d8b407ed68c0e9310e139b1df51652c7489dca1eb8afbf6027ebba8f037f2b1c3c3a2dea2c181c0ebd0a54333a9b70188662fe5665155ca231e9ef44db742b9233b6daee15f24d56a1fd69b8c4fb40e205fa367fb7ada1ac67bb573f7aebcf24bdbdc1177c4fd0d1ba4a3aa3a00463a6a93d03e6107b58cd7b6cd41f237b64b31d3a74ad4995d59971f2b0ccdc48cf105dae4f0e1e8ec6bd51ba95d0ebfeb4c9ed024b62c30a0083cbd59368f5b7a3baac998cd83eb72fd733f0e1357928dbdc0787d8d01f4523f1afa6dc4a21340ec9fb75d4eb771761d98c50be0c88b0b630fa1f8dab84c683bde873060de574aefd668736c689684b5d7976b4a39b4835330c138178c16c5d60d86b98a7315f83e8ad91170e189c58e3ea6c89596a4086fec5f34a1793a0a3908525363cdf7241bc63dd172bf12e9f38b3be82283a299cc2eddc031f756f700236ea3b5ac41018ba28b43343eb88344cdc486422a843863be1f40672c8352de5eaf0d6aa69c9a0aa166d0fd4d3ab44f4450f5546aaec1d966840c83763bc2f3f0d84287ecc5f4fe15545606070acb5b2090476f62dd2cc58ed7fc6dda8c4d4375fe35fe7c253bd38662da952122b9a21cea0a78c60e341074c2e09ff11fac2f407504c93fe27c39202dc6c38036c1c4bcab9e6197230d0343da770d4145787dc8ffc02e286019d2dda6a1a8c22f754ede1c2908072fa0d599da656464a5e3a1c1139fd5b9e19c47f90085dccecfa0ab5560ebaa030e810e9ea7458756916a0060f83e3d0d00b2d2fb17c1670a1af534a990da2f130bf659baec2cdbfab1ac99df0c2156c8443dfa0ed32ef9061038fbcdf0c27c568febac4ba49512ad5381e234ef4920b430ca91c967d99e62db9a12c49e38f872ee0d3ddf261d84199d7d483ea528a75daba58468d792f7494b5bcacf2365e977cd4bd8a252f156d4fba586bc84baef97ca49e4f87065731a67847978c4c297d0149478997061087d8b8ca42d74733fb6c489fd8e300af79e292092669fd6f5812a191edda819a9f6f10eeb26ee442c75d8686fa27e27c5945e74ad9e04ebc30422f66b490dc949aaf4658343dc3edd8c4e010d28f6880bd7a54078a699da7f229af120306f95269b8893a950047b670fc434698ab29ee984e41dc22f5e5c199766e8ea6bb5fa1557d5ef26a08d66167887da2ff5ff9fa54f03883ce7a91b522683ec3a3021b79af13d1be18e4b44064e458a36bdfd3005e585e2576746c5372af786340fb929ba6d02ad6175327468985e2868ab726aab635dbd3a6fe3bc1e58f4ac19f621ae1ae39b828d56b5dc3fd33bb2c179a4d0df914c8b8444e29c9e973ba43361c7d719ecc23a97d110a8cb3b90210bb8ff3b69dd2ef10a525971368e0d537ea044f54a0cd0d398ea8a0712d69a3258ee3bb168de44c6aa8e577adf7474e9f809ac0951787f75921928f22b5d9b191d3954822f33f68e1cf10712807bee1025dcb889475325cbbb35b318fe4556fea73a8451d78b3c8cdd4ba246145ec792c8ba5f43a6034cc098a547d14b105a28eae6d35f90187e75f2544ca7c1a2755535c7e562a35a2a814e1e13b49f5b2741b84fb1b80653fa4b2ecd9abb7292642bd6b61a6bc19b25d2c530b6b4155e34f10b21b601f1de5bac0d34a0552f47cb51e99499ff95da7ffb1cb558d46aa71845cdcca0d660f2b8860bcd19f2a338fc9077c296c5b4eb10337c868cfec9947ef1ea7e582dc45e143d4ec83beef3eb8736aab63d35e143be7b8abdd248b2995d6321008951e1d4169a126710b980ca32a416fc42068b963c2c07051b0be8708cc4cf596d439c31c60924a8e6439036e1a02097b5452ff0354f28808b9de098aa13be1c078024ecd44ac7d4a0f2cfaf61229df8729d0e69241065fafe55613659923e6f3753ebe36dd28ddb2cfba0126a0d43e3017dbc4fc553720d18ac42c0166630560ce3a03c35f80c4a2338ee8eed6be4ea42fc5c87fc2fcffd7555143a3eee3a7e8e0fb712653e0517e3f79b2aeb8f75a61352b8048485915a52f6abbf9c0d387e5f55402debf0dcd1cd39f52003abe2774345e318cc32166a87c7c241983f5c25f20217b18843e471a2784cbe0f7340d9cf69ab929cdac2e79e2d9e7438f79eced02d8936ac805c75d800aacdcc460651e90ca56449cfb0bcf8eeb75a9d6bc58de6f85ec1f9a8c53298e4cb36a1622c2904882134f3381f35490fcbcef22fb4323f3e2230ebbe39cf734b36c864310de341dfe8eac92da829e79cc98a442eb697fab26a910a60ecf88b2b0fbdd5c88c4493c21a8148591a901da66f8f64fd331654bdda0e13b386a3aae2d6f8360d1fff724248afb718115922b31f14d8373014b0140d882a7950285c15a69b2e04f4c6c2afab05bd128ac4097973c7b35b55aa8a021b6ad843c044213d81075e4a589521a508d2d3c7495425f1ef9f31cfffe6d7ca39f15e376d74d781b71877e4dd02858b1714bcd29d2e588fe7080ffe030a6d276cf8efcf2efd22e2c88850b5ea6f178bd019ff106cf14ba88ae55812cfcbb4f8914605448dcb7397fcc6a406e769b5bacc134688bf472592ebf4b9dff4562c3100870eeb2e06ea75f5a4e950f17f4a91385302a4c2be4df14561fb65f2856f51cb2020bef080776541a3e329393ebe8b29000d44d0e0777074b9c197affdc02d7424ce7a8c898f8fda375cb1ea61aeba030a6fce550caca230ec5bbdfc5ab51d80a07055dfd872052473a740a6a26d8622e174dec48cf25b59747770b098453561d7eb5ba43e89ae4479ed83fda03224d4390a2077222f37cf16469180f4f245e43e9e26b6c1006dbb217c586fc5399ed624b0cc856b273fac6304697786f152f8d00f8c37424322d7b7826cea02ec5ebadf0efa545802fa8a87bf4e99f91b94fe33ad3dd154a0d2b986d7e622aafe57460b9a86341dfe0db73214127f402cd683fc41aa9c2cd8e44e174692ec5d79cc88fa234e91289442a55ccf5080fba75d6b46918606dff9c677c5897114872c35c035c3f97196bec14bdd9fb6817a8e7d422235cf2e1ab0c1c00d070fdf65b52627cb3360737f90b4013a5c7cbfa09cfadaa0399bd9daf82fb7ed1be810cf36e27ad06f3c370784c7a8e19719326503df8fad004e987bef0836b2a9f0a86be662a1ab09976815d081cd7fb8b600fd803b6a7ee9b852ffd2483a3a2e706f7ca5e77b0f47d94e8e5aacb9e7e5af13985d100da52e9c55b6d2912130a506a5e1e9bf5d7def9efb96f4bdb5cc22efc9bdc205f33d11d50789389f2ab918710fd04a4f5f3b7a70003075d52d3fc6b75aa5a9c89b2a032882d061ef335f07ba9a7ebb48175decb6229e4a58210b1ca4cee895249a1332a133a9b253d005a6def4da7f342bb56052b99cff01fab88fafa0562c39e86e4f6a345a18a8a98963a449592d9a604795624e54dad7ca473480733241ff541b49c046ce4d0c97fc42dac6363a1352cd1dd625da3b19751378a4bc1c3c11d3269bf33dc69a5c0f0d336d66da5967a086f28ef83fe2109a218a36f2582a6d963bb71d014b87885b925d32d138313d75a01a8328416bac2637cd4abc14524cfc466ee82319f80736cf43125d953e58af7e079b5aa1d5cb23c0392b7eef729aca5951519c56f38d725a32241a073966626336f6af1efee8e35b765a694ca28ca13eacd2045f766b6e58e0e4495c7ea00b28a90fb9146921645ab1f89cb4b8361b2f0191c90942d8222c681872d164375fe56b2871e0358283427d235df82ed5d024a0633f756577c62ec5b1cecc400e8aaf3711ff451b84f045900606946206a7c3503684690421c181388c60c261d36f8a553de359b51c9190cf79112ead09bc0aef594a1f1b2345e67019ded370d4372dcd452ba764234af5a1af079ab057f38913bcb739048ca058b1966c7a87b8bf2b77a701a94a9860e2396d857f80d080103238e37612e984906600b753360be3c6b358130dc97e55f2404c29f9e550c59b38a9cc10c80721e0d443a80e215035f763187d7efa1846b810e7aafb125909820791ff34818682eb1ece2a6b38c2081a88be0fadaf36a89012056d8aed423f47da3f708d7ebace534cb2d3551c4b61a57b2b3a2721cf802622fe70912d1fbf88ff8a42c27a9e6dc32cbb13e79c2222535790478197fcda5fe0783e2eae0a4a5c531039827e6c83bd1afb131e2f959acf02e34819a4ae4d67835a59e0d9944e6beace2a968fc47a9ccb7ffbfa8b8c2f75ec6e33dffac64ff35302ff63b2df26836a7e00ce25f0819640b884a7620aa3a9e2c4881a2e538a653b8e042adde10b7de066f10b0437bef00d793db6d6f92c74dda6df9d60dad113d004d71529430dd68e84202a84bb14e051b1e6203e237b27676768e86c63ce3218bcded35bdbf558a6abd96a452aeada0dff75ad1cabacf71590cecb4ea42d79e8afd2543c2e1fa32b8a49b9cbea5c8d362c09dbfdd11938db094e17a74eab10ab0f2f3c46a30403ff87e82787ff01acb059c6c2ffc7228eec17cdc3714d3cb4e50a2329317767714760969d004710a34b816e05558e963ded9ee80accfb5162e2f9471479075306a9c32c41ee56e5f522988864a37acce4292c38506e0359aae5e1337cb36eb124f8bb03d0d90f427e046a304c7fa8b3ea38d3ecd4ee816bb4cf4c65b7df363e2a71fbbd540377235a6de4335b7459078baf7b022e5a9409e0c926d47a2b066ecee76627f5f0e7ab4e30280277050a54f511bcdf89065d6b96b81190b885b63876aea449b4a52e79c4ad132e0dc32dffc31a01a8ed94324caa88af68e514b8d8b8ddfacfcf556dc311568376542cb44c7b40748dfee725c59f6633bf483f9328998dfb813782398f9b640a43326e99baf4ffd3c9559163a7b0f30bddceb71132ca0bcdbd3c2c0a785b885225ffa3bdc4b2be931d6ea9e1159d7f9b2b00530f2485197e99bf50b7c0ac63db6298e72ea620abd76ab96f589305b646b739332687cfadace4ca2e7869fa4b8f10370815fe7d44a8f37c804e83025df967ef2ef40d928aaa69cbf3ce8cd79606cee974623224bc7b4dd3945150ce4b0b3dbe15e780700d29aa8b01b3e8f018dc3fd6bef6aa0cded63c38ca24de420f7da2b4a9139605a11ac54d158981adae3c382653db917460c1ab23623feae5f001bbe0f07826468da2ffc4e26865d2d238b55081c40b9d54ec04247f1034a31d3e8a0bdfa4f80b3a91788ed8cf787288751e067638c02ea20c3b6a45a2f6899155bb216acb82449f78910623b109d55f4fc0a59411f72b4190383b034c12c548338bacb68469560928f00eebf0802fbd8b0e57d3323bd9dbe173af08897bea10d860eef79a9146a1d4520c8375660a75a05fc5df26379d49e078da81060927586ef65f62f37377a491dcbd8ea1ce981e53685cf7371eaa56bed5d652c6f48f93d07f7b73ae4e83a7b54b9aa554efe3b3918f77e81238b7a829a8eede2f8810880a4cc0f92d4dda7bb13dadb49fdf27a02cc4c6eee03e74adddbad74abf46404eaf3cbff109bb72f9913ec44b132d81160d6470be46519de4dc42523bd4b053476693bbd4f8b5f205a2b6b15a0188520456a0c231af117fb7c81554713f955c982c8edcf4e444e4f4a414b9d36bdaa419c251df1d7e9b4d7c86f954ff88290e029454a74e9500482e10a129a8515bb8f920608a2755192a79cf5efead00b3d59b8fc212956b46c1bcceec63b6a02b4366012f6ebaea0ec4c06e8d9e926f28ff7bb6211b74a0ac77d41c4086b33d4364865e29b395b9c897428553bd54073673d014a9c52c0beb7f10a818e8d85e5cded27b929c955432f35ead66622966964e9762d45267a698e01729ca607b36ceb645b2c7aab25d9f93f2a40fdf7132ee7163b0232295775374442d4a438223a1cfa45e07efba88fe2329f4f3571e3e3faf128335d83185bae18f43dbf7a99dedfdcf0cdfe71833741fd3e83d78760e95670b2cd0a376622ebe0503263ed22c54fcc0fb67cbdfcb4bc329da6421a4862ad933f7e536b7bc13881ce84f06fb58ad452666effe5ddb741a21c170c87eb044c6527f99b62bafc5bc2fa97be3f49e6717979ea8acb450d5d1c4f1116dfac948e038680635630a131cf0591f3292579f403b0ac5e6c99caa28cf79f6fa6444ca2c58ec2e8a2733f2aaba8751269a62c8dfa9e5eb44661ad0142567275ba946355677c66439ad7b1b3dd770c15d75da662d1013388b887d540093f7dafcaad0165fb7972c265708f563a77eeb56ac05d897e8fdd054be730f797fe9c2b4928a7451045acf05d4b9843f9cda7f8c145c0f3ec6619129be2adb7ae75b7a8e3df8c0b8ccefcdb96243a6a87de5453c0ac1a92b60abcca00c9c681e316214b39d62039fa97b9120183b87648689dca9f01b4e7645f0674d438402609c79679c7d173d984c818a1c48b4a03b1752fe60d5177b7f6d14ec3fe13722019952ae34f0b05d66f873b1be76e8dc6ad416cd6c2d78f46acf0fbf3e4b60118d1e6cf3829a9ebcd64ab8f892045bdf520576a4f1c6bbcd1b6e6ca8312105ae5fbc3de36c20f0626800d71cf354909c66228687cf38ce8385502e741ffa5fdfb2bfde1d40c8158be58191da6fa58dde2727e83d1dc2f2093b14838bd3b9b83a10d206dc478f480abe42c0547c3e28c6c0f8a8e29b5608617dcc99605c8781236dd0a18d8a79b9f00ca994880b9dbc6611bb7a8fffc6a945b95d977c0fa67c240930ea693c6855b8e293a957e300cb1bd7610ab414ca8234f051ee3be145312bd8e4eb6f39689cc3748b26998dbcfbe54b8d7f7208e7bc4b192692987d55be477615a3f14c29b43885a600a92d2988aad51926ecb3059e5b83fed4c0a077dba7c073614f32827eaab7f2037e200099f2b69a821f1a786f89c315081cade4459b419fcc506332476c689d34a454a5abdcad1224bd1808cb17d34c62447a7fe1294bab9fc338e7550810c6099617f3a063e4582c1c64052d02e05ce58eb326ff62ea6f3ffe474494c63da362b4a1e19821b3d9934587a6dec475cf088767ac52ded04897517a51ddb39a552e17d7410caab729b5888cda4d1e3b3f83ecae0ad99b71628c5ce5a18c07786871c9dc02d2058dde7c344301ddc1257667cc59b7a2a8d86bec79ebd27705806706d7d9ad6cd837fc6195504947ed9e0835355a3f1f8e1430e7d4409a9218837c18ba9b8ce9e35c9493dc51f0bb96329b91388aa635181261f3afe667e3b0f0e287e72766d9b443912f74d12b1004f0a812397de2877a78c2bf84e362f0817612cee3c2a462d2d1dcaf9eb16ac9f961b334f07edbbaf4a2d78a0090649a0c695f8d6564cb74193d6ad7f1e4e5e1bb9692f17a7b4311b06a4159dec78ee7a75b8f8c8ecebeffb5bf6057da80ad4c3274815dd4c730009c4eec4b5637b14c2f1a0b45ab5c69db8462750d4e60deaef1bda29bbc5007db83037a13dbb9d55844968cfc217c0ef4e0095dc59c75412f89267812ec258fb694855571210fa2e44f72a0c522a394da32990b44090db312cb220354a5f2ee2df6cfce899663ce340517bb9854bded63aebfb815beeca2775e71789521081a04c5bafee51cb777cc352b9f63c7414db114f98b5321aa9b7d298bcf9acacae7d4792885f20c09f23aefa81eb6fbfb96fb49f8efd7bb907ab64e679a7a1f77125e2207c3aca9ffb5a718e8c6644321a21862b2ebbb3ef5b6bcd385076aca4f9c1fa4c1c414f112323866d288be60d52f81963d3779df83334971f516591560117e3d1f779fffec8c0361278f6044e448910c5becfa882e15eeb8b7d7b56aeb6daf83189418f5c3522cf71ab8d5fc76f1b479a0fcbc63d29c1231e90b797ba7cad0e72f737ef2619862c894db0e9a97830409b8daf39534dcce7e4db35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
