<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c1b387f82f9d2dd5ddb1c6f53722cc6a7c0c7449f8143cb2feca11315e7c9c627db3496ee528073b9c75a76d48e8c17a8fb8a31ce9da5a35b57b38814c8644ccf7390947dd09806f8edde775849f1c871953b917dfc8e137fcc1d94070fdef16e0c5fb4e8851e509e306780632377cb8360054dbb0b5749f42e0815e91d9356c9a828c7d634ae2ef2486a87abbb32945226e302d49fb0940f7ccb76d4effdbdb160d66281fbe08829db72135a7947f6ffa0196df3477f0be3176a2629143099a97ef6ba4d3adc8e112185dd96d9ad5943f59395146cbcd2070c417d55a31c09732e8315debb4be7c186ff0bff3fb242a45258f8492689f931a66982a1e9d4447fc2d01b5bb4bf701a208935c82d8b4d04416e5a34596c018f76a46a9202bea32025d6f142c9494917aaf2475d4d8e87cc7ffb4b30fba19546dabb2e59a5379ce400b9bf2a4784ef635c2e14326c1b495e5d5afbdd8c79e6cae5f21e8b74406fc2be9103de4e4ff4f8912eebd9e2097beeb152c26a1787b0a1f293b6971382cd87f3f5b3f33c0fb53ee89ff038acad94807cc93a78ad9243900b1cb1740685980837953ed162ff68d3c3ec96dbd467f77776189af413b2e20c92b67fc52b8e95b652b49d2c0a5ec743674726c6eedcddfb6f0827e657e01fb8864196fed23dbbe4eb1a0ce663cda1a92ea5259ccc5fd09f95ff9de18893c41937f55dc9a74af7de4436e010b4def6a4ef66312397f01de50fe06775b54a4c5763b39e02f779483c37273f2d76ae09aebe3ca629f2cb1df437d4abd6317a304be8ac0096e5a23f07aca2ab1c08d4b596f66b67733945fcd9ef2eef797e90038effe28b95b8cd854caca5a108f836df5ada45f502d1f530ed10f64eb13984e4bfd0a0ddfa31f42b53ef7f5124ceac142a155b7f72177baf007f9d4f791b58c76119ddabdc68c61d97204db50c35743f2f536206752f0db30441fc74abc1841db9cd29cc45db7dac9ec79375254f5e1955c6dc5959a89e2a13ea3e2f2c28d21698739eef86af360f6a6acf89f518b43ee126074030ed2c626dfe78eab667094ddc0cb70d759ae8f973af0e3d8a66878cb8edb92ebdbb68e31f33a90cd9adad483192065e2aca9e2dafcc7fdd00e03462d86b3a1e2eb5e020a5ac1523d56af0f077d791871c5ca28599b8d9d418d37807587e721a02388818bc9d82887a39ecf14fb5b7af1521a225984dd527cefc74c967e0a20e37b52c6c460a666c4f2487ced6ff2b1fde87e896b7b455d07e942ce1d29e1a2bca8c56cfd75e096286deaa180b0251228cf765d4962be2e28f442958d4f3de224d5cbb425c082965a714a10f605d1baf8c3cbf1aa211b120ab7c84daaa837db2dc5b9bd62dbdbbfacdbab2009aa367fa3bb9c758a2f16fba8869329339d395e0061cebffa7f0933444ce747cc74002c14a2d9c4a080981c0f9fdc37006b957eec78e46031cd86fa6578d9f1dab4636988d83c1c93011bac584ae7fa6a2b36f7ed32e6d8e37cb40cb54cbce4467b8a97457f00d7659cf3bf6e59bff6697cd3510ca655b652ccf70bdcb762660ca056a2b876fcda791da0e7f6b7cdcfcee7e5487ef809690b130c76ae4eda723125d6fc4df430629253d9c5924444377900723ed8d160f0eea55fe73b08e9e8bc47eb04b6c65dbbf23de8807adca26c82a9bc91ade5794346a2a6a12c07ce48cfbd07b556efbd723002d29db83e294d254352831fdd7e692f53804a93f0c8bce892fb95a460396dcc35870eb8e1d1cb37c2542a50bb8bda834914f14625ddc8079d40fc70cf8af03747a601fd13a54eab3f00701514abe0a0d552037c65df743b47b4bb2584773296be14a6117c64121b08eb48dd6bfc52572a143e6aed6a79b7d31d25ebe66a402fac240a1fbc882dd6c34ff46e1bc1dc060688622a0168435fc9c827322e12e85b9d059493b87d8cfbcd24cab9b31bd954fc00a85d9f6202157aa7c5d52626bd13c266e39b6a454714a05309712d891de79687d57a782f0c4b23451bb42f1afdea358dc847fcc732da3756842e47726b12bf6e00e1f47c65276882791a02a90b1d3d376c174feb8cd12835ba9ce7681d3830f980193973c82b7b9c95048937cbdb821fb5e7e9b22cc280a2bd7acc7ae9488ec8a378106e57a0fc9df3fd811a620318bede4e490712f940db9d7517c661603e3bdff8a8762ade01832632ead8aee40f819c492f579a379f1a80c4135211312cf659f3b5c8288f66f2492866e63081e8aa2889d7d67f19f461134016d982c79c4a1144b3d977531cb10a21347b46f3bc89c2c245590ec6749068337663017aef243d9c5f6ee2b77268d14209af53a16d55661766e0cfda037339f29776a8d267e905eff1f07296d6a21827c911842e5cae8b6823d6a3f2a81a0dc96eb5f571ad637170062e65b3affbde7328e3ac0d3f6338060b712b319c7dc9edb617f525dea2571e2c9190ae612e4720785764783ebf67e13d7004175bd8e7f9c3dc4fffe21a2ffc19474de294fe3604c7c5ed59ddf8015e73d4c7cf890d5d8868bffad4c1e0b1571bbbdba8212bf8fae57e0e327374232a28d7c27e476157c2412eb6019d3ec94f7f190b2d42ff0406588a2e7e118b8d72ae002d99307cb534633c10f277dc378bb5ac8d841d2c12100106f99b30deb5432cff3c46b0e5803e08ee44a386203b4caadaedeb6800604152f1a288442f4e323117903b760d665e58081a479a7bad68234fa5c8405df141f97d0cbf88ecd36cb78e245278dda84af3e759cb432ea6203fd5df47c3ae8f95f0c06bd992f4a289c1f6f9644007d31d80ff6bc42b9a9e45004ab2e8534d2ff4d1027f7418074d4961a3c2d7c260420865c0b2a4f108f5b1489ee3b90321f1d7e6172ae0f3e379c62111a02f099e4c356fc14e08a17c0297ab986fa9b7b72bc4d2c71e804b2b80be4e9fe3f714949e059470b51e286409e714c5dbbacf45b87a9a0ce24a816a68d29ade11433cd021f62ef4ceac394db73d1074c6c0d69d712f4cbcdea8bd66e3a2d131c90bc4254c226c96367c59de49932443acb3374165f28acb936b8b3b8ada7a17fce6f0a609519c4ed67b78fb174abe8ea8a8d9db835d14c2286b832fe7aaf1694568a0c22793e9a8a3c356b137b2dd3508c9079b65308bed244a76e1fba196b0677ce63a79171f5e405fc4039cbd653b5ddfaa09a9161e0ff3ac0f16a113e5762ab7bbfbc950150d8dd7b4618e2429bb7150a5fd71d68264528e31c8c5fb3113fab295c78e977d7099bff6a5bcc26c2c7e3df28a1288718cd69fbc1a69cb37952c8378fd170429b8f46c73b7396c2a2aebf7bb98eedfe01b327d8728284327ee3e35aa79b5ae418e0439144e91b0398256562f4eca668172159515b13389f02fafec6fc9db5ab67c0b734444c7d73f6aced297a23f4fdfce49864e7985fe644bc08326c5b407bcde51a173d54a8004a351c999703758452f88cefe23a791fa4fbd4ae2b042148a0b9a91ee20b90077061556252caae94676fb540d7b19c1ef48d4bc7e888b4a5ff3db6880185c9b7df651e8758d18713b51bd1ab08405b9bc72de9ee852ef67890fbcf426d11968fc42b7acbeed3610e3d3d4ab5b4c33bdf82e6176ca8f906c8652eb92ca7436f9aae76c297d0de3e8b992cf73ac864647d26d771dedcb5d31dc8300eb89ea1b0279f6ee4308c77f28d713879cbec74c26edf1d591eb5495569b4132e88d8045f58a5fa7093b0882324a3abfa5f5746c61274b4c4b34fdeeb59f1706411b0ca1fa0e9ecc6bdb30db0b7c7d9bfa71d8d4a67647e9b74ced94162d6414d9e2c6cd24c5af27a919144e1568547367bcc556df1ad86486bc9c9066fd24c8750c3cb3ea317a1065a8905eabfbc78b399c2939ef68318db71e788c95a31fed42db0519cec5718a5e5ded6e58c891cbf0e2d4e7586f7ac3d80a9c09464f794a3ac4a2cbdd2d5898a8da4f980ef2573ef0b2b6fb56f5cbe3c66396123530064dc41f2fc708fcacb0be9b7ab2a869f49e1b82b54a7e685333ff70df2ed09de6eb7f02e2487460e53089fb81213ab9bdb039d23b95ffb698d30bba49843e87ccb3d0d8e269eb6d2b54ce9de772b829612044d8feddce134c44bef2363a99fe4ec58de5828ba42cd919e5b0b805cb9715e91c4b63e96e1e6d417e8ba7eda976ea25cdd49a01812b46d7636fddf4e77db49eee5bbca842901b18324c60232813d3f67b5f65d6c96410275f507cc1e6964cba793040a06fb249b51ac8578f12e2ba446c444e80753c0f6f884734420cda6106e314a8602a53cbc53cdc15254b9a1141f1325493f652248e4b755c9e7a84224fc5ed368b8358f7032cfa19d98435221ebc5f060cf3f428a90f2a6a08fc8b159ebf5f72393f9267a49abe99e5dea7dc4716732b09e492aafa9097b47a785d9c768885b71142962f8fd4f68db92d8c162c9c3c3154fae90ef4d8ec534b5c93685c4bac238e5b716629fcf96889839f4c6535779f1a51ad4f38f2f68c8c219b4c92adea9c81be82e47c4fa76924d3736e61bf10febdebf64b62f062a66da0f4817ed8d9122458d6029510a3824064b7848e3eeb8e7746020afea6a3b97811e6aed9dc91d920fba347f0b843df4b4cf4e3b348b8bb7a39e5ffc9ea5fb84394cfb7872eed9a42576150b09a1b6150b133a0abfbe5a70b298c9f6c042d8f072eca6cf5d6bca841a584d7ff7f4bf8fedb310cd212fd03a15c6edbbb28ee591a00f0a1228c225ab25a71a10e5051b4667e21a1bd90482ec1a294c4761884b668918fec6ce801ea63e09bc0e6f93fd9c6f8c2eb445b9b32a58d06dbaa8d459c8515da50b72005ceab6c1b9230f4c0938b50d408bce14d62c8053d0a1e7e075d6074dfb07429d471241ca6bff9e04e7ae62f2819872be44d59206c3287d68a28ee979715656a6ffc3daafade372070437ab81f57a9e00ff5d0940652391be7a96a9f75e0c44b2e0b60e16fa8767ea6e4b9e07de85d3f7c50d1d10f170a3500972f73d0a95631326d62d4b16e8cd93cef2d59899224625fd4cb15d122251acded7b62f687686e36f361bb16da9750c3d8703083d07fa967488e26ecc97b45e0681f050afef5ecc69f9368f78fde07211910275d9f37ef55711bbfdecaebf61674765fc5247834ec5c6a6afdf5b5825ae8a3521466438c88ec4e143398212462d62e8e5427ec8a4248eb556c9d12f323bddbc785ce0eb5df44ac8dc9d8536aef7f12432430bf8502b04d0c28d551639daa7b56c562074a1e8411d562e03a4ec8b30a4c41c866c99a1cf7bb45b664ac05e7d90e358ab04329423d86724585247c11610fd3c0229dac47df316f49baa44383923010fee74584a43f1f5425b9292c381128348ff4576fe3ac405a95ace152aa6dba327a340a5a837142f2a2e6622b5e5defa5b674fe84572a7ab046f68bb8dc6f40b16175b4f3a240f5a2ec200b70fca447012dce66decea23d989c6a3ee9a3e1d5af061786c2326d811a2c46b6a4dd6bdc861fc86ecc5ab88b04db3c7e0ca43c4872cc5d699b230c1f5b1a25f9bde98053b34f5c1472a3c7488e71b1b5e70da1b7274c7efa811322ca4add71e82657f9d80ba42b7c56c8412615f754ca13edecc42eed1104ffed7cce2362b15525b1806212615e1c7a9b50cd1db5a1c52b281952768d831bbdfbcbb87504dba473a96e8247913438da2dd2d285838b653166778fa2e01fb75292b16359d300310f89855caafeb8f7aefff8aa71b03242ee1c4488c77b6b0e3be9d56868c1426733abf79cf9008a94e2d3609566eb33939e0d18381fef03736e083d8050265fc0be310fd37775bfbcd28e52ad782a451165f0d45eb75ac5c6841c6be9821a5c7097605ca74ba8e358ebc93183bb11d372635e6a0d7a95bc17f2d208c840da0ec37135b475ba14acbc2af6741795d5a4d239533fcdb7c23d03874aa9296813c1a711ce0f103c893ce9a4e4a847ccc5b0f3de8fe59219b6ca8ac85f3c50f67a897482aad25420a61038637df3c0f9854790066b846293076a3d4436cc399bf6707eccbbe308758a13268bf4470bdf35626ec17f47c11247540af84583fc09650b63e192753350e2744152df9e841545ba87de69ba5488e654142a7434258b52c71dae509db6af00c31e2650e3a329888814c03747c37ef6bdd33a311042b954d1562cd5aeb159d366c60d2796f09d299bacf39f4d2ae1d7934f28e7b005d0f820e34723c5ad0867e25a76973e70c53339d1dcfa9d7132f1e42e53bbae4adc766e8d68cfaa520e02dc261366f131716f7f2b9bb9a384934e1bba2452b3c20ec4768c902fe7ad5db79270cc94ef093016a14fa9b2a881928ab2307859b2ffe5dd074cb385af2fd505877648330e022c24becb929fa6bb02c31063f4747eaf7400cbee34a9187407bd52ff9c09b57e5f2f91d6b423af991bea6e97758757b1d9b9793d3a72fa3644cec9971e5718b4b32eca4573b45102f204aeb3c7ed40b1deb9788f4d6361b6b73c04ee317104adeb498f72ec8fe486a3bb63181c4248bc27429755b3f49f7f09fc551181453b37c54bccdb3cb8382292fd8770b0f4348fab4493fe7ba300ec9bbc1e91ba1e7b5a5a2330aa348f0f484fe5d88110d00880efd712893f6d81270ded0f0e396cb91d04326777b16721521e0b3def94e56aa7f83c7b7379db29b1df965b6a673dbfa7cd42c14750e119d768eacbd3f2db27633cb5b1b8cab45e2820462afb17163ec2f8a6868264b59df16ac20b93635adb1c3b33006616da547fa72e91e315dfae1efe272f160537a2f3bb44114e4bbc16867df822e233de61e58f94203c35de896adae5c58d1e38267e870f559242271440c93ce46636e6030b50627107df0f3c4f26f395afba27c37daa84466d60e6dcc5f874bf73d40478947c5440283f9972f2c986ec5947193c6324da9310e25bf65a8404806d7909685e6c131a42ca8807c5399b415f26f8b4e9ae37d063d6746ecba07b13fff6fae62070caaa251a83ac98628311005d5e8d538a635ddf4b10719540e2db6abc5606eec7c04d41555f14b6068a552f3ea99edc2e35dcdc635e0661bc53268a8c8382b5c21485c4a09a033d446cc739d249e93e3c524ecbf59ca940454b4e7ab33b29e555770d660eb2865e1b02f7bd49a0b9ad61c05353882eba1f51236612f3150cd944c926e3fe2ae2a406601b3b1f46c6ce9d358a0ffced0c477c0a6598cc0fdb119c5b48beeed6b64a07cdbd7c47fce3756f2bde759276331cf1c8568dc41436e6fff028ef5b8ffd848d606f5e326dcc672b5ff4f3b83cd9a4b44f4d23a30be1c9a21b1d0916ea588b1fda060e5f7598f9e56fb84a750d0fa21e06740c709f61eeb022893896657a1510b2f64c45547df869ef3bcbc14f73bbdee22c0034b47cc912b491c8a881ee56f57560dd920aa7dbbc7d1f87614e8f90cf99c03ef57decac88aaf1e7e3668f1b501703bc5a733f8beed61cdc97b16196483ba56df5a41157005f0cfd02ec70e5e7af69e0d677daea73045a1d0b2556aab87383f3c7f95439917798d178de0dd941f9a5095ae11761d28d25acf8b26e7594260ea4515c0cb2e77e895323d2a2ca0e78409913d5e476598c26d8f5f056f4e2ada8a6a93f9f5855661e7e1f84e7033fd32b9d3904fbed5b0c9b1ef4df8e9f3ab6ef068c3e44a3dd02d7b84f2a32ecea30cdd6f18cc2ec881e9b67f20ada23286bda51e0afc6b7fdb1c8199295883bc296feb5527ad8abb810a1607074a2f4402ed7d6f23b04a1a2cf131b9ae5f254c228064c4253c7afa17ec1140ac37fc9526e12674f696ba31c30d434ca03238da7885e7bdfbc5e6084d133b689118c305453ef3f0350b77a7370aa39fc8865b8e826b46ecec90199c4bb7cbe9d0cd84c400b5f5cb60688451f55fc5e9b97e07689740e72e7fa7cf5f8bf3fca91580c2a8f1b346c9272da7a33d8e3e14d9915d8109886c3f7c179058967d1d825d4cdf00afe9701c902bdb6ed67abc4da6444739b046348f8c2954283964a14bf86cc5ba2b79c093e46d92255fe6d765b982b97c8672acac032e251c5e8f3289c2198922875fbe261f8d8cd78653b9d0868bb999f59c06743a44094afbba1a08e9d6698fbdf90f1a941923653db031e66df3271ada8a877213861e8e1c7a601a46f375cbac09578b48887ab06c7e4c8932b76132116ec6b8c17544b48b4776e7a061c32e3a56037818905fb9ae77d8d1e6f453f0629cf930515fe54667896df88e20ed781502b1cf785baca3e135ebd352dd2d6ac06c901e8bb9eea4cdc67882cb9955953a11e1cd8e8160487b37886f0ac33f2111030bccc22efc92a194b9f3f8b098aeaec2db11da1b844f9daad28199e135fd32e67078afd31d7006ab4ea3eba5e0785db2e83d37abc8a0490f62035260ec7782c8e250c9583928bea6946e1cd4f7e0b9f3c0f4e698386bfe9795145ad1c70704f933b16b840793cd4a321272c529e2a92bf2f93b91627d3cca9fd600a1c8468c5c86029f4443411b74d806905af2e424b39935e643f02c91948f207245ebb9d4cd588f48a8c109269809c9b29cb4ea56bab320fa049fa309dd40d4ca499f80e50d98becc616eaba735bb9a0a311e28390a0612d92380d28c0e26ebb4b0d2e5b0287d21436a9d2ddc0420f787147ab6189dc2a136d8f34fe075d8aa283582c400eef6d5921c3b399c556eab867035ff80539b3c426c56cd6c0d9f6090aa6bec0d6e7179a512de22b82e728996e84f46ff320ab91fc1ad792406be89c577744612cd6a49a6945f4e015fa72242a80f02df4fde9d30966d7102fc8210f4fcf3e4b590522261d41a6e2a3efa0dd7982ce5dec6f5628fe7eefa14ea17fabf504a3b70757330de397364540bf102582cd1797d2a1b5b33f17cc667b8ec703d9057974a178b2041d289bbfc383e7006bab1e5557255b1499e977c0fe0ae6f575901c727d292622366b63f83842136ad588b1d3a925171e880ae8270b5e1d21bdd04065fd82b92e14b216b028977006da0875e58560c19e6bcb8610a196dba92d8f10129491e46a256975ccf8d55f9be5ba1b806c2d38c17b4a3e998da47de63dbe6a88643416bc54f1ec829cfdf09b88462f05a708e5344be3eadd7a42a86901311c54877751f05115a33100a7e0913dea563918b3873fa4aef8d72899e8ba4dfd982708cc9612e46f6e2373998da8333be855dd108e2e41aea0ded3b74121d09cf3dc0407ba042065d7f197c82369c54e60ff3f27cc2ee2718db80184335ab2ff363889e4f1b11d02cc8049734a7fbf58633a331fd8bfa6ce1d9b481b5c3068a90483bba3a68ac5a8612db3afab18c438adc4f2336d51c6a6de5e697da4cfc26cb1f45284aa804248b59b049bb6099296c9144fd2b9a0b08eb0b70300dd30a370932d9760fcd30f0010063e072d1b8d700689c54f93f710f7b810adfa6d7fe9bca81ba96648d22d38150325fff3d4e8aeee5470b7e98b92e8636185aa0ac63bc9666af9316a4be5bce5e8f6653fd550bb25a270161993f4141019ebc74d43c993a1c3d32e452dd14a2175c4da3a875046af229e0ac71f8d0ac5d950c5a671522c4d6d5184cef9de6ad198b1fad51aa23c83fea9cceb1d252ad7ce7ebea94ff1f18c5d7c09d9f595890a0f7f1ba03149a9cac6ff13e878f65b5403ddabb3126a99ffbccd7e2f0b0d980d1406560e4861cca863136e74e7f4af5ff1f9ec5749a35db6321d55de48551b15cefca7dacbd8249e7a62dfba30c0e070f0213cd9e52e0522811208ac3cea5d8cd755b159ade3302439e7fb38c885b12d554dd44232951f13c8405612d23b285418b4be95875559d6e9256fee4c611804039eff95713bf82078fe324bba09bce0089e2738eeef98d5872bcef134e5e26effa4046ed9a7a5ebbebdd06ca10c4454f5ec2495e9084570fc38d4ce9cf80734ba9efd6bcf0f0b53b4f67e51bf308446d3bdbe95e17e654f384dfedc3ec333001a1dadd1f7dc07e03e77ed6a30a17511a4e487c9fc238bfbd2a107900d40f9a2e435fb2e9e31acffef0b5674599d177328798f628b7a6eac1d0cb6856d1fc05b941a841cc7c0d161f7acc7c414b47dcd98eeadab0532cb1b6c58e4c2061f7adffd0e9ad52fb82bc73311a92d61611dc1bc58190fa3e4c9ec2f3ae4a930eb7ca7bcd417cef08b362b0a5759b2b41f80d73d546fd5fe8366d0f608145448ea71d17092e75b48784483c4f7d73c71ebabcfb23d379636810cf7a7550493c78309f9cd91f63a38f0372c2a90de9e5d6f418dc3ebf72cb1caed21a14bcf3bea9063d77a2a968de095a29d31f54b92ad7f2db280822e271c2aea9ca7847e68cccc7537355078698d037900680c7294dcefd35a2853488d01ee132bc29c9b81763b59a19d964d828b8a8d69d79e1993644882fc517db0d1b20893f0b6c843da319bf3878575eaa96cd06a7c7db5d27e99ddb0525a4ed07cb3fdf05bf35c9a0d11177eab8c75afe443fdc47d9bba58efa531d8d0973f9f911c79693e3212e729436ba92754a4f30ae902a6421466b6717678364902b7e68b82c24560e1c9c05a850e7926ce24462496adf9ea40dabf2c64d2f78c365f6e60c084e03b0fb127ba9f37842dd087bdf1f1098ada56a000ebccaf1e5e4e34b22da84bba9b57b434dd7a72d2c9b54d0d151817414a3b8acc9ceeca32c4caa43d24d66a1fa76846ad1570c238a6efb87ac793b18d1524f2e8f923b166f70f40cad5605d0ae3b8292735b50aacd1028f83aaa0d909250b0625172f5feccae158808689278ba9ae62aee47e0f24e772b3f2d250f81e401711b0dc5e7e7ab63710a2104bc7cd778d700f1e7197f37d1226053588fcae78b4e2632a7af3c498448c34a15854651992ed9c76507b5b5b031adf2467aa18dbc26fb7f0532e2a8aae8ae5c2a3ecac26a2bad2a23acd3d32eaf93267be9a1a6ca6414a50d44e87db3d3bcd10bd4f37c986d58a8298aa3cbe71d0005b71405a852d58af89a876a7893af153fbf7362fb4c3503c69949bca9b6a5119d577e1b868f961f20abd96c9e162e66b7dbe6668013fcb758cf8313d2e4655746c4f4ce948b017a9fa13cec00fcafc21a98bcf177e1fef057b0aec73a6e55d9be01c55b0e0182356bcae28a0fb02406a92cda8baea83ac2fc6affe8f5cd9995060f19ec3f4537bc0df7262736b96153b80c70ad80c13ce7a614f87f24f6dcef396aeb48dc36f154228050e2434dae5eac2f77e90f9ea6b4362c1aae8bab988bafa81fa301fedee1891ee073451fdaeea93e6e662cd3ba0f40d8395f104ddc9aa7d49bb9ca927ae8bb951f8d247a176213dd40cc5c26b00163a96a674379e2c42b52ad8da182f1c7652c749962443b1c4082178c0a57e0b81981ce58bbd1d1fb49cf5cda5c665388a50ed21496d687e77f92aee455a720ec82371554245cb0ee1ffa8f53d15e748de9ff3b83f881df2262b1ed5b9082f25a13584217f82261207210d6df99f1ad2e79d6fb3de3b330d09c3033deff7d24ccfe1a7db14a08c69ca10fda9cc6c7c91b11a4586fb908ba2164b88756b4dc69657a16fa313219b0a1742679a3de194cca6180bd4d2303c7906207277298e8d97a407271658b63b3c05e44df94b844e8a14224dbffe1622b8a41b1d22fbcdc44adfce02fb33464f0c13c3ee07e257fc438ebc62dce64ec322154db17a1ad4146f6a8f1d4dc9acb6c58eb54d7ec4e0d5f8ae66d2adfd77506ac2312e18a67f884937966f71f1b6df67d440b88bbc8c404685f00500b4c1ed9f60b455ff692b78ec74b8d5ed51bed0b86e74f9101226bf0b621cfe1a3080a838469cf670ca985d6af5c92f097d225aeacf261831edbec4933090ef61248900f74708c66b6ccb7b7d384aeddc02632a00b20adf05140b951539360a5854c610739e0522124432c223c09942bc6cce126cf767b649fd81dc369ee4c285f8723373d1570b0e83857c07d3959b8eee39c762aa89b249990281200380cfdc4c66a25df08729e4a2d3fc961fe725453e3fc94826bc1f9febe43846bad6aac725136c5f35243f78e8adf1019378712b3670003eef48979619d938d7466b816ed281a5513f0d1fadcb89963dead59f1eb1478cdb7e40d3271ddb2e442093cb00420f1fb59b9de11327ea3cae9c095d7edcf0942484837cd040513e589c402f1ea252df62e59739ceea01715c44014b0a7f56c3cf0ebc51e0633fadb62db5105ba25e4f925e3e9bde3fac96bb4cfae1f10a81b2538ebb5817e67e573d603ef4608df729767eed8ea9c99a985305b64259b5767d39e45814b3266c26b74516ef87a59873bc3e18830d6226940a43b99a4df4d36d7401f73d3667bec300fdada4d254ef9cc5e824a6387e5345224227b7ad7a899303a80ebe55d9b9491be6063d13f4ddaafb048bfae3a13beabf76f94cc8588afe879ba5c8f14f52e6f2cff8577be2eed8f417f275f569d30f570bc35968f01a501e09c2e2529f0eb1b99590384e78d41c9e46900559b7e7d3bf8464f23cdb309c7c17a900ee8e76d499ea4a119e515843b8752c90d9aa73bfd868372068eb486d1335caa2b351c6cd24adf53cc629169059cfb201bac146a1ea0a81e74e966d48d829216239bda25a1899d705f21dc5ae33a334c5f7966f0280f2b35ad9304e5024f8f2b17a8ae7433cb12cc90f767510890083cd58dfa7c1b84d43d27255fd044930e0ff56502e0546efaa17de93a82ba26d2c09d16926ed461c5b8c8fb0318ed8c1cc18479f3df3acceb9649e61e2f558a32f73b9f2f1da8b8430a5412c5545ce4a63e3563ace565d86cb0377c7158ed5648b7b848a94629417640c7f27208b9f6264aed5e65ff017331da5cd0434fdedb1a2001c3abcde7ef7c9135973621c5716570ffbf602501e50bef3a2e733134f4421a3fbe7160a66f559f97997cd582a2aa96f395c5de40af8a86e53ca5fbe40ba9acb0fb7ef1a7e7887821f150af224af831312c78422e6de0875c4f400b3bbadfc6c6ea6f5bc34b8a9a5a1eb7d89c8414ce5a274548ff95b2793247b33b5ae7608bc8d7efe4e7f24f97126e961ce0a197cd99f279b57aa1c11e73a34e97b453031a1bd86cdf23cb4e156990701a2e8fd6235898157e5399d9e8a53baea5e92c47c0e4ccadd8387edb22b4aef89301751646e2255f5f1c117240accd9692bc337f6566accdbc038b3726c759f8cf9d9c4f3b2b74a7bd6b908e313031941b781deac2d5c08719f3105137a79a85350ac79e484e2cded3e53d856e1be7886b66520a004d5a2aeffcace154d3508209bc5c3fa592494792a971af1a6964d15b6693099308a0b92fdd2cffd5e7c79a9f196896c982c9f19c5f0b222010f20648349b579cacb2f98e991edc4237429c5e10c66ca19b5e0bb7843647b4d6198cdd7ee7e11842a6117cdb91d6cb513260cc96e872799e2268656c33ee381aecaa001b9c535b16313c61e69954606c80048823d6da3c823d2d96d3eaeca6788f10f810ab845501555d2a1f07d8084483cadb6ee3ad426de1ae6c9877c5b9d62cf6ab7926c071526a499a320bbb31a7ff616e73041a02c14b34c7815ba668b2290a6f7a88c890502eaf7d14c1fe0199e1a154f175552fd4e28fafa52fb84794975de9cb4d7125f1b2993452d88d55583d5c98242034c3bfe5d7363d2a7e4e58603c243a57efdc0608729c394cf7deaacf0425398424929a761b1f1a4367df923ca5ef551a3b38e914f8b1bc85d134bd0f0e7dcfdc52b15bf21d3bdfe3d82398d9fbf5159fec369fc58c7bc8712e2d6513b1d28bd29337995b24f909eabe743b4730ebf631b0d0946b9fb0103310ece6b24aeadd8c8eab8e2812d144ddaf777b370ade909ecdac801711d08f5319a37345fe5ca0ec8d5e5fc15ce62990d3039d74153cea9155b48ebda8b09e1ca167fb8f983002f6f2932993aadd38a2fd1deabbcfca0405e8c085418dc866dadc5628bf1d533c537daa5e860b3b93c9209e3f9fca459d39d5271eadf8906d7725e9792a7fe75db2831bf560fda9e5df45a75ae2d9b955004c7c2a078d221c843550b9d41db5e218ad488923394274e04e2b14dc3c5016638c5d8b19b5e7a147e769e3bc75a46341160627dfeae3ff252e14e60fcee26deaf9e39936d2b8ccd810c72d8e9a2d115e9a3e2b68f75a349b17c984887fca0aff862422e8ff60363e1265574e475e6545075150631f0d95af80edf8d3b0f2df53827fc09ac2971c461c4e882956d4f2e328aa82fe84278406139799812658b25bc2a4a04830a64598b1a957c61ee9f71e7f49dee2270fc2d68ccd24332a43251356fe7a1c7d6c530ada6c3129ec4f25e8e43e69ff4c4e31207acc0dbf97e3472821535715c5f7127c06adcdd94da816e2777ef433f5656bb48ac730e8fceb2e305ffbf3cd22ebe720c03d8fdf3732dae5e493a405288091de3151b64b04005d01afc6b65384acd85b176f5c50031c002d00245d2085bf0af97d7cb54dd1c3ae47b164642efc873641e162dd46aaecd58b790b879167a0bb7337b942637ddfe315e9b69099a7f59e18a722c1d04a93c1e6ecbf504d5576b3c3e9dbc93152655ff14652bf467d61a1977cf030ffec5eecbd0b1160e8bd21306fd9eea1e6087897717ec100fc1e08c885064a21efc8b3d7638c8868d2438fddc0148e90d0ddd9ed4cf2083627003e18889d15462e00ced252a6b7c405b89938b584af0d583f95e253b7cbaf5b927c7b5d4dd453e992a049893f2e3abc486dc50ccc80a5d74a578f10a318ae089cb6ab1be2668c01f09243c842b6e4951e7f7a886292f1e7a7544b36654514f29b49c02009cf7a37b5e2ebbc85e569b3df662c8d6e8e55cbc6db6ed8e3c334a7d8a3a7533f2af7206936e1743fc99f9c941998039c82e3464c7e232e89352054b9b4cad2a54b8623cf3bfcf7d9b76b8ae76d26f2ce86ef7e94907280bc515b4fc336463bd2e0970c6d7097b0443b93e49946a0e49bc1c8ac07d1ab89c224df3e84b45dc39f77993f716dd3f0d4ddf349780239f01d960ca330bfb2e140067e46e0c78685e9f8c0992a5ecbfdb9f602837d58478d8c92fd11ff23e864f74d3c49e1d65beed3bc2243a66a6db2a2b54300ff3583273e1d1932eef62168a6416a703d7d60cfe039d961ddf3de533d8b05d609cabff13c7afbe4013ee1bce5979a86f1e1c364e95db47dcfb4000dd0b01305ee751dbe90bc522f6aa8e9bbfd8e770ad63d68ed8d82e267f37e0743a86b011228cb062620f428a1357c12e325a2443ceb6171c11c949f7629a2a6eb911521e643c97c67cb00cb9fd3432398c201bf9bf9bb0b22a46717613605ada85113529c9c59ef046dec8aca73faffd01ef49ff59b12411d80c1d211b0bbe21a90920915216cd0261eb58d436002b8823a4a5b973a4e0588e1d34ce8d79f64d6a6cf337ceadef175fd886c913759657cc3fb61fccf89c7104141efd4c6bc2194086380a78ed880a8cb31aba49ab2d3f079f555abb06c655ac9269ec3b2528e08413e10b081af1bedbe6c3561d5d158e03722db987c7422b153b74036ba6f25268512b5fab2369b49dc6216e9579084db7ce3a97d3b2977de88dd518aca9581bd32bf3631e51034a24d6b3924df970260b3c25f36c933f2ad24cdd365b83fb6ad58bb25a3a7d3ae9c8a3526b2650f2b5e59a1ccfd5b3bd9018f3d73c216c2efd4c1e08357dbf9023ce9e46b06f763466f9579cb3ce83c7398ce4628869f78bd1cd0dd2f23edbf72609f81b96373f46c49ee50e5bd225a548d551eff92168f9de8833bf334c6a79f199a873cc8b68588162302ea0ad6272530d907901b34f9a01441f8eae134cee32b093b6b5f033028f1e8fe1b04bb5b982af8a4d3bba70d03390e26750ee06fa0c3a08dd6338711eaf0b3bd52c5be5a1888add1f62ceeba53a1889a1b68cac1f189a7d8fc5d8f551e11e728cc139127a5bf9506c7fe58316da3016739a33f99a64fb316d6dd26eb4348fbf31cc5a1ba2f8d4915887444509a78197432f96ef2590e2a90111befdc67c2519c8c4d61a922a0f690bd282a89037e5aa56d7eb9f9803c567f1bf854879ab90456d96d6c06e5539548acb23eb8e642552d998e974e1c8a89663a476381ac862a3adaf05d847cb5ef96ea65484acd032f9596681661ea9ca7ae4ac8d2e2ee09039ed8cf60e3cc132cf4c7eca91ea5753292ff6401196f06bc0dc025e7e1ef80903c431eec0b5c82fae50d3247806845a024ee51cf7190b6dde1f8db62d160392fa11a63e8b77209907036c6eb12ce30e4b6ec792e9c28582bec2078f6653a86cc33ef7824e2731b5b096a70494ebe143898965dfe783a6aa5d027f9c25262c80aa1bfe7481eb6488c56b0a4862b79aeac314cf458e9f3f6d1177201cae198251ee960704d4b2b2b217411ddd1269878ed79881ee9d90ba22b2a46030e98600069a5192603817d5ad1df92410ae04208d31e1ee6e124e2d35d39bb6d5dc6261dcb11840c919d9be50874418559b20b173dff96d44ddba986ec928d2fc0a3a1f3fd994ed427b5f1081d13ae6f68180d8903bf034e8e464fbefa05af765be1e57af552933e98024333adbe62a03e1987e7699952c35b749c185aa55fd05cb2429b9d5e18f0c00170e164613ba8057e66c908f501f9df61f627469f622ecf58eb1bb19ab1f1e383ee3de4a5d7682e8204effcdcee8dce1aeac600e81d909d83ce936ddd724e3c3d879816d43c3ae9708e649c62f3f9bf65c940eb27a59583249a6fc0a020d93f4899a0907f2bddd6c94b75992b20c4f10957ff9356eae680a2e5b3cfd2a72d69568a2741a41f09f56d57dbe1d2a8d14e820bd53ae283f6c90fc1e4a7874093d9a582e02571cecb69226bde294112db1b455a03b5ad0cb2ab87cdec6166675d60721bbbafd25a612ee7c067af32f3414ade8045a0bc7b47b27a49ce5c3a4c328bfe892e1fad4545d776c75ee2d988ef615c4bed92bfc147f0e97a1cfa42e5b0d2935c6958811c0115340d8f248f9bd2f4653dd64b4aa777b199a23ee4eeb4c9a89e5f5de1b543adff177823cf4cae343471e0fb786fed882f4262e52772b99f325e08d66f5df8e72e08cc0a544f602929467c0b00a52541b717e16a9ceed4030db50cae3959a777043eb01ae648bf35b339d39ad0e48df5d50f7ede95633f2cf503a064af9f115f9db08f8ed0716ca1a06bf020af46bd862ff7f3f3c9c2fad14a78d9c69ed717b57fdba2b71e4815c4f3cc755d75f5939c7ea47abbeca3f5c128fb31a48c02405750fcef617ab56070fdd73fe1c2dcad6a131140ca1e6c314f2dc48b978828926c817ac5b19d4b31e4ca3e6c8fe03948537594958b91fafafec000cebc83bef299793c7678fa4a30f744a4d9a1b2aa5e47be5c5be920cb327772045d8555983b199f9793a5b837247a18d8b33a9de9d187b93c303353e50c1c519467e3dd9e6be1add7faef54fdf11ea6cb5d5d0a295cfb1ea35e10ed9d4eb79ce7c14e18d580f4af166abadc945b7b46b049449bceea1635052bbcc66e17c693992b68694d22bcb754dd9e2d3134576be264e539f39893159cb21c7848a2cd3d0f3df02c39ba7126724bb0cbf294bd655a863132b10513f5539deb709f845e3739917366c73664d57443a980b8875e86af7452938d4f3f4ea42f1eb80d85ec83186cd02f69d6409eab8eca7d3b8ec985ffab0dcd6a4b6cb6e1861ecee36b79e880e8fb9d4eaf0150bc67547ec06ca5bc795d5bf9818a7e55663c38d49f24b98afbf83da68666583ee47ca915b39efa45cbaefc96988a5c2a9ef8c15ded819d1452ea8b5e9cbb873ccc09ec97a14cb968afc3478f30135bc61e887614da5e8a3fe2a8689cb58aabac9fa1fa22bcc21db25f6281d720eb3ac9a17e78181978f2b0a1e41e603fd7588476b7e9211d4708f87632c174e86e18c6ef06da97df6d9f21d064b7f76353b7455c100b2a82798c9349401d7622388965a8cb5b0cf22fc29d513819d61bffcc03aa8673bc057a23ab4811da4f89e1c1f0d8fe47c2760722fedbaf06cf882de2b15db555f0c594024832530c8d666e2c2ade6680fdf38d269ac7747083a2ced01a98f444b9b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
